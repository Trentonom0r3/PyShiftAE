<h2>Begin File: A.h</h2>

```cpp
/*******************************************************************/
/*                                                                 */
/*                      ADOBE CONFIDENTIAL                         */
/*                   _ _ _ _ _ _ _ _ _ _ _ _ _                     */
/*                                                                 */
/* Copyright 2007 Adobe Systems Incorporated                       */
/* All Rights Reserved.                                            */
/*                                                                 */
/* NOTICE:  All information contained herein is, and remains the   */
/* property of Adobe Systems Incorporated and its suppliers, if    */
/* any.  The intellectual and technical concepts contained         */
/* herein are proprietary to Adobe Systems Incorporated and its    */
/* suppliers and may be covered by U.S. and Foreign Patents,       */
/* patents in process, and are protected by trade secret or        */
/* copyright law.  Dissemination of this information or            */
/* reproduction of this material is strictly forbidden unless      */
/* prior written permission is obtained from Adobe Systems         */
/* Incorporated.                                                   */
/*                                                                 */
/*******************************************************************/

/** A.h

	Adobe-standard (hopefully one day) types to promote plug-in sharing.

**/
#ifndef _H_A
#define _H_A

#ifdef A_INTERNAL

	#include <A_Private.h>

#else
	#include "stdint.h"

	typedef int32_t			A_long;
	typedef uint32_t		A_u_long;
	typedef char			A_char;
	typedef double			A_FpLong;
	typedef float			A_FpShort;
	typedef A_long			A_Err;
	typedef void *			A_Handle;
	typedef A_long			A_Fixed;
	typedef A_u_long		A_UFixed;

	#if defined( __MWERKS__) || defined (__GNUC__)  // metrowerks codewarrior and XCode/GCC
		typedef int16_t			A_short;
		typedef uint16_t		A_u_short;
		typedef uint8_t			A_u_char;
		typedef uint8_t			A_Boolean;
		typedef intptr_t		A_intptr_t;
	#else // windows
		typedef short			A_short;
		typedef unsigned short	A_u_short;
		typedef unsigned char	A_u_char;
		typedef unsigned char	A_Boolean;	
		#ifdef  _WIN64
			typedef __int64     A_intptr_t;
		#else
			typedef  int32_t       A_intptr_t;
		#endif
	#endif

#ifdef _MSC_VER	// visual c++ 
	typedef unsigned __int64 	A_u_longlong;
#endif

#if defined( __MWERKS__) || defined (__GNUC__)  // metrowerks codewarrior and XCode/GCC
	typedef uint64_t	A_u_longlong;
#endif


#include <adobesdk/config/PreConfig.h>


	typedef struct {
		A_long		value;
		A_u_long	scale;
	} A_Time;

	typedef struct {
		A_long		num;	/* numerator */
		A_u_long	den;	/* denominator */
	} A_Ratio;
	
	typedef struct {
		A_FpLong			x, y;
	} A_FloatPoint;
	
	typedef struct {
		A_FpLong			x, y, z;
	} A_FloatPoint3;

	typedef struct {
		A_FpLong			left, top, right, bottom;
	} A_FloatRect;

	typedef struct {
		A_FpLong			mat[3][3];
	} A_Matrix3;

	typedef struct {
		A_FpLong			mat[4][4];
	} A_Matrix4;

	typedef struct {
		A_short				top, left, bottom, right;
	} A_LegacyRect;

	typedef struct {
		A_long				left, top, right, bottom;
	} A_LRect;

	typedef		A_LRect		A_Rect;

	typedef struct {
		A_long				x, y;
	} A_LPoint;

	typedef struct {
		A_FpLong			radius, angle; 
	} A_FloatPolar; 

	typedef		A_u_longlong	A_HandleSize;
	
#include <adobesdk/config/PostConfig.h>




#endif


#include <adobesdk/config/PreConfig.h>

typedef struct {
	A_FpLong		alpha;
	A_FpLong		red;
	A_FpLong		green;
	A_FpLong		blue;

} A_Color;

#include <adobesdk/config/PostConfig.h>





#define A_THROW(ERR)		throw ((A_long) ERR)	

enum {
	A_Err_NONE = 0,
	A_Err_GENERIC,
	A_Err_STRUCT,
	A_Err_PARAMETER,
	A_Err_ALLOC,
	A_Err_WRONG_THREAD,					// Some calls can only be used on UI (Main) or Render threads. Also, calls back to AE can only be made from the same thread AE called you on
	A_Err_CONST_PROJECT_MODIFICATION,	// An attempt was made to write to a read only copy of an AE project. Project changes must originate in the UI/Main thread.
	A_Err_RESERVED_7,
	A_Err_RESERVED_8,
	A_Err_RESERVED_9,
	A_Err_RESERVED_10,
	A_Err_RESERVED_11,
	A_Err_RESERVED_12,
    A_Err_MISSING_SUITE = 13,	// acquire suite failed on a required suite
	A_Err_RESERVED_14,
	A_Err_RESERVED_15,
	A_Err_RESERVED_16,
	A_Err_RESERVED_17,
	A_Err_RESERVED_18,
	A_Err_RESERVED_19,
	A_Err_RESERVED_20,
	A_Err_RESERVED_21,
	A_Err_NOT_IN_CACHE_OR_COMPUTE_PENDING,
	A_Err_PROJECT_LOAD_FATAL,
	A_Err_EFFECT_APPLY_FATAL,

	A_Err_LAST
};

typedef struct {
	A_short		majorS;
	A_short		minorS;
} A_Version;

typedef struct _Up_OpaqueMem **AEGP_MemHandle;

typedef	A_u_short			A_UTF16Char;

#if defined( __MWERKS__) || defined (__GNUC__)  // metrowerks codewarrior and XCode/GCC
	typedef A_char			A_LegacyEnumType;
#else // windows
	typedef A_long			A_LegacyEnumType;
#endif

#endif

```

---

<h2>Begin File: AEConfig.h</h2>

```cpp
#ifndef AECONFIG_H
#define AECONFIG_H

/*
Usage guidelines for these defines. 4/12/2006

Always use the most specific kind for your problem. Try and use
the form

#ifdef AE_XXXXX (i.e. AE_OS_MAC)

#elif defined(AE_NOT_XXXX) (i.e. AE_OS_WIN)

#else
	#error "unknown"
#endif

when creating conditionally compiled blocks.

AE_OS_MAC | AE_OS_WIN

are used to select between the most popular version of the operating
system API's. As of this writing AE_OS_MAC implies 10.4.4u SDK, and
AE_OS_WIN implies the platform SDK shipped with VS8 and _WIN32. 


AE_PROC_PPC | AE_PROC_INTEL

are used for code that will only execute on one processor family or
the other. Essentially should only be used for asm, or asm based 
intrinsics. Note: we do not currently have a define for things
like SSE or SSE3 as we don't build the whole code base targetted
for different instances of processors. You'll need to do runtime checks for SSE3
(though our minimum requirement is Pentium4 so SSE2 can be assumed).


AE_BIG_ENDIAN | AE_LITTLE_ENDIAN

PowerPC on Mac was BIG endian (as is network byte order).
x86 is a little endian architecture.

Try and avoid writing new code that uses this. Use XML or dva::filesupport
for writing things to disk.

These defines should be seldom used, instead use the byte swapping macro's
already defined in U which will be a no-op on platforms that don't need it.

For the record, our file format is stored big endian.


*/
//Define our OS defines
#if defined(_WIN32)
	#define AE_OS_WIN
#elif defined(__GNUC__) && defined(__MACH__)
	#include "TargetConditionals.h"	// defines the nesting of TARGET_OS_*
	#if TARGET_OS_MAC
		#if TARGET_OS_IPHONE
			// Older SDKs ( before TV, WATCH ) do not have TARGET_OS_IOS defined.
			#if TARGET_OS_IOS || !defined(TARGET_OS_IOS)
				#define AE_OS_IOS
			#endif
		#else
			#define AE_OS_MAC
		#endif // TARGET_OS_IPHONE

	#if TARGET_OS_SIMULATOR
		#define AE_OS_APPLE_SIM
	#endif
	#endif // TARGET_OS_MAC
#elif Rez
	#define AE_OS_MAC
#elif defined(__ANDROID__)
	#define AE_OS_ANDROID
#else
	#error "unrecognized AE platform"
#endif

//Define our Processor defines
#if defined(__i386__) || defined(_M_IX86)
	#define AE_PROC_INTEL
#elif defined(_M_X64) || defined(__amd64__) || defined(__x86_64__)
	#define AE_PROC_INTELx64
#elif defined(__arm64__) || defined(__aarch64__)
    #define AE_PROC_ARM64
#else
	#error  "unrecognized AE processor"
#endif

#if defined(AE_OS_MAC) && defined(AE_PROC_ARM64)
// This is used to enable/disable features that are still being
// ported/tested to run on Mac arm64based M1 processors, aka Apple Silicon.
// It is intended for Adobe internal use, and will be going away once the mac
// arm64 work is completed.
#define AE_MAC_ARM64_PROTOTYPE_TODO
#endif

//Define our Byte order
#define AE_LITTLE_ENDIAN


#endif

```

---

<h2>Begin File: AEFX_SuiteHandlerTemplate.h</h2>

```cpp
#ifndef _H_AEFX_SUITE_HELPER_TEMPLATE
#define _H_AEFX_SUITE_HELPER_TEMPLATE

#include <AE_Effect.h>
#include <AE_EffectCB.h>
#include <SPBasic.h>
#include <SPSuites.h>


#ifdef __cplusplus

// Throws A_Err_MISSING_SUITE if acquisition fails and the second template argument, ALLOW_NO_SUITE, is set to false
template<typename SUITETYPE, bool ALLOW_NO_SUITE = false>
class AEFX_SuiteScoper
{
public:
	AEFX_SuiteScoper(const PF_InData *in_data, const char *suite_name, int32_t suite_versionL, PF_OutData	*out_dataP0 = 0, const char *err_stringZ0 = 0)
	{
		i_suite_name = suite_name;
		i_suite_versionL = suite_versionL;
		i_basic_suiteP = in_data->pica_basicP;

		const void *suiteP;
		SPErr err = i_basic_suiteP->AcquireSuite(i_suite_name, i_suite_versionL, &suiteP);

		if (err != kSPNoError) {
			if (ALLOW_NO_SUITE) {
				suiteP = NULL;
			}
			else {
				if (out_dataP0) {
					const char	*error_stringPC = err_stringZ0 ? err_stringZ0 : "Not able to acquire AEFX Suite.";
					out_dataP0->out_flags |= PF_OutFlag_DISPLAY_ERROR_MESSAGE;
					(*in_data->utils->ansi.sprintf)(out_dataP0->return_msg, error_stringPC);
				}
				A_THROW(A_Err_MISSING_SUITE);
			}
		}

		i_suiteP = reinterpret_cast<const SUITETYPE*>(suiteP);
	}

	~AEFX_SuiteScoper()
	{
		if (i_suiteP) {
			i_basic_suiteP->ReleaseSuite(i_suite_name, i_suite_versionL);	// ignore error, nothing we can do in dtor
		}
	}

	const SUITETYPE* operator->() const { return i_suiteP; }
	const SUITETYPE* get() const { return i_suiteP; }

private:
	mutable const SUITETYPE		*i_suiteP;
	SPBasicSuite				*i_basic_suiteP;
	const char					*i_suite_name;
	int32_t						i_suite_versionL;
};


#endif		// __cplusplus

#endif		// _H

```

---

<h2>Begin File: AE_AdvEffectSuites.h</h2>

```cpp
/*******************************************************************/
/*                                                                 */
/*                      ADOBE CONFIDENTIAL                         */
/*                   _ _ _ _ _ _ _ _ _ _ _ _ _                     */
/*                                                                 */
/* Copyright 2007 Adobe Systems Incorporated                       */
/* All Rights Reserved.                                            */
/*                                                                 */
/* NOTICE:  All information contained herein is, and remains the   */
/* property of Adobe Systems Incorporated and its suppliers, if    */
/* any.  The intellectual and technical concepts contained         */
/* herein are proprietary to Adobe Systems Incorporated and its    */
/* suppliers and may be covered by U.S. and Foreign Patents,       */
/* patents in process, and are protected by trade secret or        */
/* copyright law.  Dissemination of this information or            */
/* reproduction of this material is strictly forbidden unless      */
/* prior written permission is obtained from Adobe Systems         */
/* Incorporated.                                                   */
/*                                                                 */
/*******************************************************************/

#ifndef _H_AE_AdvEffectSuites
#define _H_AE_AdvEffectSuites

#include <AE_Effect.h>
#include <AE_EffectUI.h>


#include <adobesdk/config/PreConfig.h>

#ifdef __cplusplus
	extern "C" {
#endif


#define kPFAdvAppSuite				"PF AE Adv App Suite"
#define kPFAdvAppSuiteVersion1		1	/* frozen in AE 5.0 */


typedef struct PF_AdvAppSuite1 {

		SPAPI	PF_Err	(*PF_SetProjectDirty)(void);

		SPAPI	PF_Err	(*PF_SaveProject)(void);

		SPAPI	PF_Err	(*PF_SaveBackgroundState)(void);

		SPAPI	PF_Err	(*PF_ForceForeground)(void);

		SPAPI	PF_Err	(*PF_RestoreBackgroundState)(void);

		SPAPI	PF_Err	(*PF_RefreshAllWindows)(void);

		// 2 lines of text, same as calling PF_InfoDrawText3( line1Z0, line2Z0, NULL)
		SPAPI	PF_Err	(*PF_InfoDrawText)(
								const A_char	*line1Z0,
								const A_char	*line2Z0);

		SPAPI	PF_Err	(*PF_InfoDrawColor)(
								PF_Pixel	color);

		// 3 lines of text
		SPAPI	PF_Err	(*PF_InfoDrawText3)(
								const A_char	*line1Z0,
								const A_char	*line2Z0,
								const A_char	*line3Z0);

		// 3 lines, with two lines including formatting for right and left justification
		SPAPI	PF_Err	(*PF_InfoDrawText3Plus)(
								const A_char	*line1Z0,
								const A_char	*line2_jrZ0,
								const A_char	*line2_jlZ0,
								const A_char	*line3_jrZ0,
								const A_char	*line3_jlZ0);
								
} PF_AdvAppSuite1;





#define kPFAdvAppSuiteVersion2		2/* to be frozen in  AE 6.0 */

typedef struct PF_AdvAppSuite2 {

		SPAPI	PF_Err	(*PF_SetProjectDirty)(void);

		SPAPI	PF_Err	(*PF_SaveProject)(void);

		SPAPI	PF_Err	(*PF_SaveBackgroundState)(void);

		SPAPI	PF_Err	(*PF_ForceForeground)(void);

		SPAPI	PF_Err	(*PF_RestoreBackgroundState)(void);

		SPAPI	PF_Err	(*PF_RefreshAllWindows)(void);

		// 2 lines of text, same as calling PF_InfoDrawText3( line1Z0, line2Z0, NULL)
		SPAPI	PF_Err	(*PF_InfoDrawText)(
								const A_char	*line1Z0,
								const A_char	*line2Z0);

		SPAPI	PF_Err	(*PF_InfoDrawColor)(
								PF_Pixel	color);

		// 3 lines of text
		SPAPI	PF_Err	(*PF_InfoDrawText3)(
								const A_char	*line1Z0,
								const A_char	*line2Z0,
								const A_char	*line3Z0);

		// 3 lines, with two lines including formatting for right and left justification
		SPAPI	PF_Err	(*PF_InfoDrawText3Plus)(
								const A_char	*line1Z0,
								const A_char	*line2_jrZ0,
								const A_char	*line2_jlZ0,
								const A_char	*line3_jrZ0,
								const A_char	*line3_jlZ0);

		// append a line of text to top line for so many ticks
		SPAPI	PF_Err	(*PF_AppendInfoText)(
								const A_char	*appendZ0);

								
} PF_AdvAppSuite2;



#define PF_MAX_TIME_LEN				31

enum { 
	PF_Step_FORWARD, 
	PF_Step_BACKWARD 
};
typedef A_LegacyEnumType PF_Step;

enum {
	PF_TimeDisplayFormatTimecode,
	PF_TimeDisplayFormatFrames,
	PF_TimeDisplayFormatFeetFrames // OBSOLETE: returned only by kPFAdvTimeSuiteVersion1
};
		
typedef struct {
	A_char		display_mode;
	A_long		framemax;
	A_long		frames_per_foot;
	A_char		frames_start;
	A_Boolean	nondrop30B;
	A_Boolean	honor_source_timecodeB;
	A_Boolean	use_feet_framesB;
} PF_TimeDisplayPrefVersion3;


		
#define kPFAdvTimeSuite				"PF AE Adv Time Suite"
#define kPFAdvTimeSuiteVersion4		4	//frozen for ae15.0
		
typedef struct PF_AdvTimeSuite4 {
	
	SPAPI PF_Err (*PF_FormatTimeActiveItem)(	A_long				time_valueUL,		// time is value/scale in seconds
											A_u_long			time_scaleL,
											PF_Boolean			durationB,			// is the time value a duration or time?
											A_char				*time_buf);			// allocate as PF_MAX_TIME_LEN + 1
	
	SPAPI PF_Err (*PF_FormatTime)(				PF_InData			*in_data,
										PF_EffectWorld		*world,
										A_long				time_valueUL,
										A_u_long			time_scaleL,
										PF_Boolean			durationB,
										A_char				*time_buf);
	
	SPAPI PF_Err (*PF_FormatTimePlus)(			PF_InData			*in_data,
									  PF_EffectWorld		*world,
									  A_long				time_valueUL,
									  A_u_long			time_scaleL,
									  PF_Boolean			comp_timeB,
									  PF_Boolean			durationB,
									  A_char				*time_buf);
	
	SPAPI PF_Err (*PF_GetTimeDisplayPref)(		PF_TimeDisplayPrefVersion3	*tdp,
										  A_long				*starting_frame_num);
	
	SPAPI PF_Err (*PF_TimeCountFrames)(	const A_Time*		start_timeTP,
										const A_Time*		time_stepTP,
										A_Boolean			include_partial_frameB,
										A_long*				frame_countL);
	
} PF_AdvTimeSuite4;
		
		
#define kPFAdvTimeSuite				"PF AE Adv Time Suite"
#define kPFAdvTimeSuiteVersion3		3	//frozen for ae14.2

typedef struct PF_AdvTimeSuite3 {

	SPAPI PF_Err (*PF_FormatTimeActiveItem)(	A_long				time_valueUL,		// time is value/scale in seconds
												A_u_long			time_scaleL,
												PF_Boolean			durationB,			// is the time value a duration or time?
												A_char				*time_buf);			// allocate as PF_MAX_TIME_LEN + 1
																	
	SPAPI PF_Err (*PF_FormatTime)(				PF_InData			*in_data,
												PF_EffectWorld		*world,
												A_long				time_valueUL,
												A_u_long			time_scaleL,
												PF_Boolean			durationB,
												A_char				*time_buf);
																	
	SPAPI PF_Err (*PF_FormatTimePlus)(			PF_InData			*in_data,
												PF_EffectWorld		*world,
												A_long				time_valueUL,
												A_u_long			time_scaleL,
												PF_Boolean			comp_timeB,
												PF_Boolean			durationB,
												A_char				*time_buf);
	
	SPAPI PF_Err (*PF_GetTimeDisplayPref)(		PF_TimeDisplayPrefVersion3	*tdp,
												A_long				*starting_frame_num);

} PF_AdvTimeSuite3;


#define kPFAdvTimeSuiteVersion2		2

typedef struct {
	A_char		display_mode;
	A_char		framemax;
	A_char		frames_per_foot;
	A_char		frames_start;
	A_Boolean	nondrop30B;
	A_Boolean	honor_source_timecodeB;
	A_Boolean	use_feet_framesB;
} PF_TimeDisplayPrefVersion2;

typedef struct PF_AdvTimeSuite2 {

	SPAPI PF_Err (*PF_FormatTimeActiveItem)(	A_long				time_valueUL,		// time is value/scale in seconds
												A_u_long		time_scaleL,
												PF_Boolean				durationB,			// is the time value a duration or time?
												A_char				*time_buf);			// allocate as PF_MAX_TIME_LEN + 1
																	
	SPAPI PF_Err (*PF_FormatTime)(				PF_InData			*in_data,
												PF_EffectWorld			*world,
												A_long				time_valueUL,
												A_u_long		time_scaleL,
												PF_Boolean				durationB,
												A_char				*time_buf);
																	
	SPAPI PF_Err (*PF_FormatTimePlus)(			PF_InData			*in_data,
												PF_EffectWorld			*world,
												A_long				time_valueUL,
												A_u_long		time_scaleL,
												PF_Boolean				comp_timeB,
												PF_Boolean				durationB,
												A_char				*time_buf);
																	
												
	SPAPI PF_Err (*PF_GetTimeDisplayPref)(		PF_TimeDisplayPrefVersion2	*tdp,
												A_long				*starting_frame_num);



} PF_AdvTimeSuite2;



#define kPFAdvTimeSuiteVersion1		1 /* frozen in AE 5.0 */

typedef struct {
	A_char	time_display_format;
	A_char	framemax;
	A_char	nondrop30;
	A_char	frames_per_foot;
} PF_TimeDisplayPref;

typedef struct PF_AdvTimeSuite1 {

	SPAPI PF_Err (*PF_FormatTimeActiveItem)(	A_long				time_valueUL,		// time is value/scale in seconds
												A_u_long		time_scaleL,
												PF_Boolean				durationB,			// is the time value a duration or time?
												A_char				*time_buf);			// allocate as PF_MAX_TIME_LEN + 1
																	
	SPAPI PF_Err (*PF_FormatTime)(				PF_InData			*in_data,
												PF_EffectWorld			*world,
												A_long				time_valueUL,
												A_u_long		time_scaleL,
												PF_Boolean				durationB,
												A_char				*time_buf);
																	
	SPAPI PF_Err (*PF_FormatTimePlus)(			PF_InData			*in_data,
												PF_EffectWorld			*world,
												A_long				time_valueUL,
												A_u_long		time_scaleL,
												PF_Boolean				comp_timeB,
												PF_Boolean				durationB,
												A_char				*time_buf);
																	
												
	SPAPI PF_Err (*PF_GetTimeDisplayPref)(		PF_TimeDisplayPref	*tdp,
												A_long				*starting_frame_num);

} PF_AdvTimeSuite1;



#define kPFAdvItemSuite				"PF AE Adv Item Suite"
#define kPFAdvItemSuiteVersion1		1	/* frozen in AE 5.0 */



typedef struct PF_AdvItemSuite1 {

	SPAPI PF_Err (*PF_MoveTimeStep)(			PF_InData		*in_data,
												PF_EffectWorld		*world,
												PF_Step			time_dir,
												A_long			num_stepsL);

	SPAPI PF_Err (*PF_MoveTimeStepActiveItem) (	PF_Step			time_dir,
												A_long			num_stepsL);

								
	SPAPI PF_Err (*PF_TouchActiveItem)			(void);


	SPAPI PF_Err (*PF_ForceRerender)(			PF_InData		*in_data,
												PF_EffectWorld		*world);
								

	SPAPI PF_Err (*PF_EffectIsActiveOrEnabled)(	PF_ContextH		contextH,
												PF_Boolean			*enabledPB);


} PF_AdvItemSuite1;



#ifdef __cplusplus
}
#endif

#include <adobesdk/config/PostConfig.h>


#endif

```

---

<h2>Begin File: AE_CacheOnLoadSuite.h</h2>

```cpp
/*******************************************************************/
/*                                                                 */
/*                      ADOBE CONFIDENTIAL                         */
/*                   _ _ _ _ _ _ _ _ _ _ _ _ _                     */
/*                                                                 */
/* Copyright 2003 Adobe Systems Incorporated                       */
/* All Rights Reserved.                                            */
/*                                                                 */
/* NOTICE:  All information contained herein is, and remains the   */
/* property of Adobe Systems Incorporated and its suppliers, if    */
/* any.  The intellectual and technical concepts contained         */
/* herein are proprietary to Adobe Systems Incorporated and its    */
/* suppliers and may be covered by U.S. and Foreign Patents,       */
/* patents in process, and are protected by trade secret or        */
/* copyright law.  Dissemination of this information or            */
/* reproduction of this material is strictly forbidden unless      */
/* prior written permission is obtained from Adobe Systems         */
/* Incorporated.                                                   */
/*                                                                 */
/*******************************************************************/

#ifndef AECACHEONLOADSUITE
#define AECACHEONLOADSUITE

/**
**	CacheOnLoadSuite, used to signal whether or not the plugin needs to load from
**	disk every time on startup.
*/
#define kPFCacheOnLoadSuite			"PF Cache On Load Suite"
#define kPFCacheOnLoadSuiteVersion1	1

typedef struct PF_CacheOnLoadSuite1 {

	SPAPI PF_Err	(*PF_SetNoCacheOnLoad)(	PF_ProgPtr			effect_ref,
											long				effectAvailable);
												
} PF_CacheOnLoadSuite1;

#endif // AECACHEONLOADSUITE
```

---

<h2>Begin File: AE_ChannelSuites.h</h2>

```cpp
/*******************************************************************/
/*                                                                 */
/*                      ADOBE CONFIDENTIAL                         */
/*                   _ _ _ _ _ _ _ _ _ _ _ _ _                     */
/*                                                                 */
/* Copyright 2007 Adobe Systems Incorporated                       */
/* All Rights Reserved.                                            */
/*                                                                 */
/* NOTICE:  All information contained herein is, and remains the   */
/* property of Adobe Systems Incorporated and its suppliers, if    */
/* any.  The intellectual and technical concepts contained         */
/* herein are proprietary to Adobe Systems Incorporated and its    */
/* suppliers and may be covered by U.S. and Foreign Patents,       */
/* patents in process, and are protected by trade secret or        */
/* copyright law.  Dissemination of this information or            */
/* reproduction of this material is strictly forbidden unless      */
/* prior written permission is obtained from Adobe Systems         */
/* Incorporated.                                                   */
/*                                                                 */
/*******************************************************************/


#ifndef _H_AE_ChannelSuites
#define _H_AE_ChannelSuites

#include <AE_Effect.h>
#include <SPBasic.h>

#include <adobesdk/config/PreConfig.h>


#ifdef __cplusplus
	extern "C" {
#endif


/** PF_ChannelSuite

	PF_GetLayerChannelCount 
		use this to find the number of channels associated with a given source layer
		Most likely use is to get number of channels for iteration purposes.
		
		-param_index is the parameter index of the layer whose source you wish to interrogate
		-num_paramsL is the number of "auxillary" channels 

		
		PF_GetLayerIndexedChannelRefAndDesc
			Given a channel index return the opaque channelRef and a channel description
			channel index must lie between 0 and num_channels-1
			you will use the channelRef in all subsequent calls 

		PF_GetLayerTypedChannelRefAndDesc
			Given a type retrieve the channelRef and ChannelDescription
		
		PF_CheckoutLayerChannel
			given the time parameters and a channel reference, get the data
			The data chunk is allocated is of the type requested.
			The data is in chunky format.
			

			
					PF_ProgPtr			effect_ref,				>>		
					PF_ChannelRefPtr	channel_refP,		    >>
					A_long				what_time,				>>
					A_long				duration,				>>
					A_u_long		time_scale,				>>
					PF_DataType			data_type,				>>
					PF_ChannelData		*channel_chunkP)	<<------

		PF_CheckinLayerChannel
			The checked out channel must be checked in to avoid memory leaks.
					PF_ProgPtr			effect_ref,				
					PF_ChannelRefPtr	channel_refP,			
					PF_ChannelDataPtr	channel_data_chunkP	

**/

#define PF_CHANNEL_DEPTH_INFINITY 1e7

#define kPFChannelSuite1			"PF AE Channel Suite"
#define kPFChannelSuiteVersion1		1	/* frozen in AE 5.0 */




/**
 ** channel  data access macros with a check for the type
 **/

#define PF_GET_CHANNEL_FLOAT_DATA( CHUNK, FLOAT_PTR)		\
	do {													\
		if ( (CHUNK).data_type == PF_DataType_FLOAT) {		\
			FLOAT_PTR = (A_FpShort *) (CHUNK).dataPV;			\
		} else {											\
			FLOAT_PTR = NULL;								\
		}													\
	} while(0)


#define PF_GET_CHANNEL_DOUBLE_DATA( CHUNK, DOUBLE_PTR)		\
	do {													\
		if ((CHUNK).data_type == PF_DataType_DOUBLE) {		\
			DOUBLE_PTR = (A_FpLong *) (CHUNK).dataPV;			\
		} else {											\
			DOUBLE_PTR = NULL;								\
		}													\
	} while(0)


#define PF_GET_CHANNEL_LONG_DATA( CHUNK, LONG_PTR)			\
	do {													\
		if ((CHUNK).data_type == PF_DataType_LONG) {		\
			LONG_PTR = (A_long *) (CHUNK).dataPV;				\
		} else {											\
			LONG_PTR = NULL;								\
		}													\
	} while(0)



#define PF_GET_CHANNEL_SHORT_DATA( CHUNK, SHORT_PTR)		\
	do {													\
		if ((CHUNK).data_type == PF_DataType_SHORT) {		\
			SHORT_PTR = (A_short *) (CHUNK).dataPV;			\
		} else {											\
			SHORT_PTR = NULL;								\
		}													\
	} while(0)


#define PF_GET_CHANNEL_FIXED_DATA( CHUNK, FIXED_PTR)		\
	do {													\
		if ((CHUNK).data_type == PF_DataType_FIXED_16_16) {	\
			FIXED_PTR = (A_long *) (CHUNK).dataPV;			\
		} else {											\
			FIXED_PTR = NULL;								\
		}													\
	} while(0)




#define PF_GET_CHANNEL_CHAR_DATA( CHUNK, CHAR_PTR)			\
	do {													\
		if ((CHUNK).data_type == PF_DataType_CHAR) {		\
			CHAR_PTR = (A_char *) (CHUNK).dataPV;				\
		} else {											\
			CHAR_PTR = NULL;								\
		}													\
	} while(0)




#define PF_GET_CHANNEL_U_BYTE_DATA( CHUNK, BYTE_PTR)		\
	do {													\
		if ((CHUNK).data_type == PF_DataType_U_BYTE) {		\
			BYTE_PTR = (A_u_char *) (CHUNK).dataPV;	\
		} else {											\
			BYTE_PTR = NULL;								\
		}													\
	} while(0)





#define PF_GET_CHANNEL_U_SHORT_DATA( CHUNK, U_SHORT_PTR)	\
	do {													\
		if ((CHUNK).data_type == PF_DataType_U_SHORT) {		\
			U_SHORT_PTR = (A_u_short *) (CHUNK).dataPV;\
		} else {											\
			U_SHORT_PTR = NULL;								\
		}													\
	} while(0)




#define PF_GET_CHANNEL_U_FIXED_DATA( CHUNK, U_FIXED_PTR)	\
	do {													\
		if ((CHUNK).data_type == PF_DataType_U_FIXED_16_16) {	\
			U_FIXED_PTR = (A_u_long) (CHUNK).dataPV;	\
		} else {											\
			U_FIXED_PTR = NULL;								\
		}													\
	} while(0)




/**
 ** get a row of the chunk data
 **/
#define PF_GET_CHANNEL_ROW_FLOAT_DATA( CHUNK, ROW, FLOAT_PTR)		\
	do {															\
		if (((CHUNK).data_type == PF_DataType_FLOAT) && ((ROW) < (CHUNK).heightL)) {					\
			FLOAT_PTR = (A_FpShort *) ((A_char *)(CHUNK).dataPV + (ROW) * (CHUNK).row_bytesL);	\
		} else {													\
			FLOAT_PTR = NULL;										\
		}															\
	} while(0)


#define PF_GET_CHANNEL_ROW_DOUBLE_DATA( CHUNK, ROW, DOUBLE_PTR)		\
	do {															\
		if (((CHUNK).data_type == PF_DataType_DOUBLE) && ((ROW) < (CHUNK).heightL)) {				\
			DOUBLE_PTR = (A_FpLong *) ((A_char *)(CHUNK).dataPV + (ROW) * (CHUNK).row_bytesL);	\
		} else {													\
			DOUBLE_PTR = NULL;										\
		}															\
	} while(0)


#define PF_GET_CHANNEL_ROW_LONG_DATA( CHUNK, ROW, LONG_PTR)			\
	do {															\
		if (((CHUNK).data_type == PF_DataType_LONG) && ((ROW) < (CHUNK).heightL)) {			\
			LONG_PTR = (A_long *) ((A_char *)(CHUNK).dataPV + (ROW) * (CHUNK).row_bytesL);	\
		} else {													\
			LONG_PTR = NULL;										\
		}															\
	} while(0)



#define PF_GET_CHANNEL_ROW_SHORT_DATA( CHUNK, ROW, SHORT_PTR)		\
	do {															\
		if (((CHUNK).data_type == PF_DataType_SHORT) && ((ROW) < (CHUNK).heightL)) {			\
			SHORT_PTR = (A_short *) ((A_char *)(CHUNK).dataPV + (ROW) * (CHUNK).row_bytesL);	\
		} else {													\
			SHORT_PTR = NULL;										\
		}															\
	} while(0)


#define PF_GET_CHANNEL_ROW_FIXED_DATA( CHUNK, ROW, FIXED_PTR)		\
	do {															\
		if (((CHUNK).data_type == PF_DataType_FIXED_16_16) && ((ROW) < (CHUNK).heightL)) {	\
			FIXED_PTR = (A_long *) ((A_char *)(CHUNK).dataPV + (ROW) * (CHUNK).row_bytesL);	\
		} else {													\
			FIXED_PTR = NULL;										\
		}															\
	} while(0)




#define PF_GET_CHANNEL_ROW_CHAR_DATA( CHUNK, ROW, CHAR_PTR)			\
	do {															\
		if (((CHUNK).data_type == PF_DataType_CHAR) && ((ROW) < (CHUNK).heightL)) {			\
			CHAR_PTR = (A_char *) ((A_char *)(CHUNK).dataPV + (ROW) * (CHUNK).row_bytesL);	\
		} else {													\
			CHAR_PTR = NULL;										\
		}															\
	} while(0)




#define PF_GET_CHANNEL_ROW_U_BYTE_DATA( CHUNK, ROW, BYTE_PTR)		\
	do {															\
		if (((CHUNK).data_type == PF_DataType_U_BYTE) && ((ROW) < (CHUNK).heightL)) {		\
			BYTE_PTR = (A_u_char *) ((A_char *)(CHUNK).dataPV + (ROW) * (CHUNK).row_bytesL);	\
		} else {													\
			BYTE_PTR = NULL;										\
		}															\
	} while(0)





#define PF_GET_CHANNEL_ROW_U_SHORT_DATA( CHUNK, ROW, U_SHORT_PTR)	\
	do {															\
		if (((CHUNK).data_type == PF_DataType_U_SHORT) && ((ROW) < (CHUNK).heightL)) {		\
			U_SHORT_PTR = (A_u_short *) ((A_char *)(CHUNK).dataPV + (ROW) * (CHUNK).row_bytesL);	\
		} else {													\
			U_SHORT_PTR = NULL;										\
		}															\
	} while(0)




#define PF_GET_CHANNEL_ROW_U_FIXED_DATA( CHUNK, ROW, U_FIXED_PTR)	\
	do {															\
		if (((CHUNK).data_type == PF_DataType_U_FIXED_16_16) && ((ROW) < (CHUNK).heightL)) {	\
			U_FIXED_PTR = (A_u_long) ((A_char *)(CHUNK).dataPV + (ROW) * (CHUNK).row_bytesL);	\
		} else {													\
			U_FIXED_PTR = NULL;										\
		}															\
	} while(0)






/**
 ** get a item from the chunk data
 **/
#define PF_GET_CHANNEL_ROW_COL_FLOAT_DATA( CHUNK, ROW, COL, FLOAT_PTR)	\
	do {																\
		if (((CHUNK).data_type == PF_DataType_FLOAT)	&&				\
			((ROW) >= 0)								&&				\
			((COL) >= 0)								&&				\
			((ROW) < (CHUNK).heightL)					&&				\
			((COL) < (CHUNK).widthL)) {									\
			FLOAT_PTR = (A_FpShort *) ((A_char *)(CHUNK).dataPV + (ROW) * (CHUNK).row_bytesL);	\
			FLOAT_PTR = (A_FpShort *)FLOAT_PTR + (COL) * (CHUNK).dimensionL;	\
		} else {														\
			FLOAT_PTR = NULL;											\
		}																\
	} while(0)


#define PF_GET_CHANNEL_ROW_COL_DOUBLE_DATA( CHUNK, ROW, COL, DOUBLE_PTR)	\
	do {																	\
		if (((CHUNK).data_type == PF_DataType_DOUBLE) 	&&					\
			((ROW) >= 0)								&&					\
			((COL) >= 0)								&&					\
			((ROW) < (CHUNK).heightL)					&&					\
			((COL) < (CHUNK).widthL)) {										\
			DOUBLE_PTR = (A_FpLong *) ((A_char *)(CHUNK).dataPV + (ROW) * (CHUNK).row_bytesL);	\
			DOUBLE_PTR = (A_FpLong *)DOUBLE_PTR + (COL) * (CHUNK).dimensionL;	\
		} else {															\
			DOUBLE_PTR = NULL;												\
		}																	\
	} while(0)


#define PF_GET_CHANNEL_ROW_COL_LONG_DATA( CHUNK, ROW, COL, LONG_PTR)		\
	do {																	\
		if (((CHUNK).data_type == PF_DataType_LONG) 	&&					\
			((ROW) >= 0)								&&					\
			((COL) >= 0)								&&					\
			((ROW) < (CHUNK).heightL)					&&					\
			((COL) < (CHUNK).widthL)) {										\
				LONG_PTR = (A_long *) ((A_char *)(CHUNK).dataPV + (ROW) * (CHUNK).row_bytesL);	\
				LONG_PTR = (A_long *) LONG_PTR + (COL) * (CHUNK).dimensionL;	\
		} else {															\
				LONG_PTR = NULL;											\
		}																	\
	} while(0)



#define PF_GET_CHANNEL_ROW_COL_SHORT_DATA( CHUNK, ROW, COL, SHORT_PTR)	\
	do {																\
		if (((CHUNK).data_type == PF_DataType_SHORT)	&&				\
			((ROW) >= 0)								&&				\
			((COL) >= 0)								&&				\
			((ROW) < (CHUNK).heightL)					&&				\
			((COL) < (CHUNK).widthL)) {									\
				SHORT_PTR = (A_short *) ((A_char *)(CHUNK).dataPV + (ROW) * (CHUNK).row_bytesL);	\
				SHORT_PTR = (A_short *) SHORT_PTR + (COL) * (CHUNK).dimensionL;\
		} else {														\
			SHORT_PTR = NULL;											\
		}																\
	} while(0)


#define PF_GET_CHANNEL_ROW_COL_FIXED_DATA( CHUNK, ROW, COL, FIXED_PTR)	\
	do {																\
		if (((CHUNK).data_type == PF_DataType_FIXED_16_16)  		&&	\
			((ROW) >= 0)							&&					\
			((COL) >= 0)							&&					\
			((ROW) < (CHUNK).heightL)				&&					\
			((COL) < (CHUNK).widthL)) {									\
			FIXED_PTR = (A_long *) ((A_char *)(CHUNK).dataPV + (ROW) * (CHUNK).row_bytesL);	\
			FIXED_PTR = (A_long *) FIXED_PTR + (COL) * (CHUNK).dimensionL;	\
		} else {														\
			FIXED_PTR = NULL;											\
		}																\
	} while(0)




#define PF_GET_CHANNEL_ROW_COL_CHAR_DATA( CHUNK, ROW, COL, CHAR_PTR)		\
	do {																	\
		if (((CHUNK).data_type == PF_DataType_CHAR)  	&&					\
			((ROW) >= 0)								&&					\
			((COL) >= 0)								&&					\
			((ROW) < (CHUNK).heightL)					&&					\
			((COL) < (CHUNK).widthL)) {										\
			CHAR_PTR = (A_char *) ((A_char *)(CHUNK).dataPV + (ROW) * (CHUNK).row_bytesL);	\
			CHAR_PTR = (A_char *) CHAR_PTR + (COL) * (CHUNK).dimensionL;		\
		} else {															\
			CHAR_PTR = NULL;												\
		}																	\
	} while(0)




#define PF_GET_CHANNEL_ROW_COL_U_BYTE_DATA( CHUNK, ROW, COL, BYTE_PTR)		\
	do {																	\
		if (((CHUNK).data_type == PF_DataType_U_BYTE)   			&&		\
			((ROW) >= 0)											&&		\
			((COL) >= 0)											&&		\
			((ROW) < (CHUNK).heightL)								&&		\
			((COL) < (CHUNK).widthL)) {											\
			BYTE_PTR = (A_u_char *) ((A_char *)(CHUNK).dataPV + (ROW) * (CHUNK).row_bytesL);	\
			BYTE_PTR = (A_u_char *)  BYTE_PTR + (COL) * (CHUNK).dimensionL;			\
		} else {															\
			BYTE_PTR = NULL;												\
		}																	\
	} while(0)





#define PF_GET_CHANNEL_ROW_COL_U_SHORT_DATA( CHUNK, ROW, COL, U_SHORT_PTR)	\
	do {																	\
		if (((CHUNK).data_type == PF_DataType_U_SHORT)   				&&	\
			((ROW) >= 0)												&&	\
			((COL) >= 0)												&&	\
			((ROW) < (CHUNK).heightL)									&&	\
			((COL) < (CHUNK).widthL)) {										\
			U_SHORT_PTR = (A_u_short *) ((A_char *)(CHUNK).dataPV + (ROW) * (CHUNK).row_bytesL);	\
			U_SHORT_PTR = (A_u_short *) U_SHORT_PTR + (COL) * (CHUNK).dimensionL;	\
		} else {															\
			U_SHORT_PTR = NULL;												\
		}																	\
	} while(0)




#define PF_GET_CHANNEL_ROW_COL_U_FIXED_DATA( CHUNK, ROW, COL, U_FIXED_PTR)	\
	do {																	\
		if (((CHUNK).data_type == PF_DataType_U_FIXED_16_16) 			&&	\
			((ROW) >= 0)												&&	\
			((COL) >= 0)												&&	\
			((ROW) < (CHUNK).heightL)									&&	\
			((COL) < (CHUNK).widthL)) {										\
			U_FIXED_PTR = (A_u_long) ((A_char *)(CHUNK).dataPV + (ROW) * (CHUNK).row_bytesL);	\
			U_FIXED_PTR = (A_u_long)  U_FIXED_PTR + (COL) * (CHUNK).dimensionL;	\
		} else {															\
			U_FIXED_PTR = NULL;												\
		}																	\
	} while(0)






/**
 ** the suite functions
 **/

typedef struct PF_ChannelSuite1 { /* frozen in AE 5.0 */

	SPAPI PF_Err	(*PF_GetLayerChannelCount)(
								PF_ProgPtr			effect_ref,			/* >> */
								PF_ParamIndex		param_index,		/* >> */ 
								A_long				*num_channelsPL);	/* << */

	SPAPI PF_Err	(*PF_GetLayerChannelIndexedRefAndDesc)(
								PF_ProgPtr			effect_ref,			/* >> */
								PF_ParamIndex		param_index,		/* >> */ 
								PF_ChannelIndex		channel_index,		/* >> */
								PF_Boolean			*foundPB,			/* << */
								PF_ChannelRef		*channel_refP,		/* << */
								PF_ChannelDesc		*channel_descP);	/* << */


	SPAPI PF_Err	(*PF_GetLayerChannelTypedRefAndDesc)(
								PF_ProgPtr			effect_ref,			/* >> */
								PF_ParamIndex		param_index,		/* >> */ 
								PF_ChannelType		channel_type,		/* >> */
								PF_Boolean			*foundPB,			/* << */
								PF_ChannelRef		*channel_refP,		/* << */
								PF_ChannelDesc		*channel_descP);	/* << */

	SPAPI PF_Err	(*PF_CheckoutLayerChannel)(
								PF_ProgPtr			effect_ref,			/* >> */
								PF_ChannelRefPtr	channel_refP,		/* >> */
								A_long				what_time,			/* >> */
								A_long				duration,			/* >> */
								A_u_long		time_scale,			/* >> */
								PF_DataType			data_type,			/* << */
								PF_ChannelChunk		*channel_chunkP);	/* << */


	SPAPI PF_Err	(*PF_CheckinLayerChannel)(		
								PF_ProgPtr			effect_ref,			/* >> */
								PF_ChannelRefPtr	channel_refP,		/* >> */
								PF_ChannelChunk		*channel_chunkP);	/* << */
						
	
} PF_ChannelSuite1;





#ifdef __cplusplus
	}		// end extern "C"
#endif


#include <adobesdk/config/PostConfig.h>


#endif

```

---

<h2>Begin File: AE_ComputeCacheSuite.h</h2>

```cpp
/********************************************************************
* ADOBE CONFIDENTIAL
* __________________
*
*  Copyright 2020 Adobe Inc.
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe and its suppliers, if any. The intellectual
* and technical concepts contained herein are proprietary to Adobe
* and its suppliers and are protected by all applicable intellectual
* property laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe.
********************************************************************/

#ifndef _H_AE_ComputeCacheSuite
#define _H_AE_ComputeCacheSuite

#include <A.h>
#include <SPBasic.h>

#ifdef AEGP_INTERNAL
	#include <AE_GeneralPlug_Private.h>
#endif

#ifdef __cplusplus
	extern "C" {
#endif

///////////////////////////////////// MC Compute -- plugin registration of cached computations

// Globally unique identifier for the compute class, such as "adobe.ae.effect.test_effect.cache_v_1"
typedef const char *AEGP_CCComputeClassIdP;

typedef void *AEGP_CCComputeOptionsRefconP;	// opaque content provided by plugin for generating key and value. Input to the compute.
typedef void *AEGP_CCComputeValueRefconP;	// opaque compute result from the plugin


// GUID used as the cache key.
typedef struct AEGP_GUID {
	A_long bytes[4];
} AEGP_GUID;

typedef AEGP_GUID AEGP_CCComputeKey;
typedef AEGP_CCComputeKey *AEGP_CCComputeKeyP;
	
typedef void *AEGP_CCCheckoutReceiptP;

//
// The effect supplies implementations of these callbacks.
//
typedef struct AEGP_ComputeCacheCallbacks {
	// Cache key. Called when creating a cache entry and when doing a cache lookup. Should be fast to compute. All of the inputs
	// needed to uniquely address the cache entry must be hashed into the key. If a layer checkout is needed to calculate the cache
	// value, such as with a histogram, then the hash of that input must be included. See PF_ParamUtilsSuite::PF_GetCurrentState
	// to get the hash for a layer param. Note this is the hash of the inputs needed to generate the frame, not a hash the pixels
	// in the frame, thus a render is not triggered when making this call.
	A_Err (*generate_key)(
					AEGP_CCComputeOptionsRefconP	optionsP,
					AEGP_CCComputeKeyP				out_keyP);

	// The expensive call. Generate the cache data from the input parameters.
	A_Err (*compute)(
					AEGP_CCComputeOptionsRefconP	optionsP,
					AEGP_CCComputeValueRefconP		*out_valuePP);

	// The computed value may not be a flat data structure. This should return the total memory footprint. The size is an input
	// to the cache purging heuristic.
	size_t (*approx_size_value)(
					AEGP_CCComputeValueRefconP		valueP);

	// The computed value lives in the cache. This is called to free the value when the cached is to be purged. All resources
	// owned by the cache value must be freed here.
	void (*delete_compute_value)(
					AEGP_CCComputeValueRefconP		valueP);
} AEGP_ComputeCacheCallbacks;



#define kAEGPComputeCacheSuite				"AEGP Compute Cache"
#define kAEGPComputeCacheSuiteVersion1		1	/* frozen in AE 18.2 */

typedef struct AEGP_ComputeCacheSuite1 {

	// Register a cache type.
	SPAPI A_Err (*AEGP_ClassRegister)(
						AEGP_CCComputeClassIdP				compute_classP,
						const AEGP_ComputeCacheCallbacks	*callbacksP);

	// Unregister a cache type. Note that all cached values will be purged at this time since the delete_compute_value callback
	// is how cache entries are deleted, and delete_compute_value is not available after unregister.
	SPAPI A_Err (*AEGP_ClassUnregister)(
						AEGP_CCComputeClassIdP				compute_classP);


	// This is the main checkout call.
	//
	// When adding cache support one of the first questions to answer is if a single render call needs to checkout more than one
	// cache value. If more than one cache value is needed then the multi-checkout pattern, below, can be applied to concurrently
	// calculate the caches across multiple render calls and thus avoid serialization of the compute.
	//
	// SINGLE CACHE VALUE
	// If a render call only needs one cache value then set wait_for_other_threadB to true. The checkout call will return a receipt,
	// possibly calling the compute callback to populate the cache; or waiting on another thread that had already started the
	// needed computation.
	//
	// MULTI-CHECKOUT
	// If a render call needs multiple cache values then this pattern can be used to keep the render threads utilized and thus
	// avoid serializing the compute.
	//    Render()
	//    {
	//          bool first_err = AEGP_ComputeIfNeededAndCheckout(first_options, do_not_wait);
	//          bool second_err = AEGP_ComputeIfNeededAndCheckout(second_options, do_not_wait);
	//          // Add as many additional do_not_wait checkout calls here as needed.
	//
	//          if(first_err == A_Err_NOT_IN_CACHE_OR_COMPUTE_PENDING) {
	//              AEGP_ComputeIfNeededAndCheckout(wait);
	//          }
	//          if(second_err == A_Err_NOT_IN_CACHE_OR_COMPUTE_PENDING) {
	//              AEGP_ComputeIfNeededAndCheckout(wait);
	//          }
	//          // Add as many additional waiting checkout calls here as needed
	//    }
	//
	//                                    wait_for_other_threadB
	//      CACHE STATE   ||          FALSE                    TRUE          |
	//    ================++========================+========================+
	//        No cache    ||  Compute and checkout  |  Compute and checkout  |
	//    ----------------++------------------------+------------------------+
	//   Being computed   ||  Return error, see     |  Wait for the other    |
	//  by another thread ||  below.                |  thread and checkout   |
	//    ----------------++------------------------+------------------------+
	//        Cached      ||  Checkout              |  Checkout              |
	//    ----------------++------------------------+------------------------+
	//
	// Returns A_Err_NOT_IN_CACHE_OR_COMPUTE_PENDING if wait_for_other_threadB is false and another thread is currently computing
	// the cache value. Note that the host will not notify the user of this error; it will be silent to the user.
	//
	// Must call AEGP_CheckinComputeReceipt on success. Check-in must be done before returning to the host.
	SPAPI A_Err (*AEGP_ComputeIfNeededAndCheckout)(
						AEGP_CCComputeClassIdP				compute_classP,
						AEGP_CCComputeOptionsRefconP		opaque_optionsP,
						bool								wait_for_other_threadB,
						AEGP_CCCheckoutReceiptP				*compute_receiptPP);

	// This call does a cache check, and thus should return always quickly. It does not do compute nor does it wait for another
	// thread that is populating the cache.
	// This call could be used to implement a polling pattern where another piece of code is expected to populate the cache. For
	// example, a UI thread could poll the cache regularly for a histogram that is generated on a render thread.
	//
	// Either returns cache value or A_Err_NOT_IN_CACHE_OR_COMPUTE_PENDING if cache miss.
	// Must call AEGP_CheckinComputeReceipt on success. Check-in must be done before returning to the host.
	SPAPI A_Err (*AEGP_CheckoutCached)(
						AEGP_CCComputeClassIdP				compute_classP,
						AEGP_CCComputeOptionsRefconP		opaque_optionsP,
						AEGP_CCCheckoutReceiptP				*compute_receiptPP);

	// Get the cache value from a checkout receipt.
	SPAPI A_Err (*AEGP_GetReceiptComputeValue)(
						const AEGP_CCCheckoutReceiptP		compute_receiptP,
						AEGP_CCComputeValueRefconP			*compute_valuePP);

	// Check-in a receipt.
	SPAPI A_Err (*AEGP_CheckinComputeReceipt)(
						AEGP_CCCheckoutReceiptP				compute_receiptP );

} AEGP_ComputeCacheSuite1;

#ifdef __cplusplus
	}		// end extern "C"
#endif

#endif

```

---

<h2>Begin File: AE_CreatorInfo.h</h2>

```cpp
/*******************************************************************/
/*                                                                 */
/*                      ADOBE CONFIDENTIAL                         */
/*                   _ _ _ _ _ _ _ _ _ _ _ _ _                     */
/*                                                                 */
/* Copyright 2007 Adobe Systems Incorporated                       */
/* All Rights Reserved.                                            */
/*                                                                 */
/* NOTICE:  All information contained herein is, and remains the   */
/* property of Adobe Systems Incorporated and its suppliers, if    */
/* any.  The intellectual and technical concepts contained         */
/* herein are proprietary to Adobe Systems Incorporated and its    */
/* suppliers and may be covered by U.S. and Foreign Patents,       */
/* patents in process, and are protected by trade secret or        */
/* copyright law.  Dissemination of this information or            */
/* reproduction of this material is strictly forbidden unless      */
/* prior written permission is obtained from Adobe Systems         */
/* Incorporated.                                                   */
/*                                                                 */
/*******************************************************************/


/*	If you'd like After Effects to open files created by your application
	IN your application, embed this structure in that file.
	
	Data must be in Motorola byte order.
	
	Your application must then respond to the appleEvent (mac) or the
	command line flags (win) that are specified in the structure.
*/

#define ADBE_CREATOR_ATOM_TYPE 'Cr8r'
#define	CR8R_MAGIC	0xBEEFCAFE

#define	ADBE_CREATOR_ATOM_VERS_MAJOR	1
#define	ADBE_CREATOR_ATOM_VERS_MINOR	0

typedef struct adbe_creator_atom {
	unsigned long		magicLu;			// set to CR8R_MAGIC

	long    			atom_sizeL;			// size of this structure (sizeof(CR8R_CreatorAtom))
	short    			atom_vers_majorS;	// set to ADBE_CREATOR_ATOM_VERS_MAJOR
	short    			atom_vers_minorS;	// set to ADBE_CREATOR_ATOM_VERS_MINOR

	// mac
	unsigned long		creator_codeLu;		// application code on MacOS
	unsigned long 		creator_eventLu;	// invocation appleEvent
			
	// windows
	char    			creator_extAC[16];	// extension allowing registry search to app
	char    			creator_flagAC[16];	// flag passed to app at invocation time

	char    			creator_nameAC[32];	// name of the creator application
} CR8R_CreatorAtom, **CR8R_CreatorAtomHandle;


```

---

<h2>Begin File: AE_Effect.h</h2>

```cpp
/*******************************************************************/
/*                                                                 */
/*                      ADOBE CONFIDENTIAL                         */
/*                   _ _ _ _ _ _ _ _ _ _ _ _ _                     */
/*                                                                 */
/* Copyright 2007 Adobe Systems Incorporated                       */
/* All Rights Reserved.                                            */
/*                                                                 */
/* NOTICE:  All information contained herein is, and remains the   */
/* property of Adobe Systems Incorporated and its suppliers, if    */
/* any.  The intellectual and technical concepts contained         */
/* herein are proprietary to Adobe Systems Incorporated and its    */
/* suppliers and may be covered by U.S. and Foreign Patents,       */
/* patents in process, and are protected by trade secret or        */
/* copyright law.  Dissemination of this information or            */
/* reproduction of this material is strictly forbidden unless      */
/* prior written permission is obtained from Adobe Systems         */
/* Incorporated.                                                   */
/*                                                                 */
/*******************************************************************/


/** AE_Effect.h

	Part of the After Effects SDK

	CONTENTS
		Version Information
		Constants And Enumerations
		Output Flags
		Input Flags
		Command Selectors
		Simple Types
		Pixel Access Macros
		Effect Parameter Description Structures
		Interaction Callbacks
		Effect Parameter Blocks
		Effect Prototype

	NOTES
		It may be easiest to start reading this file at the bottom
		and work your way, section by section, to the top.  Of course,
		the best thing to do is start with the sample filter and the
		work your way from that back through the goodies in this file.

		All strings in this spec are NULL-terminated (C strings).

**/

// This stuff is a test to make sure that no code is including
// this file with contradictory settings of A_INTERNAL. It must
// come *before* the _H_AE_Effect "include once" test.
// You can define A_SUPPRESS_A_INTERNAL_WARNING if you have a plugin
// that breaks this rule innocently. 
#ifdef A_INTERNAL
	#define A_INTERNAL_TEST_ONE 1
#else
	#define A_INTERNAL_TEST_TWO 1
#endif

#if (A_INTERNAL_TEST_ONE && A_INTERNAL_TEST_TWO)
	#ifndef A_SUPPRESS_A_INTERNAL_WARNING
		#pragma message("Warning: You have included AE_Effect.h once with A_INTERNAL set and once without.")
	#endif
#endif

// End of A_INTERNAL consistency check.


#ifndef	_H_AE_Effect
#define	_H_AE_Effect

#ifdef A_INTERNAL
	#include "PF_Private.h"
#endif

#include "A.h"
#if defined(__APPLE__)
#include <CoreFoundation/CFBase.h>
#endif
#include <adobesdk/config/PreConfig.h>


#ifdef __cplusplus
	extern "C" {
#endif

#ifndef __cplusplus
    #if defined(__ANDROID__)
        #include <stdbool.h>
    #endif
#endif

/** -------------------- Version Information ----------------------------------
 **
 ** Please use these macros for designating the version information
 ** of your plug-ins. Should After Effects encounter more than one version
 ** of a specific plug-in when it starts up, it will use this information
 ** to decide which plug-in to honor. The plug-in version information
 ** (field 'my_version' in the PF_OutData) should be set at GLOBAL_SETUP
 ** time.
 **
 ** This version information is meant for your version control, and should
 ** not be confused with the min_version and desired_version fields in the
 ** PF_OutData structure, which refer to the version of the PF specification.
 ** 
 **/

#define PF_Vers_BUILD_BITS		0x1ffL
#define PF_Vers_BUILD_SHIFT		0
#define PF_Vers_STAGE_BITS		0x3L
#define PF_Vers_STAGE_SHIFT		9
#define PF_Vers_BUGFIX_BITS		0xfL
#define PF_Vers_BUGFIX_SHIFT	11
#define PF_Vers_SUBVERS_BITS	0xfL
#define PF_Vers_SUBVERS_SHIFT	15
#define PF_Vers_VERS_BITS		0x7L	// incomplete without high bits, below
#define PF_Vers_VERS_SHIFT		19
// skipping these bits for similarity to Up_Vers_ARCH_*, currently unused in PF
#define PF_Vers_VERS_HIGH_BITS		0xfL	// expand version max from 7 to 127
#define PF_Vers_VERS_HIGH_SHIFT		26

// b/c we are stripping the stand alone vers value for two fields
#define PF_Vers_VERS_LOW_SHIFT  3
#define PF_Vers_VERS_HIGH(vers) ((vers)>>PF_Vers_VERS_LOW_SHIFT)

#define PF_VERSION(vers, subvers, bugvers, stage, build)	\
	(A_u_long)(	\
 		((((A_u_long)PF_Vers_VERS_HIGH(vers)) & PF_Vers_VERS_HIGH_BITS) << PF_Vers_VERS_HIGH_SHIFT) |   \
		((((A_u_long)(vers)) & PF_Vers_VERS_BITS) << PF_Vers_VERS_SHIFT) |	\
		((((A_u_long)(subvers)) & PF_Vers_SUBVERS_BITS)<<PF_Vers_SUBVERS_SHIFT) |\
		((((A_u_long)(bugvers)) & PF_Vers_BUGFIX_BITS) << PF_Vers_BUGFIX_SHIFT) |\
		((((A_u_long)(stage)) & PF_Vers_STAGE_BITS) << PF_Vers_STAGE_SHIFT) |	\
		((((A_u_long)(build)) & PF_Vers_BUILD_BITS) << PF_Vers_BUILD_SHIFT)	\
	)

#define PF_Version_VERS(vers)		\
 	(((((A_u_long) vers) >> PF_Vers_VERS_SHIFT) & PF_Vers_VERS_BITS) + (((vers >> PF_Vers_VERS_HIGH_SHIFT) & PF_Vers_VERS_HIGH_BITS) << PF_Vers_VERS_LOW_SHIFT))

#define PF_Version_SUBVERS(vers)	\
	((((A_u_long) vers) >> PF_Vers_SUBVERS_SHIFT) & PF_Vers_SUBVERS_BITS)

#define PF_Version_BUGFIX(vers)	\
	((((A_u_long) vers) >> PF_Vers_BUGFIX_SHIFT) & PF_Vers_BUGFIX_BITS)

#define PF_Version_STAGE(vers)	\
	((((A_u_long) vers) >> PF_Vers_STAGE_SHIFT) & PF_Vers_STAGE_BITS)

#define PF_Version_BUILD(vers)	\
	((((A_u_long) vers) >> PF_Vers_BUILD_SHIFT) & PF_Vers_BUILD_BITS)


enum {
	PF_Stage_DEVELOP,
	PF_Stage_ALPHA,
	PF_Stage_BETA,
	PF_Stage_RELEASE
};
typedef A_long PF_Stage;






/** -------------------- Constants And Enumerations --------------------

	These version numbers refer to the PF_AE_PLUG_IN_VERSION & SUBVERSION of all releases of AE, and, correspondingly,
	the API used by each plug-in (i.e. the SDK that the plug-in is compiled against). The plug-in can check this number
	(PF_SpecVersion version field in in_data) to see which API the host supports, and the host can check to see what API
	the plug-in is expecting (as listed in the plug-in's PiPL).

**/

//CC
#define PF_AE234_PLUG_IN_VERSION			13	// manually set for SDK changes to allow more than 32 max threads for PF_Iterate
#define PF_AE234_PLUG_IN_SUBVERS			28	// manually set for new 'Support URL' field in PiPL and new entry point

#define PF_AE220_PLUG_IN_VERSION			13	// manually set for SDK changes to allow more than 32 max threads for PF_Iterate
#define PF_AE220_PLUG_IN_SUBVERS			27	// manually set for SDK changes to allow more than 32 max threads for PF_Iterate

#define PF_AE184_PLUG_IN_VERSION			13	// manually set for mid-cycle SDK drop
#define PF_AE184_PLUG_IN_SUBVERS			26	// manually set for mid-cycle SDK drop

#define PF_AE182_PLUG_IN_VERSION			13	// manually set for mid-cycle SDK drop
#define PF_AE182_PLUG_IN_SUBVERS			25	// manually set for mid-cycle SDK drop

#define PF_AE180_PLUG_IN_VERSION			13	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay
#define PF_AE180_PLUG_IN_SUBVERS			24	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay

#define PF_AE177_PLUG_IN_VERSION			13	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay
#define PF_AE177_PLUG_IN_SUBVERS			23	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay

#define PF_AE176_PLUG_IN_VERSION			13	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay
#define PF_AE176_PLUG_IN_SUBVERS			22	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay

#define PF_AE175_PLUG_IN_VERSION			13	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay
#define PF_AE175_PLUG_IN_SUBVERS			21	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay

#define PF_AE171_PLUG_IN_VERSION			13	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay
#define PF_AE171_PLUG_IN_SUBVERS			20	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay

#define PF_AE170_PLUG_IN_VERSION			13	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay
#define PF_AE170_PLUG_IN_SUBVERS			18	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay

#define PF_AE161_PLUG_IN_VERSION			13	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay
#define PF_AE161_PLUG_IN_SUBVERS			17	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay

#define PF_AE160_PLUG_IN_VERSION			13	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay
#define PF_AE160_PLUG_IN_SUBVERS			16	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay

#define PF_AE151_PLUG_IN_VERSION			13	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay
#define PF_AE151_PLUG_IN_SUBVERS			15	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay

#define PF_AE150_PLUG_IN_VERSION			13	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay
#define PF_AE150_PLUG_IN_SUBVERS			15	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay

#define PF_AE142_PLUG_IN_VERSION			13	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay
#define PF_AE142_PLUG_IN_SUBVERS			14	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay

#define PF_AE140_PLUG_IN_VERSION			13	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay
#define PF_AE140_PLUG_IN_SUBVERS			13	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay

#define PF_AE138_PLUG_IN_VERSION			13	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay
#define PF_AE138_PLUG_IN_SUBVERS			11	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay

// AE137 is same plugin version as AE136, below

#define PF_AE136_PLUG_IN_VERSION			13	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay
#define PF_AE136_PLUG_IN_SUBVERS			10	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay

#define PF_AE135_PLUG_IN_VERSION			13	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay
#define PF_AE135_PLUG_IN_SUBVERS			9	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay

// AE131 and AE132 are the same plugin version as AE130, below

#define PF_AE130_PLUG_IN_VERSION			13	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit okay
#define PF_AE130_PLUG_IN_SUBVERS			7	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit okay

#define PF_AE122_PLUG_IN_VERSION			13	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit okay
#define PF_AE122_PLUG_IN_SUBVERS			6	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit okay

#define PF_AE121_PLUG_IN_VERSION			13	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit okay
#define PF_AE121_PLUG_IN_SUBVERS			5	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit okay

#define PF_AE120_PLUG_IN_VERSION			13
#define PF_AE120_PLUG_IN_SUBVERS			4

//CS6.0.1
//Plugins have to make dummy checkout (hack) to fix W3163764 in CS6. The bug has been fixed in CS6.0.1 so increase SDK minor version 
//so that plugins can constrain the hack only for CS6.
#define PF_AE1101_PLUG_IN_VERSION			13
#define PF_AE1101_PLUG_IN_SUBVERS           3

#define PF_AE110_PLUG_IN_VERSION			13
#define PF_AE110_PLUG_IN_SUBVERS			2

#define PF_AE105_PLUG_IN_VERSION			13
#define PF_AE105_PLUG_IN_SUBVERS			1

#define PF_AE100_PLUG_IN_VERSION			13
#define PF_AE100_PLUG_IN_SUBVERS			0

#define PF_AE90_PLUG_IN_VERSION				12
#define PF_AE90_PLUG_IN_SUBVERS				14

#define PF_AE80_PLUG_IN_VERSION				12
#define PF_AE80_PLUG_IN_SUBVERS				13

#define PF_AE70_PLUG_IN_VERSION				12
#define PF_AE70_PLUG_IN_SUBVERS				12

#define PF_AE65_PLUG_IN_VERSION				12
#define PF_AE65_PLUG_IN_SUBVERS				11

#define PF_AE41_PLUG_IN_VERSION				12
#define PF_AE41_PLUG_IN_SUBVERS				2

#define PF_AE40_PLUG_IN_VERSION				12
#define PF_AE40_PLUG_IN_SUBVERS				1

#define PF_AE31_PLUG_IN_VERSION				11
#define PF_AE31_PLUG_IN_SUBVERS				6
#define PF_AE31_PLUG_IN_SUBVERS_STRICTIFY	8

#define PF_AE_PLUG_IN_VERSION				PF_AE234_PLUG_IN_VERSION	// manually set for SDK changes to allow more than 32 max threads for PF_Iterate
#define PF_AE_PLUG_IN_SUBVERS				PF_AE234_PLUG_IN_SUBVERS	// manually set for SDK changes to allow more than 32 max threads for PF_Iterate

/* Note:	AE3.1 will drive any v11.x plugin
			AE4.0 will drive any v11.x or v12.x plugin
			AE4.1 will drive any v11.x or v12.x plugin, changed current version from 12.1 -> 12.2
			
			If you use PF_AE31_PLUG_IN_VERSION, PF_AE31_PLUG_IN_SUBVERS_STRICTIFY
			or later (e.g. 11.8 or 12.0) AE4.0 will enforce new stricter rules and
			report more plug-in errors.
*/


#define PF_MAX_EFFECT_NAME_LEN				31
#define PF_MAX_EFFECT_CATEGORY_NAME_LEN		31
#define PF_MAX_EFFECT_PARAM_NAME_LEN		31
#define PF_MAX_PARAM_DESCRIPTION_LEN		31
#define PF_MAX_PARAM_VALUE_LEN				31
#define PF_MAX_EFFECT_MSG_LEN				255

// Through AE6.5, effects could only have this many parameters. Now the number is unlimited.
#define	PF_AE65_AND_EARLIER_MAX_NUM_EFFECT_PARAMS			127

#define PF_MAX_WORLD_WIDTH					30000
#define PF_MAX_WORLD_HEIGHT					30000

#define	PF_FIRST_ERR						512


/* Standard effect categories for After Effects effects modules.
 * These need to be set in the PiPL.
 */
#define PF_Category_BLUR_AND_SHARPEN	"Blur & Sharpen"
#define PF_Category_CHANNEL				"Channel"
#define PF_Category_DISTORT				"Distort"
#define PF_Category_IMAGE_CONTROL		"Image Control"
#define PF_Category_KEYING				"Keying"
#define PF_Category_PERSPECTIVE			"Perspective"
#define PF_Category_STYLIZE				"Stylize"
#define PF_Category_TEXT				"Text"
#define PF_Category_VIDEO				"Video"
#define PF_Category_TRANSITION			"Transition"
#define PF_Category_AUDIO				"Audio"
#define PF_Category_OTHER				"Other"	

enum {
	PF_Quality_DRAWING_AUDIO = -1,		// only used to inform audio plugins that the output
										// will be used to draw the waveform; the plugin should
										// not perform any filtering operations that may weaken
										// the amplitude when rendering at low sampling rates

	PF_Quality_LO = 0,					// LO & HI are sent to both audio & visual effects
	PF_Quality_HI
};
typedef A_long PF_Quality;

enum {
	PF_MF_Alpha_PREMUL 		= 0,
	PF_MF_Alpha_STRAIGHT 	= (1L << 0)
};
typedef A_long PF_ModeFlags;

#define			PF_ALPHA_PREMUL(F) 		(((F) & 0x00000001) == 0)
#define			PF_ALPHA_STRAIGHT(F)	(((F) & 0x00000001))

enum {
	PF_Field_FRAME = 0L,
	PF_Field_UPPER = 1L,
	PF_Field_LOWER = 2L
};
typedef A_long PF_Field;



/* PF_ParamType
 */
enum {
	PF_Param_RESERVED = -1,
	PF_Param_LAYER = 0,
	PF_Param_SLIDER,	/* obsolete, use PF_Param_FLOAT_SLIDER */
	PF_Param_FIX_SLIDER,/* obsolete, use PF_Param_FLOAT_SLIDER */
	PF_Param_ANGLE,
	PF_Param_CHECKBOX,
	PF_Param_COLOR,
	PF_Param_POINT,
	PF_Param_POPUP,
	PF_Param_CUSTOM,	/* obsolete */
	PF_Param_NO_DATA,	/* used for CustomUI in Effect window controls, with NO data stream */
	PF_Param_FLOAT_SLIDER,
	PF_Param_ARBITRARY_DATA,	// in AE: must combine with either PF_PUI_TOPIC/PF_PUI_CONTROL or PF_PUI_NO_ECW
								// in PPro starting with 8.0: it's OK to set none of those flags, which allows you to
								//		see the parameter's keyframe track on the right side of Effect Controls
								//		without creating a custom control
	PF_Param_PATH,
	PF_Param_GROUP_START,
	PF_Param_GROUP_END,
	PF_Param_BUTTON,			// must combine with PF_ParamFlag_SUPERVISE
	PF_Param_RESERVED2,
	PF_Param_RESERVED3,
	PF_Param_POINT_3D			// only supported by AE, not PPro
};
typedef A_long PF_ParamType;


/* PF_ParamFlags

	These flags are passed when adding a param (using PF_ADD_PARAM) to specify
	some details about how the param can be used.  The flags
	are:

	PF_ParamFlag_CANNOT_TIME_VARY
		If this is passed, the parameter will not be allowed to vary
		over time -- no keyframe controller will appear at the right.

	PF_ParamFlag_CANNOT_INTERP
		If this is passed, parameter values are not interpolated
		between.  You can still use no interp and discontinuous interp.
	
	PF_ParamFlag_COLLAPSE_TWIRLY / PF_ParamFlag_START_COLLAPSED
		Set this flag if you want the parameter's twirly arrow in the
		Effect Control Window to be twirled up by default when the
		effect is first applied.  New in AE 4.0: you can now set &
		clear this bit when handling PF_Cmd_UPDATE_PARAMS_UI and
		PF_Cmd_USER_CHANGED_PARAM messages, so as to twirl your
		parameters and groups up and down at will.

	PF_ParamFlag_SUPERVISE
		If this is passed, PF_Cmd_USER_CHANGED_PARAM will be sent when
		this parameter changes.

	PF_ParamFlag_USE_VALUE_FOR_OLD_PROJECTS
		This only affects the loading of projects saved with an older version
		of the effect which lacks parameters added later. When set, the PF_ParamDef 
		"value" field set in PF_ADD_PARAM will be used to initialize the missing parameter, 
		but the "dephault" field will still be used for initial value of the parameter when
		the effect is newly applied or reset. This is useful for when you want a 
		parameter to default to one value but need it set to something else to 
		preserve rendering behaviour for older projects.

		This flag is valid for all PF_Param types except PF_Param_LAYER

	PF_ParamFlag_LAYER_PARAM_IS_TRACKMATTE
		For PF_Param_LAYER, this flag indicates that the layer parameter is to be presented
		as a track matte. Supported by Premiere, ignored in AE.

	PF_ParamFlag_EXCLUDE_FROM_HAVE_INPUTS_CHANGED
		See doc for PF_HaveInputsChangedOverTimeSpan.

	PF_ParamFlag_SKIP_REVEAL_WHEN_UNHIDDEN
		when this param is "un hidden" (cuz it may hide and show), then the GUI is NOT to cause
		the parameter to be "revealed", ie: it won't twirl down it's parents and scroll it into view

**/
enum {
	PF_ParamFlag_RESERVED1			= 1 << 0,
	PF_ParamFlag_CANNOT_TIME_VARY	= 1 << 1,		/* can't vary over time */
	PF_ParamFlag_CANNOT_INTERP		= 1 << 2,		/* can only vary discontinuously */
	PF_ParamFlag_RESERVED2			= 1 << 3,		/* was _old_ PF_ParamFlag_WANTS_UPDATE value, never used */
	PF_ParamFlag_RESERVED3			= 1 << 4,		/* was _old_ PF_ParamFlag_SEPARATE, now use PF_PUI_ECW_SEPARATOR */
	PF_ParamFlag_COLLAPSE_TWIRLY	= 1 << 5,		/* controls the twirl-state of the twirly-arrow in the ECW (dynamic) */
	PF_ParamFlag_SUPERVISE			= 1 << 6,		/* call me with PF_Cmd_USER_CHANGED_PARAM (new in AE 4.0) */
	PF_ParamFlag_START_COLLAPSED = PF_ParamFlag_COLLAPSE_TWIRLY,	/* when first applied, param comes up collapsed */
	PF_ParamFlag_USE_VALUE_FOR_OLD_PROJECTS			= 1 << 7,		/* see extensive comment above */
	PF_ParamFlag_LAYER_PARAM_IS_TRACKMATTE			= 1 << 7,		/* only valid for layer parameters. indicates that a layer param is used as a track-matte with applied filters (used in Premiere, ignored in AE) */
	PF_ParamFlag_EXCLUDE_FROM_HAVE_INPUTS_CHANGED	= 1 << 8,		/* only relevant if you call PF_HaveInputsChangedOverTimeSpan() */
	PF_ParamFlag_SKIP_REVEAL_WHEN_UNHIDDEN			= 1 << 9		/* dont reveal this stream when un-hidden (use only during param setup) */
};
typedef A_long PF_ParamFlags;

enum {
	PF_Err_NONE = 0,
	PF_Err_OUT_OF_MEMORY = 4,
	PF_Err_INTERNAL_STRUCT_DAMAGED = PF_FIRST_ERR,
	PF_Err_INVALID_INDEX,			/* out of range, or action not allowed on this index */
	PF_Err_UNRECOGNIZED_PARAM_TYPE,
	PF_Err_INVALID_CALLBACK,
	PF_Err_BAD_CALLBACK_PARAM,
	PF_Interrupt_CANCEL,				/* Returned when user interrupts rendering */
	PF_Err_CANNOT_PARSE_KEYFRAME_TEXT	/* Returned from PF_Arbitrary_SCAN_FUNC when effect
											cannot parse arbitrary data from text */
};
typedef	A_long PF_Err;


enum {
	PF_WorldFlag_DEEP 	   		= 1L << 0,
	PF_WorldFlag_WRITEABLE 		= 1L << 1,


	PF_WorldFlag_RESERVED0		= 1L << 24,
	PF_WorldFlag_RESERVED1		= 1L << 25,
	PF_WorldFlag_RESERVED2		= 1L << 26,
	PF_WorldFlag_RESERVED3		= 1L << 27,
	PF_WorldFlag_RESERVED4		= 1L << 28,
	PF_WorldFlag_RESERVED5		= 1L << 29,
	PF_WorldFlag_RESERVED6		= 1L << 30,
	PF_WorldFlag_RESERVED		= 1L << 31
};

typedef A_long PF_WorldFlags;

#define PF_WORLD_IS_DEEP(W)		( ((W)->world_flags & PF_WorldFlag_DEEP) != 0 )

#define PF_MAX_CHAN8			255
#define PF_HALF_CHAN8			128
#define PF_MAX_CHAN16			32768
#define PF_HALF_CHAN16			16384



/** -------------------- Output Flags --------------------

	The out_flags field of the OutData can be set to an OR-ed
	combination of these flags to communicate various things to
	the driver program.  The flags are described here:

	PF_OutFlag_NONE
		This is the "empty" setting -- no outflags.

	PF_OutFlag_WIDE_TIME_INPUT
		Set this flag if the effect calls get_param to inquire a
		parameter at a time besides the current one (e.g. to get
		the previous video frame). This should be sent, if it is
		going to be sent, at PF_Cmd_GLOBAL_SETUP. Can be over-ridden 
		dynamically during PF_Cmd_QUERY_DYNAMIC_FLAGS.

		As of AE10, this flag is no longer recommended. It still works the
		same way and is safe to set, but there's a more efficient option.
		See PF_OutFlag2_AUTOMATIC_WIDE_TIME_INPUT.

	PF_OutFlag_NON_PARAM_VARY
		Set this if the effect uses information other than the parameters
		in the param list to generate its output at the current time.
		For instance, if the effect uses the current time of the frame
		or some random value to decide the output, set this flag.  This
		flag should be sent at PF_Cmd_GLOBAL_SETUP.  If the effect
		produces changing frames when applied to a still image and
		all parameters are constant, that's a sure sign that this bit
		should be set (e.g. Wave Warp).	Can be over-ridden dynamically 
		during PF_Cmd_QUERY_DYNAMIC_FLAGS.

	PF_OutFlag_SEQUENCE_DATA_NEEDS_FLATTENING
		When you allocate a sequence data handle, the app 
		may write the handle out to disk and reuse it  
		later. Pass this flag if the handle is not "flat" 
		(i.e. has pointers or handles hanging off of it).  
		Basically, this gives you a chance to alter the 
		handle contents before it is written out to disk, 
		so  you won't get invalid handles or pointers. Once 
		you have flattened a handle, you will get an  
		opportunity to un-flatten it before the effect 
		needs to continue. For sequence data, you will be  
		invoked with a PF_Cmd_SEQUENCE_RESETUP call. You 
		should store a boolean at a common  offset in your 
		unflattened and flattened data that says whether 
		the data is flat or not. If you get a  
		PF_Cmd_SEQUENCE_RESETUP and the boolean indicated 
		the data is flattened, you should  unflatten the 
		data, free the flattened data handle, and set the 
		sequence_data handle in the  PF_OutData. If you 
		ever set the data to NULL when you flatten it, you 
		will NOT get the sequence  resetup call to 
		unflatten it. Instead, you may just get a RENDER 
		call with NULL data. Forewarned is  forearmed. This 
		flag, indicating if the data will need to be 
		flattened, should be set at  PF_Cmd_GLOBAL_SETUP time.  
	
	PF_OutFlag_I_DO_DIALOG
		Set this is the effect responds to a PF_Cmd_DO_DIALOG, i.e. Does this
		effect bring up an options dialog box.  PF_Cmd_DO_DIALOG is generated
		when the user presses the Options button on the Effect floater.
		This flag should be set at PF_Cmd_GLOBAL_SETUP time.

	PF_OutFlag_USE_OUTPUT_EXTENT
		The output layer is passed with an "extent rect" indicating
		the area of the layer that actually contains visible image data.  If
		the effect changes its behavior based on the extent rect (for instance,
		by not iterating over the entire image), set this flag, so the
		application will know whether having the extent	change should cause
		the frame to re-render.  Specify this flag at PF_Cmd_GLOBAL_SETUP.

	PF_OutFlag_SEND_DO_DIALOG
		Some filters need their options dialog box to be brought up at least
		once to be valid.  You can set this flag, and the driver app will
		automatically send a PF_Cmd_DO_DIALOG to the effect when it is applied.
		The DO_DIALOG will be sent after PF_Cmd_SEQUENCE_SETUP.  This flag
		should be set in PF_Cmd_SEQUENCE_SETUP if it is going to be set.

	PF_OutFlag_DISPLAY_ERROR_MESSAGE
		Whenever the return_msg field in the PF_OutData is set to a string,
		After Effects will bring up a simple dialog box containing that
		string.  If you set this flag, the dialog box will be made to look
		like an error message dialog box.  If you don't set this flag, it
		will be an undecorated dialog box.  Using this flag, an effects module
		can have and display its own error messages and not worry about the
		code for dialog boxes -- the program will do it for you.
		This flag can be sent after any command.
		
	PF_OutFlag_I_EXPAND_BUFFER
		Starting with After Effects 2.0, effects will be able to expand their buffers
		beyond the current layer's dimensions. This has always been part of the
		PF specification, but as an extra precaution (and hint to the AE rendering
		engine) set this flag at PF_Cmd_GLOBAL_SETUP if you plan to expand your
		buffer.
	
	PF_OutFlag_I_SHRINK_BUFFER
		Set this flag if you can shrink your buffer based on the extent-rects passed
		to you in order to be more memory efficient.

	PF_OutFlag_PIX_INDEPENDENT
		Set this flag if the output at a given pixel is not dependent on the values
		of the pixels around it. If this is set, the pixels After Effects does not
		care about (because of field rendering, for example) could be filled with garbage
		colors.  Please set this flag at PF_Cmd_GLOBAL_SETUP. Can be over-ridden 
		dynamically during PF_Cmd_QUERY_DYNAMIC_FLAGS.

	PF_OutFlag_I_WRITE_INPUT_BUFFER
		Set this flag if your effect would like to write into the input buffer. This
		can be useful if you need an scratch buffer, but it also invalidates some speedups
		in the AE rendering pipeline, so use it with some discretion. Please set this
		flag at PF_Cmd_GLOBAL_SETUP.

	PF_OutFlag_KEEP_RESOURCE_OPEN
		
		Obsoleted in AE 2015 (does nothing when set).

		Set this flag if your effect expects its Macintosh resource fork to be open 
		at any time other than global setup.  Note that this does not mean that
		the resource fork will be kept open at all times, just whenever the
		effect is being executed.

	PF_OutFlag_NOP_RENDER
	
		Set this flag in PF_Cmd_GLOBAL_SETUP if the render would never result in changes
 		to the source image (or audio?). For example, an expression control would set this.

	PF_OutFlag_CUSTOM_UI

		This flag must be set if your effect has a custom UI in the Effect Controls
		Window, Layer Window or Comp Window.

	PF_OutFlag2_CUSTOM_UI_ASYNC_MANAGER	(new in 13.5)

		This flags enables use of AEGP_CheckoutOrRender_*_AsyncManager() calls
		which avoid the need for plugin management of the lifetime of async custom UI renders from the UI thread. 
		The plugin asks for what frames it needs and the manager calls PF_Event_DRAW again when they are available
		(or cancels them as needed automatically).  The plugin responds in PF_Event_DRAW by asking for what it needs
		and drawing what it can from what is available.

		Due to separation of Render thread and UI thread in 13.5, frames for custom UI should no longer be 
		rendered synchronously (see RenderSuite5 for more details). The manager simplifies this, especially when
		there are multiple requests needed for DRAW.

		When enabled, this flag associates a "PF_AsyncManager" with the NEW_CONTEXT/CLOSE_CONTEXT and PF_Event_DRAW
		that will automatically track completion of 1 or more asynch render requests made for drawing custom UI.
		As requests complete,  PF_Event_DRAW will be called again and the current state of the CUSTOM_UI can be drawn.
		Such requests may be canceled automatically as the user scrubs the time needle or project changes are made and
		become invalid. 

		This flag is used in addition to the CUSTOM_UI flag during PF_Cmd_GLOBAL_SETUP

	PF_OutFlag_REFRESH_UI

		Can be returned from PF_Cmd_EVENT, PF_Cmd_RENDER, and PF_Cmd_DO_DIALOG.
		Causes the effects control window, layer window, and comp window to be re-drawn.
	
	PF_OutFlag_I_USE_SHUTTER_ANGLE
		
		Must be set at PF_Cmd_GLOBAL_SETUP time if the effect uses
		the shutter_angle or the shutter_phase. Can be over-ridden dynamically during 
		PF_Cmd_QUERY_DYNAMIC_FLAGS.

	PF_OutFlag_I_USE_AUDIO
		
		Must be set at PF_Cmd_GLOBAL_SETUP time for a visual effect
		that calls the audio checkout calls.

	PF_OutFlag_I_AM_OBSOLETE

		Set at PF_Cmd_GLOBAL_SETUP time for effects that don't
		want to appear in the AE Effects menu (but will still be invoked
		if you load a project that has an old copy of the effect applied).

	PF_OutFlag_FORCE_RERENDER
	
		Set at PF_Cmd_EVENT if the effect modified sequence data,
		or did anything else that requires the effect needs to re-render.
		Note that setting PF_ChangeFlag_CHANGED_VALUE automatically
		causes a re-render, so don't worry about setting PF_OutFlag_FORCE_RERENDER
		in that case. Also, I_MIX_GUID_DEPENDENCIES can be used to trigger a rerender on
		dependant changes if sequence_data has not been changed.

		IMPORTANT: FORCE_RERENDER should be used as a last resort. Long term we should be eliminating the need for this
		because it causes forced cache invalidation that doesn't work well with undo.
		Once we have the full set of APIs in place needed to manage render state, we will be able to deprecate this.
		Prefer using ARB data + CHANGED_VALUE or I_MIX_GUID_DEPENDENCIES when possible instead.

		In 13.5 the split between a UI and render threads means that FORCE_RERENDER will now also have the needed
		side effect of copying sequence_data state to the render project.  This can be expensive if the sequence_data is large.
		Support GET_FLATTENED_SEQUENCE_DATA to prevent deallocation of your sequence_data, which can help.
		GET_FLATTENED_SEQUENCE_DATA support is required for FORCE_RERENDER use in custom mouse/key events.

	PF_OutFlag_PiPL_OVERRIDES_OUTDATA_OUTFLAGS

		Valid only for setting in your PiPL.  When set out_flags will be
		ignored at PF_Cmd_GLOBAL_SETUP time (& thus don't need to match).

	PF_OutFlag_I_HAVE_EXTERNAL_DEPENDENCIES

		Set this flag at PF_Cmd_GLOBAL_SETUP time if the effect has dependencies
		that the user should know about before transporting their project to a
		different machine.  For example, dependencies on an installed font,
		or on an external file.  If set, the effect will receive a
		PF_Cmd_GET_EXTERNAL_DEPENDENCIES request, where the extra
		param will be a PF_ExtDependenciesExtra, and the effect should
		report its information based on the given sequence_data.

	PF_OutFlag_SEND_UPDATE_PARAMS_UI

		Set this flag at PF_Cmd_GLOBAL_SETUP time if you want to receive
		PF_Cmd_UPDATE_PARAMS_UI messages.

	PF_OutFlag_AUDIO_FLOAT_ONLY

		Set this flag if you only want to receive PF_SIGNED_FLOAT data
		when processing audio data.  Requires PF_OutFlag_AUDIO_EFFECT_TOO
		or PF_OutFlag_AUDIO_EFFECT_ONLY.

	PF_OutFlag_AUDIO_IIR

		Set this flag at PF_Cmd_GLOBAL_SETUP time if you are an
		Infinite-Impulse-Response audio filter (i.e. your output at a given
		time depends on your output from previous times).

	PF_OutFlag_I_SYNTHESIZE_AUDIO

		Set this flag at PF_Cmd_GLOBAL_SETUP time if you generate
		audio even when handed silence.  Requires PF_OutFlag_AUDIO_EFFECT_TOO
		or PF_OutFlag_AUDIO_EFFECT_ONLY.

	PF_OutFlag_AUDIO_EFFECT_TOO

		Must be set at PF_Cmd_GLOBAL_SETUP time for an effect that
		wants to filter the audio too (as opposed to just reading the audio).
		
	PF_OutFlag_AUDIO_EFFECT_ONLY

		Must be set at PF_Cmd_GLOBAL_SETUP time for an effect
		that only filters audio (no video).

	PF_OutFlag2_SUPPORTS_QUERY_DYNAMIC_FLAGS

		Set this during PF_Cmd_GLOBAL_SETUP if the effect handles PF_Cmd_QUERY_DYNAMIC_FLAGS. 
		Supporting this command can dramatically improve performance for certain 
		effects, because it provides dynamic information to the host about what 
		can be cached (as opposed to PIPL bits which cannot be changed at run-time)

	PF_OutFlag2_I_USE_3D_CAMERA
		
		This bit must be set if the effect ever uses the AEGP PF_Interface suite to
		access camera layers. Can be over-ridden dynamically during PF_Cmd_QUERY_DYNAMIC_FLAGS.

	PF_OutFlag2_I_USE_3D_LIGHTS
		
		This bit must be set if the effect ever uses the AEGP PF_Interface suite to
		access camera layers. Can be over-ridden dynamically during PF_Cmd_QUERY_DYNAMIC_FLAGS.

	PF_OutFlag2_PARAM_GROUP_START_COLLAPSED_FLAG
		
		If you want a parameter group to honor the PF_ParamFlag_COLLAPSE_TWIRLY or
		PF_ParamFlag_START_COLLAPSED flag, set this bit.  Otherwise, all parameter
		groups will be collapsed by default.  

	PF_OutFlag2_DOESNT_NEED_EMPTY_PIXELS
	
		Added for render optimizations; shrinks the input buffer passed to the effect to 
		exclude any empty pixels (where empty means "zero alpha" unless 
		PF_OutFlag2_REVEALS_ZERO_ALPHA is set, in which case RGB must be zero as well.) 
		The origin of the trimmed buffer can be found in in_data->pre_effect_source_origin. 
		Effects with both this flag and PF_OutFlag_I_EXPAND_BUFFER set may get called with 
		a null input buffer if their input is completely empty, and must be able to handle 
		this case without crashing. This flag can be cleared dynamically during
		PF_Cmd_QUERY_DYNAMIC_FLAGS.

	PF_OutFlag2_REVEALS_ZERO_ALPHA
	
		The effect can take pixels with zero alpha and reveal the RGB data in them (like 
		our Set Channels effect). This tells After Effects not to trim such pixels when 
		determining the input for the effect. This flag can be cleared dynamically during
		PF_Cmd_QUERY_DYNAMIC_FLAGS.

	PF_OutFlag2_I_AM_DEPRECATED
		this effect is still available, and shows up under user-visible "Obsolete" category 
		in the UI. Setting this flag means "there's a better way to do this, but this effect
		may still be useful in some situations".  distinct from PF_OutFlag_I_AM_OBSOLETE in 
		that these will still show up in the GUI and the user can still apply them to new
		projects.  The category that is set by the effect is pretty much ignored, as it will
		instead always go into the "Obsolete" category

	PF_OutFlag2_I_USE_TIMECODE
		New in AE 9.0.  The effect depends on the Composition's timecode or a layer's
		source footage timecode.  If the underlying timecode changes the effects will
		be asked to rerender.

	PF_OutFlag2_AUTOMATIC_WIDE_TIME_INPUT
		New in AE 10. Requires setting of PF_OutFlag_WIDE_TIME_INPUT (which allows you
		to support old hosts), but effectively overrides that flag. When set, all
		parameter checkouts are tracked so over-time dependencies are known by AE. Note
		that if you use this new flag, and you cache any time-dependent data in your
		sequence data (or anywhere else), you must validate that cache using the
		new PF_HaveInputsChangedOverTimeSpan() before using it.

		This only works for smart effects (those that set PF_OutFlag2_SUPPORTS_SMART_RENDER). If you haven't
		set that, After Effects will silently treat this as PF_OutFlag_WIDE_TIME_INPUT instead.

		To test that it's working, apply your effect with one parameter keyframed on every frame.
		RAM Preview to fill the cache, then change one of the keyframes. The related frame and
		all dependent frames (e.g. later frames, in the case of a simulation) should lose their
		cache marks and require re-rendering. Simlarly, upstream changes to sources of layer
		parameters should cause time-selective invalidation of the cache.

	PF_OutFlag2_DEPENDS_ON_UNREFERENCED_MASKS
		Set this if you are going to look at paths that aren't directly referenced by a path
		param, e.g. if you are going to draw a stroke on all masks.

	PF_OutFlag2_OUTPUT_IS_WATERMARKED
		Set this if your output is going to be watermarked in some way that makes it unsuitable for
		final use, probably because the user is using an unlicensed demo version. It is ok to change
		this state during the course of app session, if e.g. a floating license status changes. 
		Plugin authors that actually do have this state changing asynchronously must be careful to 
		have the next render match the last state returned from QUERY_DYNAMIC_FLAGS otherwise race conditions
		could cause incorrect frames to be cached. (This is a non-issue if you only change this in response
		to DO_DIALOG.)
 
 	PF_OutFlag2_I_MIX_GUID_DEPENDENCIES	(new in 13.5)
 		Smart effects only. With this option, FORCE_RERENDER becomes a cache-savvy more efficient MAYBE rerender.
		If custom UI or DO_DIALOG change sequence data, returning FORCE_RERENDER requests AE to check whether
		rerender needs to occur.  During PreRender, the effect uses the GuidMixInPtr callback to mix
		any additional state that affects the render into our internal GUID for the cached frame.
		AE can then tell whether the frame already exists and if so, no longer needs to render.
		This also means that DO_DIALOG no longer always blows the cache and that undo works across DO_DIALOG.
		Cancelation of DO_DIALOG no longer blows the cache either.
		This also means that I_USE_* flags are now basically redundant since any dependency could be mixed in.
		Just be sure to mix in everything that can uniquely affect resulting rendered pixels (that is not already
		an AE stream parameter).  But don't mixin things that are disabled and have no render effect  (this 
		results in less cache efficiency).

	PF_OutFlag2_SUPPORTS_THREADED_RENDERING
		Indicates the effect supports rendering on multiple threads at the same time. Single or multiple
		applications of this effect on a layer can be called to render at the same time on multiple threads.

		UI selectors are still sent on the main thread, however Sequence Setup, Sequence Resetup, Sequence SetDown,
		PreRender, and Render may be sent on multiple threads at the same time as the UI selectors are being handled
		so all of these selectors must be thread safe.

		Global Setup and Global Setdown selectors are unaffected by this flag.  Regardless whether this flag is set
		or not, they will only be sent on the main thread, and will not be sent at the same time as any other selectors.

		If the effect sets PF_OutFlag_SEQUENCE_DATA_NEEDS_FLATTENING indicating the sequence data needs flattening
		then it must also set PF_OutFlag2_SUPPORTS_GET_FLATTENED_SEQUENCE_DATA.
		
		sequence_data is read-only at render time and must be accessed with PF_EffectSequenceDataSuite.
		in_data->sequence_data will be NULL during render. AEGP_ComputeCacheSuite is suggested if writing to
		sequence_data at render time is needed for caching. This suite unifies cache entries so multiple threads do
		not recompute the same cache value. If neither of these solutions work, see the next flag,
		PF_OutFlag2_MUTABLE_RENDER_SEQUENCE_DATA_SLOWER.

	PF_OutFlag2_MUTABLE_RENDER_SEQUENCE_DATA_SLOWER
		Indicates the effect needs sequence_data replicated for each render thread, thus allowing each render to have
		sequence_data which can be written to. Note that changes to sequence_data will be discarded regularly, currently
		after each span of frames is rendered such as single RAM Preview or Render Queue export.

**/

enum {
	PF_OutFlag_NONE = 0L,

																// which PF_Cmds each flag is relevant for:
	PF_OutFlag_KEEP_RESOURCE_OPEN				= 1L << 0,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag_WIDE_TIME_INPUT					= 1L << 1,		// PF_Cmd_GLOBAL_SETUP, PF_Cmd_QUERY_DYNAMIC_FLAGS
	PF_OutFlag_NON_PARAM_VARY					= 1L << 2,		// PF_Cmd_GLOBAL_SETUP, PF_Cmd_QUERY_DYNAMIC_FLAGS
	PF_OutFlag_RESERVED6						= 1L << 3,
	PF_OutFlag_SEQUENCE_DATA_NEEDS_FLATTENING	= 1L << 4,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag_I_DO_DIALOG						= 1L << 5,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag_USE_OUTPUT_EXTENT				= 1L << 6,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag_SEND_DO_DIALOG					= 1L << 7,		// PF_Cmd_SEQUENCE_SETUP
	PF_OutFlag_DISPLAY_ERROR_MESSAGE			= 1L << 8,		// all PF_Cmds
	PF_OutFlag_I_EXPAND_BUFFER					= 1L << 9,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag_PIX_INDEPENDENT					= 1L << 10,		// PF_Cmd_GLOBAL_SETUP, PF_Cmd_QUERY_DYNAMIC_FLAGS 
	PF_OutFlag_I_WRITE_INPUT_BUFFER				= 1L << 11,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag_I_SHRINK_BUFFER					= 1L << 12,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag_WORKS_IN_PLACE					= 1L << 13,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag_RESERVED8						= 1L << 14,
	PF_OutFlag_CUSTOM_UI						= 1L << 15,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag_RESERVED7						= 1L << 16,
	PF_OutFlag_REFRESH_UI						= 1L << 17,		// PF_Cmd_EVENT, PF_Cmd_RENDER, PF_Cmd_DO_DIALOG
	PF_OutFlag_NOP_RENDER						= 1L << 18,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag_I_USE_SHUTTER_ANGLE				= 1L << 19,		// PF_Cmd_GLOBAL_SETUP, PF_Cmd_QUERY_DYNAMIC_FLAGS
	PF_OutFlag_I_USE_AUDIO						= 1L << 20,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag_I_AM_OBSOLETE					= 1L << 21,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag_FORCE_RERENDER					= 1L << 22,		// PF_Cmd_EVENT, PF_Cmd_USER_CHANGED_PARAM, PF_Cmd_UPDATE_PARAMS_UI
	PF_OutFlag_PiPL_OVERRIDES_OUTDATA_OUTFLAGS	= 1L << 23,		// PiPL-only-flag
	PF_OutFlag_I_HAVE_EXTERNAL_DEPENDENCIES		= 1L << 24,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag_DEEP_COLOR_AWARE					= 1L << 25,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag_SEND_UPDATE_PARAMS_UI			= 1L << 26,		// PF_Cmd_GLOBAL_SETUP

	// audio flags (PF_OutFlag_AUDIO_EFFECT_TOO or PF_OutFlag_AUDIO_EFFECT_ONLY required for audio effects)
	PF_OutFlag_AUDIO_FLOAT_ONLY					= 1L << 27,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag_AUDIO_IIR						= 1L << 28,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag_I_SYNTHESIZE_AUDIO				= 1L << 29,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag_AUDIO_EFFECT_TOO					= 1L << 30,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag_AUDIO_EFFECT_ONLY				= 1L << 31		// PF_Cmd_GLOBAL_SETUP
};
typedef A_long PF_OutFlags;

enum {
	PF_OutFlag2_NONE = 0L,
																// which PF_Cmds each flag is relevant for:
	PF_OutFlag2_SUPPORTS_QUERY_DYNAMIC_FLAGS	= 1L << 0,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag2_I_USE_3D_CAMERA					= 1L << 1,		// PF_Cmd_GLOBAL_SETUP, PF_Cmd_QUERY_DYNAMIC_FLAGS
	PF_OutFlag2_I_USE_3D_LIGHTS					= 1L << 2,		// PF_Cmd_GLOBAL_SETUP, PF_Cmd_QUERY_DYNAMIC_FLAGS
	PF_OutFlag2_PARAM_GROUP_START_COLLAPSED_FLAG= 1L << 3,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag2_I_AM_THREADSAFE					= 1L << 4,		// PF_Cmd_GLOBAL_SETUP (unused)
	PF_OutFlag2_CAN_COMBINE_WITH_DESTINATION	= 1L << 5,		// Premiere only (as of AE 6.0)
	PF_OutFlag2_DOESNT_NEED_EMPTY_PIXELS		= 1L << 6,		// PF_Cmd_GLOBAL_SETUP, PF_Cmd_QUERY_DYNAMIC_FLAGS
	PF_OutFlag2_REVEALS_ZERO_ALPHA				= 1L << 7,		// PF_Cmd_GLOBAL_SETUP, PF_Cmd_QUERY_DYNAMIC_FLAGS
	PF_OutFlag2_PRESERVES_FULLY_OPAQUE_PIXELS	= 1L << 8,		// Premiere only (as of AE 6.0)
	PF_OutFlag2_SUPPORTS_SMART_RENDER			= 1L << 10,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag2_RESERVED9						= 1L << 11,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag2_FLOAT_COLOR_AWARE				= 1L << 12,		// PF_Cmd_GLOBAL_SETUP, may require PF_OutFlag2_SUPPORTS_SMART_RENDER
	PF_OutFlag2_I_USE_COLORSPACE_ENUMERATION	= 1L << 13,		// PF_Cmd_GLOBAL_SETUP, not implemented in AE7 (may be impl in Premiere Pro)
	PF_OutFlag2_I_AM_DEPRECATED					= 1L << 14,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag2_PPRO_DO_NOT_CLONE_SEQUENCE_DATA_FOR_RENDER	= 1L << 15,		// PF_Cmd_GLOBAL_SETUP, Premiere only, CS4.1 and later
	PF_OutFlag2_RESERVED10						= 1L << 16,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag2_AUTOMATIC_WIDE_TIME_INPUT		= 1L << 17,		// PF_Cmd_GLOBAL_SETUP, falls back to PF_OutFlag_WIDE_TIME_INPUT if not PF_OutFlag2_SUPPORTS_SMART_RENDER
	PF_OutFlag2_I_USE_TIMECODE					= 1L << 18,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag2_DEPENDS_ON_UNREFERENCED_MASKS	= 1L << 19,		// PF_Cmd_GLOBAL_SETUP, PF_Cmd_QUERY_DYNAMIC_FLAGS
	PF_OutFlag2_OUTPUT_IS_WATERMARKED			= 1L << 20,		// PF_Cmd_GLOBAL_SETUP, PF_Cmd_QUERY_DYNAMIC_FLAGS
	PF_OutFlag2_I_MIX_GUID_DEPENDENCIES			= 1L << 21,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag2_AE13_5_THREADSAFE				= 1L << 22,		// PF_Cmd_GLOBAL_SETUP (unused)
	PF_OutFlag2_SUPPORTS_GET_FLATTENED_SEQUENCE_DATA	= 1L << 23,		// PF_Cmd_GLOBAL_SETUP, support required if both PF_OutFlag_SEQUENCE_DATA_NEEDS_FLATTENING and PF_OutFlag2_SUPPORTS_THREADED_RENDERING is set
	PF_OutFlag2_CUSTOM_UI_ASYNC_MANAGER			= 1L << 24,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag2_SUPPORTS_GPU_RENDER_F32			= 1L << 25,		// PF_Cmd_GLOBAL_SETUP, PF_Cmd_GPU_DEVICE_SETUP. Must also set PF_RenderOutputFlag_GPU_RENDER_POSSIBLE at pre-render to enable GPU rendering.
	PF_OutFlag2_RESERVED12						= 1L << 26,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag2_SUPPORTS_THREADED_RENDERING		= 1L << 27,		// PF_Cmd_GLOBAL_SETUP
	PF_OutFlag2_MUTABLE_RENDER_SEQUENCE_DATA_SLOWER = 1L << 28	// PF_Cmd_GLOBAL_SETUP
};
typedef A_long PF_OutFlags2;


/** -------------------- Input Flags --------------------

        The in_flags field of the InData can be set to an OR-ed
        combination of these flags to communicate various things from AE to an effect plugin
        The flags are described here:

        PF_InFlag_NONE
                This is the "empty" setting -- no inflags.

        PF_InFlag_PROJECT_IS_RENDER_ONLY  (since 13.5)
 
			For efficiency, if a plugin sets up UI that is not used in render, this flag
			can be tested to skip that step when an effect is being RESETUP for render only.
			Effect instances with this flag on in RESETUP are in read-only AE projects and will not receive UI related selectors.
 
			This is an optimization hint.  If you don't make such optimizations in render your plugin should still work.
 
			This flag should generally not be used to suppress errors in render.  Errors should still be reported as usual via AE standard mechanisms,
			and AE will then handle the differences in context reporting.
 
			If this is off, UI should be set up normally (and the effect could also be running in an earlier version of
			AE that assumed render and UI on the same effect instance.)
		
**/

enum {
	PF_InFlag_NONE = 0L,
	PF_InFlag_PROJECT_IS_RENDER_ONLY = 1L << 0	// since 13.5 and only in PF_Cmd_SEQUENCE_RESETUP
};
typedef A_long PF_InFlags;





/** -------------------- Command Selectors --------------------

	The first parameter to the effect routine is one of t	hese command
	selectors.  The commands are described here.

	PF_Cmd_ABOUT
		This command should display an information dialog box about the
		effect module.  The easiest thing to do is PF_SPRINTF the info
		into the out_data->return_msg field.  After Effects will bring
		up a simple undecorated modal dialog with your text proudly displayed.
		This command can be sent at _any_ time, so don't count on having
		any global data or anything else set.  (Except, as always, the
		current resource file will be set to your effects module.)

	PF_Cmd_GLOBAL_SETUP
		When you get this command, you should check the version of the
		effect protocol with which you are being invoked, and set any of
		the necessary out flags (described above) or out data fields
		(described below).  If your global data was flattened, the flat
		data will be passed here and you should unflatten it, free the
		flat global data, and set the OutData global_data to the new un-flat
		data.  Alternatively, the global data may come in NULL and you can
		allocate new global data at this time.

	PF_Cmd_GLOBAL_SETDOWN
		You should free any global data you have allocated when you get
		this command.

	PF_Cmd_PARAMS_SETUP
		Here you should add any params your effect wants using the
		PF_ADD_PARAM callback described below.  This is called after global
		setup -- see the add_param callback described below.

	PF_Cmd_SEQUENCE_SETUP
		This is called when the effect is first applied to a layer.
		A sequence is a series of images that will usually be all be of the same
		size and in the same context.  You can allocate sequence data
		at this time -- many more input fields are defined at this time.
		See the PF_InData description below.
 
		As of 13.5 this only happens on the UI thread. 
		Except for legacy (no GET_FLATTENED_SEQUENCE_DATA) effects that do I_DO_DIALOG which can still hit this in render.

	PF_Cmd_SEQUENCE_RESETUP
		This call is made to unflatten flattened sequence data.
		There are at least three cases when this can happen:
		1) after the sequence data is written to disk, 2) after the
		sequence data is read in from disk, 3) after a duplicate
		is made (called on both original and the new sequence).
 
		This can happen in UI or Render thread (13.5),  the effect must handle
		initialization of a NULL sequence_data input if needed.  See also PF_InFlag_PROJECT_IS_RENDER_ONLY.
 
	PF_Cmd_SEQUENCE_FLATTEN
		This call is made to flatten unflat sequence data so it can be
		cached to disk.  After the data is flattened, free the un-flat data
		and set the out_data->sequence_data to the new flat data.
		If you don't want your sequence handle written to disk, you
		can set it to NULL (after disposing it) at this time.  Presumably
		you would then reallocate it at another time.

		This command will be sent when saving and when duplicating
		the sequence.

	PF_Cmd_GET_FLATTENED_SEQUENCE_DATA	(new in 13.5)
		Returns an independent allocation of the sequence data which can be written
		to disk or used to initialise or update other instances of the effect plug-in.

		The host calls this command to serialize the sequence data without
		having to flatten and resetup the UI plug-in as was legacy practice. (However, at present effects
		still may need flattening in render if the sequence_data is about to be assigned.)
 
		An effect that implements GET_FLATTENED_SEQUENCE_DATA will only receive SEQUENCE_SETUP on the UI thread.
		SEQUENCE_RESETUP can happen on either thread. Make sure you handle a NULL sequence_data in RESETUP.
		(Without GET_FLATTENED, a legacy effect may still get SEQUENCE_SETUP in render but DO_DIALOG will not be called.)
 
		Also when enabled, this means that the effect is guaranteed to get a
		SEQUENCE_SETDOWN cmd to dispose the effect's sequence_data  (previously
		it was possible for AE to bypass this if the sequence_data was flat,
		but that lead to SEQUENCE_SETUP/SETDOWN imbalances for some plugins.
		The imbalance should not happen when using this flag, but the plugin must
		handle being called on SETDOWN with possibly flat data. For example,
		try copy and pasting an effect onto itself.

		Support for this command is indicated by setting
		PF_OutFlag2_SUPPORTS_GET_FLATTENED_SEQUENCE_DATA
	
		The ownership of the returned handle is transferred to the host.

	PF_Cmd_SEQUENCE_SETDOWN
		You should free any sequence data you have allocated when you
		get this command.

	PF_Cmd_DO_DIALOG
		This command indicated that the Options button or command has
		been selected and the effect should bring up its options dialog.
		This command will only be sent it the effect has indicated that
		it has an options dialog with PF_OutFlag_I_DO_DIALOG.  This
		command will automatically be sent once upon applying the filter
		if PF_OutFlag_SEND_DO_DIALOG is set in SEQUENCE_SETUP.

	PF_Cmd_FRAME_SETUP
		This is called immediately before each frame is invoked.  You
		can allocate frame data at this time, if you wish, or you can
		just wait for the RENDER which will immediately follow.

	PF_Cmd_RENDER
		This is the call to render the frame.  All fields in the in_data
		will be valid at this time and you can inquire parameters or
		what-have-you.  This should set the output frame with the new
		image data.  This is the main action command.

	PF_Cmd_FRAME_SETDOWN
		If you allocated data in PF_Cmd_FRAME_SETUP, this is the time
		to free it and clean up after rendering the frame.

	PF_Cmd_USER_CHANGED_PARAM
		This command will be sent if you set the PF_ParamFlag_SUPERVISE
		flag for a param.  This allows you to modify the params array contents to
		control values or make one control affect others, including arbitrary
		data.  This command will be sent whenever the user interacts with a
		standard param controller that has PF_ParamFlag_SUPERVISE
		set.
		
		The "extra" field will be a pointer to a PF_UserChangedParamExtra structure
		which contains the param_index of the changed parameter.

		You can return PF_ChangeFlag_CHANGED_VALUE and/or call PF_UpdateParamUI()
		for any param.
	
	PF_Cmd_UPDATE_PARAMS_UI
		This command will be sent when the Effect Controls Window (ECW)
		needs to updated (e.g. after opening the ECW or moving the comp to
		a new time) if you have set PF_OutFlag_SEND_UPDATE_PARAMS_UI at
		global setup time.

		This gives you a chance to call PF_UpdateParamUI() to modify certain 
		ui fields for the params.  See the doc for PF_UpdateParamUI()
		to see which fields can be modified.

		WARNING: When handling PF_Cmd_UPDATE_PARAMS_UI, you can call
		PF_UpdateParamUI() for any param(s), but not PF_ChangeFlag_CHANGED_VALUE --
		only cosmetic changes can be made in response to this command.

	PF_Cmd_QUERY_DYNAMIC_FLAGS
		This command will be sent at arbitrary times if PF_OutFlag2_SUPPORTS_QUERY_DYNAMIC_FLAGS
		is set during global setup. During this call the effect may examine the values
		of its parameters at the current time (except layer parameters) by checking them out, 
		and decide whether any of the flags that support PF_Cmd_QUERY_DYNAMIC_FLAGS should be set.

		The appropriate flags must be set in out_data->out_flags and out_data->out_flags2 before
		returning. The effect must decide what information is necessary to render a frame at 
		the current time, given only the values of parameters at that time. Clearing the 
		appropriate bits when possible can result in great performance improvements, but 
		incorrectly clearing bits will result in caching bugs, and you won't like that. Nope.

	*** Important Reminder***
		Before you add a new PF_Cmd, evaluate whether it should allow
		new Sequence Data allocations! If so, remember to add it to
		CmdCanChangeSequenceData() in FLT_Host.cpp!

**/
enum {		/* The order of this enumeration must not be altered! */
	PF_Cmd_ABOUT = 0,			/* about can be called at any time */
	PF_Cmd_GLOBAL_SETUP,		/* check versions, cpu, serial #, etc. always */
	PF_Cmd_UNUSED_0,				
	PF_Cmd_GLOBAL_SETDOWN,
	PF_Cmd_PARAMS_SETUP,		/* add parameters here */
	PF_Cmd_SEQUENCE_SETUP,
	PF_Cmd_SEQUENCE_RESETUP,	/* if part of in_data changed */
	PF_Cmd_SEQUENCE_FLATTEN,	/* prepare handle to be written to disk */
	PF_Cmd_SEQUENCE_SETDOWN,
	PF_Cmd_DO_DIALOG,			/* called after SEQUENCE_SETUP only if effect requests */
	PF_Cmd_FRAME_SETUP,
	PF_Cmd_RENDER,
	PF_Cmd_FRAME_SETDOWN,
							
/* most of these command types make use of the 'extra' field */

	PF_Cmd_USER_CHANGED_PARAM, 	/* user just changed a param value, extra contains ptr to PF_UserChangedParamExtra */
	PF_Cmd_UPDATE_PARAMS_UI,	/* UI fields in paramdefs need to be refreshed according to new values, no extra info */
	PF_Cmd_EVENT,				/* handle some event. extra contains a ptr to a relevant structure */
	PF_Cmd_GET_EXTERNAL_DEPENDENCIES, /* new in AE4.1: return text description of things like fonts, etc. in PF_ExtDependenciesExtra */
	PF_Cmd_COMPLETELY_GENERAL,	/* new in AE4.1: Used for completely general effect calls via AEGP */

	PF_Cmd_QUERY_DYNAMIC_FLAGS, /* new in AE5.0: allows effect to control certain flags based on parameter values */

	PF_Cmd_AUDIO_RENDER,		/* For Audio Effects */
	PF_Cmd_AUDIO_SETUP,
	PF_Cmd_AUDIO_SETDOWN,

	PF_Cmd_ARBITRARY_CALLBACK,	/* used for arbitrary data, passes PF_ArbParamsExtra * in extra */

	PF_Cmd_SMART_PRE_RENDER,	/* used with Smart Render effect interface */
  	PF_Cmd_SMART_RENDER,	

	PF_Cmd_RESERVED1,			/* private command */
	PF_Cmd_RESERVED2,			/* private command */
	PF_Cmd_RESERVED3,			/* private command */

	PF_Cmd_GET_FLATTENED_SEQUENCE_DATA,
	PF_Cmd_TRANSLATE_PARAMS_TO_PREFS, 

	PF_Cmd_RESERVED4,			/* private command */
	PF_Cmd_SMART_RENDER_GPU,	/* used when rendering on the GPU */
	PF_Cmd_GPU_DEVICE_SETUP,
	PF_Cmd_GPU_DEVICE_SETDOWN,

	PF_Cmd_NUM_CMDS
};
typedef A_long PF_Cmd;


/** -------------------- Simple Types --------------------
**/

typedef struct _PF_LayerAudio *PF_LayerAudio;

typedef void *PF_SndSamplePtr;

/* The following is an opaque type you pass to callback routines */
struct PF_ProgressInfo;
typedef struct PF_ProgressInfo *PF_ProgPtr;

typedef A_long PF_ParamValue;

typedef struct {
	A_short		major;
	A_short		minor;
} PF_SpecVersion;

typedef A_long PF_ParamIndex;

typedef A_u_long	PF_UFixed;

#ifndef A_INTERNAL

	#if defined(_WINDOWS) || defined(__ANDROID__)

		typedef A_long		PF_Fixed;
		typedef A_char		PF_Boolean;
		typedef void		**PF_Handle;

		typedef struct {
   			A_short v;
   			A_short h;
		} PF_LegacyPoint;

		typedef struct {
			A_short top, left, bottom, right;
		} PF_LegacyRect;

	#else

		typedef Fixed		PF_Fixed;
		typedef Boolean		PF_Boolean;
		typedef Handle		PF_Handle;

	#endif

	typedef struct {
		#ifdef	LPOINT_RENAME_COMPONENTS
			A_long	x;
			A_long	y;
		#else
			A_long	h;
			A_long	v;
		#endif
	} PF_Point;

	typedef struct {
		A_long left, top, right, bottom;
	} PF_LRect;

	typedef PF_LRect	PF_Rect;

	typedef PF_Rect		PF_UnionableRect;

	typedef struct {
		A_long		num;	/* numerator */
		A_u_long	den;	/* denominator */
	} PF_RationalScale;

#endif

#define	PF_Fixed_MINVAL      ((PF_Fixed)0x80000000)		// Maximally negative value
#define PF_Fixed_MAXVAL      ((PF_Fixed)0x7fffffff)		// Maximally positive value


typedef struct {
	PF_Fixed	x, y;
} PF_FixedPoint;

typedef struct {
	PF_Fixed	left, top, right, bottom;
} PF_FixedRect;

typedef struct {
	PF_Fixed				mat[3][3];
} PF_Matrix;


#ifndef A_INTERNAL
	// typedefs from AE_EffectCB.h
	typedef A_long    PF_TransferMode;
	typedef PF_TransferMode PF_XferMode;

	// Basic pixel defn's
	typedef struct {
		A_u_char	alpha, red, green, blue;
	} PF_Pixel;

	typedef PF_Pixel		PF_Pixel8;
	typedef PF_Pixel		PF_UnionablePixel;

	typedef struct {
		#ifdef PF_PIXEL16_RENAME_COMPONENTS
			// this style is useful for debugging code converted from 8 bit
			A_u_short		alphaSu, redSu, greenSu, blueSu;
		#else
			A_u_short		alpha, red, green, blue;
		#endif
	} PF_Pixel16;
	
	typedef A_FpShort			PF_FpShort;
	typedef A_FpLong			PF_FpLong;

	typedef struct {
		PF_FpShort				alpha, red, green, blue;
	} PF_PixelFloat, PF_Pixel32;
	
	typedef struct {
		PF_FpLong				mat[3][3];
	} PF_FloatMatrix;

	typedef struct {
		PF_TransferMode     xfer;
		A_long				rand_seed;  // for PF_Xfer_DISSOLVE_RANDOMIZED
		A_u_char			opacity;	// 0 - 255	
		PF_Boolean          rgb_only;   // ignored for PF_Xfer_MULTIPLY_ALPHA modes
		A_u_short			opacitySu;	// for deep color only
	} PF_CompositeMode;

#endif


typedef A_u_long	PF_PixLong;

typedef struct _PF_PixelOpaque	*PF_PixelOpaquePtr;

#ifdef PF_DEEP_COLOR_AWARE
	typedef PF_PixelOpaquePtr		PF_PixelPtr;
#else
	typedef PF_Pixel				*PF_PixelPtr;
#endif



#define PF_HUE_UNDEFINED	0x80000000

typedef PF_Fixed	PF_RGB_Pixel[3];
typedef PF_Fixed	PF_YIQ_Pixel[3];
typedef PF_Fixed	PF_HLS_Pixel[3];




/** -------------------- Pixel Access Macros --------------------

	If you're using the PF_PixLong struct for pixel representation,
	you can use these macros to guarantee correct channel access
	for a given pixel.

**/

#define PF_PixLong_ALPHA(pl)			((A_u_char)(0xff & ((pl) >> 24)))
#define PF_PixLong_RED(pl)				((A_u_char)(0xff & ((pl) >> 16)))
#define PF_PixLong_GREEN(pl)			((A_u_char)(0xff & ((pl) >> 8)))
#define PF_PixLong_BLUE(pl)				((A_u_char)(0xff & (pl)))

#define PF_SET_PixLong_ALPHA(pl, v)		(pl)&=0x00ffffff, (pl)|=((A_long)(v)<<24)
#define PF_SET_PixLong_RED(pl, v)		(pl)&=0xff00ffff, (pl)|=((A_long)(v)<<16)
#define PF_SET_PixLong_GREEN(pl, v)		(pl)&=0xffff00ff, (pl)|=((A_long)(v)<<8)
#define PF_SET_PixLong_BLUE(pl, v)		(pl)&=0xffffff00, (pl)|=(0xff & (v))
#define PF_MAKE_PixLong(a, r, g, b)		\
		((PF_PixLong)(((A_long)(a)<<24) | ((A_long)(r)<<16) | ((A_long)(g)<<8) | (b)))



/*********************** multi-channel data *********************/

/**
 ** the kinds of multichannels we understand
 **/
#define PF_ChannelType_DEPTH		 'DPTH'
#define PF_ChannelType_DEPTHAA		 'DPAA'	 // since 16.0 for 3D Precomp in some Artisans
#define PF_ChannelType_NORMALS		 'NRML'
#define PF_ChannelType_OBJECTID		 'OBID'
#define PF_ChannelType_MOTIONVECTOR	 'MTVR'
#define PF_ChannelType_BK_COLOR		 'BKCR'
#define PF_ChannelType_TEXTURE		 'TEXR'
#define PF_ChannelType_COVERAGE		 'COVR'
#define PF_ChannelType_NODE			 'NODE'
#define PF_ChannelType_MATERIAL		 'MATR'
#define PF_ChannelType_UNCLAMPED	 'UNCP'
#define PF_ChannelType_UNKNOWN		 'UNKN'

typedef A_long PF_ChannelType;


/**
 ** These are the elementary data types we understand.
 ** By convention we reserve the last characters of the type
 ** to designate the size in bytes of a plane of data.  This together
 ** with the dimension tells us the size of each pixel.
 ** For example, data of PF_ChannelType_COLOR with PF_DataType_DOUBLE would 
 ** consist of 32 bytes per pixel.
 **/
#define PF_DataType_FLOAT			'FLT4'	/* 4 byte		*/
#define PF_DataType_DOUBLE			'DBL8'	/* 8 byte		*/
#define PF_DataType_LONG			'LON4'	/* 4 bytes		*/
#define PF_DataType_SHORT			'SHT2'	/* 2 bytes		*/
#define PF_DataType_FIXED_16_16		'FIX4'	/* 4 bytes		*/
#define PF_DataType_CHAR			'CHR1'	/* 1 byte		*/
#define PF_DataType_U_BYTE			'UBT1'	/* 1 byte		*/
#define PF_DataType_U_SHORT			'UST2'	/* 2 bytes		*/
#define PF_DataType_U_FIXED_16_16	'UFX4'	/* 4 bytes		*/
#define PF_DataType_RGB				'RBG '	/* 3 bytes		*/

typedef A_long PF_DataType;





/**
 ** for enumerating over all the channels
 **/
typedef A_long PF_ChannelIndex;

 



/** 
 ** a description of the channel
 ** use this when iterating through channels to determine
 ** the characteristics of the channel
 ** 
 **/
#define PF_CHANNEL_NAME_LEN	63

typedef struct  {
	PF_ChannelType	channel_type;
	A_char			name[PF_CHANNEL_NAME_LEN+1];
	PF_DataType		data_type;
	A_long			dimension;			// the number of data per pixel
} PF_ChannelDesc;						// eg 3 for normals
						




/**
 ** the opaque type representing the channel data
 **/
typedef struct {
	A_intptr_t opaque[8];
} PF_ChannelRef, *PF_ChannelRefPtr;






/**
 ** the channel data parallels the image data in size and shape.
 ** the width is the number of pixels, the height is the number of scanlines
 ** the height is image_height
 ** the dimension is the number of planes in a pixel
 ** the row_bytes is the length of a scanline in bytes 
 ** the data type is the type of data in a plane
 **	Note : a pixel consists of dimensionL * sizeof(data_type) bytes
 ** dataH is a handle to the data. 
 ** dataPV is a pointer to the dereferenced locked handle
 ** effects should always have dataPV non null.
 **/
typedef struct {
	PF_ChannelRef	channel_ref;
	A_long			widthL;
	A_long			heightL;
	A_long			dimensionL;
	A_long			row_bytesL;
	PF_DataType		data_type;
	PF_Handle		dataH;
	void			*dataPV;
} PF_ChannelChunk;



/** -------------------- Effect Parameter Description Structures --------------------

	In general each structure is divided into two parts:
	a) description of the parameter
	b) setting of parameter at the current invocation time

	A number of these structures end in A_char*, A_char[] unions.  These
	structures are "flattened" between the add_param callback (in which
	the A_char * should be used) and the read-only values accessible when
	the effect is later invoked (at which time the A_char [] is used and
	the string data is concatenated right at the end of the struct).

**/


enum {
	PF_LayerDefault_MYSELF = -1,	/* default to this layer */
	PF_LayerDefault_NONE = 0		/* default to no layer */
};

/** Layer -- PF_Param_LAYER

	Layer parameters represent movie or image layers in the composition.
	All effects automatically have 1 layer param, param[0], which is the
	layer to which they have been applied.  Some effects may have additional
	layer parameters to do compound effects or multi-channel effects.  If
	your effects module has a layer parameter other than the param[0] default,
	you will have to call the checkout_param callback to access the contents
	of that layer.  There is a special case for all layer params (except the
	param[0] automatic layer) which is that the user can set them to <none>,
	indicating that no layer is selected.  The effect can detect this, because
	the checkout_param callback will not return an error, but the "data" pointer
	in the returned LayerDef struct will be NULL.  For the NULL-layers, the
	effect should attempt some logical interpretation, like pretending there
	is an all alpha-zero layer or perhaps just using param[0].

**/

#ifndef A_INTERNAL



typedef struct PF_LayerDef {
	/* PARAMETER VALUE */
	
	void				*reserved0;
	void				*reserved1;
	
	PF_WorldFlags		world_flags;

	PF_PixelPtr			data;

	A_long				rowbytes;
	A_long				width;
	A_long				height;
	PF_UnionableRect	extent_hint;
	/* For source, extent_hint is the smallest rect encompassing all opaque
	 * (non-zero alpha) areas of the layer.  For output, this encompasses
	 * the area that needs to be rendered (i.e. not covered by other layers,
	 * needs refreshing, etc.). if your plug-in varies based on extent (like
	 * a diffusion dither, for example) you should ignore this param and
	 * render the full frame each time.
	 */
	void				*platform_ref;		/* unused since CS5 */

	A_long				reserved_long1;

	void				*reserved_long4;

	PF_RationalScale	pix_aspect_ratio;	/* pixel aspect ratio of checked out layer */

	void				*reserved_long2;

	A_long				origin_x;		/* origin of buffer in layer coords; smart effect checkouts only */ 
	A_long				origin_y;

	A_long				reserved_long3;
	
	/* PARAMETER DESCRIPTION */
	A_long				dephault;		/* use a PF_LayerDefault constant defined above */

} PF_LayerDef;



typedef PF_LayerDef		PF_EffectWorld;

#endif 

#ifdef PF_USE_OLD_WORLD					/* set this for source code compatibility with older effects */
	typedef PF_EffectWorld	PF_World;	
#endif

enum {
	PF_UNSIGNED_PCM = 0,
	PF_SIGNED_PCM = 1,
	PF_SIGNED_FLOAT = 2
};
typedef A_short	PF_SoundFormat;


// Sound encoding is always SIGNED
enum {
	PF_SSS_1 = 1,
	PF_SSS_2 = 2,
	PF_SSS_4 = 4
};
typedef A_short	PF_SoundSampleSize; // in bytes

enum {
	PF_Channels_MONO = 1,
	PF_Channels_STEREO = 2
};
typedef A_short	PF_SoundChannels;


typedef struct {
	PF_FpLong				rateF;
	PF_SoundChannels		num_channels;
	PF_SoundFormat			format;
	PF_SoundSampleSize		sample_size;
} PF_SoundFormatInfo;

typedef struct {
	PF_SoundFormatInfo		fi;
	A_long					num_samples;
	void					*dataP;
} PF_SoundWorld;



enum {
	PF_ValueDisplayFlag_NONE 		= 0,
	PF_ValueDisplayFlag_PERCENT		= 1 << 0,		// append % to value display for A_FpShort sliders (for fixed-point sliders, also maps range into 0-100%)
	PF_ValueDisplayFlag_PIXEL		= 1 << 1,		// assume 0..1 is a pixel value, either 0..255,  0..32768, or 0..1.0 in UI (value will always be 0..1),
	PF_ValueDisplayFlag_RESERVED1	= 1 << 2,		// reserved for After Effects
	PF_ValueDisplayFlag_REVERSE		= 1 << 3		// presentation negates values. eg: a true -5 would be presented as "5", and typing in "22" would store in the model as -22
};

#define PF_VALUEFLAG_IS_PERCENT(A)			(((A) & PF_ValueDisplayFlag_PERCENT) != 0)
#define PF_VALUEFLAG_IS_PIXEL(A)			(((A) & PF_ValueDisplayFlag_PIXEL) != 0)
#define PF_VALUEFLAG_IS_REVERSED(A)			(((A) & PF_ValueDisplayFlag_REVERSE) != 0)

typedef A_short PF_ValueDisplayFlags;


/** Slider -- PF_Param_SLIDER
**/
typedef struct {
	/* PARAMETER VALUE */
	PF_ParamValue	value;
	A_char			value_str[PF_MAX_PARAM_VALUE_LEN + 1]; /* string for value */
	A_char			value_desc[PF_MAX_PARAM_DESCRIPTION_LEN + 1]; /* qualitative descr */

	/* PARAMETER DESCRIPTION */
	PF_ParamValue	valid_min, valid_max;		/* acceptable input range */
	PF_ParamValue	slider_min, slider_max;		/* range represented by width of slider */
	PF_ParamValue	dephault;
} PF_SliderDef;


/** Fixed Point Slider -- PF_Param_FIX_SLIDER
**/
typedef struct {
	/* PARAMETER VALUE */
	PF_Fixed					value;
	A_char						value_str[PF_MAX_PARAM_VALUE_LEN + 1]; /* string for value */
	A_char						value_desc[PF_MAX_PARAM_DESCRIPTION_LEN + 1]; /* qualitative descr */

	/* PARAMETER DESCRIPTION */
	PF_Fixed					valid_min, valid_max;		/* acceptable input range */
	PF_Fixed					slider_min, slider_max;		/* range represented by width of slider */
	PF_Fixed					dephault;
	A_short						precision;					/* decimal places to display */
	PF_ValueDisplayFlags		display_flags;				/* set bit to 1 to enable special display:
												 *	--> bit 0 == append percent sign
												 */
} PF_FixedSliderDef;


#define		AEFX_AUDIO_DEFAULT_CURVE_TOLERANCE			0.05f


enum {
	PF_FSliderFlag_NONE				= 0,
	PF_FSliderFlag_WANT_PHASE		= 1L << 0	/* works for audio effects only */
};
typedef A_u_long	PF_FSliderFlags;

/** Floating Point Slider -- PF_Param_FLOAT_SLIDER
**/
typedef struct {
	/* PARAMETER VALUE */
	PF_FpLong				value;
	PF_FpLong				phase;					/* used for PF_FSliderFlag_WANT_PHASE */
	A_char					value_desc[PF_MAX_PARAM_DESCRIPTION_LEN + 1]; /* qualitative descr */

	/* PARAMETER DESCRIPTION */
	PF_FpShort				valid_min, valid_max;		/* acceptable input range */
	PF_FpShort				slider_min, slider_max;		/* range represented by width of slider */
	PF_FpShort				dephault;
	A_short					precision;					/* decimal places to display */
	PF_ValueDisplayFlags	display_flags;				/* set bit to 1 to enable special display:
														 *	--> bit 0 == append percent sign
														 */
	PF_FSliderFlags			fs_flags;
	PF_FpShort				curve_tolerance;		/* used for subdividing audio effects
														set to zero for default, or non-audio */

														/* next 2 fields are used in Premiere Pro and ignored in AE */
	PF_Boolean				useExponent;				/* use exponential value display */
	PF_FpShort				exponent;					/* typical values from 0.01 to 100 */
} PF_FloatSliderDef;


/** Angle -- PF_Param_ANGLE
**/
typedef struct {
	/* PARAMETER VALUE */
	PF_Fixed		value;		/* degrees with fixed point accuracy;
								 * this is NOT limited in range to 0 to 360.
								 */

	/* PARAMETER DESCRIPTION */
	PF_Fixed		dephault;

	/* Min and max values. Note!! Not supported for effect plugins. 
	** Angle properties in effects are always unlimited in range.
	*/
	PF_Fixed		valid_min, valid_max;
} PF_AngleDef;


/** CheckBox -- PF_Param_CHECKBOX
**/
typedef struct {
	/* PARAMETER VALUE */
	PF_ParamValue		value;

	/* PARAMETER DESCRIPTION */
	PF_Boolean		dephault;
	A_char		reserved;	/* padding	*/
	A_short		reserved1;
	union {
		const A_char	*nameptr;
	} u;
} PF_CheckBoxDef;


/** Color -- PF_Param_COLOR
**/
typedef struct {
	/* PARAMETER VALUE */
	PF_UnionablePixel	value;

	/* PARAMETER DESCRIPTION */
	PF_UnionablePixel	dephault;
} PF_ColorDef;


/** Point -- PF_Param_POINT

	The values for the point use the source's coordinate system, with the
	origin at the top left. The values are expressed in fixed point, with
	16 bits of fractional precision (out of a total of 32 bits).
	
	The dephaults (sorry) are expressed as percentages (with 16 bits of
	fraction) with the origin at the top left. The percent can be negative,
	but should not be smaller than -600%. It should not be greater than 600%.
	
	If restrict_bounds is TRUE, the user will not be allowed to specify
	points outside the bounds of the layer to which they are applying the
	effect. If this is TRUE, the dephaults should be between 0.0 and 100.0.

**/
typedef struct {
	/* PARAMETER VALUE */
	PF_Fixed			x_value;
	PF_Fixed			y_value;

	/* PARAMETER DESCRIPTION */
	A_char				reserved[3];
	PF_Boolean			restrict_bounds;		/* restrict bounds to size of src */
	PF_Fixed			x_dephault;				/* percentage */
	PF_Fixed			y_dephault;				/* percentage */
} PF_PointDef;


/** 3D Point -- PF_Param_POINT_3D

	Just like POINT, with an extra dimension. Supported in AE starting with version 10.5 (CS 5.5).

**/
typedef struct {
	/* PARAMETER VALUE */
	PF_FpLong			x_value;
	PF_FpLong			y_value;
	PF_FpLong			z_value;

	/* PARAMETER DESCRIPTION */
	PF_FpLong			x_dephault;				/* percentage of layer width; note: use 50 for halfway, not 0.5; this matches the old PF_PointDef behavior */
	PF_FpLong			y_dephault;				/* percentage of layer height */
	PF_FpLong			z_dephault;				/* percentage of layer _height_ (since typical layers are zero depth) */

	char				reserved[16];			/* set to zeros */
} PF_Point3DDef;

/** Popup Menu -- PF_Param_POPUP
 **
 ** can also be used as a radio-button group in some hosts
 ** when PF_PUI_RADIO_BUTTON is set
 **
 **/
typedef struct {
	/* PARAMETER VALUE */
	PF_ParamValue	value;

	/* PARAMETER DESCRIPTION */
	A_short		num_choices;
	A_short		dephault;
	union {
		const A_char	*namesptr; /*  menu manager standard, '|' separator */
	} u;
} PF_PopupDef;


/** Momentary Buttons -- PF_Param_BUTTON
 ** 
 ** supported by AE starting with CS 5.5 (AE 10.5); may be supported in other hosts
 **
 **/
typedef struct {
	/* PARAMETER VALUE */
	PF_ParamValue	value;		// not used at this time

	union {
		const A_char	*namesptr; /* button name */
	} u;
} PF_ButtonDef;




enum {
	PF_PathID_NONE = 0
};
typedef A_u_long	PF_PathID;


enum {
	PF_MaskMode_NONE = 0,			// mask shape does nothing
	PF_MaskMode_ADD,				// shape is added into mask (normal behavior (really screen!))
	PF_MaskMode_SUBTRACT,
	PF_MaskMode_INTERSECT,
	PF_MaskMode_LIGHTEN,
	PF_MaskMode_DARKEN,
	PF_MaskMode_DIFFERENCE,
	PF_MaskMode_ACCUM,				// real add, not screen (not exposed in UI!)

	PF_NUM_MASKMODES
};
#define PF_NUM_USER_MASKMODES (PF_NUM_MASKMODES - 1)
typedef A_long PF_MaskMode;



/** Path -- PF_Param_PATH

	Path parameters give access to the mask/path/shapes of the layer on which
	the effect is applied.  For more information
	on how to use these paths, see the PF_PathQuerySuite, and the PF_PathDataSuite
	in AE_EffectSuites.h

**/
typedef struct PF_PathDef {

	/* PARAMETER VALUE */
	PF_PathID			path_id;		/* to be used with PF_CheckoutPath()
											note that path_id != PF_PathID_NONE does not
											guarantee that PF_CheckoutPath will return a
											valid path (it may have been deleted) */

	/* PARAMETER DESCRIPTION */
	A_long				reserved0;		/*  not currently used, set to zero */

	A_long				dephault;		/*	0 means that the default is NONE,
											other numbers are the 1-based index of the
											path, if the path doesn't exist, the 
											path_idLu value will be PF_PathID_NONE.
										 */
} PF_PathDef;


/*  ---------------------  ARBITRARY DATA   -----------------------------------
 *	new arbitrary data type - you supply functions for various activities
 *	needed by After Effects to manipulate your arbitrary data.
 */

typedef PF_Handle PF_ArbitraryH;


typedef struct {
	A_short					id;			/* for effect use: lets effect distinguish between */
										/*	different arbitrary data param types in the same effect */
	A_short					pad;		/* padding, set to zero */
	PF_ArbitraryH			dephault;	/* becomes owned by host at ADD_PARAM time */
	PF_ArbitraryH			value;		/* pass NULL at ADD_PARAM time; owned by host at render time */
	void					*refconPV;	/* passed into all callbacks, for effect use */
} PF_ArbitraryDef;



enum {
	PF_Arbitrary_NEW_FUNC		= 0,
	PF_Arbitrary_DISPOSE_FUNC,
	PF_Arbitrary_COPY_FUNC,
	PF_Arbitrary_FLAT_SIZE_FUNC,
	PF_Arbitrary_FLATTEN_FUNC,
	PF_Arbitrary_UNFLATTEN_FUNC,
	PF_Arbitrary_INTERP_FUNC,
	PF_Arbitrary_COMPARE_FUNC,
	PF_Arbitrary_PRINT_SIZE_FUNC,
	PF_Arbitrary_PRINT_FUNC,
	PF_Arbitrary_SCAN_FUNC
};
typedef A_long PF_FunctionSelector;



enum {
	PF_ArbCompare_EQUAL = 0,
	PF_ArbCompare_LESS,
	PF_ArbCompare_MORE,
	PF_ArbCompare_NOT_EQUAL
};
typedef A_long PF_ArbCompareResult;


enum {
	PF_ArbPrint_NONE			= 0,	
	PF_ArbPrint_ABBREVIATED		= 1 << 0
};
typedef A_long PF_ArbPrintFlags;



/* this is what gets passed in the extra parameter with  
 * PF_Cmd_ARBITRARY_CALLBACKS 
 */
typedef struct {

	PF_FunctionSelector			which_function;

	A_short						id;
	A_short						padding;

	union {

		/*	PF_Arbitrary_NEW_FUNC
		 *
		 *	allocate and initialize the data
		 *  the passed in parameter,v, will already have its non data fields filled in
		 *  you just allocate and optionally fill out the data. 
		 */
		struct {
			void 				*refconPV;				/* >> */
			PF_ArbitraryH		*arbPH;					/* << */
		} new_func_params;



		/*	PF_Arbitrary_DISPOSE_FUNC
		 *
		 *	dispose of any allocated data 
		 */
		struct {
			void 				*refconPV;
			PF_ArbitraryH		arbH;
		} dispose_func_params;



		/*	PF_Arbitrary_COPY_FUNC
		 *
		 *	make a copy of src_dataP into dst_dataP. refconPV was assigned from parameter def.
		 */
		struct {
			void 				*refconPV;
			PF_ArbitraryH		src_arbH;
			PF_ArbitraryH 		*dst_arbPH;			/* << allocated by copy func, owned by caller */
		} copy_func_params;
		


		/*	PF_Arbitrary_FLAT_SIZE_FUNC
		 * 
		 *	return in flat_data_sizePLu the number of bytes that are needed to flatten the object.
		 */
		struct {
			void 				*refconPV;
			PF_ArbitraryH		arbH;
			A_u_long		*flat_data_sizePLu;		/* << */
		} flat_size_func_params;



		/*	PF_Arbitrary_FLATTEN_FUNC	
		 *
		 *	Flatten the arbH and place it into the supplied buffer, honoring its size.
		 */
		struct {
			void 				*refconPV;
			PF_ArbitraryH		arbH;
			A_u_long		buf_sizeLu;			// size of buffer	
			void				*flat_dataPV;		// buffer already allocated
		} flatten_func_params;



		/*	PF_Arbitrary_UNFLATTEN_FUNC
		 * 
		 *	opposite of FlattenFunc, unpack the buffer into a PF_ArbitraryH. 
		 */
		struct {
			void				*refconPV;
			A_u_long		buf_sizeLu;				/* size of buffer */
			const void			*flat_dataPV;			/* >> */
			PF_ArbitraryH		*arbPH;					/* << */	// owned by caller
		} unflatten_func_params;



		/*	PF_Arbitrary_INTERP_FUNC
		 * 
		 *	The interpolation function takes a left and a right keyframe and a value between
		 *	0 and 1, 0 being the left keyframe, 1 represents the right keyframe.
		 *  allocate PF_ArbitraryH and fill it with interpolated data.
		 *  The velocity curves have already been accounted for when the normalized time value was 
		 *  calculated. 
		 */
		struct {
			void				*refconPV;
			PF_ArbitraryH		left_arbH;			/* >> */ // left keyframe
			PF_ArbitraryH		right_arbH;			/* >> */ // right keyframe
			PF_FpLong			tF;					/* >> */ // range [0,1]
			PF_ArbitraryH		*interpPH;			/* << */ // becomes owned by caller
		} interp_func_params;


		/*	PF_Arbitrary_COMPARE_FUNC
		 * 
		 *	compare two arbitrary data types for equality
		 *  return 0 if equal, otherwise return 1 in comparePL
		 */
		struct	{
			void				*refconPV;
			PF_ArbitraryH		a_arbH;					/* >> */  // value 1
			PF_ArbitraryH		b_arbH;					/* >> */  // value 2
			PF_ArbCompareResult	*compareP;				/* << */  // result of compare use enumeration above
		} compare_func_params;



		/*	PF_Arbitrary_PRINT_SIZE_FUNC
		 * 
		 *	return in print_sizePLu the number of bytes that are needed to print the object.
		 */
		struct {
			void 				*refconPV;
			PF_ArbitraryH		arbH;					/* >> */	// the data
			A_u_long		*print_sizePLu;			/* << */	// size of buffer needed to print
		} print_size_func_params;


		/*	PF_Arbitrary_PRINT_FUNC
		 * 
		 *	return in buff a user-readable description of your arb data
		 */
		struct {
			void 				*refconPV;					/* >> */
			PF_ArbPrintFlags	print_flags;				/* >> */	// PF_ArbPrint_NONE means print the complete description
			PF_ArbitraryH		arbH;						/* >> */
			A_u_long		print_sizeLu;				/* >> */	// size of buffer	
			A_char				*print_bufferPC;			/* << */
		} print_func_params;



		/*	PF_Arbitrary_SCAN_FUNC
		 * 
		 *	return a PF_ArbitraryH from the text description of your arb data
		 */
		struct {
			void 				*refconPV;					/* >> */
			const A_char			*bufPC;						/* >> */
			A_u_long		bytes_to_scanLu;			/* >> */
			PF_ArbitraryH		*arbPH;						/* << */
		} scan_func_params;

	} u;

} PF_ArbParamsExtra;


typedef struct {
	PF_ParamIndex				param_index;
} PF_UserChangedParamExtra;		// passed as extra for PF_Cmd_USER_CHANGED_PARAM


/* The following is an opaque type you pass to PF_Cmd_TRANSLATE_PARAMS_TO_PREFS */
typedef struct PF_ImporterPrefsData *PF_ImporterPrefsDataPtr;

/* prefsPC is a pointer to an importer opaque data (prefs) that coincides 
 * with its matching importer. It's an in/out param. The host owns it, 
 * but the filter will modify it.
 * prefs_sizeLU is the size of the prefs object pointed to.
 * This is part of a Premiere Pro feature that requires a matching Importer/Source Settings effect
 * and will only be used in that particular case. 
 */
typedef struct {
	PF_ImporterPrefsDataPtr prefsPC;
	A_u_long		prefs_sizeLu;
} PF_TranslateParamsToPrefsExtra;		// passed as extra for PF_Cmd_TRANSLATE_PARAMS_TO_PREFS


enum {
	PF_DepCheckType_NONE = 0,
	PF_DepCheckType_ALL_DEPENDENCIES,
	PF_DepCheckType_MISSING_DEPENDENCIES
};
typedef A_long PF_DepCheckType;

typedef struct {
	PF_DepCheckType				check_type;					/* >> */ // effect should ignore any unknown type
	PF_Handle					dependencies_strH;			/* << */ // NULL terminated string.  Flat and disposed of by the host
} PF_ExtDependenciesExtra;


#ifdef PREMIERE_INTERNAL
	#include "PF_Private_Premiere.h"
#else


typedef union {
	PF_LayerDef					ld;
	PF_SliderDef				sd;
	PF_FixedSliderDef			fd;
	PF_AngleDef					ad;
	PF_CheckBoxDef				bd;
	PF_ColorDef					cd;
	PF_PointDef					td;
	PF_PopupDef					pd;
	PF_FloatSliderDef			fs_d;
	PF_ArbitraryDef				arb_d;
	PF_PathDef					path_d;
	PF_ButtonDef				button_d;
	PF_Point3DDef				point3d_d;
} PF_ParamDefUnion;

#endif

/** Param UI Flags

	PF_PUI_TOPIC
		
		Set this flag if you handle PF_Cmd_EVENTs for the "topic" of
		the parameter.  The "topic" is the portion of the param UI
		in the Effect Controls Window (ECW) that is still visible
		when the twirly-arrow is twirled up for that param.

		If you set this flag, you must also set PF_OutFlag_CUSTOM_UI
		at PF_Cmd_GLOBAL_SETUP time.

	PF_PUI_CONTROL

		Set this flag if you handle PF_Cmd_EVENTs for the control
		area in the ECW.  This is the area that becomes invisible
		when you twirl up a parameter's twirly arrow (and is the
		usual place to have your custom UI).

		If you set this flag, you must also set PF_OutFlag_CUSTOM_UI
		at PF_Cmd_GLOBAL_SETUP time.

	PF_PUI_STD_CONTROL_ONLY
		
		Set this flag if you want the standard control only -- no
		data stream will be associated with this parameter, and
		thus no keyframes (nothing appears in the Time Layout window
		for this type of param).

		You might want to do this to control something in your
		sequence data with a standard control.  Or in your arb
		data, or custom UI in the comp window, or to group-set multiple
		other controls.

		
		This flag can be used with these param types:
			PF_Param_SLIDER, PF_Param_FIX_SLIDER, PF_Param_ANGLE,
			PF_Param_CHECKBOX, PF_Param_COLOR, PF_Param_POINT,
			PF_Param_POPUP, PF_Param_FLOAT_SLIDER, PF_Param_POINT_3D

		but NOT:

			PF_Param_CUSTOM, PF_Param_NO_DATA,
			PF_Param_LAYER, PF_Param_ARBITRARY_DATA, PF_Param_PATH

		If you set this flag, you must also set PF_ParamFlag_SUPERVISE
		(otherwise you would never find out about value changes, and
		the setting would never be used for anything).  This flag
		does not require the setting of PF_OutFlag_CUSTOM_UI.

		If you want a standard control for PF_Param_ARBITRARY_DATA,
		just add one (or more) using PF_PUI_STD_CONTROL_ONLY with
		the supported param types, and then when handling 
		PF_Cmd_USER_CHANGED_PARAM you can modify your arb data.


	PF_PUI_NO_ECW_UI

		Set this flag if you want no UI to appear in the Effect Controls
		Window.  Presumably, you are setting the value of the parameter
		through some other method (e.g. custom UI in the comp window,
		or while handling PF_Cmd_USER_CHANGED_PARAM for a different param with 
		PF_ParamFlag_SUPERVISE set). In AE, this doesn't affect keyframe
		visibility in the timeline. In PPro it does remove the entire row,
		so you won't see keyframes.

	PF_PUI_ECW_SEPARATOR

		Set this flag if you'd like a thick line above this parameter
		in the effect control window. This is provided so that parameters
		can be grouped visually, if needed (without adding groups).
		This flag can be changed at runtime through the PF_UpdateParamUI()
		method. Not used by AE.

	PF_PUI_INVISIBLE

		Set this flag if you'd like the parameter to be initially invisible. This is useful
		if your effect needs hidden data parameters that affect rendering.
		
		Premiere only: The parameter can later be made visible by clearing the flag
		during the PF_UpdateParamUI() callback.

**/

enum {
	PF_PUI_NONE 			= 0,
	PF_PUI_TOPIC			= 1L << 0,	// effect has custom UI and wants events for this params' title (portion visible when twirled up)
	PF_PUI_CONTROL			= 1L << 1,	// effect has custom UI and wants events for this params' control (portion invisible when twirled up)
										//		use the width and height below

	// following flags are new in AE 4.0

	PF_PUI_STD_CONTROL_ONLY	= 1L << 2,	// param will be used as UI only, no data (new in AE 4.0) */
	PF_PUI_NO_ECW_UI		= 1L << 3,	// stop param from appearing in Effect Controls (which in PPro also means you won't see a keyframe track there)
	PF_PUI_ECW_SEPARATOR	= 1L << 4,	// draw a thick separating line above this param; not used by AE
	PF_PUI_DISABLED			= 1L << 5,	// disable (gray-out) UI for this param

	// following flags are new in AE 4.1

	// AE will not erase the ECW topic, it's up to the FX to erase/draw every pixel. 
	// Handy if FX author implements an offscreen, prevents flashing.  
	PF_PUI_DONT_ERASE_TOPIC		= 1L << 6,
	PF_PUI_DONT_ERASE_CONTROL	= 1L << 7,
	
	PF_PUI_RADIO_BUTTON			= 1L << 8,	// display as a radio-button group; only valid for PF_Param_POPUP; ignored by AE

	PF_PUI_INVISIBLE			= 1L << 9	// in AE as of CS6, this hides the parameter UI in both the Effect Controls and Timeline.
											// in Premiere since earlier than that, this hides the parameter UI in the Effect Controls,
											//	which includes the keyframe track; for PPro only, the flag is dynamic and can be cleared
											//	to make the parameter visible again.
};
typedef A_long PF_ParamUIFlags;

/** PF_ChangeFlags

	New in AE 4.0 (although PF_ChangeFlag_CHANGED_VALUE was implemented
	by setting low bit of old changed field).

	PF_ChangeFlag_CHANGED_VALUE

		Set this flag for each param whose value you change when handling
		a PF_Cmd_USER_CHANGED_PARAM or specific PF_Cmd_EVENT events
		(PF_Event_DO_CLICK, PF_Event_DRAG, & PF_Event_KEYDOWN). If set during
		PF_Cmd_EVENT, but sure to also set PF_EO_HANDLED_EVENT before returning.
		You can change as many params as you want at once.  These changes are undoable and
		re-doable by the user.  Exception: do not set PF_PUI_STD_CONTROL_ONLY
		param values with this flag, use PF_UpdateParamUI() instead.

	PF_ChangeFlag_SET_TO_VARY

		Not yet implemented.  Same restrictions as PF_ChangeFlag_CHANGED_VALUE.

	PF_ChangeFlag_SET_TO_CONSTANT

		Not yet implemented.  Same restrictions as PF_ChangeFlag_CHANGED_VALUE.

**/

enum {
	PF_ChangeFlag_NONE = 0,
	PF_ChangeFlag_CHANGED_VALUE		= 1L << 0,
	PF_ChangeFlag_RESERVED			= 1L << 1,
	PF_ChangeFlag_SET_TO_VARY		= 1L << 2,
	PF_ChangeFlag_SET_TO_CONSTANT	= 1L << 3
};
typedef A_long PF_ChangeFlags;


/** ParamDef
**/
typedef struct {
	/* PARAMETER VALUE */
	union {
		A_long				id;					// used by PF_ADD_PARAM callback, see doc
		PF_ChangeFlags		change_flags;		// set when handling PF_Cmd_USER_CHANGED_PARAM & PF_Cmd_UPDATE_PARAMS_UI
	} uu;

	PF_ParamUIFlags	ui_flags;
	A_short			ui_width;		/* ignored if !PF_PUI_CONTROL */
	A_short			ui_height;		/* ignored if !PF_PUI_CONTROL */
	
	/* PARAMETER DESCRIPTION */
	PF_ParamType	param_type;
	A_char			name[PF_MAX_EFFECT_PARAM_NAME_LEN + 1];
	PF_ParamFlags	flags;
	
	A_long			unused;		// Once upon a time was reserved_tdb
	PF_ParamDefUnion u;

} PF_ParamDef, *PF_ParamDefPtr, **PF_ParamDefH;

typedef PF_ParamDef** PF_ParamList;

#define        PF_ParamDef_IS_PUI_FLAG_SET(_defP, _puiFlag)        \
  (((_defP)->ui_flags & _puiFlag) != 0)
   
#define        PF_ParamDef_IS_PARAM_FLAG_SET(_defP, _paramFlag)    \
   (((_defP)->flags & _paramFlag) != 0)



 /** -------------------- Smart Render Interface Constants and Structures -------------------- 
 
   PF_Cmd_SMART_PRE_RENDER gets a PF_PreRenderExtra struct in the extra pointer, and must
   fill out the "output" field before returning.
 
   PF_Cmd_SMART_RENDER gets a PF_SmartRenderExtra struct in the extra pointer, if pre-render was invoked.
 
 */
 
 enum {
 	PF_ChannelMask_ALPHA = 0x1,
 	PF_ChannelMask_RED   = 0x2,
 	PF_ChannelMask_GREEN = 0x4,
 	PF_ChannelMask_BLUE  = 0x8,
 	PF_ChannelMask_ARGB  = 0xF
 };
 typedef A_long PF_ChannelMask;
 
 enum {
	PF_GPU_Framework_NONE = 0,
	PF_GPU_Framework_OPENCL,
	PF_GPU_Framework_METAL,
	PF_GPU_Framework_CUDA,
 };
 typedef A_long PF_GPU_Framework;
		
 typedef struct {
 	PF_LRect		rect;
 	PF_Field		field;
 	PF_ChannelMask	channel_mask;
 	PF_Boolean		preserve_rgb_of_zero_alpha;	// whether the effect should attempt to preserve RGB when A=0
 	char			unused[3];			// keep this zeroed!
 	A_long			reserved[4];		// this too
 } PF_RenderRequest;
 
 typedef struct {
 	PF_RenderRequest	output_request;	// what the effect is being asked to render
 	short				bitdepth;		// bitdepth the effect is being driven in (in bpc)
	const void			*gpu_data;
	PF_GPU_Framework	what_gpu;
	A_u_long			device_index;
 } PF_PreRenderInput;

 typedef void (*PF_DeletePreRenderDataFunc)(void *pre_render_data);

 
 enum {
 	PF_RenderOutputFlag_RETURNS_EXTRA_PIXELS = 0x1, // if it's just as cheap to compute more pixels at once, set this to allow result > request rect
	PF_RenderOutputFlag_GPU_RENDER_POSSIBLE = 0x2,   // if the GPU render is possible given the params and frame render context
	PF_RenderOutputFlag_RESERVED1 = 0x4,
 };
 typedef short PF_RenderOutputFlags;

 typedef struct {
 	PF_LRect		result_rect;		// the rectangle actually available from this request (can be empty)
 	PF_LRect		max_result_rect;	// the maximum size the output could possibly be, if AE asked for all of it
										// (this must not vary depending on requested output size!)

	PF_Boolean		solid;				// optimization hint; set this if there is full alpha at every pixel in the result rect
	PF_Boolean		reserved;
	PF_RenderOutputFlags flags;			// RETURNS_EXTRA_PIXELS, other things later

	void*			pre_render_data;	// will be passed back to render
	PF_DeletePreRenderDataFunc	delete_pre_render_data_func; // and eventually passed to this function for deletion, if set

 } PF_PreRenderOutput;					

typedef struct {
 	PF_LRect		result_rect;		// the rectangle actually available from this request (can be empty)
 	PF_LRect		max_result_rect;	// the maximum size the output could possibly be, if AE asked for all of it
	PF_RationalScale par;				// aspect ratio of pixels
	PF_Boolean		solid;				// boolean; true if result has full alpha throughout result rect
	PF_Boolean		reservedB[3];
	A_long			ref_width;			// original size of layer, pre-effects (without DSF, comp size for collapsed layers)
	A_long			ref_height;
	A_long			reserved[6];
 } PF_CheckoutResult;					

	
 typedef struct {
 	
 	PF_Err (*checkout_layer)(
 		PF_ProgPtr		effect_ref,		// reference from in_data 
 		PF_ParamIndex	index, 			// 0 = input, 1..n = param 
 		A_long			checkout_idL,	// chosen by effect, must be >=0 and unique
 		const PF_RenderRequest *req,
 		A_long			what_time,
 		A_long			time_step,
 		A_u_long	time_scale,
		PF_CheckoutResult	*checkout_result); // out

 	PF_Err (*GuidMixInPtr)(
 		PF_ProgPtr		effect_ref,		// reference from in_data 
 		//const PF_RenderRequest *req,
		A_u_long                buf_sizeLu,             /* >> size of buffer to mix into guid */
                const void              *buf );      
 
 } PF_PreRenderCallbacks;
 
 // This is passed as the extra parameter to PF_Cmd_PRE_RENDER when an effect is using the pre-render interface. 
 // Effect must fill out output.
 typedef struct {
 	PF_PreRenderInput	*input;
 	PF_PreRenderOutput	*output;
 	PF_PreRenderCallbacks *cb;
 } PF_PreRenderExtra;
 
 typedef struct {
 	PF_RenderRequest    output_request;	// what the effect is being asked to render
	short               bitdepth;		// bitdepth the effect is being driven in (in bpc)
	void                *pre_render_data;// passed back from value placed in extra->output->pre_render_data during PF_Cmd_PRE_RENDER
	const void			*gpu_data;
	PF_GPU_Framework    what_gpu;
	A_u_long            device_index; // For use in conjunction with PrSDKGPUDeviceSuite
 } PF_SmartRenderInput;

 typedef struct {
 	
 	PF_Err (*checkout_layer_pixels)(
 		PF_ProgPtr		effect_ref,		// reference from in_data 
 		A_long			checkout_idL,	// passed during checkout_layer
 		PF_EffectWorld	**pixels);		// out, valid for duration of current command or until checked in
 
 	PF_Err (*checkin_layer_pixels)(		// not strictly necessary to call, but useful to free up memory early
 		PF_ProgPtr		effect_ref,
 		A_long			checkout_idL);
 
 	PF_Err (*checkout_output)(
 		PF_ProgPtr		effect_ref,		// reference from in_data 
 		PF_EffectWorld	**output);		// out

 } PF_SmartRenderCallbacks;

 // Passed as extra param during PF_Cmd_SMART_RENDER
 typedef struct {
 	PF_SmartRenderInput		*input;
 	PF_SmartRenderCallbacks *cb;
 } PF_SmartRenderExtra;


 /** -------------------- GPU Setup/Setdown Constants and Structures --------------------
 
   PF_Cmd_GPU_DEVICE_SETUP gets a PF_GPUDeviceSetupExtra struct in the extra pointer.
 
   PF_Cmd_GPU_DEVICE_SETDOWN gets a PF_GPUDeviceSetdownExtra struct in the extra pointer.

 */


 typedef struct {
	PF_GPU_Framework what_gpu;
	A_u_long         device_index; // For use in conjunction with PrSDKGPUDeviceSuite
 } PF_GPUDeviceSetupInput;

 typedef struct {
	void *gpu_data; // effect owned pointer.
 } PF_GPUDeviceSetupOutput;

 typedef struct {
	PF_GPUDeviceSetupInput *input;
	PF_GPUDeviceSetupOutput *output;
 } PF_GPUDeviceSetupExtra;
 

 
 typedef struct {
	void        		*gpu_data; // effect must dispose.
	PF_GPU_Framework	what_gpu;
	A_u_long			device_index; // For use in conjunction with PrSDKGPUDeviceSuite
 } PF_GPUDeviceSetdownInput;

 typedef struct {
	PF_GPUDeviceSetdownInput *input;
 } PF_GPUDeviceSetdownExtra;



/** -------------------- Interaction Callbacks --------------------

	Effects modules use callbacks to define their parameters.  When invoked,
	they will be given the parameters values at the particular invocation
	moment, but some effects may need to ask for the parameter values at
	other times (notably of layer parameters for, say, a visual echo).

	While running, effects modules are responsible for checking for user
	interrupts.  This checking can be done with either the abort callback,
	which will return a value indicating if the user has taken any action,
	or with the progress callback, which performs user interrupt checking
	just like the abort callback, and also displays a progress display.

	At the bottom of this section are macros for accessing these callback
	routines.  The first parameter to each macro is a pointer to a PF_InData
	structure, defined below.  This pointer will be passed to your effect.

	checkout_param
		The checkout_param callback allows you to inquire param values at times
		other than the current one, and allows you to access layer params other
		than the default input layer and the output layer.  See the notes on the
		"params" structure at the end of this file.  The PF_ParamDef you must
		specify cannot point into the "params" array; the memory must exist else-
		where, such as on the stack.
 
		If you checkout a layer parameter and the layer popup is currently set
		to <none>, the return value will be filled with zeros.  You can check
		the "data" pointer.  If it is NULL, then the layer param is set to <none>
		and you should do something like faking an all alpha zero layer or some
		such nonsense.  IMPORTANT: Due to 13.5 threading changes, checking out
		a layer param that is not <none> inside of UPDATE_PARAMS_UI will return 
		a frame with black pixels to avoid render requests and possible deadlock.
		In other selectors the actual render will be triggered as it did before.

	checkin_param
		When you have called checkout_param, you must call checkin_param when you
		are done, so After Effects can clean up after itself and you.  This is
		very important for smooth functioning and also to save memory where possible.
		Once checked in, the fields in the PF_ParamDef will no longer be valid.

	add_param
		When given the PARAMS_SETUP message, the effect will generally make a
		series of calls to the add_param routine to define the interface that
		the After Effects user will see.  See the PF_ParamDefs defined above.
		Currently you can only add params at the end, and only at PARAMS_SETUP
		time.

	abort
		Periodically, you should check if the user wants to interrupt the
		current processing.  The abort proc here will return non-zero if
		the effects module should suspend its current processing.  If you
		call this routine and it returns a value other than zero, you should
		return that value when your effect returns.  That will let us know
		if the effect completed rendering or not.

	progress
		Alternatively, you may wish to display a progress bar while you are
		processing the image.  This routine combines the abort proc user
		interrupt checking with code that will display a progress bar for
		you.  The current and total params represent a fraction (current/total)
		that describes how far you are along in your processing.  Current
		should equal total when done.  Additionally, this routine will return
		non-zero if you should suspend/abort your current processing.  You
		should probably try not to call this too frequently (e.g. at every pixel).
		It is better to call it, say, once per scanline, unless your filter is
		really really slow.

**/

typedef struct _PF_CustomUIInfo PF_CustomUIInfo;


typedef struct {
	// IMPORTANT: This structure is FROZEN. Changing this would break binary compatibility with PF_InData

	PF_Err (*checkout_param)(
		PF_ProgPtr		effect_ref,	/* reference from in_data */
		PF_ParamIndex	index, 		/* 0 = input, 1..n = param */
		A_long			what_time,
		A_long			time_step,	/* duration between frames in time_scale units */
		A_u_long	time_scale,
		PF_ParamDef		*param);	/* the param you've been waiting for...	*/

	PF_Err (*checkin_param)(
		PF_ProgPtr		effect_ref,	/* reference from in_data */
		PF_ParamDef		*param);

	PF_Err (*add_param)(
		PF_ProgPtr		effect_ref,	/* reference from in_data */
		PF_ParamIndex	index,		/* -1 = add to end */
		PF_ParamDefPtr	def);

	PF_Err (*abort)(
		PF_ProgPtr		effect_ref);	/* reference from in_data */

	PF_Err (*progress)(
		PF_ProgPtr		effect_ref,	/* reference from in_data */
		A_long			current,
		A_long			total);

	PF_Err (*register_ui)(
		PF_ProgPtr			effect_ref,	/* reference from in_data	*/
		PF_CustomUIInfo		*cust_info);

	PF_Err (*checkout_layer_audio)(
		PF_ProgPtr		effect_ref,	/* reference from in_data */
		PF_ParamIndex	index, 		/* 0 = input, 1..n = param */
		A_long			start_time,	/* in time_scale units */
		A_long			duration,	/* in time_scale units */
		A_u_long	time_scale,	/* units/sec */
		PF_UFixed		rate,		/* unsigned! */
		A_long			bytes_per_sample,
		A_long			num_channels,
		A_long			fmt_signed,	/* non-zero for signed, zero for unsigned */		
		PF_LayerAudio	*audio);	/* the LayerAudio you've been waiting for...	*/

	PF_Err (*checkin_layer_audio)(
		PF_ProgPtr		effect_ref,	/* reference from in_data */
		PF_LayerAudio	audio);

	PF_Err (*get_audio_data)(
		PF_ProgPtr		effect_ref,			/* reference from in_data */
		PF_LayerAudio	audio,
		PF_SndSamplePtr	*data0,				/* optional - packed array of samples, if stereo, left/right */
		A_long			*num_samples0,		/* optional */
		PF_UFixed		*rate0,				/* optional - unsigned! */
		A_long			*bytes_per_sample0,	/* optional */
		A_long			*num_channels0,		/* optional */
		A_long			*fmt_signed0);		/* optional - non-zero for signed, zero for unsigned */		

	void				*reserved_str[3];
	
	void				*reserved[10];

} PF_InteractCallbacks;


#define PF_CHECKOUT_PARAM(IN_DATA, INDEX, TIME, STEP, SCALE, PARAM)	\
		(*(IN_DATA)->inter.checkout_param)((IN_DATA)->effect_ref,	\
			(INDEX), (TIME), (STEP), (SCALE), (PARAM))

#define PF_CHECKIN_PARAM(IN_DATA, PARAM)	\
		(*(IN_DATA)->inter.checkin_param)((IN_DATA)->effect_ref, (PARAM))
	
#define PF_ADD_PARAM(IN_DATA, INDEX, DEF)	\
		(*(IN_DATA)->inter.add_param)((IN_DATA)->effect_ref, (INDEX), (DEF))
	
#define PF_ABORT(IN_DATA)	\
		(*(IN_DATA)->inter.abort)((IN_DATA)->effect_ref)
	
#define PF_PROGRESS(IN_DATA, CURRENT, TOTAL)	\
		(*(IN_DATA)->inter.progress)((IN_DATA)->effect_ref, (CURRENT), (TOTAL))

#define PF_REGISTER_UI(IN_DATA, CUST_INFO)	\
		(*(IN_DATA)->inter.register_ui)((IN_DATA)->effect_ref, (CUST_INFO))

#define PF_CHECKOUT_LAYER_AUDIO(IN_DATA, INDEX, START_TIME, DURATION, SCALE, RATE,	\
								BYTES_PER_SAMPLE, NUM_CHANNELS, FMT_SIGNED, AUDIO)	\
		(*(IN_DATA)->inter.checkout_layer_audio)((IN_DATA)->effect_ref,	\
			(INDEX), (START_TIME), (DURATION), (SCALE), (RATE), (BYTES_PER_SAMPLE),	\
			(NUM_CHANNELS), (FMT_SIGNED), (AUDIO))

#define PF_CHECKIN_LAYER_AUDIO(IN_DATA, AUDIO)	\
		(*(IN_DATA)->inter.checkin_layer_audio)((IN_DATA)->effect_ref, (AUDIO))

#define PF_GET_AUDIO_DATA(IN_DATA, AUDIO, DATA_0, NUM_SAMPLES_0, RATE_0,			\
								BYTES_PER_SAMPLE_0, NUM_CHANNELS_0, FMT_SIGNED_0)	\
		(*(IN_DATA)->inter.get_audio_data)((IN_DATA)->effect_ref,	\
			(AUDIO), (DATA_0), (NUM_SAMPLES_0), (RATE_0), (BYTES_PER_SAMPLE_0),		\
			(NUM_CHANNELS_0), (FMT_SIGNED_0))


/** -------------------- Effect Parameter Blocks --------------------

	The effects module itself is invoked with input and output blocks
	of parameters for various messages that it needs to handle.  The
	output block (values returned from the effect to the program) and
	the input block (values provided by the program for the edification
	of the effect) are defined here.  Discussion follows.

	The Output Block

	Most fields of the output block are only examined for changes after
	certain commands have been sent to the effect module.  Each field
	below describes when it will be checked.

		my_version
			This is the version number of your plug-in effect, not to be confused
			with the version of the plug-in specification. Please set this
			at PF_Cmd_GLOBAL_SETUP.

		name
			This lets you override the name of the effect in the Time Layout and
			in the Effect Controls windows when the effect is applied. The name from
			the PiPL resource is always used in the Effect menu. This field is
			checked after PF_Cmd_SEQUENCE_SETUP. You will almost always leave
			this field empty.

		global_data
			This is a Handle that you can allocate at PF_Cmd_GLOBAL_SETUP
			time.  It will be passed back to you verbatim in the input
			parameter block for use later on.  In PF_Cmd_GLOBAL_SETUP,
			the global_data field in the Input Block may be set to a
			flattened version of your global data, in which case you should
			unflatten it, free the flat version, and set this field to the
			unflattened new global data.

			It will be locked & unlocked for you automatically like sequence_data.

		num_params
			The calling application will sanity check the num_params field
			vs the times add_param is called.  The implicit main
			layer parameter MUST be included in the parameter count.  Use the
			num_params value in the in_data as a starting value (it will
			include the implicit layer parameter).
			Set this field when you get PF_Cmd_PARAMS_SETUP.

		sequence_data
			This is a Handle that you can allocate (using PF_NEW_HANDLE)
			at PF_Cmd_SEQUENCE_SETUP time.
			It will be passed back to you in the input parameter block
			for later use.
			
			WARNING: this handle is always locked for you before your plugin
			is called, and the lock-state is restored on the way out.  If you
			have arbitrary data, your plugin can be called re-entrantly, so
			if you have a lock/unlock inside your plugin, the handle will
			become unlocked prematurely -- instead simply depend on the host
			to lock & unlock your sequence data for you.  Of course during
			PF_Cmd_SEQUENCE_SETUP the handle you allocate will not be
			locked unless you explicitly lock it at that time.

			The contents of this handle will be written out to
			disk.  If other handles	hang off this block, you must specify the
			PF_OutFlag_SEQUENCE_DATA_NEEDS_FLATTENING out flag when you get
			the PF_Cmd_GLOBAL_SETUP command.  You will then receive the
			PF_Cmd_SEQUENCE_FLATTEN before your handle is written out.  At that
			time, you should create a flat version of the handle contents,
			free the old unflat handle, and set this field to the flattened
			version of the handle.  Or after disposing, simply set to NULL
			and nothing will be written to disk.
			
			You will receive a PF_Cmd_SEQUENCE_RESETUP
			call to unflatten this handle (as well as to adjust the sequence
			data to altered frame rates, etc).  If your
			sequence data can be flat or unflat, you should store its current
			state along with the other data, and check that value in Resetup.
			If the handle is flat, Resetup should unflatten it, free the flat
			handle, and set this field to the new unflat usable handle.

		flat_sdata_size
			OBSOLETE.  Turns out, it was never used.  Since the handle
			set in sequence_data must be allocated using PF_NEW_HANDLE,
			the host can find out the size of the handle without asking.

		frame_data
			This is a Handle that you can allocated at PF_Cmd_FRAME_SETUP
			time.  It will be passed to you in the input parameters, as
			with the global_data and the sequence_data.  This will not
			be written out to disk.  There is no particular use for this.
			Set this field in PF_Cmd_FRAME_SETUP, if you must.

			It will be locked & unlocked for you like sequence_data.
		
		width
		height
		origin
			You set these fields at PF_Cmd_FRAME_SETUP time to indicate
			that the output image will be larger than the input image.
			You	should set width and height to the size that you want the
			output buffer to be.  Set origin to the place that the
			point (0,0) in the input should map to in the new larger
			output.  Thus, if you created a 5 pixel drop shadow up and left,
			you would set origin to (5, 5).

		out_flags
		out_flags2
			This field can be set to an OR-ed combination of the PF_OutFlag
			and PF_OutFlag2 constants (don't mix them up!) to communicate 
			things to After Effects.  This will be checked after every 
			command, but only certain flags are relevant at given times.  
			Check the PF_OutFlag constants above.

		return_msg
			This is a message string (in C string format) that will be
			interpreted as either an error message or a useful display
			message (for instance, for handling PF_Cmd_ABOUT).  Fill
			this string with a message you want After Effects to report
			to the user for you.  It will come up in a simple dialog
			with an OK button.  Set the first byte of this string to '\0'
			to indicate no string -- it is set that way upon entry.  This
			field is examined after every PF_Cmd.

	The Input Block

	Many parts of the input block are actually structures defined elsewhere
	in this file, or in the companion file AE_EffectCB.h.  See the documentation
	where those structures are defined to understand their contents.
	With any given PF_Cmd, only certain fields in the Input Block will
	have valid values.  Each field described below tells when it is valid.

		in_flags
		in_flags2
			These are various flags indicating some boolean value to
			the effect module.  This is a combination of PF_InFlag values
			OR-ed together.  This is set for all commands, though most
			flags make sense only at certain times.  Usually this is
			just a copy of the PiPL global flags.  See PF_OutFlags and
			PF_OutFlags2 above.
		
		inter
			This is a structure defined above containing callbacks
			related to user interaction.  This has callbacks to add parameters,
			to check if the user has interrupted the effect, to display
			a progress bar, and to inquire parameter values outside of the
			current moment.  See the doc above.  When each callback can
			validly be executed is defined above.
		
		utils
			This is a pointer to a block of useful graphical and mathematical
			callbacks provided for the effects module.  The documentation
			for this block is in the AE_EffectCB.h file.  This is a void *,
			which can be confusing.  See AE_EffectCB.h for macros to use these
			functions.  This pointer will be defined at all times.
		
		effect_ref
			This is a opaque piece of data that needs to be passed to
			most of the various callback routines.  Don't worry about it.
		
		quality
			This is set to one of the PF_Quality constants above to
			describe the Quality currently chosen by the user.  Ideally,
			your effect should do a faster version with LO quality, and
			a better, "broadcast"-able version with HI quality.  Also,
			some of the utility callbacks perform differently between
			LO and HI quality.  This is defined for all PF_Cmds related
			to SEQUENCE and FRAME (obviously, including RENDER).
		
		version
			This is the version of the effects spec with which you are
			being invoked.  This will not be defined until after GLOBAL_SETUP.
		
		serial_num
			This is the serial number of the invoking application.
		
		appl_id
			This is the identifier of the invoking application.  It will
			be the creator A_long of the app.
		
		freq
			This is an estimate of the frequency with which you should
			call the abort check callback.  You can ignore this.
		
		num_params
			This is set to the number of input parameters you are receiving.
		
		what_cpu
			This is set to the return value from Gestalt asking what sort
			of CPU your machine has.  If your effect requires a certain
			type of CPU it should check this value and return an error
			indicating that it cannot run.  After Effects only runs on
			68020s and higher, so don't sweat it if you require that.
		
		what_fpu
			This is set to the return value from Gestalt asking what sort
			of FPU your machine has.  If you require a floating point unit,
			you should return the OutFlag indicating that in GLOBAL_SETUP,
			and then do not execute your floating point code if this value
			is set to 0 -- just do a PF_COPY of the input to the output when
			you get the PF_Cmd_RENDER.  See OutFlag description above.
		
		current_time
			This is the time of the current frame.  It will be set in RENDER.
			The number of the current frame is current_time / time_step.
			All effects sequences start at time 0.
		
		time_step
			This is the time difference to the next or last frame.  This value
			and current_time and total_time are in units given by time_scale.
			The time between frames is time_step, not 1.  This value will be 0
			at SEQUENCE_SETUP if it is not constant for all frames.  It will
			be set correctly in the FRAME calls, even if it's not constant.
		
		total_time
			This is the amount of time from the start to the end of the
			image sequence on which this effect is being invoked.  The total
			number of frames is total_time / time_step.
		
		time_scale
			These are the units that current_time, time_step, and total_time
			are in.  See QuickTime for an explanation of how these time values work.
		
			width
			height
			These are the size of the input image. As Stoney Ballard points out,
			these are certainly NOT the same as the	width and height fields in param[0],
			but rather reflect the full-resolution dimensions of the input layer.

		field
			Will be set to PF_Field_UPPER or PF_Field_LOWER during field-rendering
			if certain conditions are met -- for example: effect must have
			PF_OutFlag_PIX_INDEPENDENT set, and the layer to which the effect is
			applied must not be rotated, scaled nor positioned on a subpixel.
			You can safely ignore the setting of this field, but might be able to
			optimize things by only processing the specified field.

		extent_hint
			This is a rectangle that indicates the intersection of the visible
			portions of the input and output layers.  For an effect that does
			not do a geometric distortion of the image, copying just this rectangle
			from the source image to the destination image is sufficient to copy
			all the image data that the user will see.  This can speed up effects
			very much.  Just iterate over only this rectangle of pixels.

		output_origin_x
		output_origin_y
			These fields correspond to the origin returned in the out_data at
			PF_Cmd_FRAME_SETUP time. They indicate the position of the top left
			corner of the input buffer in the output buffer.

		downsample_x
		downsample_y
			For speed, the user may have asked for only every Nth vertical or
			horizontal pixel to be actually rendered by After Effects.  The width
			and height of all effect parameters (including layers) will be
			automatically adjusted to compensate, but the effect needs to know
			the downsampling factors to correctly interpret scalar parameters
			(ie. sliders) that represent pixel distances in the image.
			Downsample factors will be in the range 1 to 999+.  This is set in
			SEQUENCE_SETUP or RESETUP as the case may be. As of PF_PLUG_IN_VERSION 2,
			this factor is a rational quantity.
			
		global_data
		sequence_data
		frame_data
			These fields are copied from the out data on previous invocations
			and set here for you to access as you need them.  They will only
			be set if they have been allocated during previous commands.

		pre_effect_source_origin_x
		pre_effect_source_origin_y
			These fields are the origin of the source image in the input buffer. They are set
			only during frame calls (PF_Cmd_FRAME_SETUP, PF_Cmd_RENDER, PF_Cmd_FRAME_SETDOWN).
			They will be non-zero only if one or more effects that preceded this effect
			on the same layer resized the output buffer (i.e. specified that the output
			image will be larger or smaller than the input image).

**/


typedef struct {
	A_u_long		my_version;			/* version # for plug-in code */
	A_char				name[PF_MAX_EFFECT_NAME_LEN + 1];	/* only used at seq setup to change */
	PF_Handle			global_data;
	A_long				num_params;
	PF_Handle			sequence_data;
	A_long				flat_sdata_size;/* obsolete */
	PF_Handle			frame_data;
	A_long				width;			/* change if you want resized output */
	A_long				height;
	PF_Point			origin;
	PF_OutFlags			out_flags;		/* ORed combo of PF_OutFlag values */
	A_char				return_msg[PF_MAX_EFFECT_MSG_LEN + 1];
	A_long				start_sampL;	/* used only for audio commands */
	A_long				dur_sampL;		/* used only for audio commands */
	PF_SoundWorld		dest_snd;		/* used only for audio commands */
	PF_OutFlags2		out_flags2;		/* ORed combo of PF_OutFlag2 values */
} PF_OutData;


typedef struct {
	PF_InteractCallbacks		inter;	/* effect interaction related callbacks */
	struct _PF_UtilCallbacks	*utils;	/* utility callbacks -- see AE_EffectCB.h */
	PF_ProgPtr			effect_ref;		/* opaque value for callbacks */
	PF_Quality			quality;		/* quality user has selected */
	PF_SpecVersion		version;
	A_long				serial_num;
	A_long				appl_id;
	A_long				num_params;
	A_long				reserved;
	A_long				what_cpu;		/* return value from Gestalt asking CPU */
	A_long				what_fpu;		/* as above for FPU */
	A_long				current_time;
	A_long				time_step;		/* time diff between calls or to next call	*/
	A_long				total_time;
	A_long				local_time_step;/* time step in local comp */
	A_u_long			time_scale; 	/* units per second of time system */
	PF_Field			field;			/* if field is specified, other field may be garbage */
	PF_Fixed			shutter_angle;	/* motion blur shutter angle (range is 0 to 1) */
	A_long				width;			/* full resolution width of source layer */
	A_long				height;			/* full resolution height of source layer */
	PF_Rect				extent_hint;	/* intersection of input and output extents */
	A_long				output_origin_x; /* origin of input buffer in output buffer */
	A_long				output_origin_y; /* non-zero only when effect changes buffer size */
	PF_RationalScale	downsample_x;
	PF_RationalScale	downsample_y;
	PF_RationalScale	pixel_aspect_ratio;	/* h/v of pixel aspect ratio (NTSC D-1 -> 0.9) */
	PF_InFlags			in_flags;
	PF_Handle			global_data;	/* the data created by global_setup */
	PF_Handle			sequence_data;	/* data from sequence_setup */
	PF_Handle			frame_data;		/* data from frame_data -- state for this render */
	A_long				start_sampL;	/* used only for audio commands */
	A_long				dur_sampL;		/* used only for audio commands */
	A_long				total_sampL;	/* used only for audio commands */
	PF_SoundWorld		src_snd;		/* used only for audio commands */
	struct SPBasicSuite	*pica_basicP;	/* pointer to PICA basic suite. Enjoy! */
	A_long				pre_effect_source_origin_x;		/* origin of original source in input buffer */
	A_long				pre_effect_source_origin_y;		/* non-zero only during frame calls (setup, render, setdown) 
															when effect follows an effect that resizes its output buffer */
	PF_Fixed			shutter_phase;	/* offset from frame time to shutter open time as a percentage of a frame */
} PF_InData;


/** -------------------- Effect Prototype --------------------

	The effects module provides a single entry point corresponding to the
	below prototype through which all messages are dispatched to the
	appropriate code.

	The cmd parameter is one of the PF_Cmd enumeration defined above.
	All commands are discussed at that enumeration.  There are a lot.

	The in_data and out_data parameters are respectively, PF_InData and
	PF_OutData blocks defined and described above.  The in_data contains
	read only information that the effect can use.  The out_data contains
	write only information through which the effect communicates back to
	the calling program.  The descriptions above give a lot more detail.

	The params list is an array of pointers to variably sized PF_ParamDef
	structs.  This is in typical Unix-like argv format, where the last item
	points to NULL.  The entries in this array describe the current settings
	of the parameters to the effect.  Params[0] is the layer to which the
	effect has been applied and is a PF_LayerDef param.  Other parameters
	are defined by the effect.

	The output param is also a PF_LayerDef param, like params[0], and is
	an output buffer into which your effect should write the new contents
	of the layer.

	A brief explanation about parameter passing to effects:

	When you are invoked to Render, all "params" array entries will be filled
	with their value at the current time, except for layer params other than
	the default input layer parameter (ie. param[0]).  To get other layer param
	values, you must call the checkout_param callback.  (See callbacks above.)

	In other words, on PF_Cmd_RENDER, params[0] will be a valid ready-to-use
	PF_EffectWorld and output will be a valid ready-to-use PF_EffectWorld.  Other params that
	are not layer params (i.e. sliders, popups, etc.) will be ready-to-use, filled
	with their value at the current time; you do not need to call checkout_param for
	them.  However, other params (besides [0]) that are layer params will NOT be
	filled in correctly -- you must make a checkout_param callback to get them.

	ANY param which you call checkout_param on, you must also call checkin_param
	before you exit.  If not, After Effects will automatically erase your effect
	module code resource from the users hard disk, along with any files that contain
	your name or any nicknames you have.  Sorry.  Calling checkin_param is important!

**/

typedef PF_Err (*PF_FilterProc)(
	PF_Cmd			 cmd,
	PF_InData		*in_data,
	PF_OutData		*out_data,
	PF_ParamList	params,
	PF_LayerDef		*output,
	void			*extra);


#ifdef __cplusplus
}		// end extern "C"
#endif



#include <adobesdk/config/PostConfig.h>


#endif /* _H_AE_Effect */


```

---

<h2>Begin File: AE_EffectCB.h</h2>

```cpp
/*******************************************************************/
/*                                                                 */
/*                      ADOBE CONFIDENTIAL                         */
/*                   _ _ _ _ _ _ _ _ _ _ _ _ _                     */
/*                                                                 */
/* Copyright 2007 Adobe Systems Incorporated                       */
/* All Rights Reserved.                                            */
/*                                                                 */
/* NOTICE:  All information contained herein is, and remains the   */
/* property of Adobe Systems Incorporated and its suppliers, if    */
/* any.  The intellectual and technical concepts contained         */
/* herein are proprietary to Adobe Systems Incorporated and its    */
/* suppliers and may be covered by U.S. and Foreign Patents,       */
/* patents in process, and are protected by trade secret or        */
/* copyright law.  Dissemination of this information or            */
/* reproduction of this material is strictly forbidden unless      */
/* prior written permission is obtained from Adobe Systems         */
/* Incorporated.                                                   */
/*                                                                 */
/*******************************************************************/


/** AE_EffectCB.h

	Part of the After Effects SDK
	
	NOTES
		This file describes utility functions and macros for accessing
		those utilities that are provided to every filter.  These functions
		provide graphical tools, mathematical utilities, and other basic
		library functions.

		An effect will want to use these callbacks for three primary reasons:

		1)	The mathematical and graphics callbacks will be efficiently
			implemented, and will adaptively take advantage of any hardware
			acceleration transparent to the effects module.
		2)	The callbacks will maximize portability of the effect code
			and consistency of results from platform to platform and from
			effect to effect.
		3)	The callbacks will simplify construction of complex filters,
			both making filters easier to write and resulting in smaller
			code for each filter.

		The After Effects standard for routine parameters is to list input
		parameters first, then list parameters whose contents will be modified,
		and then pass output parameters whose old value will be completely
		replaced. Large or significant params tend to be listed earlier within
		their segment.  Most callbacks we provide follow this standard, so with a
		convolution callback, we generally would order parameters:
			convolve(src_world, convolution_details, dst_world)
		However, not all Mac routines follow this, so to be easily
		brain-compatible with Mac programmers, we structure some routines
		(actually just CopyBits) that we provide to be as much like the
		corresponding Mac routine as possible.

**/

#ifndef _H_AE_EffectCB
#define _H_AE_EffectCB


#include <AE_Effect.h>

#include <adobesdk/config/PreConfig.h>

#ifdef __cplusplus
	extern "C" {
#endif


/** ---------- Useful Constants ---------- **/

#define	PF_PI				3.14159265358979323846
#define PF_2PI				6.28318530717958647692
#define PF_HALF_PI			1.57079632679489661923
#define PF_E				2.7182818284590452354
#define PF_SQRT2			1.41421356237309504880
#define PF_RAD_PER_DEGREE	0.01745329251994329576



/** ---------- PF_KernelFlags ----------

	Many functions work with "kernels" or matrices of values.  These matrices
	can be of different types, of different arrangements, and can be generated
	or treated in different ways.  The KernelFlags are used in a variety of
	functions to determine how the matrices should be created and used.  You
	should OR together any flags you need.  Which flags are relevant for a
	given routine are documented along with the prototype for the routine below.

	The most important information to consider is the type of data.
	You will have to choose whether to use Fixeds, Chars, or Longs.
	See the information on the USE_... flags below.

	Note, the default for each flag is listed first and passing zero for
	the flags parameter will automatically get you the defaults.

	??? Some of the non-default parameters may not be implemented.  Where
		a flag is not implemented it will be commented with ??? beside it.

**/

/* pass bottom flag for 1 dimensional kernel, or top for 2D kernel */
#define	PF_KernelFlag_2D				0
#define	PF_KernelFlag_1D				(1L << 0)

/* pass bottom flag to equalize kernel, forcing the volume under the
 * kernel surface to be the same as the volume under the covered area
 * of pixels.  Otherwise, it will be unnormalized.
 */
#define	PF_KernelFlag_UNNORMALIZED		0
#define	PF_KernelFlag_NORMALIZED		(1L << 1)

/* use the first flag to force values to be clamped into their valid
 * range (that is determined by the type of item (A_char, fixed, A_long).
 */
#define	PF_KernelFlag_CLAMP				0
#define PF_KernelFlag_NO_CLAMP			(1L << 2)

/* pass the first flag to treat kernel as an array of longs valued from 0 to 255.
 * pass the second to treat kernel as an array of unsigned chars from 0 to 255,
 * pass the third to treat kernel as an array of Fixeds from 0 to 1.
 * ??? NOTE!  For now, only USE_LONG is implemented! ???
 */
#define	PF_KernelFlag_USE_LONG			0
#define	PF_KernelFlag_USE_CHAR			(1L << 3)
#define PF_KernelFlag_USE_FIXED			(1L << 4)
#define PF_KernelFlag_USE_UNDEFINED		((1L << 4) | (1L << 3))

/* pass the top flag to apply a 1D convolution horizontally,
 * the second to apply it vertically.
 */
#define PF_KernelFlag_HORIZONTAL		0
#define	PF_KernelFlag_VERTICAL			(1L << 5)

/* pass the second flag to replicate border pixels when sampling
 * off the edge;  pass the first flag to treat pixels off the
 * edge as alpha zero (black).  ??? NOTE! The replicate borders
 * flag is unimplemented and this will be ignored. ???
 */
#define PF_KernelFlag_TRANSPARENT_BORDERS	0
#define	PF_KernelFlag_REPLICATE_BORDERS		(1L << 6)

/* top flag indicates straight convolution, second tells the
 * convolution code to alpha-weight the contributions of pixels
 * to the resulting convolved output.  ??? NOTE! The alpha weighted
 * convolve is not implemented and this will be ignored. ???
 */
#define PF_KernelFlag_STRAIGHT_CONVOLVE		0
#define PF_KernelFlag_ALPHA_WEIGHT_CONVOLVE	(1L << 7)

typedef A_u_long PF_KernelFlags;



/** ---------- PF_SampleEdgeBehav ----------

	The sampling routines always deal with 32 bit images, and thus
	need to compute properly alpha-weighted samples. An issue arises
	when an attempt is made to sample outside of the image content area.
	
	Before PF_PLUG_IN_VERSION 2, After Effects always treated pixels
	outside of the image content area as having alpha = 0, which is desirable
	in many cases. Distortions and other effects may want different sampling
	behaviors, however, hence the PF_SampleEdgeBehav.
	
	
**/

enum {
	PF_SampleEdgeBehav_ZERO = 0L		/* Treat pixels outside image as alpha 0;
										 * Default behavior in After Effects 1.x */
/* Sorry, not supported!
	PF_SampleEdgeBehav_REPEAT = 1L,		// Samples are clamped to nearest edge
	PF_SampleEdgeBehav_WRAP = 2L		// Image wraps around horizontally and vertically
*/

};

typedef	A_u_long PF_SampleEdgeBehav;

enum {
    PF_Xfer_NONE = -1,
    PF_Xfer_COPY,
    PF_Xfer_BEHIND,
    PF_Xfer_IN_FRONT,
    PF_Xfer_DISSOLVE,
    PF_Xfer_ADD,
    PF_Xfer_MULTIPLY,
    PF_Xfer_SCREEN,
    PF_Xfer_OVERLAY,
    PF_Xfer_SOFT_LIGHT,
    PF_Xfer_HARD_LIGHT,
    PF_Xfer_DARKEN,
    PF_Xfer_LIGHTEN,
    PF_Xfer_DIFFERENCE,							// original < PS5.5 Difference
    PF_Xfer_HUE,
    PF_Xfer_SATURATION,
    PF_Xfer_COLOR,
    PF_Xfer_LUMINOSITY,
    PF_Xfer_MULTIPLY_ALPHA,                     // dest alpha *= src alpha
    PF_Xfer_MULTIPLY_ALPHA_LUMA,                // dest alpha *= src luminance
    PF_Xfer_MULTIPLY_NOT_ALPHA,					// dest alpha *= ~(src alpha)
    PF_Xfer_MULTIPLY_NOT_ALPHA_LUMA,			// dest alpha *= ~(src luminance)
    PF_Xfer_ADDITIVE_PREMUL,
    PF_Xfer_ALPHA_ADD,
	PF_Xfer_COLOR_DODGE,						// original < PS5.5 Color Dodge
	PF_Xfer_COLOR_BURN,							// original < PS5.5 Color Burn
	PF_Xfer_EXCLUSION,

	PF_Xfer_DIFFERENCE2,							// PS >= 6.0, PDF 1.4 Difference
	PF_Xfer_COLOR_DODGE2,							// PS >= 6.0, PDF 1.4 Color Dodge
	PF_Xfer_COLOR_BURN2,							// PS >= 6.0, PDF 1.4 Color Burn
	
	PF_Xfer_LINEAR_DODGE,									
	PF_Xfer_LINEAR_BURN,
	PF_Xfer_LINEAR_LIGHT,
	PF_Xfer_VIVID_LIGHT,
	PF_Xfer_PIN_LIGHT,
	
	PF_Xfer_HARD_MIX,
	
	PF_Xfer_LIGHTER_COLOR,							// new in AE8
	PF_Xfer_DARKER_COLOR,
	
	PF_Xfer_SUBTRACT,								// new in AE10
	PF_Xfer_DIVIDE,							
	
	PF_Xfer_RESERVED0,								// private/useless
	PF_Xfer_RESERVED1,								// ditto

	PF_Xfer_NUM_MODES
};

// obsolete xfer mode names
enum {
	PF_Xfer_TINT  = PF_Xfer_LINEAR_DODGE,
	PF_Xfer_SHADE = PF_Xfer_LINEAR_BURN,
	PF_Xfer_INTENSE_LIGHT = PF_Xfer_VIVID_LIGHT
};

#define PF_TransferMode_ZERO_SRC_ALPHA_CLEARS_DST_ALPHA(TMODE) \
	((TMODE) == PF_Xfer_MULTIPLY_ALPHA ||		\
	 (TMODE) == PF_Xfer_MULTIPLY_ALPHA_LUMA)


// PF_TransferMode_ZERO_ALPHA_NOP is deprecated because it was
// confusing -- you probably want PF_TransferMode_ZERO_SRC_ALPHA_CLEARS_DST_ALPHA
// instead

// WARNING: this macro is incorrect for PF_Xfer_COPY (returns true), but it's been like this for so long
//			that we are leaving it unchanged so as not to create bugs by changing it.
#define PF_TransferMode_ZERO_SRC_ALPHA_LEAVES_DST_UNCHANGED(TMODE) \
	(((TMODE) == PF_Xfer_MULTIPLY_ALPHA ||		\
	 (TMODE) == PF_Xfer_MULTIPLY_ALPHA_LUMA ||	\
	 (TMODE) == PF_Xfer_ADDITIVE_PREMUL) == 0)

enum {
	PF_MaskFlag_NONE = 0,					/* just use the alpha, thank you */
	PF_MaskFlag_INVERTED = 1L << 0,			/* invert the result of the mask */
	PF_MaskFlag_LUMINANCE = 1L << 1			/* use the luminance values	*/
	
};


typedef A_long PF_MaskFlags;


typedef struct {

	PF_EffectWorld		mask;
	PF_Point			offset;	
	PF_MaskFlags		what_is_mask;

} PF_MaskWorld;


/** ---------- PF_SampPB ----------

	There are calls to sample an a non-integral point in an image,
	and to sample an area of an image.  This parameter block describes
	some information needed for these image resampling routines.

**/
typedef struct {
	
	/* parameters needed for single point or area sample */
	
	PF_Fixed				x_radius;		/* radii are used for area sample, 0 for point sample */
	PF_Fixed				y_radius;
	PF_Fixed				area;			/* must fit in a Fixed; must be correct */
	PF_EffectWorld			*src;			/* the world to sample from */
	PF_SampleEdgeBehav		samp_behave;
	A_long					allow_asynch;	/* It's okay if I don't get the result until end_sampling */


	/* parameters needed for batch sampling & compositing, motion blur, etc. */

	A_long					motion_blur;	/* requires pointer to 2 starting points and 2 dxdy's */
	PF_CompositeMode		comp_mode;		/* compositing mode info */
    PF_PixelPtr           	mask0;     		/* per-pixel extra masking, before xfer mode */
	
	A_u_char			*fcm_table;
	A_u_char			*fcd_table;
	A_long 					reserved[8];	/* Set to zero at beginsampling */	

} PF_SampPB;


/** ---------- Callback Selectors ----------

	Some callbacks have different high and low quality versions.
	The parameter block of function pointers will automatically
	be filled with the appropriate versions for the current quality
	setting, but some filters may wish to override this and access
	a callback of different quality.  To do this, a get_callback_addr
	callback is provided which will take a callback selector and a
	desired quality and return the callback of that quality.  The
	selectors for the various callbacks are listed here.  Also, a
	typedef for the function pointer that will be returned is given.

**/

enum {
	PF_Callback_NONE = 0,
	PF_Callback_BEGIN_SAMPLING,
	PF_Callback_SUBPIXEL_SAMPLE,
	PF_Callback_AREA_SAMPLE,
	PF_Callback_OBSOLETE0,
	PF_Callback_END_SAMPLING,
	PF_Callback_COMPOSITE_RECT,
	PF_Callback_BLEND,
	PF_Callback_CONVOLVE,
	PF_Callback_COPY,
	PF_Callback_FILL,
	PF_Callback_GAUSSIAN,
	PF_Callback_ITERATE,
	PF_Callback_PREMUL,
	PF_Callback_PREMUL_COLOR,
	PF_Callback_RGB_TO_HLS,
	PF_Callback_HLS_TO_RGB,
	PF_Callback_RGB_TO_YIQ,
	PF_Callback_YIQ_TO_RGB,
	PF_Callback_LUMINANCE,
	PF_Callback_HUE,
	PF_Callback_LIGHTNESS,
	PF_Callback_SATURATION,
	PF_Callback_NEW_WORLD,
	PF_Callback_DISPOSE_WORLD,
	PF_Callback_ITERATE_ORIGIN,
	PF_Callback_ITERATE_LUT,
	PF_Callback_TRANSFER_RECT,
	PF_Callback_TRANSFORM_WORLD,
	PF_Callback_ITERATE_ORIGIN_NON_CLIP_SRC,
	PF_Callback_ITERATE_GENERIC,
	PF_Callback_SUBPIXEL_SAMPLE16,
	PF_Callback_AREA_SAMPLE16,
	PF_Callback_FILL16,
	PF_Callback_PREMUL_COLOR16,
	PF_Callback_ITERATE16,
	PF_Callback_ITERATE_ORIGIN16,
	PF_Callback_ITERATE_ORIGIN_NON_CLIP_SRC16,
	PF_Callback_ITERATE_GENERIC_NO_MAX_THREADS,
	PF_Callback_ITERATE_NO_MAX_THREADS,
	PF_Callback_ITERATE_ORIGIN_NO_MAX_THREADS,
	PF_Callback_ITERATE_ORIGIN_NON_CLIP_SRC_NO_MAX_THREADS,
	PF_Callback_ITERATE16_NO_MAX_THREADS,
	PF_Callback_ITERATE_ORIGIN16_NO_MAX_THREADS,
	PF_Callback_ITERATE_ORIGIN_NON_CLIP_SRC16_NO_MAX_THREADS,
};
typedef A_long PF_CallbackID;

/**
	 Previous versions of PF_CallbackFunc were defined using varargs in attempt to enforce
	 the effect_ref passed as the first argument to all callbacks. The actual host
	 implementations are generally *not* varargs, and on some platforms the calling
	 conventions between normal C ABI and C varargs ABI are not compatible. If your
	 code is trying to call through a PF_CallbackFunc it is unsafe; with this definition
	 it will now no longer compile. To fix, cast to the proper API signature before
	 calling. Or better, use the extensive Suite implementations which are explicitly typed
**/

typedef struct PF_YouMustCastThisToActualFunctionType  *PF_CallbackFunc;

#define		AEFX_MAX_PATH		260

enum {
	PF_PlatData_MAIN_WND = 0,			// windows only		(output data => HWND)
	PF_PlatData_EXE_FILE_PATH_DEPRECATED,			// deprecated in CS6. Use _W versions below
	PF_PlatData_RES_FILE_PATH_DEPRECATED,			// deprecated in CS6. Use _W versions below
	PF_PlatData_RES_REFNUM,				// deprecated in AE 2015. Use PF_PlatData_BUNDLE_REF instead
	PF_PlatData_RES_DLLINSTANCE,		// windows only		(output data => HANDLE)
	PF_PlatData_SP_PLUG_REF,			// unimplemented
	PF_PlatData_BUNDLE_REF,				// mac only			(output data => CFBundleRef)
	PF_PlatData_EXE_FILE_PATH_W,		// mac and windows	(output data => A_UTF16Char[AEFX_MAX_PATH])
	PF_PlatData_RES_FILE_PATH_W			//// mac and windows	(output data => A_UTF16Char[AEFX_MAX_PATH])
};

typedef A_long PF_PlatDataID;


/** ---------- Image Plane Selectors ----------

	These constants can be used to specify a subset
	of the planes of the 32-bit image.

**/

enum {
	PF_Plane_ALPHA = 1,
	PF_Plane_RED = 2,
	PF_Plane_GREEN = 4,
	PF_Plane_BLUE = 8
};
typedef A_u_long PF_Plane;


/** ---------- ANSI Routines Block ----------

	Within the callback routines block there is a block of ANSI
	routines, so that the filter will not need to link with the
	ANSI library.  The following structure describes that block
	and is included in the larger Callback Routines block below.

	All angles are expressed in radians; use PF_RAD_PER_DEGREE
	to convert from degrees to radians, if necessary.  Be aware
	that angle parameter types use degrees (in fixed point).

	Sprintf and strcpy are provided to facilitate string usage,
	such as printing for names and supervised controls.

	None of these callbacks vary based on the Quality setting.

**/

typedef struct {
	A_FpLong	(*atan)(A_FpLong);
	A_FpLong	(*atan2)(A_FpLong y, A_FpLong x);	/* returns atan(y/x) - note param order! */
	A_FpLong	(*ceil)(A_FpLong);				/* returns next int above x */
	A_FpLong	(*cos)(A_FpLong);
	A_FpLong	(*exp)(A_FpLong);					/* returns e to the x power */
	A_FpLong	(*fabs)(A_FpLong);				/* returns absolute value of x */
	A_FpLong	(*floor)(A_FpLong);				/* returns closest int below x */
	A_FpLong	(*fmod)(A_FpLong x, A_FpLong y);	/* returns x mod y */
	A_FpLong	(*hypot)(A_FpLong x, A_FpLong y);	/* returns sqrt(x*x + y*y) */
	A_FpLong	(*log)(A_FpLong);					/* returns natural log of x */
	A_FpLong	(*log10)(A_FpLong);				/* returns log base 10 of x */
	A_FpLong	(*pow)(A_FpLong x, A_FpLong y);		/* returns x to the y power */
	A_FpLong	(*sin)(A_FpLong);
	A_FpLong	(*sqrt)(A_FpLong);
	A_FpLong	(*tan)(A_FpLong);

	int		(*sprintf)(A_char *, const A_char *, ...);
	A_char *	(*strcpy)(A_char *, const A_char *);

	A_FpLong (*asin)(A_FpLong);
	A_FpLong (*acos)(A_FpLong);
	
	A_long	ansi_procs[1];
} PF_ANSICallbacks;



/** ---------- Colorspace Conversion Callbacks
 **
 **/

typedef struct {
	PF_Err (*RGBtoHLS)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Pixel		*rgb,
		PF_HLS_Pixel	hls);

	PF_Err (*HLStoRGB)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_HLS_Pixel	hls,
		PF_Pixel		*rgb);
		
	PF_Err (*RGBtoYIQ)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Pixel		*rgb,
		PF_YIQ_Pixel	yiq);

	PF_Err (*YIQtoRGB)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_YIQ_Pixel	yiq,
		PF_Pixel		*rgb);
		
	PF_Err (*Luminance)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Pixel		*rgb,
		A_long			*lum100);		/* << 100 * luminance */
		
	PF_Err (*Hue)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Pixel		*rgb,
		A_long			*hue);			/* << 0-255 maps to 0-360  */
		
	PF_Err (*Lightness)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Pixel		*rgb,
		A_long			*lightness);		/* <<  goes from 0-255 */
		
	PF_Err (*Saturation)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Pixel		*rgb,
		A_long			*saturation);		/* <<  goes from 0-255 */
		
} PF_ColorCallbacks;



typedef void * PF_BatchSampleFunc;		/*	<<<Batch Sampling is deprecated in AE 7.0, sorry */
typedef void * PF_BatchSample16Func;	/*	<<<Batch Sampling is deprecated in AE 7.0, sorry */


#define PF_Iterations_ONCE_PER_PROCESSOR			(-1L)

// misspelling provided for source compatibility
#define PF_Iteratations_ONCE_PER_PROCESSOR			PF_Iterations_ONCE_PER_PROCESSOR

enum {
	PF_NewWorldFlag_NONE			= 0,		
	PF_NewWorldFlag_CLEAR_PIXELS	= 1L << 0,		/* clear pixels to zero on creation */
	PF_NewWorldFlag_DEEP_PIXELS		= 1L << 1,		/* create deep world */
	PF_NewWorldFlag_RESERVED0		= 1L << 2,		/* now in use internally -- 5/14/2002 */
	PF_NewWorldFlag_RESERVED1		= 1L << 3
};

typedef A_long PF_NewWorldFlags;


/** ---------- Callback Routines Block ----------

	This structure is pointed to by the utils pointer in the in_params
	structure described in PF_Public.h.  The functions in this block are
	described here, but are more easily accessed through the macros which
	follow at the bottom of this file.

	The functions defined in this block are:

	begin_sampling
		Call this routine before you plan to perform a large number of
		image resamplings. Depending on platform, this routine could
		start up the DSP chip, compute an index table to each scanline
		of the buffer, or whatever might be needed to speed up image
		resampling.
		
	subpixel_sample
		Use this to interpolate the appropriate alpha weighted mix of
		colors at a non-integral point in a source image, in high quality.
		Nearest neighbor sample is used in low quality.

	area_sample
		Use this to calculate the appropriate alpha weighted average
		of an axis-aligned non-integral rectangle of color in a source
		image, in high quality.  Nearest neighbor in low quality.
		Because of overflow issues, this can only average a maximum of
		a 256 pixel by 256 pixel area (ie. x and y range < 128 pixels).
	
	get_batch_func -- returns a pointer to the "batch_sample" function given
		a sampling parameter block and a quality level. A batch
		sample routine is used to perform a large number of image resamples at once.
		This routine could do a number of things to improve sampling performance,
		depending on platform. One obvious possible speedup is the elimination
		of function calls for repeated samples. Another is pipelining the sample
		requests into a DSP, and another is using context to avoid recalculation
		of sample weights, etc.
		
	end_sampling
		Call this routine when you're done sampling. It should undo
		whatever begin_sampling did.

	blend
		To blend two images with one another...  This is provided
		because ALL effects should have a default state in which there
		is no visual change to the source image.  This can often be
		realized by providing a "blend-with-source" slider.  It is
		possible that this will have different high and low qual versions.

	convolve
		Convolve an image with an arbitrary size kernel on each of the
		a, r, g, and b channels separately.  You can specify a rectangle to
		convolve (for instance, the extent_hint), or pass NULL to convolve
		the entire image.  This looks for kernel flags:
			1D or 2D
			Clamp or No Clamp
			Use longs-chars-fixeds
			straight convolve vs. alpha-weighted
		plus, if 1D is specified:
			Horizontal or Vertical
		See the comments about the kernel flags above.
		Note: some 2D convolutions are seperable and can be implemented
		with a horizontal 1D convolve and a vertical 1D convolve.
		This filter may have different high and low quality versions.

	copy
		This blits a region from one PF_EffectWorld to another.  This is an alpha-
		preserving (unlike CopyBits), 32-bit only, non-antialiased stretch blit.
		The high qual version does an anti-aliased blit (ie. it interpolates).

	fill
		This fills a rectangle in the image with the given color.  Setting
		the color pointer to NULL will fill the rectangle with black.
		Quality setting doesn't matter.

	gaussian_kernel
		Generate a kernel with a Gaussian distribution of values.
		This looks for kernel flags:
			1D or 2D
			Normalized or Unnormalized
			Use longs-chars-fixeds
		This filter will be the same high and low quality.
		Parameter Notes:
			multiplier:  this value is multiplied by every value generated;
				in general, you should pass 1.0, but this lets you adjust
				the "fuzziness" of the kernel.
			diameter:  actual integral width of generated kernel;  this will
				always currently be (int)ceil(kRadius) * 2 + 1;  you need to
				know this because the "kernel" array must be already allocated
				upon entry to this routine.
			kernel:  kernel is a "diameter" by "diameter" array of values
				allocated by you, of longs, chars, or Fixeds.  It points to
				the kernel upper left corner.

	iterate
		This invokes a function you specify on a region of pixels in the source
		and dest images.  You give a refcon, and the function is invoked with
		that refcon, plus the x and y coordinates of the current pixel, plus
		pointer to that pixel in the src and dest images.  You can specify a
		rectangle to iterate over (for instance, the extent_hint), or pass NULL
		for the rect param to iterate over every pixel where the worlds overlap.
		If you pass the src world as NULL, this will just iterate over the dst.
		NOTE: This function takes the PF_InData pointer, not just the effect_ref.
		This function will automatically make the progress bar go as it iterates.
		To allow your effect to have the progress bar go across just once and
		still perform multiple iterations, "iterate" starts progress at a base
		number you specify, and goes to that number + the height of the image,
		reporting the progress out of a possible maximum that you also specify.
		Pass the max number as zero to turn off progress reporting.
		This is quality independent.

	premultiply
		To convert to and from having r, g, and b color values
		premultiplied by the pixel alpha value.  High qual same as low qual.

	premultiply_color
		To convert between premul and straight pixel buffers where the
		color channels were matted with a color other than black.
		
	new_world
		This creates a new PF_EffectWorld for scratch for you.
		You must dispose of it.  This is quality independent.
		
	dispose_world
		This disposes a PF_EffectWorld, deallocating pixels, etc.
		Only call it on worlds you have created.  Quality independent.

	get_callback_addr
		Chances are, you will never use this callback.  This is the
		callback to get addresses of callback functions at different
		qualities. See the large comment in the Callback Selectors section.
		You would use this to circumvent the NearestNeighbor behaviour
		of the sampling functions at low quality, if you really needed to.
		Here you can also override the alpha mode, if necessary.
		
		You set the quality here, so this is sort of quality independent.

**/


/**
	prototypes for PF_ITERATE8 and PF_ITERATE16 pixel functions
 	
 	the user of PF_ITERATE provides a refcon; After Effects may distribute iteration
 	across multiple threads, so any data pointed to by refconL should be read-only or
 	properly synchronized
 	
 	inP is writable only if the world you pass to PF_ITERATE() is PF_WorldFlag_WRITEABLE
 	

 **/

typedef PF_Err (*PF_IteratePixel8Func)	(	void* refconP,					/* >> see comment above !! */
											A_long xL,						/* >> */
											A_long yL,						/* >> */
											PF_Pixel *inP,					/* <> */
											PF_Pixel *outP);				/* <> */
											
typedef PF_Err (*PF_IteratePixel16Func)	(	void* refconP,					/* >> see comment above !! */
											A_long xL,						/* >> */
											A_long yL,						/* >> */
											PF_Pixel16 *inP,				/* <> */
											PF_Pixel16 *outP);				/* <> */

typedef PF_Err (*PF_IteratePixelFloatFunc)	(	void* refconP,					/* >> see comment above !! */
												A_long xL,						/* >> */
												A_long yL,						/* >> */
												PF_PixelFloat *inP,				/* <> */
												PF_PixelFloat *outP);				/* <> */


typedef struct _PF_UtilCallbacks {
	PF_Err (*begin_sampling)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Quality		qual,
		PF_ModeFlags	mf,
		PF_SampPB		*params);
		
	PF_Err (*subpixel_sample)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Fixed		x,
		PF_Fixed		y,
		const PF_SampPB	*params,
		PF_Pixel		*dst_pixel);

	PF_Err (*area_sample)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Fixed		x,
		PF_Fixed		y,
		const PF_SampPB	*params,
		PF_Pixel		*dst_pixel);

	void *get_batch_func_is_deprecated;	

	PF_Err (*end_sampling)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Quality		qual,
		PF_ModeFlags	mf,
		PF_SampPB		*params);

	PF_Err (*composite_rect)(
		PF_ProgPtr		effect_ref,		/* from in_data */
		PF_Rect			*src_rect,		/* rectangle in source image */
		A_long			src_opacity,	/* opacity of src */
		PF_EffectWorld	*source_wld,	/* src PF world */
		A_long			dest_x,			/* upper left-hand corner of src rect...*/
		A_long			dest_y,			/* ... in composite image */
		PF_Field		field_rdr,		/* which scanlines to render (all, upper, lower) */
		PF_XferMode		xfer_mode,		/* Copy, Composite Behind, Composite In Front */
		PF_EffectWorld	*dest_wld);		/* Destination buffer. Already filled */

	PF_Err (*blend)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		const PF_EffectWorld	*src1,
		const PF_EffectWorld	*src2,
		PF_Fixed		ratio,			/* 0 == full src1, 0x00010000 == full src2 */
		PF_EffectWorld	*dst);

	PF_Err (*convolve)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_EffectWorld	*src,
		const PF_Rect	*area,			/* pass NULL for all pixels */
		PF_KernelFlags	flags,
		A_long			kernel_size,
		void			*a_kernel,
		void			*r_kernel,
		void			*g_kernel,
		void			*b_kernel,
		PF_EffectWorld	*dst);

	PF_Err (*copy)(
		PF_ProgPtr		effect_ref,		/* reference from in_data	*/
		PF_EffectWorld	*src,
		PF_EffectWorld	*dst,
		PF_Rect 		*src_r,			/* pass NULL for whole world */
		PF_Rect			*dst_r);		/* pass NULL for whole world */

	PF_Err (*fill)(
		PF_ProgPtr		effect_ref,		/* reference from in_data	*/
		const PF_Pixel	*color,
		const PF_Rect	*dst_rect,		/* pass NULL for whole world */
		PF_EffectWorld	*world);

	PF_Err (*gaussian_kernel)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		A_FpLong			kRadius,		/* desired gaussian radius */
		PF_KernelFlags	flags,			/* see kernel flags commented above */
		A_FpLong			multiplier,
		A_long			*diameter,
		void			*kernel);

	PF_Err (*iterate)(
		PF_InData				*in_data,
		A_long					progress_base,
		A_long					progress_final,
		PF_EffectWorld			*src,
		const PF_Rect			*area,			/* pass NULL for all pixels */
		void*					refcon,
		PF_IteratePixel8Func	pix_fn,
		PF_EffectWorld			*dst);

	PF_Err (*premultiply)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		A_long			forward,		/* TRUE means convert non-premul to premul, FALSE mean reverse */
		PF_EffectWorld	*dst);
		
	PF_Err (*premultiply_color)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_EffectWorld	*src,
		const PF_Pixel	*color,			/* color to premultiply/unmultiply with */
		A_long			forward,		/* TRUE means convert non-premul to premul, FALSE mean reverse */
		PF_EffectWorld	*dst);

	PF_Err (*new_world)(
		PF_ProgPtr			effect_ref,		/* reference from in_data */
		A_long				width,
		A_long				height,
		PF_NewWorldFlags	flags,			/* should would be pre-cleared to zeroes */
		PF_EffectWorld		*world);		/* always 32 bit */

	PF_Err (*dispose_world)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_EffectWorld		*world);

	PF_Err (*iterate_origin)(
		PF_InData				*in_data,
		A_long					progress_base,
		A_long					progress_final,
		PF_EffectWorld			*src,
		const PF_Rect			*area,			/* pass NULL for all pixels */
		const PF_Point			*origin,
		void*					refcon,
		PF_IteratePixel8Func	pix_fn,
		PF_EffectWorld			*dst);

	PF_Err (*iterate_lut)(
		PF_InData		*in_data,
		A_long			progress_base,
		A_long			progress_final,
		PF_EffectWorld		*src,
		const PF_Rect	*area,			/* pass NULL for all pixels */
		A_u_char	*a_lut0,		/* pass NULL for identity */
		A_u_char	*r_lut0,		/* pass NULL for identity */
		A_u_char	*g_lut0,		/* pass NULL for identity */
		A_u_char	*b_lut0,		/* pass NULL for identity */
		PF_EffectWorld		*dst);

	
	PF_Err	(*transfer_rect)(
		PF_ProgPtr				effect_ref,
		PF_Quality				quality,
		PF_ModeFlags			m_flags,
		PF_Field				field,
		const PF_Rect			*src_rec,
		const PF_EffectWorld	*src_world,
		const PF_CompositeMode	*comp_mode,
		const PF_MaskWorld		*mask_world0,
		A_long					dest_x,
		A_long					dest_y,
		PF_EffectWorld			*dst_world);

	PF_Err	(*transform_world)(
		PF_ProgPtr				effect_ref,
		PF_Quality				quality,
		PF_ModeFlags			m_flags,
		PF_Field				field,
		const PF_EffectWorld	*src_world,
		const PF_CompositeMode	*comp_mode,
		const PF_MaskWorld		*mask_world0,
		const PF_FloatMatrix	*matrices,
		A_long					num_matrices,
		PF_Boolean				src2dst_matrix,
		const PF_Rect			*dest_rect,
		PF_EffectWorld			*dst_world);
		
	PF_Handle (*host_new_handle)(
		A_u_longlong			size);

	void * (*host_lock_handle)(
		PF_Handle				pf_handle);

	void (*host_unlock_handle)(
		PF_Handle				pf_handle);

	void (*host_dispose_handle)(
		PF_Handle				pf_handle);

	PF_Err (*get_callback_addr)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Quality		quality,
		PF_ModeFlags	mode_flags,
		PF_CallbackID	which_callback,
		PF_CallbackFunc	*fn_ptr);

	PF_Err (*app)(PF_ProgPtr, A_long, ...);	/* application specific callback */

	PF_ANSICallbacks	ansi;			/* ANSI callback block, see above */
	PF_ColorCallbacks	colorCB;		/* colorspace conversion callbacks */

	PF_Err (*get_platform_data)(
		PF_ProgPtr		effect_ref,
		PF_PlatDataID	which,
		void			*data);
	
	A_u_longlong (*host_get_handle_size)(
		PF_Handle				pf_handle);

	PF_Err	(*iterate_origin_non_clip_src)(
		PF_InData				*in_data,
		A_long					progress_base,
		A_long					progress_final,
		PF_EffectWorld			*src,
		const PF_Rect			*area,
		const PF_Point			*origin,
		void*					refcon,
		PF_IteratePixel8Func	pix_fn,
		PF_EffectWorld			*dst);

	PF_Err (*iterate_generic)(
		A_long			iterationsL,						/* >> */		// can be PF_Iterations_ONCE_PER_PROCESSOR
		void			*refconPV,							/* >> */
		PF_Err			(*fn_func)(	void *refconPV,			/* >> */
									A_long thread_indexL,		// only call abort and progress from thread_indexL == 0.
									A_long i,
									A_long iterationsL));		// never sends PF_Iterations_ONCE_PER_PROCESSOR

	PF_Err (*host_resize_handle)(
		A_u_longlong		new_sizeL,		/* >> */
		PF_Handle			*handlePH);		/* <> Handle Value May Change */


	PF_Err (*subpixel_sample16)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Fixed		x,
		PF_Fixed		y,
		const PF_SampPB	*params,
		PF_Pixel16		*dst_pixel);

	PF_Err (*area_sample16)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Fixed		x,
		PF_Fixed		y,
		const PF_SampPB	*params,
		PF_Pixel16		*dst_pixel);

	PF_Err (*fill16)(
		PF_ProgPtr			effect_ref,		/* reference from in_data	*/
		const PF_Pixel16	*color,
		const PF_Rect		*dst_rect,		/* pass NULL for whole world */
		PF_EffectWorld		*world);

	PF_Err (*premultiply_color16)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_EffectWorld	*src,
		const PF_Pixel16 *color,			/* color to premultiply/unmultiply with */
		A_long			forward,		/* TRUE means convert non-premul to premul, FALSE mean reverse */
		PF_EffectWorld	*dst);

	PF_Err (*iterate16)(
		PF_InData				*in_data,
		A_long					progress_base,
		A_long					progress_final,
		PF_EffectWorld			*src,
		const PF_Rect			*area,			/* pass NULL for all pixels */
		void*					refcon,
		PF_IteratePixel16Func	pix_fn,
		PF_EffectWorld			*dst);
		
	PF_Err (*iterate_origin16)(
		PF_InData				*in_data,
		A_long					progress_base,
		A_long					progress_final,
		PF_EffectWorld			*src,
		const PF_Rect			*area,			/* pass NULL for all pixels */
		const PF_Point			*origin,
		void*					refcon,
		PF_IteratePixel16Func	pix_fn,
		PF_EffectWorld			*dst);

	PF_Err	(*iterate_origin_non_clip_src16)(
		PF_InData				*in_data,
		A_long					progress_base,
		A_long					progress_final,
		PF_EffectWorld				*src,
		const PF_Rect			*area,
		const PF_Point			*origin,
		void*				refcon,
		PF_IteratePixel16Func	pix_fn,
		PF_EffectWorld				*dst);

	PF_Err	(*get_pixel_data8)(
		PF_EffectWorld	*worldP,
		PF_PixelPtr		pixelsP0,		// NULL to use data in PF_EffectWorld
		PF_Pixel8		**pixPP);		// will return NULL if depth mismatch
		
	PF_Err	(*get_pixel_data16)(
		PF_EffectWorld	*worldP,
		PF_PixelPtr		pixelsP0,		// NULL to use data in PF_EffectWorld
		PF_Pixel16		**pixPP);		// will return NULL if depth mismatch
	
	
										// and we're done. all future expansion
										// is thru suite mechanism. (for example,
										// this is where you'll find the floating
										// pt pixel callbacks)	
	A_long				reserved[1];

} PF_UtilCallbacks;


/** ---------- Callback Access Macros ----------

	Each of these macros _ASSUMES_ that the (PF_InData *) parameter to
	the effects module was passed as a parameter named "in_data".  I know
	this is a heinous assumption, but the template code all declares the
	parameter like that, and by making that assumption, I can simplify
	all these macros very much.  If you absolutely need to change the
	name of that parameter, you will have to pick apart these macros and
	invoke the callbacks by yourself.  It's not too hard...

	For efficiency, most notably with the image resampling functions (i.e.
	subpixel_sample and area_sample), you may wish to declare a local function
	pointer and bypass these macros to avoid the multiple dereferences in
	your inner loop.  The sample code will show how to do this.

	The prototypes and comments about each function are given above in
	the PF_UtilCallbacks structure definition.

**/
#define PF_BEGIN_SAMPLING(QUALITY, PARAMS)	\
	(*in_data->utils->begin_sampling)(	\
		in_data->effect_ref, (QUALITY), PF_MF_Alpha_STRAIGHT, (PARAMS))

#define PF_SUBPIXEL_SAMPLE(X, Y, PARAMS, DST_PXL)	\
	(*in_data->utils->subpixel_sample)(	\
		in_data->effect_ref, (X), (Y), (PARAMS), (DST_PXL))

#define PF_AREA_SAMPLE(X, Y, PARAMS, DST_PXL)	\
	(*in_data->utils->area_sample)(	\
		in_data->effect_ref, (X), (Y), (PARAMS), (DST_PXL))

#define PF_END_SAMPLING(QUALITY, PARAMS)	\
	(*in_data->utils->end_sampling)(	\
		in_data->effect_ref, (QUALITY), PF_MF_Alpha_STRAIGHT, (PARAMS))

#define PF_BLEND(SRC1, SRC2, RATIO, DST)	\
	(*in_data->utils->blend)(	\
		in_data->effect_ref, (SRC1), (SRC2), (RATIO), (DST))

#define PF_CONVOLVE(SRC, RCT_P, FLAGS, KRNL_SZ, AK, RK, GK, BK, DST)	\
	(*in_data->utils->convolve)(	\
		in_data->effect_ref, (SRC), (RCT_P), (FLAGS), (KRNL_SZ), (AK), (RK), (GK), (BK), (DST))

#define PF_COPY(SRC, DST, SRC_RECT, DST_RECT)	\
	(*in_data->utils->copy)(	\
		in_data->effect_ref, (SRC), (DST), (SRC_RECT), (DST_RECT))

#define PF_FILL(COLOR, DST_RECT, DST)	\
	(*in_data->utils->fill)(	\
		in_data->effect_ref, (COLOR), (DST_RECT), (DST))

#define PF_GAUSSIAN_KERNEL(K_RAD, FLAGS, MULT, DIAM, KERNEL)	\
	(*in_data->utils->gaussian_kernel)(	\
		in_data->effect_ref, (K_RAD), (FLAGS), (MULT), (DIAM), (KERNEL))

#define PF_ITERATE(PROG_BASE, PROG_FINAL, SRC, RCT_P, REFCON, PIX_FUNC, DST)	\
	(*in_data->utils->iterate)(	\
		in_data, (PROG_BASE), (PROG_FINAL), (SRC), (RCT_P), (REFCON), (PIX_FUNC), (DST))

#define PF_ITERATE16(PROG_BASE, PROG_FINAL, SRC, RCT_P, REFCON, PIX_FUNC, DST)	\
	(*in_data->utils->iterate16)(	\
		in_data, (PROG_BASE), (PROG_FINAL), (SRC), (RCT_P), (REFCON), (PIX_FUNC), (DST))

#define PF_PREMUL(FORWARD, DST)	\
	(*in_data->utils->premultiply)(	\
		in_data->effect_ref, (FORWARD), (DST))

#define PF_PREMUL_COLOR(SRC, COLOR, FORWARD, DST)	\
	(*in_data->utils->premultiply_color)(	\
		in_data->effect_ref, (SRC), (COLOR), (FORWARD), (DST))

#define PF_NEW_WORLD(WIDTH, HEIGHT, FLAGS, WORLD)	\
	(*in_data->utils->new_world)(	\
		in_data->effect_ref, (WIDTH), (HEIGHT), (FLAGS), (WORLD))

#define PF_DISPOSE_WORLD(WORLD)	\
	(*in_data->utils->dispose_world)(	\
		in_data->effect_ref, (WORLD))

#define PF_ITERATE_ORIGIN(PROG_BASE, PROG_FINAL, SRC, RCT_P, OR, REFCON, PIX_FUNC, DST)	\
	(*in_data->utils->iterate_origin)(	\
		in_data, (PROG_BASE), (PROG_FINAL), (SRC), (RCT_P), (OR), (REFCON), (PIX_FUNC), (DST))
		
#define PF_ITERATE_ORIGIN16(PROG_BASE, PROG_FINAL, SRC, RCT_P, OR, REFCON, PIX_FUNC, DST)	\
	(*in_data->utils->iterate_origin16)(	\
		in_data, (PROG_BASE), (PROG_FINAL), (SRC), (RCT_P), (OR), (REFCON), (PIX_FUNC), (DST))

#define PF_ITERATE_LUT(PROG_BASE, PROG_FINAL, SRC, RCT_P, A_LUT, R_LUT, G_LUT, B_LUT, DST)	\
	(*in_data->utils->iterate_lut)(			\
		in_data, (PROG_BASE), (PROG_FINAL), (SRC), (RCT_P), (A_LUT), 	\
		(R_LUT), (G_LUT), (B_LUT), (DST))

#define PF_TRANSFER_RECT(QUALITY, M_FLAGS, FIELD, SRC_REC, SRC_WORLD, COMP_MODE,	\
						MASK_WORLD_0, DST_X, DST_Y, DST)	\
	(*in_data->utils->transfer_rect)(			\
		in_data->effect_ref, (QUALITY), (M_FLAGS), (FIELD), (SRC_REC), (SRC_WORLD), 	\
		(COMP_MODE), (MASK_WORLD_0), (DST_X), (DST_Y), (DST))

#define PF_TRANSFORM_WORLD(QUALITY, M_FLAGS, FIELD, SRC_WORLD, COMP_MODE,	\
						MASK_WORLD_0, MATRICES, NUM_MATRICES, SRC2DST_MATRIX,	\
						DST_RECT, DST)	\
	(*in_data->utils->transform_world)(			\
		in_data->effect_ref, (QUALITY), (M_FLAGS), (FIELD), (SRC_WORLD), 	\
		(COMP_MODE), (MASK_WORLD_0), (MATRICES), (NUM_MATRICES), (SRC2DST_MATRIX),	\
		(DST_RECT), (DST))

#define PF_ITERATE_ORIGIN_NON_SRC_CLIP(PROG_BASE, PROG_FINAL, SRC, RCT_P, OR, REFCON, PIX_FUNC, DST)	\
	(*in_data->utils->iterate_origin_non_clip_src)(	\
		in_data, (PROG_BASE), (PROG_FINAL), (SRC), (RCT_P), (OR), (REFCON), (PIX_FUNC), (DST))


#define PF_NEW_HANDLE(SIZE) \
    (*in_data->utils->host_new_handle)((SIZE))

#define PF_DISPOSE_HANDLE(PF_HANDLE) \
    (*in_data->utils->host_dispose_handle)((PF_Handle)(PF_HANDLE))

#define PF_LOCK_HANDLE(PF_HANDLE) \
    (*in_data->utils->host_lock_handle)((PF_Handle)(PF_HANDLE))

#define PF_UNLOCK_HANDLE(PF_HANDLE) \
    (*in_data->utils->host_unlock_handle)((PF_Handle)(PF_HANDLE))

#define PF_GET_HANDLE_SIZE(PF_HANDLE) \
    (*in_data->utils->host_get_handle_size)((PF_Handle)(PF_HANDLE))


// Takes a pointer to a handle.  Handle may change.  4.1 and later ONLY.
#define PF_RESIZE_HANDLE(NEW_SIZE, PF_HANDLE_P) \
	(*in_data->utils->host_resize_handle)((NEW_SIZE), (PF_Handle*)(PF_HANDLE_P))



#define PF_GET_PLATFORM_DATA(ID, DATA) \
	(*in_data->utils->get_platform_data)(in_data->effect_ref, (ID), (DATA))

#define PF_GET_PIXEL_DATA8(WORLDP, PIXELPTR0, PIXEL8PP) \
	(*frameH->utils->get_pixel_data8)((WORLDP), (PIXELPTR0), (PIXEL8PP))

#define PF_GET_PIXEL_DATA16(WORLDP, PIXELPTR0, PIXEL16PP) \
	(*in_data->utils->get_pixel_data16)((WORLDP), (PIXELPTR0), (PIXEL16PP))




#define PF_ACOS(X)		(*in_data->utils->ansi.acos)(X)
#define PF_ASIN(X)		(*in_data->utils->ansi.asin)(X)
#define PF_ATAN(X)		(*in_data->utils->ansi.atan)(X)
#define PF_ATAN2(Y, X)	(*in_data->utils->ansi.atan2)((Y), (X))
#define PF_CEIL(X)		(*in_data->utils->ansi.ceil)(X)
#define PF_COS(X)		(*in_data->utils->ansi.cos)(X)
#define PF_EXP(X)		(*in_data->utils->ansi.exp)(X)
#define PF_FABS(X)		(*in_data->utils->ansi.fabs)(X)
#define PF_FLOOR(X)		(*in_data->utils->ansi.floor)(X)
#define PF_FMOD(X, Y)	(*in_data->utils->ansi.fmod)((X), (Y))
#define PF_HYPOT(X, Y)	(*in_data->utils->ansi.hypot)((X), (Y))
#define PF_LOG(X)		(*in_data->utils->ansi.log)(X)
#define PF_LOG10(X)		(*in_data->utils->ansi.log10)(X)
#define PF_POW(X, Y)	(*in_data->utils->ansi.pow)((X), (Y))
#define PF_SIN(X)		(*in_data->utils->ansi.sin)(X)
#define PF_SQRT(X)		(*in_data->utils->ansi.sqrt)(X)
#define PF_TAN(X)		(*in_data->utils->ansi.tan)(X)

/* This is kind of a hack to deal with the varargs params to sprintf */

#define PF_SPRINTF		(*in_data->utils->ansi.sprintf)

#define	PF_STRCPY(DST, SRC)	\
		(*in_data->utils->ansi.strcpy)((DST), (SRC))
		

		
#define PF_RGB_TO_HLS(RGB, HLS) \
	(*in_data->utils->colorCB.RGBtoHLS)(in_data->effect_ref, (RGB), (HLS))
	
#define PF_HLS_TO_RGB(HLS, RGB) \
	(*in_data->utils->colorCB.HLStoRGB)(in_data->effect_ref, (HLS), (RGB))
	
#define PF_RGB_TO_YIQ(RGB, YIQ) \
	(*in_data->utils->colorCB.RGBtoYIQ)(in_data->effect_ref, (RGB), (YIQ))
	
#define PF_YIQ_TO_RGB(YIQ, RGB) \
	(*in_data->utils->colorCB.YIQtoRGB)(in_data->effect_ref, (YIQ), (RGB))
	
#define PF_LUMINANCE(RGB, LUM100) \
	(*in_data->utils->colorCB.Luminance)(in_data->effect_ref, (RGB), (LUM100))
	
#define PF_HUE(RGB, HUE) \
	(*in_data->utils->colorCB.Hue)(in_data->effect_ref, (RGB), (HUE))

#define PF_LIGHTNESS(RGB, LIGHTNESS) \
	(*in_data->utils->colorCB.Lightness)(in_data->effect_ref, (RGB), (LIGHTNESS))
	
#define PF_SATURATION(RGB, SATURATION) \
	(*in_data->utils->colorCB.Saturation)(in_data->effect_ref, (RGB), (SATURATION))
	

	

#ifdef __cplusplus
	}		// end extern "C"
#endif



#include <adobesdk/config/PostConfig.h>


#endif /* _H_AE_EffectCB */

```

---

<h2>Begin File: AE_EffectCBSuites.h</h2>

```cpp
/*******************************************************************/
/*                                                                 */
/*                      ADOBE CONFIDENTIAL                         */
/*                   _ _ _ _ _ _ _ _ _ _ _ _ _                     */
/*                                                                 */
/* Copyright 2007 Adobe Systems Incorporated                       */
/* All Rights Reserved.                                            */
/*                                                                 */
/* NOTICE:  All information contained herein is, and remains the   */
/* property of Adobe Systems Incorporated and its suppliers, if    */
/* any.  The intellectual and technical concepts contained         */
/* herein are proprietary to Adobe Systems Incorporated and its    */
/* suppliers and may be covered by U.S. and Foreign Patents,       */
/* patents in process, and are protected by trade secret or        */
/* copyright law.  Dissemination of this information or            */
/* reproduction of this material is strictly forbidden unless      */
/* prior written permission is obtained from Adobe Systems         */
/* Incorporated.                                                   */
/*                                                                 */
/*******************************************************************/


#ifndef _H_AE_EffectCBSuites
#define _H_AE_EffectCBSuites


#include <AE_EffectCB.h>
#include <AE_EffectPixelFormat.h>
#include <SPBasic.h>

#include <adobesdk/config/PreConfig.h>

#ifdef __cplusplus
	extern "C" {
#endif

// note: many of these suites are not SPAPI because they are shared with the
// old-style PF_UtilCallback definitions and we want calls to them to
// be object compatible

#define kPFHandleSuite			"PF Handle Suite"
#define kPFHandleSuiteVersion1	2	/* frozen in AE 10.0 */

//Keeping the same version for compatibility reasons but bumping the actual value for 64-bit SDK. Please define A_HandleSize
//as A_u_long to get the same suite working with 32-bit SDK.

typedef struct PF_HandleSuite1 {
	PF_Handle (*host_new_handle)(
		A_HandleSize			size);

	void * (*host_lock_handle)(
		PF_Handle				pf_handle);

	void (*host_unlock_handle)(
		PF_Handle				pf_handle);

	void (*host_dispose_handle)(
		PF_Handle				pf_handle);

	A_HandleSize (*host_get_handle_size)(
		PF_Handle				pf_handle);

	PF_Err (*host_resize_handle)(
		A_HandleSize			new_sizeL,		/* >> */
		PF_Handle				*handlePH);		/* <> Handle Value May Change */
	
} PF_HandleSuite1;


#define kPFANSISuite			"PF ANSI Suite"
#define kPFANSISuiteVersion1	1	/* frozen in AE 5.0 */

typedef struct PF_ANSICallbacksSuite1 {
		A_FpLong	(*atan)(A_FpLong);
		A_FpLong	(*atan2)(A_FpLong y, A_FpLong x);	/* returns atan(y/x) - note param order! */
		A_FpLong	(*ceil)(A_FpLong);				/* returns next int above x */
		A_FpLong	(*cos)(A_FpLong);
		A_FpLong	(*exp)(A_FpLong);					/* returns e to the x power */
		A_FpLong	(*fabs)(A_FpLong);				/* returns absolute value of x */
		A_FpLong	(*floor)(A_FpLong);				/* returns closest int below x */
		A_FpLong	(*fmod)(A_FpLong x, A_FpLong y);	/* returns x mod y */
		A_FpLong	(*hypot)(A_FpLong x, A_FpLong y);	/* returns sqrt(x*x + y*y) */
		A_FpLong	(*log)(A_FpLong);					/* returns natural log of x */
		A_FpLong	(*log10)(A_FpLong);				/* returns log base 10 of x */
		A_FpLong	(*pow)(A_FpLong x, A_FpLong y);		/* returns x to the y power */
		A_FpLong	(*sin)(A_FpLong);
		A_FpLong	(*sqrt)(A_FpLong);
		A_FpLong	(*tan)(A_FpLong);

		int		(*sprintf)(A_char *, const A_char *, ...);
		A_char *	(*strcpy)(A_char *, const A_char *);

		A_FpLong (*asin)(A_FpLong);
		A_FpLong (*acos)(A_FpLong);
	
} PF_ANSICallbacksSuite1;


#define kPFPixelDataSuite				"PF Pixel Data Suite"
#define kPFPixelDataSuiteVersion1	1	/* frozen in AE 7.0 */	

typedef struct PF_PixelDataSuite1 {

	PF_Err	(*get_pixel_data8)(
		PF_EffectWorld	*worldP,
		PF_PixelPtr		pixelsP0,		// NULL to use data in PF_EffectWorld
		PF_Pixel8		**pixPP);		// will return NULL if depth mismatch
		
	PF_Err	(*get_pixel_data16)(
		PF_EffectWorld	*worldP,
		PF_PixelPtr		pixelsP0,		// NULL to use data in PF_EffectWorld
		PF_Pixel16		**pixPP);		// will return NULL if depth mismatch
	
	PF_Err	(*get_pixel_data_float)(
		PF_EffectWorld	*worldP,
		PF_PixelPtr		pixelsP0,		// NULL to use data in PF_EffectWorld
		PF_PixelFloat	**pixPP);		// will return NULL if depth mismatch
	
	
} PF_PixelDataSuite1;
		

#define kPFPixelDataSuiteVersion2	2	/* frozen in AE 16.0 */
		
typedef struct PF_PixelDataSuite2 {
	
	PF_Err	(*get_pixel_data8)(
		PF_EffectWorld	*worldP,
		PF_PixelPtr		pixelsP0,		// NULL to use data in PF_EffectWorld
		PF_Pixel8		**pixPP);		// will return NULL if depth mismatch
	
	PF_Err	(*get_pixel_data16)(
		PF_EffectWorld	*worldP,
		PF_PixelPtr		pixelsP0,		// NULL to use data in PF_EffectWorld
		PF_Pixel16		**pixPP);		// will return NULL if depth mismatch
	
	PF_Err	(*get_pixel_data_float)(
		PF_EffectWorld	*worldP,
		PF_PixelPtr		pixelsP0,		// NULL to use data in PF_EffectWorld
		PF_PixelFloat	**pixPP);		// will return NULL if depth mismatch
	
	PF_Err	(*get_pixel_data_float_gpu)(
		PF_EffectWorld	*worldP,
		void			**pixPP);		// will return NULL if depth mismatch
		
} PF_PixelDataSuite2;


#define kPFColorCallbacksSuite			"PF Color Suite"
#define kPFColorCallbacksSuiteVersion1	1	/* frozen in AE 5.0 */	


typedef struct PF_ColorCallbacksSuite1 {
		PF_Err (*RGBtoHLS)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Pixel		*rgb,
		PF_HLS_Pixel	hls);

		PF_Err (*HLStoRGB)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_HLS_Pixel	hls,
		PF_Pixel		*rgb);
		
		PF_Err (*RGBtoYIQ)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Pixel		*rgb,
		PF_YIQ_Pixel	yiq);

		PF_Err (*YIQtoRGB)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_HLS_Pixel	yiq,
		PF_Pixel		*rgb);
		
		PF_Err (*Luminance)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Pixel		*rgb,
		A_long			*lum100);		/* << 100 * luminance */
		
		PF_Err (*Hue)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Pixel		*rgb,
		A_long			*hue);			/* << 0-255 maps to 0-360  */
		
		PF_Err (*Lightness)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Pixel		*rgb,
		A_long			*lightness);		/* <<  goes from 0-255 */
		
		PF_Err (*Saturation)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Pixel		*rgb,
		A_long			*saturation);		/* <<  goes from 0-255 */
		
} PF_ColorCallbacksSuite1;

#define kPFColorCallbacks16Suite			"PF Color16 Suite"
#define kPFColorCallbacks16SuiteVersion1	1	/* frozen in AE 5.0 */	


typedef struct PF_ColorCallbacks16Suite1 {
		PF_Err (*RGBtoHLS)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Pixel16		*rgb,
		PF_HLS_Pixel	hls);

		PF_Err (*HLStoRGB)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_HLS_Pixel	hls,
		PF_Pixel16		*rgb);
		
		PF_Err (*RGBtoYIQ)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Pixel16		*rgb,
		PF_YIQ_Pixel	yiq);

		PF_Err (*YIQtoRGB)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_HLS_Pixel	yiq,
		PF_Pixel16		*rgb);
		
		PF_Err (*Luminance)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Pixel16		*rgb,
		A_long			*lum100);		/* << 100 * luminance */
		
		PF_Err (*Hue)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Pixel16		*rgb,
		A_long			*hue);			/* << 0-255 maps to 0-360  */
		
		PF_Err (*Lightness)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Pixel16		*rgb,
		A_long			*lightness);		/* <<  goes from 0-32768 */
		
		PF_Err (*Saturation)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Pixel16		*rgb,
		A_long			*saturation);		/* <<  goes from 0-32768 */
		
} PF_ColorCallbacks16Suite1;




#define kPFColorCallbacksFloatSuite				"PF ColorFloat Suite"
#define kPFColorCallbacksFloatSuiteVersion1	1	/* frozen in AE 7.0 */	


typedef struct PF_ColorCallbacksFloatSuite1 {
		PF_Err (*RGBtoHLS)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_PixelFloat		*rgb,
		PF_HLS_Pixel		hls);

		PF_Err (*HLStoRGB)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_HLS_Pixel	hls,
		PF_PixelFloat	*rgb);
		
		PF_Err (*RGBtoYIQ)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_PixelFloat	*rgb,
		PF_YIQ_Pixel	yiq);

		PF_Err (*YIQtoRGB)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_HLS_Pixel	yiq,
		PF_PixelFloat	*rgb);
		
		PF_Err (*Luminance)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_PixelFloat	*rgb,
		float			*lumP);		/* <<  luminance -- note *not* 100*lum */
		
		PF_Err (*Hue)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_PixelFloat	*rgb,
		float			*hue);			/* 0..360 float  */
		
		PF_Err (*Lightness)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_PixelFloat	*rgb,
		float			*lightness);		/* <<  */
		
		PF_Err (*Saturation)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_PixelFloat	*rgb,
		float			*saturation);		/* <<  */
		
} PF_ColorCallbacksFloatSuite1;



#define kPFBatchSamplingSuite			"PF Batch Sampling Suite"
#define kPFBatchSamplingSuiteVersion1	1	/* frozen in AE 5.0 */	


typedef struct PF_BatchSamplingSuite1 {
	 PF_Err (*begin_sampling)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Quality		qual,
		PF_ModeFlags	mf,
		PF_SampPB		*params);
		
	 PF_Err (*end_sampling)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Quality		qual,
		PF_ModeFlags	mf,
		PF_SampPB		*params);
		
	 PF_Err (*get_batch_func)(
		PF_ProgPtr			effect_ref,		/* reference from in_data */
		PF_Quality			quality,
		PF_ModeFlags		mode_flags,
		const PF_SampPB		*params,
		PF_BatchSampleFunc	*batch);

	 PF_Err (*get_batch_func16)(
		PF_ProgPtr				effect_ref,		/* reference from in_data */
		PF_Quality				quality,
		PF_ModeFlags			mode_flags,
		const PF_SampPB			*params,
		PF_BatchSample16Func	*batch);
		
} PF_BatchSamplingSuite1;


#define kPFSampling8Suite			"PF Sampling8 Suite"
#define kPFSampling8SuiteVersion1	1	/* frozen in AE 5.0 */	

typedef struct PF_Sampling8Suite1 {

	 PF_Err (*nn_sample)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Fixed		x,
		PF_Fixed		y,
		const PF_SampPB	*params,
		PF_Pixel		*dst_pixel);

	 PF_Err (*subpixel_sample)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Fixed		x,
		PF_Fixed		y,
		const PF_SampPB	*params,
		PF_Pixel		*dst_pixel);

	 PF_Err (*area_sample)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Fixed		x,
		PF_Fixed		y,
		const PF_SampPB	*params,
		PF_Pixel		*dst_pixel);
		

} PF_Sampling8Suite1;

#define kPFSampling16Suite			"PF Sampling16 Suite"
#define kPFSampling16SuiteVersion1	1	/* frozen in AE 5.0 */	


typedef struct PF_Sampling16Suite1 {

	 PF_Err (*nn_sample16)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Fixed		x,
		PF_Fixed		y,
		const PF_SampPB	*params,
		PF_Pixel16		*dst_pixel);
		
	 PF_Err (*subpixel_sample16)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Fixed		x,
		PF_Fixed		y,
		const PF_SampPB	*params,
		PF_Pixel16		*dst_pixel);

	 PF_Err (*area_sample16)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Fixed		x,
		PF_Fixed		y,
		const PF_SampPB	*params,
		PF_Pixel16		*dst_pixel);
		
} PF_Sampling16Suite1;


#define kPFSamplingFloatSuite			"PF SamplingFloat Suite"
#define kPFSamplingFloatSuiteVersion1	1	/* frozen in AE 7.0 */	


typedef struct PF_SamplingFloatSuite1 {

	 PF_Err (*nn_sample_float)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Fixed		x,
		PF_Fixed		y,
		const PF_SampPB	*params,
		PF_PixelFloat	*dst_pixel);
		
	 PF_Err (*subpixel_sample_float)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Fixed		x,
		PF_Fixed		y,
		const PF_SampPB	*params,
		PF_PixelFloat	*dst_pixel);

	 PF_Err (*area_sample_float)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_Fixed		x,
		PF_Fixed		y,
		const PF_SampPB	*params,
		PF_PixelFloat	*dst_pixel);
		
} PF_SamplingFloatSuite1;




#define kPFWorldSuite				"PF World Suite"
#define kPFWorldSuiteVersion2	2	/* frozen in AE 7.0 */	


typedef struct PF_WorldSuite2 {

	PF_Err (*PF_NewWorld)(
		PF_ProgPtr			effect_ref,				/* reference from in_data */
		A_long				widthL,
		A_long				heightL,
		PF_Boolean			clear_pixB,
		PF_PixelFormat		pixel_format,
		PF_EffectWorld		*worldP);		

	PF_Err (*PF_DisposeWorld)(
		PF_ProgPtr			effect_ref,				/* reference from in_data */
		PF_EffectWorld		*worldP);


	PF_Err (*PF_GetPixelFormat)(
		const PF_EffectWorld		*worldP,				/* the pixel buffer of interest */
		PF_PixelFormat				*pixel_formatP);		/* << OUT. one of the above PF_PixelFormat types */


} PF_WorldSuite2;





#define kPFPixelFormatSuite			"PF Pixel Format Suite"
#define kPFPixelFormatSuiteVersion2	2


// call during global setup

typedef struct PF_PixelFormatSuite2 {

	PF_Err	(*PF_AddSupportedPixelFormat)(
						PF_ProgPtr			effect_ref,					/* reference from in_data */
						PF_PixelFormat		pixel_format);				/* add a supported pixel format */


	PF_Err	(*PF_ClearSupportedPixelFormats)(
						PF_ProgPtr			effect_ref);				/* reference from in_data */

} PF_PixelFormatSuite2;





#define kPFWorldSuite			"PF World Suite"
#define kPFWorldSuiteVersion1	1	/* frozen in AE 5.0 */	


typedef struct PF_WorldSuite1 {

	 PF_Err (*new_world)(
		PF_ProgPtr			effect_ref,		/* reference from in_data */
		A_long				width,
		A_long				height,
		PF_NewWorldFlags	flags,			/* should would be pre-cleared to zeroes */
		PF_EffectWorld		*world);		/* always 32 bit */

	 PF_Err (*dispose_world)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_EffectWorld	*world);


} PF_WorldSuite1;



#define kPFIterate8Suite			"PF Iterate8 Suite"
#define kPFIterate8SuiteVersion1	1	/* frozen in AE 5.0 */	


typedef struct PF_Iterate8Suite1 {
	 PF_Err (*iterate)(
		PF_InData		*in_data,
		A_long			progress_base,
		A_long			progress_final,
		PF_EffectWorld	*src,
		const PF_Rect	*area,			/* pass NULL for all pixels */
		void*		refcon,
		 PF_Err			(*pix_fn)(void* refcon, A_long x, A_long y, PF_Pixel *in, PF_Pixel *out),
		PF_EffectWorld	*dst);


	 PF_Err (*iterate_origin)(
		PF_InData		*in_data,
		A_long			progress_base,
		A_long			progress_final,
		PF_EffectWorld	*src,
		const PF_Rect	*area,			/* pass NULL for all pixels */
		const PF_Point	*origin,
		void*		refcon,
		 PF_Err			(*pix_fn)(void* refcon, A_long x, A_long y, PF_Pixel *in, PF_Pixel *out),
		PF_EffectWorld	*dst);

	 PF_Err (*iterate_lut)(
		PF_InData		*in_data,
		A_long			progress_base,
		A_long			progress_final,
		PF_EffectWorld	*src,
		const PF_Rect	*area,			/* pass NULL for all pixels */
		A_u_char	*a_lut0,		/* pass NULL for identity */
		A_u_char	*r_lut0,		/* pass NULL for identity */
		A_u_char	*g_lut0,		/* pass NULL for identity */
		A_u_char	*b_lut0,		/* pass NULL for identity */
		PF_EffectWorld	*dst);

	 PF_Err	(*iterate_origin_non_clip_src)(
		PF_InData		*in_data,
		A_long			progress_base,
		A_long			progress_final,
		PF_EffectWorld	*src,
		const PF_Rect	*area,
		const PF_Point	*origin,
		void*		refcon,
		PF_Err	(*pix_fn)(void* refcon, A_long x, A_long y, PF_Pixel *in, PF_Pixel *out),
		PF_EffectWorld	*dst);

	 PF_Err (*iterate_generic)(
		A_long			iterationsL,						/* >> */		// can be PF_Iterations_ONCE_PER_PROCESSOR
		void			*refconPV,							/* >> */
		PF_Err			(*fn_func)(	void *refconPV,			/* >> */
									A_long thread_indexL,		// only call abort and progress from thread_indexL == 0.
									A_long i,
									A_long iterationsL));		// never sends PF_Iterations_ONCE_PER_PROCESSOR

} PF_Iterate8Suite1;

#define kPFIterate8SuiteVersion2	2	/* frozen in AE 22.0 */	

typedef struct PF_Iterate8Suite2 {
	PF_Err(*iterate)(
		PF_InData		*in_data,
		A_long			progress_base,
		A_long			progress_final,
		PF_EffectWorld	*src,
		const PF_Rect	*area,			/* pass NULL for all pixels */
		void			*refcon,
		PF_Err(*pix_fn)(void* refcon, A_long x, A_long y, PF_Pixel* in, PF_Pixel* out),
		PF_EffectWorld	*dst);


	PF_Err(*iterate_origin)(
		PF_InData		*in_data,
		A_long			progress_base,
		A_long			progress_final,
		PF_EffectWorld	*src,
		const PF_Rect	*area,			/* pass NULL for all pixels */
		const PF_Point	*origin,
		void			*refcon,
		PF_Err(*pix_fn)(void* refcon, A_long x, A_long y, PF_Pixel* in, PF_Pixel* out),
		PF_EffectWorld	*dst);

	PF_Err(*iterate_lut)(
		PF_InData		*in_data,
		A_long			progress_base,
		A_long			progress_final,
		PF_EffectWorld	*src,
		const PF_Rect	*area,			/* pass NULL for all pixels */
		A_u_char		*a_lut0,		/* pass NULL for identity */
		A_u_char		*r_lut0,		/* pass NULL for identity */
		A_u_char		*g_lut0,		/* pass NULL for identity */
		A_u_char		*b_lut0,		/* pass NULL for identity */
		PF_EffectWorld	*dst);

	PF_Err(*iterate_origin_non_clip_src)(
		PF_InData		*in_data,
		A_long			progress_base,
		A_long			progress_final,
		PF_EffectWorld	*src,
		const PF_Rect	*area,
		const PF_Point	*origin,
		void			*refcon,
		PF_Err(*pix_fn)(void* refcon, A_long x, A_long y, PF_Pixel* in, PF_Pixel* out),
		PF_EffectWorld	*dst);

	PF_Err(*iterate_generic)(
		A_long			iterationsL,	/* >> */		// can be PF_Iterations_ONCE_PER_PROCESSOR
		void			*refconPV,		/* >> */
		PF_Err(*fn_func)(
			void	*refconPV,			/* >> */
			A_long	thread_indexL,		// only call abort and progress from thread_indexL == 0.
			A_long	i,
			A_long	iterationsL));		// never sends PF_Iterations_ONCE_PER_PROCESSOR

} PF_Iterate8Suite2;

#define kPFIterate16Suite			"PF iterate16 Suite"
#define kPFIterate16SuiteVersion1	1	/* frozen in AE 5.0 */	


typedef struct PF_iterate16Suite1 {
	 PF_Err (*iterate)(
		PF_InData		*in_data,
		A_long			progress_base,
		A_long			progress_final,
		PF_EffectWorld	*src,
		const PF_Rect	*area,			/* pass NULL for all pixels */
		void*		refcon,
		 PF_Err			(*pix_fn)(void* refcon, A_long x, A_long y, PF_Pixel16 *in, PF_Pixel16 *out),
		PF_EffectWorld	*dst);


	 PF_Err (*iterate_origin)(
		PF_InData		*in_data,
		A_long			progress_base,
		A_long			progress_final,
		PF_EffectWorld	*src,
		const PF_Rect	*area,			/* pass NULL for all pixels */
		const PF_Point	*origin,
		void*			refcon,
		 PF_Err			(*pix_fn)(void* refcon, A_long x, A_long y, PF_Pixel16 *in, PF_Pixel16 *out),
		PF_EffectWorld	*dst);

	 PF_Err	(*iterate_origin_non_clip_src)(
		PF_InData		*in_data,
		A_long			progress_base,
		A_long			progress_final,
		PF_EffectWorld	*src,
		const PF_Rect	*area,
		const PF_Point	*origin,
		void*		refcon,
		PF_Err	(*pix_fn)(void* refcon, A_long x, A_long y, PF_Pixel16 *in, PF_Pixel16 *out),
		PF_EffectWorld	*dst);
		
} PF_Iterate16Suite1;

#define kPFIterate16SuiteVersion2	2	/* frozen in AE 22.0 */	

typedef struct PF_iterate16Suite2 {
	PF_Err(*iterate)(
		PF_InData		*in_data,
		A_long			progress_base,
		A_long			progress_final,
		PF_EffectWorld	*src,
		const PF_Rect	*area,			/* pass NULL for all pixels */
		void			*refcon,
		PF_Err(*pix_fn)(void* refcon, A_long x, A_long y, PF_Pixel16* in, PF_Pixel16* out),
		PF_EffectWorld	*dst);


	PF_Err(*iterate_origin)(
		PF_InData		*in_data,
		A_long			progress_base,
		A_long			progress_final,
		PF_EffectWorld	*src,
		const PF_Rect	*area,			/* pass NULL for all pixels */
		const PF_Point	*origin,
		void			*refcon,
		PF_Err(*pix_fn)(void* refcon, A_long x, A_long y, PF_Pixel16* in, PF_Pixel16* out),
		PF_EffectWorld	*dst);

	PF_Err(*iterate_origin_non_clip_src)(
		PF_InData		*in_data,
		A_long			progress_base,
		A_long			progress_final,
		PF_EffectWorld	*src,
		const PF_Rect	*area,
		const PF_Point	*origin,
		void			*refcon,
		PF_Err(*pix_fn)(void* refcon, A_long x, A_long y, PF_Pixel16* in, PF_Pixel16* out),
		PF_EffectWorld	*dst);

} PF_Iterate16Suite2;

#define kPFIterateFloatSuite			"PF iterateFloat Suite"
#define kPFIterateFloatSuiteVersion1	1	/* frozen in AE 7.0 */	


typedef struct PF_iterateFloatSuite1 {
	 PF_Err (*iterate)(
		PF_InData		*in_data,
		A_long			progress_base,
		A_long			progress_final,
		PF_EffectWorld	*src,
		const PF_Rect	*area,			/* pass NULL for all pixels */
		void*		refcon,
		PF_IteratePixelFloatFunc			pix_fn,
		PF_EffectWorld	*dst);


	 PF_Err (*iterate_origin)(
		PF_InData		*in_data,
		A_long			progress_base,
		A_long			progress_final,
		PF_EffectWorld	*src,
		const PF_Rect	*area,			/* pass NULL for all pixels */
		const PF_Point	*origin,
		void*		refcon,
		PF_IteratePixelFloatFunc			pix_fn,
		PF_EffectWorld	*dst);

	 PF_Err	(*iterate_origin_non_clip_src)(
		PF_InData		*in_data,
		A_long			progress_base,
		A_long			progress_final,
		PF_EffectWorld	*src,
		const PF_Rect	*area,
		const PF_Point	*origin,
		void*		refcon,
		PF_IteratePixelFloatFunc			pix_fn,
		PF_EffectWorld	*dst);
		
} PF_IterateFloatSuite1;

#define kPFIterateFloatSuiteVersion2	2	/* frozen in AE 22.0 */	

typedef struct PF_iterateFloatSuite2 {
	 PF_Err (*iterate)(
		PF_InData					*in_data,
		A_long						progress_base,
		A_long						progress_final,
		PF_EffectWorld				*src,
		const PF_Rect				*area,			/* pass NULL for all pixels */
		void*						refcon,
		PF_IteratePixelFloatFunc	pix_fn,
		PF_EffectWorld				*dst);


	 PF_Err (*iterate_origin)(
		PF_InData					*in_data,
		A_long						progress_base,
		A_long						progress_final,
		PF_EffectWorld				*src,
		const PF_Rect				*area,			/* pass NULL for all pixels */
		const PF_Point				*origin,
		void*						refcon,
		PF_IteratePixelFloatFunc	pix_fn,
		PF_EffectWorld				*dst);

	 PF_Err	(*iterate_origin_non_clip_src)(
		PF_InData					*in_data,
		A_long						progress_base,
		A_long						progress_final,
		PF_EffectWorld				*src,
		const PF_Rect				*area,
		const PF_Point				*origin,
		void*						refcon,
		PF_IteratePixelFloatFunc	pix_fn,
		PF_EffectWorld				*dst);
		
} PF_IterateFloatSuite2;

#define kPFWorldTransformSuite			"PF World Transform Suite"
#define kPFWorldTransformSuiteVersion1	1	/* frozen in AE 5.0 */	

typedef struct PF_WorldTransformSuite1 {

	 PF_Err (*composite_rect)(
		PF_ProgPtr		effect_ref,		/* from in_data */
		PF_Rect			*src_rect,		/* rectangle in source image */
		A_long			src_opacity,	/* opacity of src */
		PF_EffectWorld	*source_wld,	/* src PF world */
		A_long			dest_x,			/* upper left-hand corner of src rect...*/
		A_long			dest_y,			/* ... in composite image */
		PF_Field		field_rdr,		/* which scanlines to render (all, upper, lower) */
		PF_XferMode		xfer_mode,		/* Copy, Composite Behind, Composite In Front */
		PF_EffectWorld	*dest_wld);		/* Destination buffer. Already filled */

	 PF_Err (*blend)(
		PF_ProgPtr				effect_ref,		/* reference from in_data */
		const PF_EffectWorld	*src1,
		const PF_EffectWorld	*src2,
		PF_Fixed				ratio,			/* 0 == full src1, 0x00010000 == full src2 */
		PF_EffectWorld			*dst);

	 PF_Err (*convolve)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_EffectWorld	*src,
		const PF_Rect	*area,			/* pass NULL for all pixels */
		PF_KernelFlags	flags,
		A_long			kernel_size,
		void			*a_kernel,
		void			*r_kernel,
		void			*g_kernel,
		void			*b_kernel,
		PF_EffectWorld	*dst);

	 PF_Err (*copy)(
		PF_ProgPtr		effect_ref,		/* reference from in_data	*/
		PF_EffectWorld	*src,
		PF_EffectWorld	*dst,
		PF_Rect 		*src_r,			/* pass NULL for whole world */
		PF_Rect			*dst_r);		/* pass NULL for whole world */

	 PF_Err (*copy_hq)(
		PF_ProgPtr		effect_ref,		/* reference from in_data	*/
		PF_EffectWorld	*src,
		PF_EffectWorld	*dst,
		PF_Rect 		*src_r,			/* pass NULL for whole world */
		PF_Rect			*dst_r);		/* pass NULL for whole world */


	 PF_Err	(*transfer_rect)(
		PF_ProgPtr				effect_ref,
		PF_Quality				quality,
		PF_ModeFlags			m_flags,
		PF_Field				field,
		const PF_Rect			*src_rec,
		const PF_EffectWorld	*src_world,
		const PF_CompositeMode	*comp_mode,
		const PF_MaskWorld		*mask_world0,
		A_long					dest_x,
		A_long					dest_y,
		PF_EffectWorld			*dst_world);

	 PF_Err	(*transform_world)(
		PF_ProgPtr				effect_ref,
		PF_Quality				quality,
		PF_ModeFlags			m_flags,
		PF_Field				field,
		const PF_EffectWorld	*src_world,
		const PF_CompositeMode	*comp_mode,
		const PF_MaskWorld		*mask_world0,
		const PF_FloatMatrix	*matrices,
		A_long					num_matrices,
		PF_Boolean				src2dst_matrix,
		const PF_Rect			*dest_rect,
		PF_EffectWorld			*dst_world);


} PF_WorldTransformSuite1;


#define kPFFillMatteSuite			"PF Fill Matte Suite"


#define kPFFillMatteSuiteVersion2	2	/* frozen in AE 7.0 */	
typedef struct PF_FillMatteSuite2 {

	 PF_Err (*fill)(
		PF_ProgPtr		effect_ref,		/* reference from in_data	*/
		const PF_Pixel	*color,
		const PF_Rect	*dst_rect,		/* pass NULL for whole world */
		PF_EffectWorld	*world);

	 PF_Err (*fill16)(
		PF_ProgPtr			effect_ref,		/* reference from in_data	*/
		const PF_Pixel16	*color,
		const PF_Rect		*dst_rect,		/* pass NULL for whole world */
		PF_EffectWorld		*world);

	 PF_Err (*fill_float)(
		PF_ProgPtr			effect_ref,		/* reference from in_data	*/
		const PF_PixelFloat	*color,
		const PF_Rect		*dst_rect,		/* pass NULL for whole world */
		PF_EffectWorld		*world);

	 PF_Err (*premultiply)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		A_long			forward,		/* TRUE means convert non-premul to premul, FALSE mean reverse */
		PF_EffectWorld	*dst);
		
	 PF_Err (*premultiply_color)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_EffectWorld	*src,
		const PF_Pixel	*color,			/* color to premultiply/unmultiply with */
		A_long			forward,		/* TRUE means convert non-premul to premul, FALSE mean reverse */
		PF_EffectWorld	*dst);
		
	 PF_Err (*premultiply_color16)(
		PF_ProgPtr		effect_ref,		/* reference from in_data */
		PF_EffectWorld	*src,
		const PF_Pixel16 *color,			/* color to premultiply/unmultiply with */
		A_long			forward,		/* TRUE means convert non-premul to premul, FALSE mean reverse */
		PF_EffectWorld	*dst);

	 PF_Err (*premultiply_color_float)(
		PF_ProgPtr			effect_ref,		/* reference from in_data */
		PF_EffectWorld		*src,
		const PF_PixelFloat *color,			/* color to premultiply/unmultiply with */
		A_long				forward,		/* TRUE means convert non-premul to premul, FALSE mean reverse */
		PF_EffectWorld		*dst);

} PF_FillMatteSuite2;



#ifdef __cplusplus
	}		// end extern "C"
#endif



#include <adobesdk/config/PostConfig.h>


#endif


```

---

<h2>Begin File: AE_EffectGPUSuites.h</h2>

```cpp
/*******************************************************************/
/*                                                                 */
/*                      ADOBE CONFIDENTIAL                         */
/*                   _ _ _ _ _ _ _ _ _ _ _ _ _                     */
/*                                                                 */
/* Copyright 2018 Adobe Systems Incorporated                       */
/* All Rights Reserved.                                            */
/*                                                                 */
/* NOTICE:  All information contained herein is, and remains the   */
/* property of Adobe Systems Incorporated and its suppliers, if    */
/* any.  The intellectual and technical concepts contained         */
/* herein are proprietary to Adobe Systems Incorporated and its    */
/* suppliers and may be covered by U.S. and Foreign Patents,       */
/* patents in process, and are protected by trade secret or        */
/* copyright law.  Dissemination of this information or            */
/* reproduction of this material is strictly forbidden unless      */
/* prior written permission is obtained from Adobe Systems         */
/* Incorporated.                                                   */
/*                                                                 */
/*******************************************************************/

#ifndef _H_AE_EffectGPUSuites
#define _H_AE_EffectGPUSuites

#include <AE_Effect.h>
#include <SPBasic.h>

#include <adobesdk/config/PreConfig.h>

#ifdef __cplusplus
	extern "C" {
#endif


#define PF_CUDAVersion						10010


#define kPFGPUDeviceSuite			"PF GPU Device Suite"
#define kPFGPUDeviceSuiteVersion1	1	/* frozen in AE 16.0 */	

typedef struct
{
	PF_GPU_Framework device_framework;
	PF_Boolean compatibleB;	// device meets minimum requriement for acceleration
	
	void* platformPV; // cl_platform_id
	void* devicePV; // CUdevice or cl_device_id or MTLDevice
	void* contextPV; // CUcontext or cl_context
	void* command_queuePV; // CUstream or cl_command_queue or MTLCommandQueue
	void* offscreen_opengl_contextPV; // CGLContextObj or HGLRC - only available on the primary device
	void* offscreen_opengl_devicePV; // HDC - only available on the primary device

} PF_GPUDeviceInfo;



typedef struct PF_GPUDeviceSuite1 {

	/**
	**	This will return the number of gpu devices the host supports.
	**
	**	@param	effect_ref								Comes with PF_InData. 
	**	@param	device_countP							Return number of devices available.
	*/
	SPAPI PF_Err	(*GetDeviceCount)( 					PF_ProgPtr			effect_ref,
														A_u_long			*device_countP);	/* << */

	/**
	**	This will return the device info with given device index, which includes necessary context/queue information
	**	needed to dispatch task to the device. Refer PF_GPUDeviceInfo for details.
	**
	**	@param	effect_ref								Comes with PF_InData. 
	**	@param	device_index							The device index for the requested device.
	**	@param	PF_GPUDeviceInfo						The device info will to be filled.
	*/
	SPAPI PF_Err	(*GetDeviceInfo)( 					PF_ProgPtr			effect_ref,
														A_u_long			device_index,
									  					PF_GPUDeviceInfo	*device_infoP);	/* << */


	/**
	**	Acquire/release exclusive access to inDeviceIndex. All calls below this point generally require access be held.
	**	For full GPU plugins (those that use a separate entry point for GPU rendering) exclusive access is always held.
	**	These calls do not need to be made in that case.
	**		For CUDA calls cuCtxPushCurrent/cuCtxPopCurrent on the current thread to manage the devices context.
	*/
	SPAPI PF_Err	(*AcquireExclusiveDeviceAccess)( 	PF_ProgPtr			effect_ref,
														A_u_long			device_index);

	SPAPI PF_Err	(*ReleaseExclusiveDeviceAccess)( 	PF_ProgPtr			effect_ref,
														A_u_long			device_index);

	/**
	**	All device memory must be allocated through this suite.
	**		Purge should be called only in emergency situations when working with GPU memory
	**			that cannot be allocated through this suite (eg OpenGL memory).
	**		Returned pointer value represents memory allocated through cuMemAlloc or clCreateBuffer.
	*/

	SPAPI PF_Err	(*AllocateDeviceMemory)(	PF_ProgPtr			effect_ref,
	 											A_u_long			device_index,
											 	size_t				size_bytes,
												void 				**memoryPP);	/* << */

	SPAPI PF_Err	(*FreeDeviceMemory)( 		PF_ProgPtr			effect_ref,
												A_u_long			device_index,
										 		void         	  	*memoryP);

	SPAPI PF_Err	(*PurgeDeviceMemory)( 		PF_ProgPtr			effect_ref,
												A_u_long			device_index,
										  		size_t				size_bytes,
										 	 	size_t 				*bytes_purgedP0);	/* << */

	/**
	**	All host (pinned) memory must be allocated through this suite.
	**		Purge should be called only in emergency situations when working with GPU memory
	**			that cannot be allocated through this suite (eg OpenGL memory).
	**		Returned pointer value represents memory allocated through cuMemHostAlloc or malloc.
	*/
	SPAPI PF_Err	(*AllocateHostMemory)(	PF_ProgPtr			effect_ref,
											A_u_long			device_index,
											size_t				size_bytes,
											void 				**memoryPP);	/* << */


	SPAPI PF_Err	(*FreeHostMemory)( 		PF_ProgPtr			effect_ref,
											A_u_long			device_index,
											void				*memoryP);


	SPAPI PF_Err	(*PurgeHostMemory)( 	PF_ProgPtr			effect_ref,	
											A_u_long			device_index,
											size_t				bytes_to_purge,
											size_t 				*bytes_purgedP0);	/* << */

	/**
	**	This will allocate a gpu effect world. Caller is responsible for deallocating the buffer with
	**	PF_GPUDeviceSuite1::DisposeGPUWorld.
	**
	**	@param	effect_ref					Comes with PF_InData. 
	**	@param	device_index				The device you want your gpu effect world allocated with.
	**	@param	width						Width of the effect world.
	**	@param	height						Height of the effect world.
	**	@param	pixel_aspect_ratio			Pixel Aspect Ratio of the effect world.
	**	@param	field_type					The field of the effect world.
	**	@param	pixel_format				The pixel format of the effect world, only gpu formats are accepted.
	**	@param	clear_pixB					Pass in 'true' for a transparent black frame.
	**	@param	worldPP						The handle to the effect world to be created.
	*/
	SPAPI PF_Err	(*CreateGPUWorld)(		PF_ProgPtr			effect_ref,
											A_u_long			device_index,
											A_long				width,
											A_long				height,
											PF_RationalScale	pixel_aspect_ratio,
											PF_Field 			field_type,
											PF_PixelFormat		pixel_format,
											PF_Boolean			clear_pixB,
											PF_EffectWorld		**worldPP);	/* << */


	/**
	**	This will free this effect world. The effect world is no longer valid after this function is called.
	**	Plugin module is only allowed to dispose of effect worlds they create.
	**
	**	@param	effect_ref					Comes with PF_InData. 
	**	@param	worldP						The effect world you want to dispose.
	*/
	SPAPI PF_Err	(*DisposeGPUWorld)(		PF_ProgPtr			effect_ref,
											PF_EffectWorld		*worldP);


	/**
	**	This will return the gpu buffer address of the given effect world.
	**
	**	@param	effect_ref						Comes with PF_InData. 
	**	@param	worldP							The effect world you want to operate on, has to be a gpu effect world.
	**	@param	pixPP							Returns the gpu buffer address.
	*/
	SPAPI PF_Err	(*GetGPUWorldData)(			PF_ProgPtr			effect_ref,
												PF_EffectWorld		*worldP,
												void				**pixPP);	/* << */

	/**
	**	This will return the size of the total data in the effect world.
	**
	**	@param	effect_ref						Comes with PF_InData.
	**	@param	worldP							The effect world you want to operate on, has to be a gpu effect world.
	**	@param	device_indexP					Returns the size of the total data in the effect world.
	*/
	SPAPI PF_Err	(*GetGPUWorldSize)( 		PF_ProgPtr			effect_ref,
												PF_EffectWorld		*worldP,
												size_t				*size_in_bytesP);	/* << */


	/**
	**	This will return device index the gpu effect world is associated with.
	**
	**	@param	effect_ref						Comes with PF_InData. 
	**	@param	worldP							The effect world you want to operate on, has to be a gpu effect world.
	**	@param	device_indexP					Returns the device index of the given effect world.
	*/
	SPAPI PF_Err	(*GetGPUWorldDeviceIndex)( 	PF_ProgPtr			effect_ref,
												PF_EffectWorld		*worldP,
												A_u_long			*device_indexP);	/* << */


} PF_GPUDeviceSuite1;



/**********************************************************/
/**********************************************************/

#ifdef __cplusplus
	}
#endif


#include <adobesdk/config/PostConfig.h>

#endif

```

---

<h2>Begin File: AE_EffectPixelFormat.h</h2>

```cpp
#ifndef _H_AE_PIXEL_FORMAT
#define _H_AE_PIXEL_FORMAT

#include "A.h"

/* data types for PF_EffectWorlds that are not just 8bpc ARGB
 *
 * see AE_EffectCBSuites.h for more details
 *
 */

#ifndef MAKE_PIXEL_FORMAT_FOURCC

#define MAKE_PIXEL_FORMAT_FOURCC(ch0, ch1, ch2, ch3)                              \
                ((A_u_long)(A_u_char)(ch0) | ((A_u_long)(A_u_char)(ch1) << 8) |       \
                ((A_u_long)(A_u_char)(ch2) << 16) | ((A_u_long)(A_u_char)(ch3) << 24 ))

#endif


//
// note! MAKE_PIXEL_FORMAT_FOURCC('a', 'r', 'g', 'b') does not give the same result
// as the literal 'argb' in your compiler
//
// MS image compression interfaces define FOURCC this way (unlike QuickTime) so please
// be careful and use the enums as defined rather than rolling your own.
//

enum {
	PF_PixelFormat_ARGB32 		= MAKE_PIXEL_FORMAT_FOURCC('a', 'r', 'g', 'b'),		// After Effects-style ARGB, 8 bits per channel, range 0...255
																					// trillions of pixels served since 1992. support required for After Effects
	
	PF_PixelFormat_ARGB64		= MAKE_PIXEL_FORMAT_FOURCC('a', 'e', '1', '6'),		// After Effects-style ARGB, 16 bits per channel, range 0...32768
	PF_PixelFormat_ARGB128		= MAKE_PIXEL_FORMAT_FOURCC('a', 'e', '3', '2'),		// After Effects-style ARGB, 32 bits floating point per channel, 1.0 is "white"
	
	
	/* -------------------------------------------------------------------------------------- */
	
	PF_PixelFormat_GPU_BGRA128		= MAKE_PIXEL_FORMAT_FOURCC('@', 'C', 'D', 'A'),		// GPU, BGRA, 32 bits floating point per channel.
	
	PF_PixelFormat_RESERVED			= MAKE_PIXEL_FORMAT_FOURCC('@', 'C', 'D', 'a'),		// reserved for future use.
	
	/* -------------------------------------------------------------------------------------- */
	
	PF_PixelFormat_BGRA32		= MAKE_PIXEL_FORMAT_FOURCC('b', 'g', 'r', 'a'),		// Premiere-style BGRA, 8 bits per channel. Premiere-only; support required for Premiere
	PF_PixelFormat_VUYA32		= MAKE_PIXEL_FORMAT_FOURCC('v', 'u', 'y', 'a'),		// Premiere-style YUVA, 8 bits per channel. Premiere-only
		
	PF_PixelFormat_NTSCDV25		= MAKE_PIXEL_FORMAT_FOURCC('d', 'v', 'n', '2'),		// compressed DV-25. Premiere only.
	PF_PixelFormat_PALDV25		= MAKE_PIXEL_FORMAT_FOURCC('d', 'v', 'p', '2'),		// compressed DV-25. Premiere only.

	PF_PixelFormat_INVALID		= MAKE_PIXEL_FORMAT_FOURCC('b', 'a', 'd', 'f'),		// invalid pixel format - this is used for intialization and error conditions


	PF_PixelFormat_FORCE_LONG_INT = 0xFFFFFFFF
};

typedef A_long PF_PixelFormat;


#ifdef PREMIERE
// for Premiere-specific pixel format support
// some of these are aliases of formats already available as a PF_PixelFormat

#ifndef PRSDKPIXELFORMAT_H
typedef  PF_PixelFormat PrPixelFormat;

enum {
	// Uncompressed formats - these are most common for effects
	PrPixelFormat_BGRA_4444_8u		= PF_PixelFormat_BGRA32,
	PrPixelFormat_VUYA_4444_8u		= PF_PixelFormat_VUYA32,
	PrPixelFormat_ARGB_4444_8u		= PF_PixelFormat_ARGB32,
	PrPixelFormat_BGRA_4444_16u		= MAKE_PIXEL_FORMAT_FOURCC('B', 'g', 'r', 'a'),		// 16 bit integer per component BGRA
	PrPixelFormat_VUYA_4444_16u		= MAKE_PIXEL_FORMAT_FOURCC('V', 'u', 'y', 'a'),		// 16 bit integer per component VUYA
	PrPixelFormat_ARGB_4444_16u		= MAKE_PIXEL_FORMAT_FOURCC('A', 'r', 'g', 'b'),		// 16 bit integer per component ARGB 
	PrPixelFormat_BGRA_4444_32f		= MAKE_PIXEL_FORMAT_FOURCC('B', 'G', 'r', 'a'),		// 32 bit float per component BGRA
	PrPixelFormat_VUYA_4444_32f		= MAKE_PIXEL_FORMAT_FOURCC('V', 'U', 'y', 'a'),		// 32 bit float per component VUYA
	PrPixelFormat_ARGB_4444_32f		= MAKE_PIXEL_FORMAT_FOURCC('A', 'R', 'g', 'b'),		// 32 bit float per component ARGB

	// Packed formats
	PrPixelFormat_YUYV_422_8u_601	= MAKE_PIXEL_FORMAT_FOURCC('y', 'u', 'y', '2'),		// 8 bit 422 YUY2 601 colorspace
	PrPixelFormat_YUYV_422_8u_709	= MAKE_PIXEL_FORMAT_FOURCC('y', 'u', 'y', '3'),		// 8 bit 422 YUY2 709 colorspace
	PrPixelFormat_UYVY_422_8u_601	= MAKE_PIXEL_FORMAT_FOURCC('u', 'y', 'v', 'y'),		// 8 bit 422 UYVY 601 colorspace
	PrPixelFormat_UYVY_422_8u_709	= MAKE_PIXEL_FORMAT_FOURCC('u', 'y', 'v', '7'),		// 8 bit 422 UYVY 709 colorspace
	PrPixelFormat_V210_422_10u_601	= MAKE_PIXEL_FORMAT_FOURCC('v', '2', '1', '0'),		// packed uncompressed 10 bit 422 YUV aka V210 601 colorspace
	PrPixelFormat_V210_422_10u_709	= MAKE_PIXEL_FORMAT_FOURCC('v', '2', '1', '1'),	

	// Planar formats
	PrPixelFormat_YUV_420_MPEG2_FRAME_PICTURE_PLANAR_8u	= MAKE_PIXEL_FORMAT_FOURCC('y', 'v', '1', '2'),		//	YUV with 2x2 chroma subsampling. Planar. (for MPEG-2)
	PrPixelFormat_YUV_420_MPEG2_FIELD_PICTURE_PLANAR_8u	= MAKE_PIXEL_FORMAT_FOURCC('y', 'v', 'i', '2'),		//	YUV with 2x2 chroma subsampling. Planar. (for MPEG-2)

	// Compressed formats
	PrPixelFormat_NTSCDV25			= PF_PixelFormat_NTSCDV25,		// compressed DV-25
	PrPixelFormat_PALDV25			= PF_PixelFormat_PALDV25,		// compressed DV-25
	PrPixelFormat_720pDV100			= MAKE_PIXEL_FORMAT_FOURCC('d', 'v', '7', '1'),		// compressed DV-100 720p
	PrPixelFormat_1080iDV100		= MAKE_PIXEL_FORMAT_FOURCC('d', 'v', '1', '1'),		// compressed DV-100 1080i

	// Raw, opaque data formats
	PrPixelFormat_Raw				= MAKE_PIXEL_FORMAT_FOURCC('r', 'a', 'w', 'w'),		// raw, opaque data, with no row bytes or height

	// Invalid
	PrPixelFormat_Invalid			= PF_PixelFormat_INVALID,		// invalid pixel format - this is used for intialization and error conditions

	PrPixelFormat_Any				= 0
};

#endif	// PRSDKPIXELFORMAT_H

#endif // PREMIERE

#endif	// AE_PixelFormat

```

---

<h2>Begin File: AE_EffectSuites.h</h2>

```cpp
/*******************************************************************/
/*                                                                 */
/*                      ADOBE CONFIDENTIAL                         */
/*                   _ _ _ _ _ _ _ _ _ _ _ _ _                     */
/*                                                                 */
/* Copyright 2007 Adobe Systems Incorporated                       */
/* All Rights Reserved.                                            */
/*                                                                 */
/* NOTICE:  All information contained herein is, and remains the   */
/* property of Adobe Systems Incorporated and its suppliers, if    */
/* any.  The intellectual and technical concepts contained         */
/* herein are proprietary to Adobe Systems Incorporated and its    */
/* suppliers and may be covered by U.S. and Foreign Patents,       */
/* patents in process, and are protected by trade secret or        */
/* copyright law.  Dissemination of this information or            */
/* reproduction of this material is strictly forbidden unless      */
/* prior written permission is obtained from Adobe Systems         */
/* Incorporated.                                                   */
/*                                                                 */
/*******************************************************************/

#ifndef _H_AE_EffectSuites
#define _H_AE_EffectSuites

#include <AE_Effect.h>
#include <AE_EffectUI.h>		// for PF_CursorType
#include <SPBasic.h>

#include <adobesdk/config/PreConfig.h>

#ifdef __cplusplus
	extern "C" {
#endif



#define kPFPathQuerySuite			"PF Path Query Suite"
#define kPFPathQuerySuiteVersion1	1	/* frozen in AE 5.0 */	


typedef struct PF_PathOutline *PF_PathOutlinePtr;
typedef struct PF_PathSegPrep *PF_PathSegPrepPtr;

typedef struct PF_PathQuerySuite1 {

	SPAPI PF_Err	(*PF_NumPaths)(	PF_ProgPtr			effect_ref,
									A_long				*num_pathsPL);	/* << */

	SPAPI PF_Err	(*PF_PathInfo)(	PF_ProgPtr			effect_ref,
									A_long				indexL,
									PF_PathID			*unique_idP);	/* << */

	SPAPI PF_Err	(*PF_CheckoutPath)(	PF_ProgPtr			effect_ref,
										PF_PathID			unique_id,
										A_long				what_time,
										A_long				time_step,
										A_u_long		time_scale,
										PF_PathOutlinePtr	*pathPP);	/* << */	// can return NULL ptr if path doesn't exist

	SPAPI PF_Err	(*PF_CheckinPath)(	PF_ProgPtr			effect_ref,
										PF_PathID			unique_id,
										PF_Boolean			changedB,
										PF_PathOutlinePtr	pathP);

} PF_PathQuerySuite1;



/* -------------------------------------------------------------------- */


#define kPFPathDataSuite			"PF Path Data Suite"
#define kPFPathDataSuiteVersion1	1	/* frozen in AE 5.0 */	


typedef struct {

	PF_FpLong				x, y;
	PF_FpLong				tan_in_x, tan_in_y;
	PF_FpLong				tan_out_x, tan_out_y;

} PF_PathVertex;

#define	PF_MAX_PATH_NAME_LEN		31


typedef struct PF_PathDataSuite1 {

	SPAPI PF_Err	(*PF_PathIsOpen)(		PF_ProgPtr			effect_ref0,
											PF_PathOutlinePtr	pathP,
											PF_Boolean			*openPB);

	// N segments means there are segments [0..N-1]; segment J is defined by vertex J & J+1
	SPAPI PF_Err 	(*PF_PathNumSegments)(	PF_ProgPtr			effect_ref0,
											PF_PathOutlinePtr	pathP,
											A_long				*num_segmentsPL);
	
	// which_pointL range: [0..num_segments]; for closed paths vertex[0] == vertex[num_segments]
	SPAPI PF_Err 	(*PF_PathVertexInfo)(	PF_ProgPtr			effect_ref0,
											PF_PathOutlinePtr	pathP,
											A_long				which_pointL,
											PF_PathVertex		*vertexP);

	SPAPI PF_Err 	(*PF_PathPrepareSegLength)(
											PF_ProgPtr			effect_ref0,
											PF_PathOutlinePtr	pathP,
											A_long				which_segL,
											A_long				frequencyL,
											PF_PathSegPrepPtr	*lengthPrepPP);

	SPAPI PF_Err 	(*PF_PathGetSegLength)(	PF_ProgPtr			effect_ref0,
											PF_PathOutlinePtr	pathP,
											A_long				which_segL,
											PF_PathSegPrepPtr	*lengthPrepP0,
											PF_FpLong			*lengthPF);
											
	SPAPI PF_Err 	(*PF_PathEvalSegLength)(PF_ProgPtr			effect_ref0,
											PF_PathOutlinePtr	pathP,
											PF_PathSegPrepPtr	*lengthPrepPP0,
											A_long				which_segL,
											PF_FpLong			lengthF,
											PF_FpLong			*x,
											PF_FpLong			*y);

	SPAPI PF_Err 	(*PF_PathEvalSegLengthDeriv1)(
											PF_ProgPtr			effect_ref0,
											PF_PathOutlinePtr	pathP,
											PF_PathSegPrepPtr	*lengthPrepPP0,
											A_long				which_segL,
											PF_FpLong			lengthF,
											PF_FpLong			*x,
											PF_FpLong			*y,
											PF_FpLong			*deriv1x,
											PF_FpLong			*deriv1y);


	SPAPI PF_Err 	(*PF_PathCleanupSegLength)(
											PF_ProgPtr			effect_ref0,
											PF_PathOutlinePtr	pathP,
											A_long				which_segL,
											PF_PathSegPrepPtr	*lengthPrepPP);


	SPAPI PF_Err 	(*PF_PathIsInverted)(	PF_ProgPtr			effect_ref,
											PF_PathID			unique_id,
											PF_Boolean			*invertedB);

	SPAPI PF_Err 	(*PF_PathGetMaskMode)(	PF_ProgPtr			effect_ref,
											PF_PathID			unique_id,
											PF_MaskMode			*modeP);

	SPAPI PF_Err	(*PF_PathGetName)(		PF_ProgPtr			effect_ref,
											PF_PathID			unique_id,
											A_char				*nameZ);		/* << can be up to PF_MAX_PATH_NAME_LEN+1 bytes long */


} PF_PathDataSuite1;


/* -------------------------------------------------------------------- */

// New versions of state related APIs added in CS6

#define kPFParamUtilsSuite			"PF Param Utils Suite"
#define kPFParamUtilsSuiteVersion3	3	// Frozen in AE CS6 [aka AE11.0]

typedef struct {
	A_long	reservedAL[4];
} PF_State;


#define PF_ParamIndex_NONE							(-1L)
#define PF_ParamIndex_CHECK_ALL						(-2L)
#define PF_ParamIndex_CHECK_ALL_EXCEPT_LAYER_PARAMS	(-3L)
#define PF_ParamIndex_CHECK_ALL_HONOR_EXCLUDE		(-4L)	// Like PF_ParamIndex_CHECK_ALL, but honor PF_ParamFlag_EXCLUDE_FROM_HAVE_INPUTS_CHANGED

#define PF_KeyIndex_NONE							(-1L)


enum {
	PF_TimeDir_GREATER_THAN				= 0x0000,
	PF_TimeDir_LESS_THAN				= 0x0001,
	PF_TimeDir_GREATER_THAN_OR_EQUAL	= 0x1000,
	PF_TimeDir_LESS_THAN_OR_EQUAL		= 0x1001
};
typedef A_long	PF_TimeDir;

typedef A_long	PF_KeyIndex;


/** PF_ParamUtilsSuite3

	PF_UpdateParamUI()

  		You can call this function for each param whose UI settings you
		want to change when handling a PF_Cmd_USER_CHANGED_PARAM or
		PF_Cmd_UPDATE_PARAMS_UI.  These changes are cosmetic only, and don't
		go into the undo buffer.
		
		The ONLY fields that can be changed in this way are:

			PF_ParamDef
				ui_flags: PF_PUI_ECW_SEPARATOR, PF_PUI_DISABLED only (and PF_PUI_INVISIBLE in Premiere).
				ui_width
				ui_height
				name
				flags: PF_ParamFlag_COLLAPSE_TWIRLY only

				PF_ParamDefUnion:
					slider_min, slider_max, precision, display_flags of any slider type

		For PF_PUI_STD_CONTROL_ONLY params, you can also change the value field by setting
		PF_ChangeFlag_CHANGED_VALUE before returning.  But you are not allowed to change
		the value during PF_Cmd_UPDATE_PARAMS_UI.

		PF_GetCurrentState() / PF_AreStatesIdentical()
			This API lets you determine if a set of your inputs (either layers, other properties, or both) 
			are different between when you first called PF_GetCurrentState() and a current call, so it can
			be used for caching. You can specify a range of time to consider or all of time.

			For effects that do simulation across time and therefore set PF_OutFlag2_AUTOMATIC_WIDE_TIME_INPUT, 
			when you ask about a time range, it will be expanded to include any times needed to produce
			that range.

			See doc on the old PF_HaveInputsChangedOverTimeSpan() for historical context.

**/

typedef struct PF_ParamUtilsSuite3 {

	SPAPI PF_Err	(*PF_UpdateParamUI)(
								PF_ProgPtr			effect_ref,
								PF_ParamIndex		param_index,
								const PF_ParamDef	*defP);

	// IMPORTANT: as of 13.5 to avoid threading deadlock problems, PF_GetCurrentState() returns a random state
	// if used in the context of UPDATE_PARAMS_UI only. In other selectors this will behave normally.
	SPAPI PF_Err	(*PF_GetCurrentState)(
								PF_ProgPtr			effect_ref,
								PF_ParamIndex		param_index,
								const A_Time		*startPT0,		// NULL for both start & duration means over all of time
								const A_Time		*durationPT0,
								PF_State			*stateP);		/* << */

	SPAPI PF_Err	(*PF_AreStatesIdentical)(
								PF_ProgPtr			effect_ref,
								const PF_State		*state1P,	
								const PF_State		*state2P,	
								A_Boolean			*samePB);		/* << */

	SPAPI PF_Err	(*PF_IsIdenticalCheckout)(
								PF_ProgPtr			effect_ref,
								PF_ParamIndex		param_index,
								A_long				what_time1,
								A_long				time_step1,
								A_u_long			time_scale1,
								A_long				what_time2,
								A_long				time_step2,
								A_u_long			time_scale2,
								PF_Boolean			*identicalPB);		/* << */

	SPAPI PF_Err	(*PF_FindKeyframeTime)(
								PF_ProgPtr			effect_ref,
								PF_ParamIndex		param_index,
								A_long				what_time,
								A_u_long		time_scale,
								PF_TimeDir			time_dir,
								PF_Boolean			*foundPB,			/* << */
								PF_KeyIndex			*key_indexP0,		/* << */
								A_long				*key_timeP0,		/* << */	// you can ask for either:
								A_u_long		*key_timescaleP0);	/* << */	// time&timescale OR neither

	SPAPI PF_Err	(*PF_GetKeyframeCount)(
								PF_ProgPtr			effect_ref,
								PF_ParamIndex		param_index,
								PF_KeyIndex			*key_countP);		/* << */	// returns PF_KeyIndex_NONE for constant

	SPAPI PF_Err	(*PF_CheckoutKeyframe)(
								PF_ProgPtr			effect_ref,
								PF_ParamIndex		param_index,
								PF_KeyIndex			key_index,			// zero-based
								A_long				*key_timeP0,		/* << */	// you can ask for either:
								A_u_long		*key_timescaleP0,	/* << */	// time&timescale OR neither
								PF_ParamDef			*paramP0);			/* << */

	SPAPI PF_Err	(*PF_CheckinKeyframe)(
								PF_ProgPtr			effect_ref,
								PF_ParamDef			*paramP);

	SPAPI PF_Err	(*PF_KeyIndexToTime)(
								PF_ProgPtr			effect_ref,
								PF_ParamIndex		param_index,
								PF_KeyIndex			key_indexP,			/* >> */
								A_long				*key_timeP,			/* >> */
								A_u_long		*key_timescaleP);	/* << */

} PF_ParamUtilsSuite3;




/* -------------------------------------------------------------------- */


#define kPFColorParamSuite					"PF ColorParamSuite"
#define kPFColorParamSuiteVersion1	1		/* frozen in AE 7.0 */

/** PF_ColorParamSuite1

**/

typedef struct PF_ColorParamSuite1 {

	// floating point color is in the working space of
	// your effect, i.e. the same color space
	// as the pixels you get
	
	// note that overrange and underrange values are possible
	// even when project is not set to 32bpc
	
	SPAPI PF_Err	(*PF_GetFloatingPointColorFromColorDef)(
								PF_ProgPtr			effect_ref,			/* >> */
								const PF_ParamDef	*color_defP,		/* >> */
								PF_PixelFloat		*fp_colorP);		/* << */

} PF_ColorParamSuite1;




/* -------------------------------------------------------------------- */

#define kPFPointParamSuite					"PF PointParamSuite"
#define kPFPointParamSuiteVersion1		1	/* frozen in AE 10.5 */

/** PF_PointParamSuite1

**/

typedef struct PF_PointParamSuite1 {

	// this api returns floating point value of a point parameter.

	SPAPI PF_Err	(*PF_GetFloatingPointValueFromPointDef)(
								PF_ProgPtr			effect_ref,			/* >> */
								const PF_ParamDef	*point_defP,		/* >> */
								A_FloatPoint		*fp_pointP);		/* << */

} PF_PointParamSuite1;


/* -------------------------------------------------------------------- */

#define kPFAngleParamSuite					"PF AngleParamSuite"
#define kPFAngleParamSuiteVersion1			1	/* frozen in AE 11.0.x */

/** PF_AngleParamSuite1

**/

typedef struct PF_AngleParamSuite1 {

	// this api returns floating point value of an angle parameter.

	SPAPI PF_Err	(*PF_GetFloatingPointValueFromAngleDef)(
		PF_ProgPtr			effect_ref,			/* >> */
		const PF_ParamDef	*angle_defP,		/* >> */
		A_FpLong			*fp_valueP);		/* << */

} PF_AngleParamSuite1;


/* -------------------------------------------------------------------- */

#define kPFAppSuite			"PF AE App Suite"
#define kPFAppSuiteVersion6	1	/* frozen in AE 13.1 */
	
enum {
	PF_App_Color_NONE = -1, 

	PF_App_Color_FRAME, 
	PF_App_Color_FILL, 
	PF_App_Color_TEXT, 
	PF_App_Color_LIGHT_TINGE, 
	PF_App_Color_DARK_TINGE, 
	PF_App_Color_HILITE, 
	PF_App_Color_SHADOW, 
	
	PF_App_Color_BUTTON_FRAME, 
	PF_App_Color_BUTTON_FILL, 
	PF_App_Color_BUTTON_TEXT, 
	PF_App_Color_BUTTON_LIGHT_TINGE, 
	PF_App_Color_BUTTON_DARK_TINGE, 
	PF_App_Color_BUTTON_HILITE, 
	PF_App_Color_BUTTON_SHADOW, 
	
	PF_App_Color_BUTTON_PRESSED_FRAME, 
	PF_App_Color_BUTTON_PRESSED_FILL, 
	PF_App_Color_BUTTON_PRESSED_TEXT, 
	PF_App_Color_BUTTON_PRESSED_LIGHT_TINGE, 
	PF_App_Color_BUTTON_PRESSED_DARK_TINGE, 
	PF_App_Color_BUTTON_PRESSED_HILITE, 
	PF_App_Color_BUTTON_PRESSED_SHADOW, 

	/********************************/

	PF_App_Color_FRAME_DISABLED, 
	PF_App_Color_FILL_DISABLED, 
	PF_App_Color_TEXT_DISABLED, 
	PF_App_Color_LIGHT_TINGE_DISABLED, 
	PF_App_Color_DARK_TINGE_DISABLED, 
	PF_App_Color_HILITE_DISABLED, 
	PF_App_Color_SHADOW_DISABLED, 
	
	PF_App_Color_BUTTON_FRAME_DISABLED, 
	PF_App_Color_BUTTON_FILL_DISABLED, 
	PF_App_Color_BUTTON_TEXT_DISABLED, 
	PF_App_Color_BUTTON_LIGHT_TINGE_DISABLED, 
	PF_App_Color_BUTTON_DARK_TINGE_DISABLED, 
	PF_App_Color_BUTTON_HILITE_DISABLED, 
	PF_App_Color_BUTTON_SHADOW_DISABLED, 
	
	PF_App_Color_BUTTON_PRESSED_FRAME_DISABLED, 
	PF_App_Color_BUTTON_PRESSED_FILL_DISABLED, 
	PF_App_Color_BUTTON_PRESSED_TEXT_DISABLED, 
	PF_App_Color_BUTTON_PRESSED_LIGHT_TINGE_DISABLED, 
	PF_App_Color_BUTTON_PRESSED_DARK_TINGE_DISABLED, 
	PF_App_Color_BUTTON_PRESSED_HILITE_DISABLED, 
	PF_App_Color_BUTTON_PRESSED_SHADOW_DISABLED, 
	
	/********************************/
	PF_App_Color_BLACK, 
	PF_App_Color_WHITE, 
	PF_App_Color_GRAY, 
	PF_App_Color_RED, 
	PF_App_Color_YELLOW, 
	PF_App_Color_GREEN, 
	PF_App_Color_CYAN,

	/********************************/
	PF_App_Color_TLW_NEEDLE_CURRENT_TIME,
	PF_App_Color_TLW_NEEDLE_PREVIEW_TIME,
	PF_App_Color_TLW_CACHE_MARK_MEM,
	PF_App_Color_TLW_CACHE_MARK_DISK,
	PF_App_Color_TLW_CACHE_MARK_MIX,
	PF_App_Color_FILL_LIGHT, 
	PF_App_Color_HOT_TEXT,
	PF_App_Color_HOT_TEXT_DISABLED,

	/********************************/
	PF_App_Color_LABEL_0, 
	PF_App_Color_LABEL_1, 
	PF_App_Color_LABEL_2, 
	PF_App_Color_LABEL_3, 
	PF_App_Color_LABEL_4, 
	PF_App_Color_LABEL_5, 
	PF_App_Color_LABEL_6, 
	PF_App_Color_LABEL_7, 
	PF_App_Color_LABEL_8,
	PF_App_Color_LABEL_9,
	PF_App_Color_LABEL_10,
	PF_App_Color_LABEL_11,
	PF_App_Color_LABEL_12,
	PF_App_Color_LABEL_13,
	PF_App_Color_LABEL_14,
	PF_App_Color_LABEL_15,
	PF_App_Color_LABEL_16,

	/********************************/
	PF_App_Color_TLW_CACHE_MARK_MEM_DUBIOUS,
	PF_App_Color_TLW_CACHE_MARK_DISK_DUBIOUS,
	PF_App_Color_TLW_CACHE_MARK_MIX_DUBIOUS,
	PF_App_Color_HOT_TEXT_PRESSED,
	PF_App_Color_HOT_TEXT_WARNING,
	PF_App_Color_PURE_BLACK, 
	PF_App_Color_PURE_WHITE, 

	PF_App_Color_PANEL_BACKGROUND = 1000,
	PF_App_Color_LIST_BOX_FILL,
	PF_App_Color_DARK_CAPTION_FILL,
	PF_App_Color_DARK_CAPTION_TEXT,
	PF_App_Color_TEXT_ON_LIGHTER_BG,

	PF_App_Color_NUMTYPES
};
typedef A_short	PF_App_ColorType;

enum {
	// the first entry allows the user to do it the way they normally do with
	// ae native color pickers (straight is the default, shift gives you premul)
	PF_EyeDropperSampleMode_DEFAULT,
	PF_EyeDropperSampleMode_STRAIGHT,
	PF_EyeDropperSampleMode_PREMUL
};

typedef A_short PF_EyeDropperSampleMode;

typedef	struct PF_App_Color {
		A_u_short red;		
		A_u_short green;	
		A_u_short blue;	
} PF_App_Color;


#define	PF_APP_MAX_PERS_LEN				63

typedef struct PF_AppPersonalTextInfo {
	A_char		name[PF_APP_MAX_PERS_LEN + 1];
	A_char		org[PF_APP_MAX_PERS_LEN + 1];
	A_char		serial_str[PF_APP_MAX_PERS_LEN + 1];
} PF_AppPersonalTextInfo;


enum {
	PF_FontStyle_NONE		= -1,	// sentinel
	PF_FontStyle_SYS		= 0,	// system font, system size, system style (0, 0, 0)
	PF_FontStyle_SMALL,				// usually small annotation text
	PF_FontStyle_SMALL_BOLD,		// more important small annotations
	PF_FontStyle_SMALL_ITALIC,		// missing things, etc.
	PF_FontStyle_MED,				// times in in/out panels
	PF_FontStyle_MED_BOLD,			// 
	PF_FontStyle_APP,				// 
	PF_FontStyle_APP_BOLD,			// time in TL window
	PF_FontStyle_APP_ITALIC			// 
};
typedef A_LegacyEnumType PF_FontStyleSheet;



#define	PF_FONT_NAME_LEN				255

typedef struct PF_FontName {
	A_char		font_nameAC[PF_FONT_NAME_LEN+1];
} PF_FontName;
		
	
#define PF_APP_LANG_TAG_SIZE	(5 + 1)
		
typedef struct _PF_AppProgressDialog	*PF_AppProgressDialogP;
		

typedef struct PFAppSuite6 {		/* frozen in AE 13.1 */

	SPAPI PF_Err 	(*PF_AppGetBgColor)(	PF_App_Color			*bg_colorP);		/* << */

	SPAPI PF_Err 	(*PF_AppGetColor)(		PF_App_ColorType		color_type,			/* >> */
											PF_App_Color			*app_colorP);		/* << */
	
	// Provides the active displayed language of AE UI so plugin can match. e.g. "en_US"
	SPAPI PF_Err 	(*PF_AppGetLanguage)(	A_char					*lang_tagZ);		/* << up to PF_APP_LANG_TAG_SIZE-1  */

	SPAPI PF_Err 	(*PF_GetPersonalInfo)(	PF_AppPersonalTextInfo	*ptiP);				/* << */

	SPAPI PF_Err 	(*PF_GetFontStyleSheet)(PF_FontStyleSheet		sheet,				/* >> */
											PF_FontName				*font_nameP0,		/* << */			
											A_short					*font_numPS0,		/* << */
											A_short					*sizePS0,			/* << */
											A_short					*stylePS0);			/* << */

	// normally the effect should respond to PF_Event_ADJUST_CURSOR, but for changing
	//	the cursor during modal situations, you can use this API
	SPAPI PF_Err	(*PF_SetCursor)(		PF_CursorType		cursor);				/* >> */

	// as of AE6.5, this function returns TRUE if installed app is the render engine (as before)
	//				OR if the app is being run with no UI OR if the app is in watch-folder mode
	SPAPI PF_Err	(*PF_IsRenderEngine)(	PF_Boolean				*render_enginePB);		/* >> */

	// will return PF_Interrupt_CANCEL if user cancels dialog. color is in project working colorspace
	// if use_ws_to_monitor_xformB is TRUE, then the color chips and pickers are run through the
	// working space -> display transformation while interacting. set FALSE to have the raw RGB values
	// pushed directly to the screen. TRUE is intended for when the returned color is used in rendering, FALSE
	// is intended if the color is for UI elements or other nonrenderables.
	
	SPAPI PF_Err	(*PF_AppColorPickerDialog)(	const A_char			*dialog_titleZ0,				/* >> */
												const PF_PixelFloat		*sample_colorP,					/* >> */
												PF_Boolean				use_ws_to_monitor_xformB, 		/* >> */
												PF_PixelFloat			*new_colorP);					/* << */

	// for use only when processing an event in an effect with custom UI
	SPAPI PF_Err	(*PF_GetMouse)(PF_Point* pointP);

	// NEW api in version 4.
	// Use it to invalidate rect of current window being drawn. Invalidated rect will be updated during idle time. 
	// Specify PF_EO_UPDATE_NOW out flag to update the window immediately after the event returns. Specify rectP0 
	// as NULL to invalidate the whole window.
	// Only valid while handling an non-draw event in the effect.
	SPAPI PF_Err	(*PF_InvalidateRect)(	const PF_ContextH	contextH, 
											const PF_Rect*		rectP0);

	// only safe to use when processing an event from a custom UI event.
	SPAPI PF_Err	(*PF_ConvertLocalToGlobal)(const PF_Point* localP, PF_Point* globalP);
	
	// this will return a deep color if over a content window containing 32bpc.
	// eyeSize == 0 will use the application pref as set by the user.
	SPAPI PF_Err	(*PF_GetColorAtGlobalPoint)(const PF_Point* globalP, A_short eyeSize, PF_EyeDropperSampleMode mode, PF_PixelFloat* outColorP);
	

	// Manages a modal progress dialog session for use inside of time-consuming AEGP commands
	// Only one dialog active at a time is supported, and it may not get displayed in cases where AE UI is disabled (become no-ops)
	// These calls must be used from the AE main/UI thread
	// The app busy cursor will automatically set/reset as needed, regardless of whether dialog is displayed
	SPAPI PF_Err	(*PF_CreateNewAppProgressDialog)(	
											const A_UTF16Char*	titleZ,			// >> title of the progress dialog
											const A_UTF16Char*	cancel_strZ0,	// >> [optional] what the name on the button should be. 
																				// If NULL, AE localized Cancel used by default
											PF_Boolean			indeterminateB,	// >> TRUE shows "barber pole" style animation with no incremental progress
											PF_AppProgressDialogP *prog_dlgPP);	// <> Returns allocated ProgressDialog session (may not display actual dialog yet)
	
	// This will trigger initial dialog display once timeout elapses.
	// While dialog is displayed, this updates animation/progress status.  
	// If the session is disposed before the elapsed time the dialog is never displayed.
	// This must be called frequently during your algorithm to keep UI responsive and animation moving. About 100ms interval would be a good target.
	// Returns PF_Interrupt_CANCEL if user canceled the dialog
	SPAPI PF_Err	(*PF_AppProgressDialogUpdate)(
											PF_AppProgressDialogP prog_dlgP,	// >> The allocated session
											A_long countL, A_long totalL);		// >>  count/total is the fraction of progress to display (when not indeterminate style)
																				//     (pass zeros to keep barber-pole animation alive)
																				
	// PF_AppProgressDialogP MUST be disposed whether the actual dialog is displayed or not
	SPAPI PF_Err	(*PF_DisposeAppProgressDialog)(PF_AppProgressDialogP prog_dlgP);	// >> The allocated session.  MUST be disposed.

} PFAppSuite6;



#define kPFEffectUISuite			"PF Effect UI Suite"
#define kPFEffectUISuiteVersion1	1 /* frozen in 5.5 */

typedef struct PF_EffectUISuite1 {

	SPAPI PF_Err	(*PF_SetOptionsButtonName)(	PF_ProgPtr			effect_ref,
												const A_char			*nameZ);

} PF_EffectUISuite1;




#define kPFEffectCustomUISuite			"PF Effect Custom UI Suite"
#define kPFEffectCustomUISuiteVersion2	2 /* frozen in 13.5 */

typedef struct _PF_AsyncManager	 *PF_AsyncManagerP;		// manage multiple asynchronous render requests during lifetime, especially for better caching on UI thread

// apis that relate to

typedef struct PF_EffectCustomUISuite2 {

	// This provides basic apis needed for custom ui drawing in any window (Comp/Layer/ECW)
	// Get the drawing reference for custom ui drawing.
	SPAPI PF_Err	(*PF_GetDrawingReference)(	const PF_ContextH		effect_contextH,		/* >> */
												DRAWBOT_DrawRef			*referenceP0);			/* << */

        // NEW in version 2 (ae13.5)
        // When using PF_OutFlag2_CUSTOM_UI_ASYNC_MANAGER, use this to get the async manager associated with the effect PF_ContextH.  
		// The managed can then be asked to do Async render requests
	SPAPI PF_Err    (*PF_GetContextAsyncManager)(  PF_InData* in_data, PF_EventExtra* extra, PF_AsyncManagerP*               managerPP0);

} PF_EffectCustomUISuite2;




#define kPFEffectCustomUIOverlayThemeSuite				"PF Effect Custom UI Overlay Theme Suite"
#define kPFEffectCustomUIOverlayThemeSuiteVersion1		1 /* frozen in 10.0 */

// This suite should be used for stroking/filling paths, vertices etc on Comp/Layer window. After Effects is internally using it
// so use it to make custom ui look consistent across effects. The foreground/shadow colors are computed based on the app brightness
// level so custom ui is always visible regardless of app brightness.

typedef struct PF_EffectCustomUIOverlayThemeSuite1 {

	// Get foreground/shadow colors preferred for custom ui drawing in AE. 
	// These colors are used by AE custom ui effects.
	SPAPI PF_Err	(*PF_GetPreferredForegroundColor)(	DRAWBOT_ColorRGBA		*foreground_colorP);	/* << */

	SPAPI PF_Err	(*PF_GetPreferredShadowColor)	(	DRAWBOT_ColorRGBA		*shadow_colorP);		/* << */


	// Get foreground & shadow stroke width, vertex size and shadow offset preferred for custom ui drawing in AE. 
	// These settings are used by AE custom ui effects.
	SPAPI PF_Err	(*PF_GetPreferredStrokeWidth)(	float					*stroke_widthPF);		/* << for both foreground and shadow stroke */

	SPAPI PF_Err	(*PF_GetPreferredVertexSize)(	float					*vertex_sizePF);		/* << */
	
	SPAPI PF_Err	(*PF_GetPreferredShadowOffset)(	A_LPoint				*shadow_offsetP);		/* << */


	// Stroke the path with overlay theme foreground color. It can also draw shadow using overlay theme shadow color.
	// It uses overlay theme stroke width for stroking foreground and shadow strokes.
	SPAPI PF_Err	(*PF_StrokePath)	(	const DRAWBOT_DrawRef			drawbot_ref,			/* >> */
											const DRAWBOT_PathRef			path_ref,				/* >> */
											PF_Boolean						draw_shadowB);			/* >> */


	// Fills the path with overlay theme foreground color. It can also draw shadow using overlay theme shadow color.
	// It can be used for drawing in any Comp/Layer/EC windows.
	SPAPI PF_Err	(*PF_FillPath)		(	const DRAWBOT_DrawRef			drawbot_ref,			/* >> */
											const DRAWBOT_PathRef			path_ref,				/* >> */
											PF_Boolean						draw_shadowB);			/* >> */


	// Fills a square (vertex) around the center point using overlay theme foreground color and vertex size.
	SPAPI PF_Err	(*PF_FillVertex)	(	const DRAWBOT_DrawRef			drawbot_ref,			/* >> */
											const A_FloatPoint				*center_pointP,			/* >> */
											PF_Boolean						draw_shadowB);			/* >> */

} PF_EffectCustomUIOverlayThemeSuite1;


// we include this at the end here to maintain source-level compatibility with
//	files that #include AE_EffectSuite but are still using the old suites
//	note: this is _inside_ the pre/post & ifdefs, as this is just a snippet,
//	and not designed to be #include by anyone else
#define _H_AE_EffectSuitesOld
	#include "AE_EffectSuitesOld.h"
#undef _H_AE_EffectSuitesOld

/**********************************************************/
/**********************************************************/

#ifdef __cplusplus
	}
#endif


#include <adobesdk/config/PostConfig.h>

#endif

```

---

<h2>Begin File: AE_EffectSuitesHelper.h</h2>

```cpp
/*******************************************************************/
/*                                                                 */
/*                      ADOBE CONFIDENTIAL                         */
/*                   _ _ _ _ _ _ _ _ _ _ _ _ _                     */
/*                                                                 */
/* Copyright 2007 Adobe Systems Incorporated                       */
/* All Rights Reserved.                                            */
/*                                                                 */
/* NOTICE:  All information contained herein is, and remains the   */
/* property of Adobe Systems Incorporated and its suppliers, if    */
/* any.  The intellectual and technical concepts contained         */
/* herein are proprietary to Adobe Systems Incorporated and its    */
/* suppliers and may be covered by U.S. and Foreign Patents,       */
/* patents in process, and are protected by trade secret or        */
/* copyright law.  Dissemination of this information or            */
/* reproduction of this material is strictly forbidden unless      */
/* prior written permission is obtained from Adobe Systems         */
/* Incorporated.                                                   */
/*                                                                 */
/* Adobe Premiere Device Control plug-in definitions			   */
/*																   */
/* AE_EffectSuitesHelper.h										   */
/*																   */ 
/* After Effects 5.0 PICA Suites (extended 3/8/00)				   */
/*																   */
/*																   */
/*******************************************************************/

#ifndef _H_AE_EffectSuitesHelper
#define _H_AE_EffectSuitesHelper

#include <AE_Effect.h>
#include <SPBasic.h>

#include <adobesdk/config/PreConfig.h>

#ifdef __cplusplus
	extern "C" {
#endif


/** PF_HelperSuite1

	PF_GetCurrentTool()

		retrieves the type of the current tool palette tool selected					

**/

#define kPFHelperSuite				"AE Plugin Helper Suite"
#define kPFHelperSuiteVersion1		1
#define kPFHelperSuiteVersion		kPFHelperSuiteVersion1

enum {
	PF_SuiteTool_NONE = 0, 				
	PF_SuiteTool_ARROW,
	PF_SuiteTool_ROTATE,
	PF_SuiteTool_SHAPE,
	PF_SuiteTool_OBSOLETE,
	PF_SuiteTool_PEN,
	PF_SuiteTool_PAN,
	PF_SuiteTool_HAND,
	PF_SuiteTool_MAGNIFY,
	PF_SuiteTool_ROUNDED_RECT,
	PF_SuiteTool_POLYGON,
	PF_SuiteTool_STAR,
	PF_SuiteTool_PIN,
	PF_SuiteTool_PIN_STARCH,
	PF_SuiteTool_PIN_DEPTH
};
typedef A_LegacyEnumType PF_SuiteTool;



typedef struct PF_HelperSuite1 {
	// obsolete, use PF_HelperSuite2
	SPAPI PF_Err 	(*PF_GetCurrentTool)( PF_SuiteTool 		*toolP );		/* << */
} PF_HelperSuite1;


/** PF_HelperSuite2

	PF_ParseClipboard()

		causes After Effects to parse the clipboard immediately
					
**/
enum {
	PF_ExtendedSuiteTool_NONE = 0,
	PF_ExtendedSuiteTool_ARROW,
	PF_ExtendedSuiteTool_ROTATE,
	PF_ExtendedSuiteTool_PEN_NORMAL,
	PF_ExtendedSuiteTool_PEN_ADD_POINT,
	PF_ExtendedSuiteTool_PEN_DELETE_POINT,
	PF_ExtendedSuiteTool_PEN_CONVERT_POINT,
	PF_ExtendedSuiteTool_RECT,
	PF_ExtendedSuiteTool_OVAL,
	PF_ExtendedSuiteTool_CAMERA_ORBIT_CAMERA,
	PF_ExtendedSuiteTool_CAMERA_PAN_CAMERA,				//changed from PF_ExtendedSuiteTool_CAMERA_TRACK_XY
	PF_ExtendedSuiteTool_CAMERA_DOLLY_CAMERA,			//changed from PF_ExtendedSuiteTool_CAMERA_TRACK_Z
	PF_ExtendedSuiteTool_PAN_BEHIND,
	PF_ExtendedSuiteTool_HAND,
	PF_ExtendedSuiteTool_MAGNIFY,
	PF_ExtendedSuiteTool_PAINTBRUSH,	// All below added in 6.0
	PF_ExtendedSuiteTool_PENCIL,
	PF_ExtendedSuiteTool_CLONE_STAMP,
	PF_ExtendedSuiteTool_ERASER,
	PF_ExtendedSuiteTool_TEXT,
	PF_ExtendedSuiteTool_TEXT_VERTICAL,
	PF_ExtendedSuiteTool_PIN,
	PF_ExtendedSuiteTool_PIN_STARCH,
	PF_ExtendedSuiteTool_PIN_DEPTH,
	PF_ExtendedSuiteTool_ROUNDED_RECT,
	PF_ExtendedSuiteTool_POLYGON,
	PF_ExtendedSuiteTool_STAR,
	PF_ExtendedSuiteTool_QUICKSELECT,
	PF_ExtendedSuiteTool_CAMERA_MAYA,
	PF_ExtendedSuiteTool_HAIRBRUSH,
	PF_ExtendedSuiteTool_FEATHER,
	PF_ExtendedSuiteTool_PIN_BEND,
	PF_ExtendedSuiteTool_PIN_ADVANCED,
	PF_ExtendedSuiteTool_CAMERA_ORBIT_CURSOR,			//new cursors should go at the end to avoid messing with sdk order
	PF_ExtendedSuiteTool_CAMERA_ORBIT_SCENE,
	PF_ExtendedSuiteTool_CAMERA_PAN_CURSOR,
	PF_ExtendedSuiteTool_CAMERA_DOLLY_TOWARDS_CURSOR,
	PF_ExtendedSuiteTool_CAMERA_DOLLY_TO_CURSOR,
};
typedef A_LegacyEnumType PF_ExtendedSuiteTool;


#define kPFHelperSuite2				"AE Plugin Helper Suite2"
#define kPFHelperSuite2Version1		1
#define kPFHelperSuite2Version2		2
#define kPFHelperSuite2Version		kPFHelperSuite2Version2

typedef struct PF_HelperSuite2 {
	SPAPI PF_Err 	(*PF_ParseClipboard)( void );
	// Do not call PF_SetCurrentExtendedTool until the UI is built. i.e. Do not call it from
	// your plugin init function.
	SPAPI PF_Err	(*PF_SetCurrentExtendedTool)(PF_ExtendedSuiteTool tool);
	SPAPI PF_Err	(*PF_GetCurrentExtendedTool)(PF_ExtendedSuiteTool *tool);
} PF_HelperSuite2;

#ifdef __cplusplus
	}
#endif

#include <adobesdk/config/PostConfig.h>



#endif

```

---

<h2>Begin File: AE_EffectSuitesOld.h</h2>

```cpp
// AE_EffectSuitesOld.h
//
// Copyright (c) 2011 Adobe Systems Inc, Seattle WA
// All Rights Reserved
//
// These are old, deprecated versions of some suites. Please use the ones in AE_EffectSuites.h instead if at all possible.
//
//

// 
#ifndef _H_AE_EffectSuitesOld
	#error this file is designed to be included only by AE_EffectSuites.h; do not include directly
#endif

/** PF_ParamUtilsSuite1

	PF_UpdateParamUI()

	You can call this function for each param whose UI settings you
	want to change when handling a PF_Cmd_USER_CHANGED_PARAM or
	PF_Cmd_UPDATE_PARAMS_UI.  These changes are cosmetic only, and don't
	go into the undo buffer.

	The ONLY fields that can be changed in this way are:

	PF_ParamDef
	ui_flags: PF_PUI_ECW_SEPARATOR, PF_PUI_DISABLED only (and PF_PUI_INVISIBLE in Premiere).
	ui_width
	ui_height
	name
	flags: PF_ParamFlag_COLLAPSE_TWIRLY only

	PF_ParamDefUnion:
	slider_min, slider_max, precision, display_flags of any slider type

	For PF_PUI_STD_CONTROL_ONLY params, you can also change the value field by setting
	PF_ChangeFlag_CHANGED_VALUE before returning.  But you are not allowed to change
	the value during PF_Cmd_UPDATE_PARAMS_UI.

	PF_HaveInputsChangedOverTimeSpan() -- OBSOLETE, see PF_AreStatesIdentical() instead.
	This API is handy for effects that do simulation across time, where frame N is
	dependent on frame N-1, and you have a cache in your sequence data that needs validating.
	When asked to render frame N, assume you have your cached data from frame N-1, you'd call
	PF_HaveInputsChangedOverTimeSpan(start=0, duration=N-1) to see if your cache is still valid.
	The state of all parameters (except those with PF_ParamFlag_EXCLUDE_FROM_HAVE_INPUTS_CHANGED
	set), including layer parameters (including param[0]) are checked over the passed time
	span. This is done efficiently, as the change tracking is done with timestamps.

	Requires PF_OutFlag2_AUTOMATIC_WIDE_TIME_INPUT to be set by the effect. If validating a
	cache for use during a render, the call to PF_HaveInputsChangedOverTimeSpan() must
	happen during one of the rendering PF_Cmds (PF_Cmd_FRAME_SETUP, PF_Cmd_RENDER,
	PF_Cmd_FRAME_SETDOWN,PF_Cmd_SMART_PRE_RENDER, PF_Cmd_SMART_RENDER).

	If *changedPB is returned FALSE, you can safely use your cache, AND the internal
	caching system will assume that you have a temporal dependency on the passed range,
	so if something changes upstream, AE's caches will be properly invalidated.		

**/

#define kPFParamUtilsSuiteVersion1	2	/* 64-bit version frozen in AE 10.0 */	


typedef struct PF_ParamUtilsSuite1 {

	SPAPI PF_Err	(*PF_UpdateParamUI)(
		PF_ProgPtr			effect_ref,
		PF_ParamIndex		param_index,
		const PF_ParamDef	*defP);

	// The next 3 methods have had "Obsolete" added to their name to intentionally
	// break compile compatibility. They continue to work and are binary compatible, but
	// are more conservative and inefficient than in previous versions. Please
	// switch to the current version of this suite for maximum benefit.
	SPAPI PF_Err	(*PF_GetCurrentStateObsolete)(
		PF_ProgPtr			effect_ref,
		PF_State			*stateP);		/* << */

	SPAPI PF_Err	(*PF_HasParamChangedObsolete)(
		PF_ProgPtr			effect_ref,
		const PF_State		*stateP,		// has param changed since this state was grabbed
		PF_ParamIndex		param_index,	// ignored, always treated as PF_ParamIndex_CHECK_ALL_HONOR_EXCLUDE - go use the modern version of this suite!
		//	have changed including layer param[0];
		// pass PF_ParamIndex_CHECK_ALL_EXCEPT_LAYER_PARAMS to see
		//	if any non-layer param values have changed
		PF_Boolean			*changedPB);	/* << */

	SPAPI PF_Err	(*PF_HaveInputsChangedOverTimeSpanObsolete)(			// see comment above
		PF_ProgPtr			effect_ref,
		const PF_State		*stateP,		// has param changed since this state was grabbed
		const A_Time		*startPT0,		// NULL for both start & duration mean at any time
		const A_Time		*durationPT0,
		PF_Boolean			*changedPB);	/* << */

	SPAPI PF_Err	(*PF_IsIdenticalCheckout)(
		PF_ProgPtr			effect_ref,
		PF_ParamIndex		param_index,
		A_long				what_time1,
		A_long				time_step1,
		A_u_long		time_scale1,
		A_long				what_time2,
		A_long				time_step2,
		A_u_long		time_scale2,
		PF_Boolean			*identicalPB);		/* << */


	SPAPI PF_Err	(*PF_FindKeyframeTime)(
		PF_ProgPtr			effect_ref,
		PF_ParamIndex		param_index,
		A_long				what_time,
		A_u_long		time_scale,
		PF_TimeDir			time_dir,
		PF_Boolean			*foundPB,			/* << */
		PF_KeyIndex			*key_indexP0,		/* << */
		A_long				*key_timeP0,		/* << */	// you can ask for either:
		A_u_long		*key_timescaleP0);	/* << */	// time&timescale OR neither

	SPAPI PF_Err	(*PF_GetKeyframeCount)(
		PF_ProgPtr			effect_ref,
		PF_ParamIndex		param_index,
		PF_KeyIndex			*key_countP);		/* << */	// returns PF_KeyIndex_NONE for constant

	SPAPI PF_Err	(*PF_CheckoutKeyframe)(
		PF_ProgPtr			effect_ref,
		PF_ParamIndex		param_index,
		PF_KeyIndex			key_index,			// zero-based
		A_long				*key_timeP0,		/* << */	// you can ask for either:
		A_u_long		*key_timescaleP0,	/* << */	// time&timescale OR neither
		PF_ParamDef			*paramP0);			/* << */

	SPAPI PF_Err	(*PF_CheckinKeyframe)(
		PF_ProgPtr			effect_ref,
		PF_ParamDef			*paramP);

	SPAPI PF_Err	(*PF_KeyIndexToTime)(
		PF_ProgPtr			effect_ref,
		PF_ParamIndex		param_index,
		PF_KeyIndex			key_indexP,			/* >> */
		A_long				*key_timeP,			/* >> */
		A_u_long		*key_timescaleP);	/* << */

} PF_ParamUtilsSuite1;


/* -------------------------------------------------------------------- */

#define kPFAppSuite			"PF AE App Suite"
#define kPFAppSuiteVersion4	6	/* frozen in AE 10.0 */


typedef struct PFAppSuite4 {		/* frozen in AE 10.0 */
	
	SPAPI PF_Err 	(*PF_AppGetBgColor)(	PF_App_Color			*bg_colorP);		/* << */
	
	SPAPI PF_Err 	(*PF_AppGetColor)(		PF_App_ColorType		color_type,			/* >> */
									  PF_App_Color			*app_colorP);		/* << */
	
	SPAPI PF_Err 	(*PF_GetPersonalInfo)(	PF_AppPersonalTextInfo	*ptiP);				/* << */
	
	SPAPI PF_Err 	(*PF_GetFontStyleSheet)(PF_FontStyleSheet		sheet,				/* >> */
											PF_FontName				*font_nameP0,		/* << */
											A_short					*font_numPS0,		/* << */
											A_short					*sizePS0,			/* << */
											A_short					*stylePS0);			/* << */
	
	// normally the effect should respond to PF_Event_ADJUST_CURSOR, but for changing
	//	the cursor during modal situations, you can use this API
	SPAPI PF_Err	(*PF_SetCursor)(		PF_CursorType		cursor);				/* >> */
	
	// as of AE6.5, this function returns TRUE if installed app is the render engine (as before)
	//				OR if the app is being run with no UI OR if the app is in watch-folder mode
	SPAPI PF_Err	(*PF_IsRenderEngine)(	PF_Boolean				*render_enginePB);		/* >> */
	
	// will return PF_Interrupt_CANCEL if user cancels dialog. color is in project working colorspace
	// if use_ws_to_monitor_xformB is TRUE, then the color chips and pickers are run through the
	// working space -> display transformation while interacting. set FALSE to have the raw RGB values
	// pushed directly to the screen. TRUE is intended for when the returned color is used in rendering, FALSE
	// is intended if the color is for UI elements or other nonrenderables.
	
	SPAPI PF_Err	(*PF_AppColorPickerDialog)(	const A_char			*dialog_titleZ0,				/* >> */
											   const PF_PixelFloat		*sample_colorP,					/* >> */
											   PF_Boolean				use_ws_to_monitor_xformB, 		/* >> */
											   PF_PixelFloat			*new_colorP);					/* << */
	
	// for use only when processing an event in an effect with custom UI
	SPAPI PF_Err	(*PF_GetMouse)(PF_Point* pointP);
	
	// NEW api in version 4.
	// Use it to invalidate rect of current window being drawn. Invalidated rect will be updated during idle time.
	// Specify PF_EO_UPDATE_NOW out flag to update the window immediately after the event returns. Specify rectP0
	// as NULL to invalidate the whole window.
	// Only valid while handling an non-draw event in the effect.
	SPAPI PF_Err	(*PF_InvalidateRect)(	const PF_ContextH	contextH,
										 const PF_Rect*		rectP0);
	
	// only safe to use when processing an event from a custom UI event.
	SPAPI PF_Err	(*PF_ConvertLocalToGlobal)(const PF_Point* localP, PF_Point* globalP);
	
	// this will return a deep color if over a content window containing 32bpc.
	// eyeSize == 0 will use the application pref as set by the user.
	SPAPI PF_Err	(*PF_GetColorAtGlobalPoint)(const PF_Point* globalP, A_short eyeSize, PF_EyeDropperSampleMode mode, PF_PixelFloat* outColorP);
	
} PFAppSuite4;


/* -------------------------------------------------------------------- */


#define kPFAppSuiteVersion5	7	/* frozen in AE 12.0 */

typedef struct PFAppSuite5 {		/* frozen in AE 12.0 */
	
	SPAPI PF_Err 	(*PF_AppGetBgColor)(	PF_App_Color			*bg_colorP);		/* << */
	
	SPAPI PF_Err 	(*PF_AppGetColor)(		PF_App_ColorType		color_type,			/* >> */
									  PF_App_Color			*app_colorP);		/* << */
	
	// Provides the active displayed language of AE UI so plugin can match. e.g. "en_US"
	SPAPI PF_Err 	(*PF_AppGetLanguage)(	A_char					*lang_tagZ);		/* << up to PF_APP_LANG_TAG_SIZE-1  */
	
	SPAPI PF_Err 	(*PF_GetPersonalInfo)(	PF_AppPersonalTextInfo	*ptiP);				/* << */
	
	SPAPI PF_Err 	(*PF_GetFontStyleSheet)(PF_FontStyleSheet		sheet,				/* >> */
											PF_FontName				*font_nameP0,		/* << */
											A_short					*font_numPS0,		/* << */
											A_short					*sizePS0,			/* << */
											A_short					*stylePS0);			/* << */
	
	// normally the effect should respond to PF_Event_ADJUST_CURSOR, but for changing
	//	the cursor during modal situations, you can use this API
	SPAPI PF_Err	(*PF_SetCursor)(		PF_CursorType		cursor);				/* >> */
	
	// as of AE6.5, this function returns TRUE if installed app is the render engine (as before)
	//				OR if the app is being run with no UI OR if the app is in watch-folder mode
	SPAPI PF_Err	(*PF_IsRenderEngine)(	PF_Boolean				*render_enginePB);		/* >> */
	
	// will return PF_Interrupt_CANCEL if user cancels dialog. color is in project working colorspace
	// if use_ws_to_monitor_xformB is TRUE, then the color chips and pickers are run through the
	// working space -> display transformation while interacting. set FALSE to have the raw RGB values
	// pushed directly to the screen. TRUE is intended for when the returned color is used in rendering, FALSE
	// is intended if the color is for UI elements or other nonrenderables.
	
	SPAPI PF_Err	(*PF_AppColorPickerDialog)(	const A_char			*dialog_titleZ0,				/* >> */
											   const PF_PixelFloat		*sample_colorP,					/* >> */
											   PF_Boolean				use_ws_to_monitor_xformB, 		/* >> */
											   PF_PixelFloat			*new_colorP);					/* << */
	
	// for use only when processing an event in an effect with custom UI
	SPAPI PF_Err	(*PF_GetMouse)(PF_Point* pointP);
	
	// NEW api in version 4.
	// Use it to invalidate rect of current window being drawn. Invalidated rect will be updated during idle time.
	// Specify PF_EO_UPDATE_NOW out flag to update the window immediately after the event returns. Specify rectP0
	// as NULL to invalidate the whole window.
	// Only valid while handling an non-draw event in the effect.
	SPAPI PF_Err	(*PF_InvalidateRect)(	const PF_ContextH	contextH,
										 const PF_Rect*		rectP0);
	
	// only safe to use when processing an event from a custom UI event.
	SPAPI PF_Err	(*PF_ConvertLocalToGlobal)(const PF_Point* localP, PF_Point* globalP);
	
	// this will return a deep color if over a content window containing 32bpc.
	// eyeSize == 0 will use the application pref as set by the user.
	SPAPI PF_Err	(*PF_GetColorAtGlobalPoint)(const PF_Point* globalP, A_short eyeSize, PF_EyeDropperSampleMode mode, PF_PixelFloat* outColorP);
	
	
} PFAppSuite5;

/* -------------------------------------------------------------------- */

#define kPFEffectCustomUISuite			"PF Effect Custom UI Suite"
#define kPFEffectCustomUISuiteVersion1	1 /* frozen in 10.0 */

// This suite provides basic apis needed for custom ui drawing in any window (Comp/Layer/ECW)

typedef struct PF_EffectCustomUISuite1 {
	
	// Get the drawing reference for custom ui drawing.
	SPAPI PF_Err	(*PF_GetDrawingReference)(	const PF_ContextH		effect_contextH,		/* >> */
											  DRAWBOT_DrawRef			*referenceP0);			/* << */
	
} PF_EffectCustomUISuite1;



```

---

<h2>Begin File: AE_EffectUI.h</h2>

```cpp
/*******************************************************************/
/*                                                                 */
/*                      ADOBE CONFIDENTIAL                         */
/*                   _ _ _ _ _ _ _ _ _ _ _ _ _                     */
/*                                                                 */
/* Copyright 2007 Adobe Systems Incorporated                       */
/* All Rights Reserved.                                            */
/*                                                                 */
/* NOTICE:  All information contained herein is, and remains the   */
/* property of Adobe Systems Incorporated and its suppliers, if    */
/* any.  The intellectual and technical concepts contained         */
/* herein are proprietary to Adobe Systems Incorporated and its    */
/* suppliers and may be covered by U.S. and Foreign Patents,       */
/* patents in process, and are protected by trade secret or        */
/* copyright law.  Dissemination of this information or            */
/* reproduction of this material is strictly forbidden unless      */
/* prior written permission is obtained from Adobe Systems         */
/* Incorporated.                                                   */
/*                                                                 */
/*******************************************************************/

/** AE_EffectUI.h

	Part of the After Effects SDK.

	Describes structures and callbacks used by plug-ins with Custom
	composition window and effect palette UIs.
 
**/

#ifndef _H_AE_EffectUI
#define _H_AE_EffectUI


#include <AE_Effect.h>

#ifdef ADOBE_SDK_INTERNAL		
	#include <adobesdk/private/drawbotsuite/DrawbotSuiteTypes.h>
#else
	#include <adobesdk/drawbotsuite/DrawbotSuiteTypes.h>
#endif


#include <adobesdk/config/PreConfig.h>





#ifdef __cplusplus
	extern "C" {
#endif


/** PF_CustomFlags
 **
 ** kinds of events and actions the custom parameter type might require
 **
 **/

enum {
	PF_CustomEFlag_NONE 			= 0,

	PF_CustomEFlag_COMP 			= 1L << 0,
	PF_CustomEFlag_LAYER			= 1L << 1,
	PF_CustomEFlag_EFFECT			= 1L << 2,
	PF_CustomEFlag_PREVIEW			= 1L << 3
};
typedef A_long PF_CustomEventFlags;


enum {
	PF_Window_NONE = -1,
	PF_Window_COMP,
	PF_Window_LAYER,
	PF_Window_EFFECT,
	PF_Window_PREVIEW
};
typedef A_long PF_WindowType;


/* $$$ document!

	new context -> evt extra has context and type, but everything else should be ignored
		fill in plugin_state[4]
	close context -> 
	all other evts -> params set up, but no layers 

*/
enum {
	PF_Event_NONE = -1,
	PF_Event_NEW_CONTEXT,
	PF_Event_ACTIVATE,
	PF_Event_DO_CLICK,
	PF_Event_DRAG,
	PF_Event_DRAW,
	PF_Event_DEACTIVATE,
	PF_Event_CLOSE_CONTEXT,
	PF_Event_IDLE,
	PF_Event_KEYDOWN_OBSOLETE,	// As of AE 7, this is no longer used.
	PF_Event_ADJUST_CURSOR,		// new for AE 4.0, sent when mouse moves over custom UI
	PF_Event_KEYDOWN,			// new for AE 7.0, replaces previous keydown event with cross platform codes and unicode characters.
	PF_Event_MOUSE_EXITED,		// new for AE 11.0, notification that the mouse is no longer over a specific view (layer or comp only).
	
	PF_Event_NUM_EVENTS
};
typedef A_long PF_EventType;


enum {
	PF_Cursor_NONE = 0,			// see comment in PF_AdjustCursorEventInfo
	PF_Cursor_CUSTOM,			// means effect set cursor itself with platform-specific calls
	PF_Cursor_ARROW,
	PF_Cursor_HOLLOW_ARROW,
	PF_Cursor_WATCH_N_WAIT,		// watch on the Mac, wait (hourglass) on Windows
	PF_Cursor_MAGNIFY,
	PF_Cursor_MAGNIFY_PLUS,
	PF_Cursor_MAGNIFY_MINUS,
	PF_Cursor_CROSSHAIRS,
	PF_Cursor_CROSS_RECT,
	PF_Cursor_CROSS_OVAL,
	PF_Cursor_CROSS_ROTATE,
	PF_Cursor_PAN,
	PF_Cursor_EYEDROPPER,
	PF_Cursor_HAND,
	PF_Cursor_PEN,
	PF_Cursor_PEN_ADD,
	PF_Cursor_PEN_DELETE,
	PF_Cursor_PEN_CLOSE,
	PF_Cursor_PEN_DRAG,
	PF_Cursor_PEN_CORNER,
	PF_Cursor_RESIZE_VERTICAL,
	PF_Cursor_RESIZE_HORIZONTAL,
	PF_Cursor_FINGER_POINTER,
	PF_Cursor_SCALE_HORIZ, 
	PF_Cursor_SCALE_DIAG_LR, 
	PF_Cursor_SCALE_VERT, 
	PF_Cursor_SCALE_DIAG_UR, 
	PF_Cursor_ROT_TOP, 
	PF_Cursor_ROT_TOP_RIGHT, 
	PF_Cursor_ROT_RIGHT, 
	PF_Cursor_ROT_BOT_RIGHT, 
	PF_Cursor_ROT_BOTTOM, 
	PF_Cursor_ROT_BOT_LEFT, 
	PF_Cursor_ROT_LEFT, 
	PF_Cursor_ROT_TOP_LEFT, 
	PF_Cursor_DRAG_CENTER,
	PF_Cursor_COPY, 
	PF_Cursor_ALIAS, 
	PF_Cursor_CONTEXT, 
	PF_Cursor_SLIP_EDIT, 
	PF_Cursor_CAMERA_ORBIT_CAMERA, 		//changed from PF_Cursor_ORBIT
	PF_Cursor_CAMERA_PAN_CAMERA,		//changed from PF_Cursor_TRACK_XY
	PF_Cursor_CAMERA_DOLLY_CAMERA, 		//changed from PF_Cursor_TRACK_Z
	PF_Cursor_ROTATE_X, 
	PF_Cursor_ROTATE_Y, 
	PF_Cursor_ROTATE_Z, 
	PF_Cursor_ARROW_X, 
	PF_Cursor_ARROW_Y, 
	PF_Cursor_ARROW_Z, 
	PF_Cursor_SCISSORS, 
	PF_Cursor_FAT_EYEDROPPER, 
	PF_Cursor_FINGER_POINTER_SCRUB, 
	PF_Cursor_HORZ_I_BEAM, 
	PF_Cursor_VERT_I_BEAM, 
	PF_Cursor_HORZ_BOX_I_BEAM, 
	PF_Cursor_VERT_BOX_I_BEAM, 
	PF_Cursor_I_BEAM_0,
	PF_Cursor_I_BEAM_11_25,
	PF_Cursor_I_BEAM_22_5,
	PF_Cursor_I_BEAM_33_75,
	PF_Cursor_I_BEAM_45,
	PF_Cursor_I_BEAM_56_25,
	PF_Cursor_I_BEAM_67_5,
	PF_Cursor_I_BEAM_78_75,
	PF_Cursor_I_BEAM_90,
	PF_Cursor_I_BEAM_101_25,
	PF_Cursor_I_BEAM_112_5,
	PF_Cursor_I_BEAM_123_75,
	PF_Cursor_I_BEAM_135,
	PF_Cursor_I_BEAM_146_25,
	PF_Cursor_I_BEAM_157_5,
	PF_Cursor_I_BEAM_168_75,
	PF_Cursor_CROSSHAIRS_PICKUP,
	PF_Cursor_ARROW_SELECTOR,
	PF_Cursor_LAYER_MOVE,
	PF_Cursor_MOVE_START_MARGIN,
	PF_Cursor_MOVE_END_MARGIN,
	PF_Cursor_SOLID_ARROW,
	PF_Cursor_HOLLOW_ARROW_PLUS,
	PF_Cursor_BRUSH_CENTER,
	PF_Cursor_CLONE_SOURCE,
	PF_Cursor_CLONE_SOURCE_OFFSET,
	PF_Cursor_HOLLOW_LAYER_MOVE,
	PF_Cursor_MOVE_TRACK_SEARCH_REGION,
	PF_Cursor_MOVE_TRACK_ATTACH_POINT,
	PF_Cursor_COLOR_CUBE_CROSS_SECTION,
	PF_Cursor_PEN_CORNER_ROTOBEZ_TENSION, 
	PF_Cursor_PIN, 
	PF_Cursor_PIN_ADD, 
	PF_Cursor_MESH_ADD, 
	PF_Cursor_MARQUEE, 
	PF_Cursor_CROSS_ROUNDED_RECT, 
	PF_Cursor_CROSS_POLYGON, 
	PF_Cursor_CROSS_STAR, 
	PF_Cursor_PIN_STARCH, 
	PF_Cursor_PIN_OVERLAP, 
	PF_Cursor_STOPWATCH,
	PF_Cursor_DRAG_DOT,
	PF_Cursor_DRAG_CIRCLE,
	PF_Cursor_DIRECT_SELECT,
	PF_Cursor_DRAG_COPY_MOVE,
	PF_Cursor_DRAG_COPY_ROTATE,
	PF_Cursor_CAMERA_MAYA,			//Changed from PF_Cursor_MAYA
	PF_Cursor_RESIZE_HORIZONTAL_LEFT,
	PF_Cursor_RESIZE_HORIZONTAL_RIGHT,
	PF_Cursor_FEATHER,
	PF_Cursor_FEATHER_ADD,
	PF_Cursor_FEATHER_DELETE,
	PF_Cursor_FEATHER_MOVE,
	PF_Cursor_FEATHER_TENSION, 
	PF_Cursor_FEATHER_MARQUEE,
	PF_Cursor_LASSO_ARROW, 
	PF_Cursor_DRAG_NO_DROP,
	PF_Cursor_DRAG_COPY,
	PF_Cursor_DRAG_LINK,
	PF_Cursor_PIN_BEND,
	PF_Cursor_PIN_ADVANCED,
	PF_Cursor_CAMERA_ORBIT_CURSOR,
	PF_Cursor_CAMERA_ORBIT_SCENE,
	PF_Cursor_CAMERA_PAN_CURSOR,
	PF_Cursor_CAMERA_DOLLY_TOWARDS_CURSOR,
	PF_Cursor_CAMERA_DOLLY_TO_CURSOR,

	PF_MAX_CURSOR_PLUS_ONE
};
typedef A_long PF_CursorType;


enum {
	PF_Mod_NONE					= 0x0000,
	PF_Mod_CMD_CTRL_KEY			= 0x0100,		// cmd on Mac, ctrl on Windows
	PF_Mod_SHIFT_KEY			= 0x0200,
	PF_Mod_CAPS_LOCK_KEY		= 0x0400,
	PF_Mod_OPT_ALT_KEY			= 0x0800,		// option on Mac, alt on Windows
	PF_Mod_MAC_CONTROL_KEY		= 0x1000		// Mac control key only
};
typedef A_long PF_Modifiers;


typedef struct {
	PF_Point			screen_point;		/* >> where the mouse is right now */
	PF_Modifiers		modifiers;			/* >> modifiers right now */
	PF_CursorType		set_cursor;			/* << set this to your desired cursor, or PF_Cursor_CUSTOM if you
													set the cursor yourself, or PF_Cursor_NONE if you don't
													want to override the cursor (i.e. the app will set the
													cursor however it wants) */
} PF_AdjustCursorEventInfo;

typedef struct {
	A_u_long			when;
	PF_Point			screen_point;
	A_long				num_clicks;
	PF_Modifiers		modifiers;
	A_intptr_t			continue_refcon[4];	/* <> if send_drag is TRUE, set this */
	PF_Boolean			send_drag;			/* << set this from a do_click to get a drag */
	PF_Boolean			last_time;			/* >> set the last time you get a drag */
} PF_DoClickEventInfo;


typedef struct {
	PF_UnionableRect	update_rect;		// in window's coordinate system
	A_long				depth;
} PF_DrawEventInfo;


typedef struct {				
	A_u_long			when;
	PF_Point			screen_point;
	A_long				char_code;
	A_long				key_code;
	PF_Modifiers		modifiers;
} PF_KeyDownEventObsolete;	// As of AE 7, this is no longer used.


typedef A_u_long	PF_KeyCode;				// For printable characters, we use the unshifted upper case version (A not a, 7 not &).
typedef A_u_short	PF_ControlCode;

typedef struct {					
	A_u_long			when;
	PF_Point			screen_point;
	PF_KeyCode			keycode;		// as of AE 7, this is either a control code, or character code
	PF_Modifiers		modifiers;

} PF_KeyDownEvent;


enum {
	PF_KEYCODE_FLAG_Printable			= 1 << 31,		// a printable key, otherwise a control code like page up
	PF_KEYCODE_FLAG_Extended			= 1 << 30		// an alternate key, typically on the numeric keypad.
};

#define PF_GENERATE_KEYBOARD_CODE_VALUE(CODE_VALUE, FLAGS)					(((CODE_VALUE) & 0xFFFF) | (FLAGS))
#define PF_GENERATE_KEYBOARD_CODE_VALUE_FROM_CHARACTER(CHAR)				PF_GENERATE_KEYBOARD_CODE_VALUE(CHAR, PF_KEYCODE_FLAG_Printable)
#define PF_GENERATE_KEYBOARD_CODE_VALUE_FROM_CHARACTER_EXTENDED(CHAR)		PF_GENERATE_KEYBOARD_CODE_VALUE(CHAR, PF_KEYCODE_FLAG_Printable | PF_KEYCODE_FLAG_Extended)
#define PF_GENERATE_KEYBOARD_CODE_VALUE_FROM_CONTROL_CODE(CODE)				PF_GENERATE_KEYBOARD_CODE_VALUE(CODE, 0)
#define PF_GENERATE_KEYBOARD_CODE_VALUE_FROM_CONTROL_CODE_EXTENDED(CODE)	PF_GENERATE_KEYBOARD_CODE_VALUE(CODE, PF_KEYCODE_FLAG_Extended)

#define PF_KEYCODE_IS_PRINTABLE(_KEY_CODE)				(((_KEY_CODE) & PF_KEYCODE_FLAG_Printable ) != 0) 
#define PF_KEYCODE_IS_EXTENDED(_KEY_CODE)				(((_KEY_CODE) & PF_KEYCODE_FLAG_Extended ) != 0) 

#define PF_KEYCODE_GET_SHORTCUT_CHARACTER(_KEY_CODE)	(PF_KEYCODE_IS_PRINTABLE(_KEY_CODE)) ? ((_KEY_CODE) & 0xFFFF) : 0
#define PF_KEYCODE_GET_CONTROL_CODE(_KEY_CODE)			(!PF_KEYCODE_IS_PRINTABLE(_KEY_CODE)) ? ((_KEY_CODE) & 0xFFFF) : 0

enum {
	PF_ControlCode_Unknown		= (PF_ControlCode)0xFFFF,

	PF_ControlCode_Space		= 1,
	PF_ControlCode_Backspace,
	PF_ControlCode_Tab,
	PF_ControlCode_Return,
	PF_ControlCode_Enter,

	PF_ControlCode_Escape,

	PF_ControlCode_F1,
	PF_ControlCode_F2,
	PF_ControlCode_F3,
	PF_ControlCode_F4,
	PF_ControlCode_F5,
	PF_ControlCode_F6,
	PF_ControlCode_F7,
	PF_ControlCode_F8,
	PF_ControlCode_F9,
	PF_ControlCode_F10,
	PF_ControlCode_F11,
	PF_ControlCode_F12,
	PF_ControlCode_F13,
	PF_ControlCode_F14,
	PF_ControlCode_F15,
	PF_ControlCode_F16,
	PF_ControlCode_F17,
	PF_ControlCode_F18,
	PF_ControlCode_F19,
	PF_ControlCode_F20,
	PF_ControlCode_F21,
	PF_ControlCode_F22,
	PF_ControlCode_F23,
	PF_ControlCode_F24,

	PF_ControlCode_PrintScreen,
	PF_ControlCode_ScrollLock,
	PF_ControlCode_Pause,

	PF_ControlCode_Insert,
	PF_ControlCode_Delete,
	PF_ControlCode_Home,
	PF_ControlCode_End,
	PF_ControlCode_PageUp,
	PF_ControlCode_PageDown,
	PF_ControlCode_Help,
	PF_ControlCode_Clear,

	PF_ControlCode_Left,
	PF_ControlCode_Right,
	PF_ControlCode_Up,
	PF_ControlCode_Down,

	PF_ControlCode_NumLock,

	PF_ControlCode_Command,
	PF_ControlCode_Option,
	PF_ControlCode_Alt = PF_ControlCode_Option,
	PF_ControlCode_Control,
	PF_ControlCode_Shift,
	PF_ControlCode_CapsLock,

	PF_ControlCode_ContextMenu
};


typedef union {
	PF_DoClickEventInfo			do_click;		// also drag
	PF_DrawEventInfo			draw;
	PF_KeyDownEvent				key_down;
	PF_AdjustCursorEventInfo	adjust_cursor;

	// add other event types here
		
} PF_EventUnion;

#if	defined(A_INTERNAL) && defined (__cplusplus)
	class FLT_FCSeqSpec;
	typedef	FLT_FCSeqSpec				*PF_ContextRefcon;
#else
	typedef	struct _PF_ContextRefcon	*PF_ContextRefcon;
#endif

#define			PF_CONTEXT_MAGIC		0x05ea771e
typedef struct {
	A_u_long			magic;
	PF_WindowType		w_type;
	PF_ContextRefcon	reserved_flt;
	A_intptr_t			plugin_state[4];	// plug-in specific data
	DRAWBOT_DrawRef		reserved_drawref;
	void				*reserved_paneP;
  	void                            *reserved_job_manageP;  // used for managing async job requests for UI in the context of Effect pane custom UI
} PF_Context, *PF_ContextPtr, **PF_ContextH;

typedef enum {
	PenTip,
	PenEraser
} PF_StylusTool;

typedef struct {
	// only applies when stylus_dataB == true;
	A_FpShort			stylus_tiltxF;		// 	-1.0 to 1.0	0.0 == vertical
	A_FpShort			stylus_tiltyF;		// 	-1.0 to 1.0	0.0 == vertical
	A_FpShort			stylus_pressureF;	//  0.0 to 1.0	1.0 == full pressure
	A_FpShort			stylus_wheelF;		// 	-1.0 to 1.0	0.0 == none
} PF_StylusEventInfo;

typedef struct PF_PointerEventInfo {
	A_FpLong			when_secondsF;
	PF_Point			screen_point;
	A_short				num_clicksS;
	A_long				mod_keysL;

	PF_StylusTool		stylus_tool;		// set to PenTip when using mouse
	PF_Boolean			stylus_extra_dataB;
	PF_StylusEventInfo	stylus_extra_data;  // only valid when stylus_extra_dataB == true
} PF_PointerEventInfo;

typedef struct {
	void		*refcon;			// front-end's refcon
	
	PF_Err		(*layer_to_comp)(void *refcon, 			/* >> */
								PF_ContextH context,	/* >> */
								A_long curr_time,			/* >> */
								A_long time_scale,		/* >> */
								PF_FixedPoint *pt);		/* << */
								
	PF_Err		(*comp_to_layer)(void *refcon, 			/* >> */
								PF_ContextH context, 	/* >> */
								A_long curr_time, 		/* >> */
								A_long time_scale,	 	/* >> */
								PF_FixedPoint *pt);		/* << */

	PF_Err		(*get_comp2layer_xform)(void *refcon, 	/* >> */
								PF_ContextH context,	/* >> */
								A_long curr_time, 		/* >> */
								A_long time_scale, 		/* >> */
								A_long *exists,			/* << non-zero if exists */
								PF_FloatMatrix *c2l);	/* << */
								
	PF_Err		(*get_layer2comp_xform)(void *refcon,	/* >> */
								PF_ContextH context, 	/* >> */
								A_long curr_time, 		/* >> */
								A_long time_scale, 		/* >> */
								PF_FloatMatrix *l2c);	/* << */
	
	PF_Err		(*source_to_frame)(void *refcon, PF_ContextH context, PF_FixedPoint *pt);
	PF_Err		(*frame_to_source)(void *refcon, PF_ContextH context, PF_FixedPoint *pt);

	PF_Err		(*info_draw_color)(void *refcon, PF_Pixel color);

	// 2 lines of text, same as calling PF_InfoDrawText3( line1Z0, line2Z0, NULL)
	PF_Err		(*info_draw_text)(void *refcon, const A_char *text1Z0, const A_char *text2Z0);	// Cstrings

	// Due to this structure's containment within PF_EventExtra,
	// we are unable to add new functions to this structure in order
	// to remain backwards compatible.  In other words, do not add any
	// new functions here, add them to the PF_AdvAppSuite1 suite
	// within AE_AdvEffectSuites.h. -jja 10-24-2000
	
} PF_EventCallbacks, *PF_EventCallbacksPtr;

enum {
	PF_EA_NONE = 0,
	PF_EA_PARAM_TITLE,
	PF_EA_CONTROL
};
typedef	A_long	PF_EffectArea;

typedef struct {
	PF_ParamIndex			index;
	PF_EffectArea			area;
	PF_UnionableRect		current_frame;		// full frame of the current area
	PF_UnionableRect		param_title_frame;	// full frame of the param title area
 	A_long					horiz_offset;		// h offset to draw into title
} PF_EffectWindowInfo;

enum {
	PF_EO_NONE				= 0,
	PF_EO_HANDLED_EVENT		= (1L << 0),
	PF_EO_ALWAYS_UPDATE		= (1L << 1),	//rerender the comp
	PF_EO_NEVER_UPDATE		= (1L << 2),	//do not rerender the comp
	PF_EO_UPDATE_NOW		= (1L << 3)		//update the view immediately after the event returns when using PF_InvalidateRect
};
typedef	A_long	PF_EventOutFlags;

enum {
	PF_EI_NONE = 0,
	PF_EI_DONT_DRAW			= 1L << 0		// don't draw controls in comp or layer window
};
typedef	A_long	PF_EventInFlags;

//	this info is passed for ALL event types, except those in the Effect Control Window
//	in ECW, you get the PF_EffectWindowInfo, during all events
typedef struct {
	PF_UnionableRect		port_rect;
} PF_ItemWindowInfo;

/*
	to know what union to take, look in 
	(**contextH).w_type.  if == effect win, you get effect win, else you get item win
*/
typedef union {
	PF_EffectWindowInfo		effect_win;			/* >> only for Effect window do_click, draw, and adjust-cursor */
	PF_ItemWindowInfo		item_win;			/* >> comp or layer		*/
} PF_WindowUnion;

//	uncomment if you want to get the port rect during most events
//	#define	PF_USE_NEW_WINDOW_UNION
typedef struct {
	PF_ContextH				contextH;			/* >> */
	PF_EventType			e_type;				/* >> */
	PF_EventUnion			u;					/* >> based on e_type */
	
	#ifdef PF_USE_NEW_WINDOW_UNION
		PF_WindowUnion			window_union;		/* >> union of window-specific handy information	*/
	#else
		PF_EffectWindowInfo		effect_win;			/* >> only for Effect window do_click, draw, and adjust-cursor */
	#endif

	PF_EventCallbacks		cbs;				/* >> not for new_context or close_context */
	PF_EventInFlags			evt_in_flags;		/* >> */
	PF_EventOutFlags		evt_out_flags;		/* << */
} PF_EventExtra;

enum {
	PF_UIAlignment_NONE = 0,					// No values other than PF_UIAlignment_NONE are honored, in AE or PPro.
	PF_UIAlignment_TOP = 1L << 0,
	PF_UIAlignment_LEFT = 1L << 1,
	PF_UIAlignment_BOTTOM = 1L << 2,
	PF_UIAlignment_RIGHT = 1L << 3
};

typedef A_long PF_UIAlignment;

struct _PF_CustomUIInfo {
	
	A_long					reserved;
	PF_CustomEventFlags		events;

	A_long				comp_ui_width;
	A_long				comp_ui_height;
	PF_UIAlignment		comp_ui_alignment;			// unused
	
	A_long				layer_ui_width;
	A_long				layer_ui_height;
	PF_UIAlignment		layer_ui_alignment;			// unused

	A_long				preview_ui_width;			// unused
	A_long				preview_ui_height;			// unused
	PF_UIAlignment		preview_ui_alignment;		// unused

};


#ifdef __cplusplus
}
#endif


#include <adobesdk/config/PostConfig.h>



#endif /* _H_AE_EffectUI */

```

---

<h2>Begin File: AE_EffectVers.h</h2>

```cpp
#ifndef _H_AE_EffectVers
#define _H_AE_EffectVers


#define AEFX_API_VERSION			8
#define AEFX_API_SUBVERS			' '
#define	AEFXp_CODE_VERSION			0		// no longer user, we have p4 now

// these are here as copies -> when these change in AE_Effect.h, AEFX won't compile
// when they change, decide how to update above versions
// NOTE: this file is included by effect\shared\AEFX_PiPL.r and these versions are
//			used when building PiPLs
#define PF_PLUG_IN_VERSION			13	// auto-set by prep_codeline_for_release.py, adjust comment if manually edit is okay
#define PF_PLUG_IN_SUBVERS			28	// manually set for new 'Support URL' field in PiPL and new entry point


#endif

```

---

<h2>Begin File: AE_GeneralPlug.h</h2>

```cpp
/*******************************************************************/
/*                                                                 */
/*                      ADOBE CONFIDENTIAL                         */
/*                   _ _ _ _ _ _ _ _ _ _ _ _ _                     */
/*                                                                 */
/* Copyright 2007 Adobe Systems Incorporated                       */
/* All Rights Reserved.                                            */
/*                                                                 */
/* NOTICE:  All information contained herein is, and remains the   */
/* property of Adobe Systems Incorporated and its suppliers, if    */
/* any.  The intellectual and technical concepts contained         */
/* herein are proprietary to Adobe Systems Incorporated and its    */
/* suppliers and may be covered by U.S. and Foreign Patents,       */
/* patents in process, and are protected by trade secret or        */
/* copyright law.  Dissemination of this information or            */
/* reproduction of this material is strictly forbidden unless      */
/* prior written permission is obtained from Adobe Systems         */
/* Incorporated.                                                   */
/*                                                                 */
/*******************************************************************/

#ifndef _H_AE_PlugGeneral
#define _H_AE_PlugGeneral

#include <A.h>
#include <FIEL_Public.h>
#include <AE_Effect.h>
#include <AE_EffectCB.h>
#include <SPBasic.h>

#include <PR_Public.h>
#include <PF_Masks.h>
#include <AE_EffectSuites.h>
#ifdef AEGP_INTERNAL
#include <AE_GeneralPlug_Private.h>
#endif
#include <AE_IO.h>
#include <PT_Public.h>


#include <AE_GeneralPlugPre.h>

#define AEGP_PLUGIN_TYPE			'AEgx'

#define AEGP_INITFUNC_MAJOR_VERSION			1
#define AEGP_INITFUNC_MINOR_VERSION			9

#ifndef AEGP_INTERNAL
	typedef struct _AEGP_Project			**AEGP_ProjectH;
	typedef struct _AEGP_Item 				**AEGP_ItemH;
	typedef struct _AEGP_Comp				**AEGP_CompH;
	typedef struct _AEGP_Footage			**AEGP_FootageH;
	typedef struct _AEGP_Layer				**AEGP_LayerH;
	typedef struct _AEGP_Effect				**AEGP_EffectRefH;
	typedef struct _AEGP_Mask				**AEGP_MaskRefH;
	typedef struct _AEGPp_Stream			**AEGP_StreamRefH;
	typedef struct _AEGP_LayerContext		**AEGP_RenderLayerContextH;
	typedef struct _AEGP_PersistentBlob		**AEGP_PersistentBlobH;
	typedef struct _AEGP_MaskOutline		**AEGP_MaskOutlineValH;
	typedef struct _AEGP_Collection			**AEGP_CollectionH;
	typedef struct _AEGP_Collection2		**AEGP_Collection2H;
	typedef struct _AEGP_SoundData			**AEGP_SoundDataH;
	typedef struct _AEGP_AddKeyframesInfo	**AEGP_AddKeyframesInfoH;
	typedef struct _AEGP_RenderReceipt		**AEGP_RenderReceiptH;
	typedef struct _AEGP_World				**AEGP_WorldH;
	typedef struct _AEGP_RenderOptions		**AEGP_RenderOptionsH;
	typedef struct _AEGP_LayerRenderOptions	**AEGP_LayerRenderOptionsH;
	typedef struct _AEGP_FrameReceipt		**AEGP_FrameReceiptH;
	typedef struct _AEGP_RenderQueueItem 	**AEGP_RQItemRefH;
	typedef struct _AEGP_OutputModule		**AEGP_OutputModuleRefH;
	typedef struct _AEGP_TextDocument		**AEGP_TextDocumentH;
	typedef struct _AEGP_MarkerVal			*AEGP_MarkerValP;
    // AEGP_ConstMarkerValP is defined in AE_IO.h;
	typedef struct _AEGP_TextOutlines		**AEGP_TextOutlinesH;
	typedef struct _AEGP_TimeStamp{A_char a[4];}	AEGP_TimeStamp;
	typedef struct _AEGP_PlatformWorld		**AEGP_PlatformWorldH;
	typedef	struct _AEGP_ItemView			*AEGP_ItemViewP;
	typedef struct _AEGP_ColorProfile		*AEGP_ColorProfileP;
	typedef const struct _AEGP_ColorProfile	*AEGP_ConstColorProfileP;
#endif

typedef A_long	AEGP_SubLayerIndex;

#define AEGP_SubLayer_ALL			(-1L)

typedef A_long	AEGP_PluginID;
// define a _AEGP_Refcon1 struct to use a typesafe refcon.
typedef struct _AEGP_GlobalRefcon				*AEGP_GlobalRefcon;
typedef struct _AEGP_CommandRefcon				*AEGP_CommandRefcon;
typedef struct _AEGP_UpdateMenuRefcon			*AEGP_UpdateMenuRefcon;
typedef struct _AEGP_DeathRefcon				*AEGP_DeathRefcon;
typedef struct _AEGP_VersionRefcon				*AEGP_VersionRefcon;
typedef struct _AEGP_AboutStringRefcon			*AEGP_AboutStringRefcon;
typedef struct _AEGP_AboutRefcon				*AEGP_AboutRefcon;
typedef struct _AEGP_AsyncFrameRequestRefcon	*AEGP_AsyncFrameRequestRefcon;
typedef struct _AEGP_IdleRefcon					*AEGP_IdleRefcon;
typedef struct _AEGP_IORefcon					*AEGP_IORefcon;
typedef struct _AEGP_CancelRefcon				*AEGP_CancelRefcon;


// _SIZE constants include space for the terminating null. -1 for string length.
#define		AEGP_MAX_PATH_SIZE					260
#define		AEGP_MAX_ABOUT_STRING_SIZE			256
#define		AEGP_MAX_RQITEM_COMMENT_SIZE		256
#define		AEGP_MAX_TYPE_NAME_SIZE				32
#define		AEGP_MAX_ITEM_NAME_SIZE				32
#define		AEGP_MAX_ITEM_NAME_SIZE				32
#define		AEGP_MAX_LAYER_NAME_SIZE			32
#define		AEGP_MAX_MASK_NAME_SIZE				32
#define		AEGP_MAX_EFFECT_NAME_SIZE			(PF_MAX_EFFECT_NAME_LEN + 17)
#define		AEGP_MAX_EFFECT_MATCH_NAME_SIZE		(PF_MAX_EFFECT_NAME_LEN + 17)
#define		AEGP_MAX_EFFECT_CATEGORY_NAME_SIZE	(PF_MAX_EFFECT_CATEGORY_NAME_LEN + 1)
#define		AEGP_MAX_STREAM_NAME_SIZE			(PF_MAX_EFFECT_PARAM_NAME_LEN + 1)
#define		AEGP_MAX_STREAM_UNITS_SIZE			(PF_MAX_EFFECT_PARAM_NAME_LEN + 1)
#define		AEGP_MAX_PROJ_NAME_SIZE				48
#define		AEGP_MAX_PLUGIN_NAME_SIZE			32

#define		AEGP_MAX_MARKER_NAME_SIZE			64
#define		AEGP_MAX_MARKER_URL_SIZE			1024
#define		AEGP_MAX_MARKER_TARGET_SIZE			128
#define		AEGP_MAX_MARKER_CHAPTER_SIZE		128


enum {
	AEGP_Platform_MAC,
	AEGP_Platform_WIN
};
typedef	A_long	AEGP_Platform;

enum {
	AEGP_ProjBitDepth_8 = 0,
	AEGP_ProjBitDepth_16,
	AEGP_ProjBitDepth_32,
	AEGP_ProjBitDepth_NUM_VALID_DEPTHS
};
typedef A_char AEGP_ProjBitDepth;

#define AEGP_Index_NONE			((A_long)0x80000000)
#define AEGP_Index_START		((A_long)0)
#define AEGP_Index_END			((A_long)-1)

typedef A_long 	AEGP_Index;

#define AEGP_LayerIDVal_NONE			(0L)

typedef A_long			AEGP_LayerIDVal;

#define AEGP_MaskIDVal_NONE			(0L)

typedef A_long			AEGP_MaskIDVal;

typedef struct {
	A_FpLong		alphaF, redF, greenF, blueF;  // in the range [0.0 - 1.0]
} AEGP_ColorVal;


enum {
	AEGP_CameraType_NONE = -1,

	AEGP_CameraType_PERSPECTIVE,
	AEGP_CameraType_ORTHOGRAPHIC,

	AEGP_CameraType_NUM_TYPES
};

typedef A_u_long AEGP_CameraType;

enum {
	AEGP_FootageDepth_1		= 1,
	AEGP_FootageDepth_2  		= 2,
	AEGP_FootageDepth_4  		= 4,
	AEGP_FootageDepth_8  		= 8,
	AEGP_FootageDepth_16 		= 16,
	AEGP_FootageDepth_24 		= 24,
	AEGP_FootageDepth_30		= 30,
	AEGP_FootageDepth_32 		= 32,
	AEGP_FootageDepth_GRAY_2 	= 34,
	AEGP_FootageDepth_GRAY_4 	= 36,
	AEGP_FootageDepth_GRAY_8 	= 40,
	AEGP_FootageDepth_48	 	= 48,
	AEGP_FootageDepth_64	 	= 64,
	AEGP_FootageDepth_GRAY_16	= -16
};


enum {
	AEGP_FilmSizeUnits_NONE = 0,
	AEGP_FilmSizeUnits_HORIZONTAL,
	AEGP_FilmSizeUnits_VERTICAL,
	AEGP_FilmSizeUnits_DIAGONAL
};
typedef A_long AEGP_FilmSizeUnits;


enum {
	AEGP_LightType_NONE = -1,

	AEGP_LightType_PARALLEL,
	AEGP_LightType_SPOT,
	AEGP_LightType_POINT,
	AEGP_LightType_AMBIENT,
	AEGP_LightType_RESERVED1,

	AEGP_LightType_NUM_TYPES
};

typedef A_u_long AEGP_LightType;


enum {
	AEGP_LightFalloff_NONE = 0,
	AEGP_LightFalloff_SMOOTH,
	AEGP_LightFalloff_INVERSE_SQUARE_CLAMPED
};

typedef A_u_long AEGP_LightFalloffType;


/* -------------------------------------------------------------------- */

enum {
	AEGP_TimeDisplayType_TIMECODE = 0,
	AEGP_TimeDisplayType_FRAMES,
	AEGP_TimeDisplayType_FEET_AND_FRAMES
};
typedef A_char AEGP_TimeDisplayType;

#define AEGP_FramesPerFoot_35MM		16
#define AEGP_FramesPerFoot_16MM		40

typedef struct {	// note: unused values are still stored in settings and used when cycling through
					//	the 3 types using cmd/ctrl-click on timecode
	AEGP_TimeDisplayType	time_display_type;
	A_char					timebaseC;			// only used for AEGP_TimeDisplayType_TIMECODE, 1 to 100
	A_Boolean				non_drop_30B;		// only used for AEGP_TimeDisplayType_TIMECODE,
												//	when timebaseC == 30 && item framerate == 29.97, use drop frame or non-drop?
	A_char					frames_per_footC;	// only used for AEGP_TimeDisplayType_FEET_AND_FRAMES
	A_long					starting_frameL;	// usually 0 or 1, not used for AEGP_TimeDisplayType_TIMECODE
	A_Boolean				auto_timecode_baseB;
} AEGP_TimeDisplay2;

enum {
	AEGP_TimeDisplay_TIMECODE = 0,
	AEGP_TimeDisplay_FRAMES
};
typedef char AEGP_TimeDisplayMode;

enum {
	AEGP_SourceTimecode_ZERO	= 0,
	AEGP_SourceTimecode_SOURCE_TIMECODE
};
typedef char AEGP_SourceTimecodeDisplayMode;

enum {
	AEGP_Frames_ZERO_BASED	= 0,
	AEGP_Frames_ONE_BASED,
	AEGP_Frames_TIMECODE_CONVERSION
};
typedef char AEGP_FramesDisplayMode;

typedef struct {
	AEGP_TimeDisplayMode				display_mode;
	AEGP_SourceTimecodeDisplayMode		footage_display_mode;
	A_Boolean							display_dropframeB;
	A_Boolean							use_feet_framesB;
	A_char								timebaseC;
	A_char								frames_per_footC;
	AEGP_FramesDisplayMode				frames_display_mode;
} AEGP_TimeDisplay3;



#define kAEGPProjSuite				"AEGP Proj Suite"
#define kAEGPProjSuiteVersion6		9	/* frozen in AE 10.5 */

typedef struct AEGP_ProjSuite6 {

	SPAPI A_Err	(*AEGP_GetNumProjects)(									/* will always (in 5.0) return 1 if project is open */
		A_long				*num_projPL);				/* << */

	SPAPI A_Err	(*AEGP_GetProjectByIndex)(
		A_long				proj_indexL,				/* >> */
		AEGP_ProjectH		*projPH);					/* << */

	SPAPI A_Err	(*AEGP_GetProjectName)(
		AEGP_ProjectH		projH,						/* >> */
		A_char 				*nameZ);					/* << space for A_char[AEGP_MAX_PROJ_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetProjectPath)(
		AEGP_ProjectH		projH,						/* >> */
		AEGP_MemHandle		*unicode_pathPH);			// << empty string if no file. handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle

	SPAPI A_Err	(*AEGP_GetProjectRootFolder)(
		AEGP_ProjectH		projH,						/* >> */
		AEGP_ItemH			*root_folderPH);			/* << */

	SPAPI A_Err (*AEGP_SaveProjectToPath)(
		AEGP_ProjectH		projH,						/* >> */
		const A_UTF16Char	*pathZ);					// >> null terminated unicode path with platform separators

	SPAPI A_Err (*AEGP_GetProjectTimeDisplay)(
		AEGP_ProjectH		projH,						/* >> */
		AEGP_TimeDisplay3	*time_displayP);			/* << */

	SPAPI A_Err (*AEGP_SetProjectTimeDisplay)(							/* UNDOABLE */
		AEGP_ProjectH			projH,					/* <> */
		const AEGP_TimeDisplay3	*time_displayP);		/* >> */

	SPAPI A_Err (*AEGP_ProjectIsDirty)(
		AEGP_ProjectH		projH,						/* >> */
		A_Boolean			*is_dirtyPB);				/* << */

	SPAPI A_Err (*AEGP_SaveProjectAs)(
		AEGP_ProjectH		projH,						/* >> */
		const A_UTF16Char	*pathZ);					// >> null terminated unicode path with platform separators

	SPAPI A_Err (*AEGP_NewProject)(
		AEGP_ProjectH	*new_projectPH);				/* << WARNING: Will close any open projects! */

	// WARNING: Will close any open projects!
	SPAPI A_Err (*AEGP_OpenProjectFromPath)(
		const A_UTF16Char	*pathZ,						// >> null terminated unicode path with platform separators
		AEGP_ProjectH		*projectPH);				/* << */

	SPAPI A_Err	(*AEGP_GetProjectBitDepth)(
		AEGP_ProjectH		projectH,					/* >> */
		AEGP_ProjBitDepth	*bit_depthP);				/* << */

	SPAPI A_Err	(*AEGP_SetProjectBitDepth)(								/* UNDOABLE */
		AEGP_ProjectH		projectH,					/* >> */
		AEGP_ProjBitDepth	bit_depth);					/* >> */

} AEGP_ProjSuite6;

/* -------------------------------------------------------------------- */

enum {
	AEGP_SoundEncoding_UNSIGNED_PCM = 3,
	AEGP_SoundEncoding_SIGNED_PCM,
	AEGP_SoundEncoding_FLOAT,
	AEGP_SoundEncoding_END,
	AEGP_SoundEncoding_BEGIN = AEGP_SoundEncoding_UNSIGNED_PCM
};
typedef A_long AEGP_SoundEncoding;

typedef struct AEGP_SoundDataFormat {
	A_FpLong				sample_rateF;
	AEGP_SoundEncoding		encoding;
	A_long					bytes_per_sampleL;		/* 1, 2, or 4 only (ignored if encoding == AEGP_SoundEncoding_FLOAT) */
	A_long					num_channelsL;			/* 1 for mono, 2 for stereo */
}AEGP_SoundDataFormat;


enum {
	AEGP_ItemType_NONE,
	AEGP_ItemType_FOLDER,
	AEGP_ItemType_COMP,
	AEGP_ItemType_SOLID_defunct,	// as of AE6, solids are now just AEGP_ItemType_FOOTAGE with AEGP_FootageSignature_SOLID
	AEGP_ItemType_FOOTAGE,
	AEGP_ItemType_NUM_TYPES1
};
typedef A_short AEGP_ItemType;


enum {
	AEGP_ItemFlag_MISSING			= 0x1,			/* footage property: here for convenience	*/
	AEGP_ItemFlag_HAS_PROXY			= 0x2,
	AEGP_ItemFlag_USING_PROXY		= 0x4,			/* is using the proxy as source				*/
	AEGP_ItemFlag_MISSING_PROXY		= 0x8,			/* footage property: here for convenience	*/
	AEGP_ItemFlag_HAS_VIDEO			= 0x10,			/* is there a video track?					*/
	AEGP_ItemFlag_HAS_AUDIO			= 0x20,			/* is there an audio track?					*/
	AEGP_ItemFlag_STILL				= 0x40,			/* are all frames exactly the same			*/
	AEGP_ItemFlag_HAS_ACTIVE_AUDIO	= 0x80			/* new in AE CS 5.5: is there an audio track, and is it also turned on right now? */
};
typedef A_long AEGP_ItemFlags;


enum {
	AEGP_Label_NONE = -1,			/* undefined sentinel value	*/
	AEGP_Label_NO_LABEL = 0,
	AEGP_Label_1,
	AEGP_Label_2,
	AEGP_Label_3,
	AEGP_Label_4,
	AEGP_Label_5,
	AEGP_Label_6,
	AEGP_Label_7,
	AEGP_Label_8,
	AEGP_Label_9,
	AEGP_Label_10,
	AEGP_Label_11,
	AEGP_Label_12,
	AEGP_Label_13,
	AEGP_Label_14,
	AEGP_Label_15,
	AEGP_Label_16,			// label 16 is new in AE 10.0 (CS5)

	AEGP_Label_NUMTYPES
};
typedef A_char AEGP_LabelID;

/* -------------------------------------------------------------------- */

enum {
	AEGP_PersistentType_MACHINE_SPECIFIC,
	AEGP_PersistentType_MACHINE_INDEPENDENT,
	AEGP_PersistentType_MACHINE_INDEPENDENT_RENDER,
	AEGP_PersistentType_MACHINE_INDEPENDENT_OUTPUT,
	AEGP_PersistentType_MACHINE_INDEPENDENT_COMPOSITION,
	AEGP_PersistentType_MACHINE_SPECIFIC_TEXT,
	AEGP_PersistentType_MACHINE_SPECIFIC_PAINT,
	AEGP_PersistentType_MACHINE_SPECIFIC_EFFECTS,
	AEGP_PersistentType_MACHINE_SPECIFIC_EXPRESSION_SNIPPETS,
	AEGP_PersistentType_MACHINE_SPECIFIC_SCRIPT_SNIPPETS,

	AEGP_PersistentType_NUMTYPES
};
typedef A_long AEGP_PersistentType;


#define kAEGPItemSuite				"AEGP Item Suite"
#define kAEGPItemSuiteVersion9		14	/* frozen in AE 14.1 */

typedef struct AEGP_ItemSuite9 {

	SPAPI A_Err	(*AEGP_GetFirstProjItem)(
						AEGP_ProjectH		projectH,				/* >> */
						AEGP_ItemH			*itemPH);					/* << */

	SPAPI A_Err	(*AEGP_GetNextProjItem)(
						AEGP_ProjectH		projectH,				/* >> */
						AEGP_ItemH			itemH,					/* >> */
						AEGP_ItemH			*next_itemPH);			/* << NULL after last item */

	SPAPI A_Err	(*AEGP_GetActiveItem)(
						AEGP_ItemH			*itemPH);				/* << NULL if none is active */

	SPAPI A_Err	(*AEGP_IsItemSelected)(
						AEGP_ItemH			itemH,					/* >> */
						A_Boolean			*selectedPB);			/* << */

	SPAPI A_Err	(*AEGP_SelectItem)(
						AEGP_ItemH			itemH,					/* >> */
						A_Boolean			selectB,				/* >>	allows to select or deselect the item */
						A_Boolean			deselect_othersB);		/* >> */

	SPAPI A_Err	(*AEGP_GetItemType)(
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_ItemType		*item_typeP);			/* << */

	SPAPI A_Err	(*AEGP_GetTypeName)(
						AEGP_ItemType		item_type,				/* << */
						A_char 				*nameZ);				/* << space for A_char[AEGP_MAX_TYPE_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetItemName)(
						AEGP_PluginID			pluginID,				// in
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_MemHandle		*unicode_namePH);	// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle

	SPAPI A_Err	(*AEGP_SetItemName)(								/* UNDOABLE */
						AEGP_ItemH 			itemH,					/* >> */
						const A_UTF16Char	*nameZ);				/* >> null terminated UTF16 */

	SPAPI A_Err	(*AEGP_GetItemID)(
						AEGP_ItemH 			itemH,					/* >> */
						A_long				*item_idPL);			/* << */

	SPAPI A_Err	(*AEGP_GetItemFlags)(
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_ItemFlags		*item_flagsP);			/* << */

	SPAPI A_Err	(*AEGP_SetItemUseProxy)(							/* UNDOABLE */
						AEGP_ItemH 			itemH,					/* >> error if has_proxy is FALSE! */
						A_Boolean			use_proxyB);			/* >> */

	SPAPI A_Err	(*AEGP_GetItemParentFolder)(
						AEGP_ItemH			itemH,					/* >> */
						AEGP_ItemH			*parent_folder_itemPH);	/* << */

	SPAPI A_Err	(*AEGP_SetItemParentFolder)(
						AEGP_ItemH			itemH,					/* <> */
						AEGP_ItemH			parent_folder_itemH);	/* >> */

	SPAPI A_Err	(*AEGP_GetItemDuration)(							/* Returns the result in the item's native timespace:	*/
						AEGP_ItemH 			itemH,					/* >>		Comp			-> comp time,				*/
						A_Time 				*durationPT);			/* <<		Footage			-> footage time,			*/
																	/*			Folder			-> 0 (no duration)			*/

	SPAPI A_Err	(*AEGP_GetItemCurrentTime)(							/* Returns the result in the item's native timespace (not updated while rendering)*/
						AEGP_ItemH 			itemH,					/* >>	*/
						A_Time 				*curr_timePT);			/* <<	*/

	SPAPI A_Err	(*AEGP_GetItemDimensions)(
						AEGP_ItemH 			itemH,					/* >> */
						A_long	 			*widthPL,				/* << */
						A_long				*heightPL);				/* << */

	SPAPI A_Err	(*AEGP_GetItemPixelAspectRatio)(
						AEGP_ItemH 			itemH,					/* >> */
						A_Ratio 			*pix_aspect_ratioPRt);	/* << */

	SPAPI A_Err	(*AEGP_DeleteItem)(									/* UNDOABLE */
						AEGP_ItemH 			itemH);					/* >> removes item from all comps */

	SPAPI A_Err (*AEGP_CreateNewFolder)(
						const A_UTF16Char	*nameZ,				/* >> null terminated UTF16 */
						AEGP_ItemH			parent_folderH0,		/* >> */
						AEGP_ItemH			*new_folderPH);			/* << allocated and owned by AE */

	SPAPI A_Err (*AEGP_SetItemCurrentTime)(							/* UNDOABLE. Use the item's native timespace */
						AEGP_ItemH 			itemH,					/* >> */
						const A_Time		*new_timePT);			/* >> */

	SPAPI A_Err	(*AEGP_GetItemComment)(
						AEGP_ItemH			itemH,					/* >> */
						AEGP_MemHandle		*unicode_namePH);		/* << */

	SPAPI A_Err (*AEGP_SetItemComment)(
						AEGP_ItemH			itemH, 					/* >> UNDOABLE */
						const A_UTF16Char	*commentZ);				/* >> */

	SPAPI A_Err (*AEGP_GetItemLabel)(
						AEGP_ItemH			itemH, 					/* >> */
						AEGP_LabelID		*labelP);				/* << */

	SPAPI A_Err (*AEGP_SetItemLabel)(
						AEGP_ItemH			itemH, 					/* >> UNDOABLE */
						AEGP_LabelID		label);					/* >> */

	SPAPI A_Err (*AEGP_GetItemMRUView)(
						AEGP_ItemH			itemH,					// >>
						AEGP_ItemViewP		*mru_viewP);			// <<

} AEGP_ItemSuite9;


/* -------------------------------------------------------------------- */

#define kAEGPItemViewSuite                             "AEGP Item View Suite"
#define kAEGPItemViewSuiteVersion1                  1 /* frozen in AE 13.6 */

typedef struct AEGP_ItemViewSuite1 {
	// Each item view can have its own playback time, if previewing is active, otherwise the current associated item time
        SPAPI A_Err (*AEGP_GetItemViewPlaybackTime)(
		AEGP_ItemViewP 	item_viewP,						/* >> */
		A_Boolean		*is_currently_previewingPB0,	/* >>  whether the time is actually playback time (TRUE),  FALSE is default item current_time */
		A_Time          *curr_timePT );					/* << */
		
} AEGP_ItemViewSuite1;



/* -------------------------------------------------------------------- */

#define kAEGPSoundDataSuite				"AEGP Sound Data Suite"
#define kAEGPSoundDataVersion1			1 /* frozen in AE 5.0 */


typedef struct AEGP_SoundDataSuite1 {
	SPAPI A_Err (*AEGP_NewSoundData)(								/* Must be disposed with DisposeSoundData	*/
					const AEGP_SoundDataFormat*	sound_formatP,
					AEGP_SoundDataH			*new_sound_dataPH);		/* << can return NULL if no audio			*/

	SPAPI A_Err (*AEGP_DisposeSoundData)(
					AEGP_SoundDataH	sound_dataH); 					/* >> */

	SPAPI A_Err (*AEGP_GetSoundDataFormat)(
					AEGP_SoundDataH			soundH,					/* >> */
					AEGP_SoundDataFormat	*sound_formatP);		/* << */


	/*
		If the sound format has two channels, the data is interleaved
		left (0), right(1), left(0), right(1), ...

		AEGP_SoundEncoding_FLOAT has a type of FpShort

		For bytes_per_sample == 1
			AEGP_SoundEncoding_UNSIGNED_PCM == A_u_char
			AEGP_SoundEncoding_SIGNED_PCM	== A_char

		For bytes_per_sample == 2
			AEGP_SoundEncoding_UNSIGNED_PCM == A_u_short
			AEGP_SoundEncoding_SIGNED_PCM	== A_short

		For bytes_per_sample == 4
			AEGP_SoundEncoding_UNSIGNED_PCM == A_u_long
			AEGP_SoundEncoding_SIGNED_PCM	== A_long

		usage:
		void * sound_dataP;
		sds->AEGP_LockSoundDataSamples( soundH, &sound_dataP);
		A_u_long* correct_samples = (A_u_long*)sound_dataP; // for AEGP_SoundEncoding_UNSIGNED_PCM
	*/

	SPAPI A_Err (*AEGP_LockSoundDataSamples)(
					AEGP_SoundDataH			soundH,				/* >> */
					void					**samples);			/* << use the correct combination of unsigned/signed/float and bytes_per_sample to determine type */

	SPAPI A_Err (*AEGP_UnlockSoundDataSamples)(
					AEGP_SoundDataH			soundH);			/* >> */

	SPAPI A_Err (*AEGP_GetNumSamples)(
					AEGP_SoundDataH			soundH,				/* >> */
					A_long					*num_samplesPL);	/* << */

} AEGP_SoundDataSuite1 ;



/* -------------------------------------------------------------------- */


typedef struct {
	A_short	xS, yS;
} AEGP_DownsampleFactor;

enum {
	AEGP_CompFlag_SHOW_ALL_SHY			= 0x1,
	AEGP_CompFlag_RESERVED_1			= 0x2,
	AEGP_CompFlag_RESERVED_2			= 0x4,
	AEGP_CompFlag_ENABLE_MOTION_BLUR	= 0x8,
	AEGP_CompFlag_ENABLE_TIME_FILTER	= 0x10,
	AEGP_CompFlag_GRID_TO_FRAMES		= 0x20,
	AEGP_CompFlag_GRID_TO_FIELDS		= 0x40,
	AEGP_CompFlag_USE_LOCAL_DSF			= 0x80,		// If on, use the dsf in the comp, not the RO
	AEGP_CompFlag_DRAFT_3D				= 0x100,
	AEGP_CompFlag_SHOW_GRAPH			= 0x200,
	AEGP_CompFlag_RESERVED_3			= 0x400

};
typedef A_long	AEGP_CompFlags;




#define kAEGPCompSuite				"AEGP Comp Suite"
#define kAEGPCompSuiteVersion11		25 /* frozen in AE 14.2 */

typedef struct AEGP_CompSuite11 {

	SPAPI A_Err	(*AEGP_GetCompFromItem)(							// error if item isn't AEGP_ItemType_COMP!
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_CompH			*compPH);				/* << */

	SPAPI A_Err	(*AEGP_GetItemFromComp)(
						AEGP_CompH			compH,					/* >> */
						AEGP_ItemH 			*itemPH);				/* << */

	SPAPI A_Err	(*AEGP_GetCompDownsampleFactor)(
						AEGP_CompH				compH,				/* >> */
						AEGP_DownsampleFactor	*dsfP);				/* << */

	SPAPI A_Err	(*AEGP_SetCompDownsampleFactor)(
						AEGP_CompH					compH,			/* <> */
						const AEGP_DownsampleFactor	*dsfP);			/* >> */

	SPAPI A_Err	(*AEGP_GetCompBGColor)(
						AEGP_CompH			compH,					/* >> */
						AEGP_ColorVal		*bg_colorP);			/* << */

	SPAPI A_Err (*AEGP_SetCompBGColor)(
						AEGP_CompH				compH,				/* >> */
						const AEGP_ColorVal		*bg_colorP);		/* >> */

	SPAPI A_Err	(*AEGP_GetCompFlags)(
						AEGP_CompH			compH,					/* >> */
						AEGP_CompFlags		*comp_flagsP);			/* << */

	/*Opens the comp*/
	SPAPI A_Err	(*AEGP_GetShowLayerNameOrSourceName)(
						AEGP_CompH 				compH,					/* >> */
						A_Boolean				*layer_names_shownPB);	/* << true if layer names, false if source names */

	/*Opens the comp*/
	SPAPI A_Err	(*AEGP_SetShowLayerNameOrSourceName)(
						AEGP_CompH 				compH,					/* >> */
						A_Boolean				show_layer_namesB);		/* >> true to show layer names, false to show source names */
	
	/*Opens the comp*/
	SPAPI A_Err	(*AEGP_GetShowBlendModes)(
						AEGP_CompH 				compH,					/* >> */
						A_Boolean				*blend_modes_shownPB);	/* << */

	/*Opens the comp*/
	SPAPI A_Err	(*AEGP_SetShowBlendModes)(
						AEGP_CompH 				compH,					/* >> */
						A_Boolean				show_blend_modesB);		/* << */

	SPAPI A_Err	(*AEGP_GetCompFramerate)(
						AEGP_CompH			compH,					/* >> */
						A_FpLong			*fpsPF);				/* << */

	SPAPI A_Err (*AEGP_SetCompFrameRate)(
						AEGP_CompH			compH,					/* >> */
						const A_FpLong		*fpsPF);				/* >> */

	SPAPI A_Err	(*AEGP_GetCompShutterAnglePhase)(
						AEGP_CompH			compH,					/* >> */
						A_Ratio				*angle,					/* << */
						A_Ratio				*phase);				/* << */

	SPAPI A_Err	(*AEGP_GetCompShutterFrameRange)(
						AEGP_CompH			compH,					/* >> */
						const A_Time		*comp_timeP,			/* >> */
						A_Time				*start,					/* << */
						A_Time				*duration);				/* << */

	SPAPI A_Err	(*AEGP_GetCompSuggestedMotionBlurSamples)(
						AEGP_CompH			compH,					/* >> */
						A_long				*samplesPL);			/* << */

	SPAPI A_Err	(*AEGP_SetCompSuggestedMotionBlurSamples)(			/* UNDOABLE */
						AEGP_CompH			compH,					/* >> */
						A_long				samplesL);				/* >> */
						
	SPAPI A_Err	(*AEGP_GetCompMotionBlurAdaptiveSampleLimit)(
						AEGP_CompH			compH,					/* >> */
						A_long				*samplesPL);			/* << */

	SPAPI A_Err	(*AEGP_SetCompMotionBlurAdaptiveSampleLimit)(			/* UNDOABLE */
						AEGP_CompH			compH,					/* >> */
						A_long				samplesL);				/* >> */

	SPAPI A_Err	(*AEGP_GetCompWorkAreaStart)(
						AEGP_CompH			compH,					/* >> */
						A_Time 				*work_area_startPT);	/* << */

	SPAPI A_Err	(*AEGP_GetCompWorkAreaDuration)(
						AEGP_CompH			compH,					/* >> */
						A_Time 				*work_area_durationPT);	/* << */

	SPAPI A_Err	(*AEGP_SetCompWorkAreaStartAndDuration)(			/* UNDOABLE */
						AEGP_CompH			compH,					/* >> */
						const A_Time 		*work_area_startPT,		/* >> */
						const A_Time 		*work_area_durationPT);	/* >> */

	SPAPI A_Err (*AEGP_CreateSolidInComp)(
						const A_UTF16Char		*utf_nameZ,			/* >> */
						A_long				width,					/* >> */
						A_long				height,					/* >> */
						const AEGP_ColorVal	*color,					/* >> */
						AEGP_CompH			parent_compH,			/* >> */
						const A_Time		*durationPT0,			/* >> */
						AEGP_LayerH			*new_solidPH);			/* << */

	SPAPI A_Err (*AEGP_CreateCameraInComp)(
						const A_UTF16Char		*utf_nameZ,			/* >> */
						A_FloatPoint		center_point,			/* >> */
						AEGP_CompH			parent_compH,			/* >> */
						AEGP_LayerH			*new_cameraPH);			/* << */

	SPAPI A_Err (*AEGP_CreateLightInComp)(
						const A_UTF16Char		*utf_nameZ,			/* >> */
						A_FloatPoint		center_point,			/* >> */
						AEGP_CompH			parent_compH,			/* >> */
						AEGP_LayerH			*new_lightPH);			/* << */

	SPAPI A_Err (*AEGP_CreateComp)(
						AEGP_ItemH			parent_folderH0,		/* >> */
						const A_UTF16Char		*utf_nameZ,			/* >> */
						A_long				widthL,					/* >> */
						A_long				heightL,				/* >> */
						const A_Ratio		*pixel_aspect_ratioPRt,	/* >> */
						const A_Time		*durationPT,			/* >> */
						const A_Ratio		*frameratePRt,			/* >> */
						AEGP_CompH			*new_compPH);			/* << */

	SPAPI A_Err	(*AEGP_GetNewCollectionFromCompSelection)(
						AEGP_PluginID		plugin_id,				/* >> */
						AEGP_CompH			compH,					/* >> */
						AEGP_Collection2H	*collectionPH);			/* << */

	SPAPI A_Err (*AEGP_SetSelection)(
						AEGP_CompH			compH,					/* >> */
						AEGP_Collection2H	collectionH);			/* >> not adopted */

	SPAPI A_Err (*AEGP_GetCompDisplayStartTime)(
						AEGP_CompH			compH,					/* >> */
						A_Time				*start_timePT);			/* << */

	SPAPI A_Err (*AEGP_SetCompDisplayStartTime)(					/*	NOT Undoable! */
						AEGP_CompH			compH,					/* >> */
						const A_Time		*start_timePT);			/* >> */

	SPAPI A_Err (*AEGP_SetCompDuration)(
						AEGP_CompH			compH,					/* >> */
						const A_Time		*durationPT);			/* >> */

	SPAPI A_Err (*AEGP_CreateNullInComp)(
						const A_UTF16Char		*utf_nameZ,			/* >> */
						AEGP_CompH			parent_compH,			/* >> */
						const A_Time		*durationPT0,			/* >> */
						AEGP_LayerH			*new_null_solidPH);		/* << */

	SPAPI A_Err (*AEGP_SetCompPixelAspectRatio)(
						AEGP_CompH			compH,					/* >> */
						const A_Ratio		*pix_aspectratioPRt);	/* >> */

	SPAPI A_Err (*AEGP_CreateTextLayerInComp)(
						AEGP_CompH			parent_compH,			/* >> */
						A_Boolean			select_new_layerB,		/* >> */
						AEGP_LayerH			*new_text_layerPH);		/* << */

	SPAPI A_Err (*AEGP_CreateBoxTextLayerInComp)(
						AEGP_CompH			parent_compH,			/* >> */
						A_Boolean			select_new_layerB,		/* >> */
						A_FloatPoint		box_dimensions,			/* >> */ // (width and height)
						AEGP_LayerH			*new_text_layerPH);		/* << */

	SPAPI A_Err (*AEGP_SetCompDimensions)(
						AEGP_CompH			compH,					/* >> */
						A_long				widthL,					/* >> */
						A_long				heightL);				/* >> */

	SPAPI A_Err (*AEGP_DuplicateComp)(
						AEGP_CompH			compH,					/* >> */
						AEGP_CompH			*new_compPH);			/* << */

	SPAPI A_Err	(*AEGP_GetCompFrameDuration)(
						AEGP_CompH			compH,    				/* >> */
						A_Time				*timeP);				/* << */

	SPAPI A_Err (*AEGP_GetMostRecentlyUsedComp)(
						AEGP_CompH			*compPH);				/* << If compPH returns NULL, there's no available comp */

	SPAPI A_Err (*AEGP_CreateVectorLayerInComp)(
						AEGP_CompH			parent_compH,			/* >> */
						AEGP_LayerH			*new_vector_layerPH);	/* << */

	SPAPI A_Err (*AEGP_GetNewCompMarkerStream)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_CompH			parent_compH,			/* >> */
						AEGP_StreamRefH		*streamPH);				/* << must be disposed by caller */

	SPAPI A_Err (*AEGP_GetCompDisplayDropFrame)(
						AEGP_CompH			compH,					/* >> */
						A_Boolean			*dropFramePB);			/* << */

	SPAPI A_Err (*AEGP_SetCompDisplayDropFrame)(
						AEGP_CompH			compH,					/* >> */
						A_Boolean			dropFrameB);			/* << */
	
	SPAPI A_Err (*AEGP_ReorderCompSelection)(
						AEGP_CompH			compH,					/* >> */
						A_long				index);					/* >> */

} AEGP_CompSuite11;


/* -------------------------------------------------------------------- */


#define kAEGPMemorySuite				"AEGP Memory Suite"
#define kAEGPMemorySuiteVersion1		1 /* frozen in AE 5.0 */

enum {
	AEGP_MemFlag_NONE 	= 0x0,
	AEGP_MemFlag_CLEAR 	= 0x01,
	AEGP_MemFlag_QUIET 	= 0x02
};
typedef A_long	AEGP_MemFlag;

typedef A_u_long	AEGP_MemSize;


typedef struct AEGP_MemorySuite1 {


	SPAPI A_Err	 (*AEGP_NewMemHandle)( AEGP_PluginID	plugin_id,			/* >> */
									   const A_char	*whatZ,					/* >> */
									   AEGP_MemSize	size,					/* >> */
									   AEGP_MemFlag	flags,					/* >> */
									   AEGP_MemHandle	*memPH);			/* << */

	SPAPI A_Err	 (*AEGP_FreeMemHandle)(		AEGP_MemHandle memH);

	SPAPI A_Err	 (*AEGP_LockMemHandle)(		AEGP_MemHandle memH,			/* nestable */
											void			**ptr_to_ptr);	/* << */

	SPAPI A_Err	 (*AEGP_UnlockMemHandle)(	AEGP_MemHandle memH);

	SPAPI A_Err	 (*AEGP_GetMemHandleSize)(	AEGP_MemHandle	memH,
											AEGP_MemSize	*sizeP);		/* << */

	SPAPI A_Err	 (*AEGP_ResizeMemHandle)(	const A_char		*whatZ,			/* >> */
											AEGP_MemSize	new_size,		/* >> */
											AEGP_MemHandle	memH);			/* <> */

	SPAPI A_Err	 (*AEGP_SetMemReportingOn)(	A_Boolean 		turn_OnB);

	SPAPI A_Err	 (*AEGP_GetMemStats)(	AEGP_PluginID	plugin_id,			/* >> */
										A_long			*countPL,			/* << */
										A_long			*sizePL);			/* << */
} AEGP_MemorySuite1;

/* -------------------------------------------------------------------- */


enum {
	AEGP_TransferFlag_PRESERVE_ALPHA		= 0x1,
	AEGP_TransferFlag_RANDOMIZE_DISSOLVE	= 0x2
};
typedef A_long	AEGP_TransferFlags;

enum {
	AEGP_TrackMatte_NO_TRACK_MATTE,
	AEGP_TrackMatte_ALPHA,
	AEGP_TrackMatte_NOT_ALPHA,
	AEGP_TrackMatte_LUMA,
	AEGP_TrackMatte_NOT_LUMA
};
typedef A_long	AEGP_TrackMatte;

typedef struct {
	PF_TransferMode			mode;				// defined in AE_EffectCB.h
	AEGP_TransferFlags		flags;
	AEGP_TrackMatte			track_matte;
} AEGP_LayerTransferMode;



enum {
	AEGP_LayerQual_NONE = -1,					// sentinel
	AEGP_LayerQual_WIREFRAME,					// wire-frames only
	AEGP_LayerQual_DRAFT,						// LO-qual filters, LO-qual geom
	AEGP_LayerQual_BEST							// HI-qual filters, HI-qual geom
};
typedef A_short AEGP_LayerQuality;


enum {
	AEGP_LayerSamplingQual_BILINEAR,						// bilinear interpolation
	AEGP_LayerSamplingQual_BICUBIC							// bicubic interpolation
};
typedef A_short AEGP_LayerSamplingQuality;

enum {
	AEGP_LayerFlag_NONE				 			= 0x00000000,
	AEGP_LayerFlag_VIDEO_ACTIVE		 			= 0x00000001,
	AEGP_LayerFlag_AUDIO_ACTIVE 				= 0x00000002,
	AEGP_LayerFlag_EFFECTS_ACTIVE	 			= 0x00000004,
	AEGP_LayerFlag_MOTION_BLUR 					= 0x00000008,
	AEGP_LayerFlag_FRAME_BLENDING	 			= 0x00000010,
	AEGP_LayerFlag_LOCKED 						= 0x00000020,
	AEGP_LayerFlag_SHY 							= 0x00000040,
	AEGP_LayerFlag_COLLAPSE						= 0x00000080,
	AEGP_LayerFlag_AUTO_ORIENT_ROTATION			= 0x00000100,
	AEGP_LayerFlag_ADJUSTMENT_LAYER				= 0x00000200,
	AEGP_LayerFlag_TIME_REMAPPING				= 0x00000400,
  	AEGP_LayerFlag_LAYER_IS_3D					= 0x00000800,
  	AEGP_LayerFlag_LOOK_AT_CAMERA				= 0x00001000,
  	AEGP_LayerFlag_LOOK_AT_POI					= 0x00002000,
	AEGP_LayerFlag_SOLO							= 0x00004000,
	AEGP_LayerFlag_MARKERS_LOCKED				= 0x00008000,
	AEGP_LayerFlag_NULL_LAYER					= 0x00010000,
	AEGP_LayerFlag_HIDE_LOCKED_MASKS			= 0x00020000,
	AEGP_LayerFlag_GUIDE_LAYER					= 0x00040000,
	AEGP_LayerFlag_ADVANCED_FRAME_BLENDING		= 0x00080000,
	AEGP_LayerFlag_SUBLAYERS_RENDER_SEPARATELY	= 0x00100000,
	AEGP_LayerFlag_ENVIRONMENT_LAYER			= 0x00200000
};
typedef A_long	AEGP_LayerFlags;


// Layers are always one of the following types.

enum {
	AEGP_ObjectType_NONE = -1,
	AEGP_ObjectType_AV,			/* Includes all pre-AE 5.0 layer types (audio or video source, including adjustment layers)	*/
	AEGP_ObjectType_LIGHT,
	AEGP_ObjectType_CAMERA,
	AEGP_ObjectType_TEXT,
	AEGP_ObjectType_VECTOR,
	AEGP_ObjectType_RESERVED1,
	AEGP_ObjectType_RESERVED2,
	AEGP_ObjectType_RESERVED3,
	AEGP_ObjectType_RESERVED4,
	AEGP_ObjectType_RESERVED5,
	AEGP_ObjectType_NUM_TYPES
};
typedef A_long AEGP_ObjectType;

enum {
	AEGP_LTimeMode_LayerTime,
	AEGP_LTimeMode_CompTime
};
typedef A_short				AEGP_LTimeMode;

#define	AEGP_REORDER_LAYER_TO_END	-1

#define kAEGPLayerSuite				"AEGP Layer Suite"

#define kAEGPLayerSuiteVersion9		15	/* frozen AE 23.0 */

typedef struct AEGP_LayerSuite9 {

	SPAPI A_Err	(*AEGP_GetCompNumLayers)(
						AEGP_CompH			compH,					/* >> */
						A_long				*num_layersPL);			/* << */

	SPAPI A_Err	(*AEGP_GetCompLayerByIndex)(
						AEGP_CompH			compH,					/* >> */
						A_long				layer_indexL,			/* >> */
						AEGP_LayerH			*layerPH);				/* << */

	SPAPI A_Err	(*AEGP_GetActiveLayer)(
						AEGP_LayerH			*layerPH);				/* << returns non null only if one layer is selected */

	SPAPI A_Err	(*AEGP_GetLayerIndex)(
						AEGP_LayerH			layerH,					/* >> */
						A_long				*layer_indexPL);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerSourceItem)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_ItemH			*source_itemPH);		/* << */

	SPAPI A_Err (*AEGP_GetLayerSourceItemID)(
						AEGP_LayerH			layerH,					/* >> */
						A_long				*source_item_idPL);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerParentComp)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_CompH			*compPH);				/* << */

	SPAPI A_Err	(*AEGP_GetLayerName)(
						AEGP_PluginID			pluginID,				// in
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_MemHandle		*utf_layer_namePH0,		// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle
						AEGP_MemHandle		*utf_source_namePH0);	// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle

	SPAPI A_Err	(*AEGP_GetLayerQuality)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerQuality	*qualityP);				/* << */

	SPAPI A_Err	(*AEGP_SetLayerQuality)(							/* UNDOABLE */
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerQuality	quality);				/* >> */

	SPAPI A_Err	(*AEGP_GetLayerFlags)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerFlags		*layer_flagsP);			/* << */

	SPAPI A_Err (*AEGP_SetLayerFlag)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerFlags		single_flag,			/* >> */
						A_Boolean			valueB);				/* >> */

	SPAPI A_Err	(*AEGP_IsLayerVideoReallyOn)(						// accounts for solo status of other layers in comp
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			*onPB);					/* << */

	SPAPI A_Err	(*AEGP_IsLayerAudioReallyOn)(						// accounts for solo status of other layers in comp
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			*onPB);					/* << */

	SPAPI A_Err	(*AEGP_GetLayerCurrentTime)(						// not updated while rendering
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						A_Time 				*curr_timePT);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerInPoint)(
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						A_Time 				*in_pointPT);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerDuration)(
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						A_Time 				*durationPT);			/* << */

	SPAPI A_Err	(*AEGP_SetLayerInPointAndDuration)(					/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						const A_Time 		*in_pointPT,			/* >> */
						const A_Time 		*durationPT);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerOffset)(
						AEGP_LayerH 		layerH,					/* >> */
						A_Time 				*offsetPT);				/* << always in comp time */

	SPAPI A_Err	(*AEGP_SetLayerOffset)(								/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						const A_Time 		*offsetPT);				/* >> always in comp time */

	SPAPI A_Err	(*AEGP_GetLayerStretch)(
						AEGP_LayerH 		layerH,					/* >> */
						A_Ratio 			*stretchPRt);			/* << */

	SPAPI A_Err	(*AEGP_SetLayerStretch)(							/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						const A_Ratio 		*stretchPRt);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerTransferMode)(
						AEGP_LayerH 			layerH,				/* >> */
						AEGP_LayerTransferMode	*transfer_modeP);	/* << */

	SPAPI A_Err	(*AEGP_SetLayerTransferMode)(								/* UNDOABLE */
						AEGP_LayerH 					layerH,				/* >> */
						const AEGP_LayerTransferMode	*transfer_modeP);	/* >> */

	SPAPI A_Err	(*AEGP_IsAddLayerValid)(
						AEGP_ItemH 			item_to_addH,			/* >> */
						AEGP_CompH 			into_compH,				/* >> */
						A_Boolean			*validPB);				/* << */

	SPAPI A_Err	(*AEGP_AddLayer)(									/* UNDOABLE */
						AEGP_ItemH 			item_to_addH,			/* >> check AEGP_IsAddLayerValid() before using */
						AEGP_CompH 			into_compH,				/* >> */
						AEGP_LayerH			*added_layerPH0);		/* << */

	SPAPI A_Err	(*AEGP_ReorderLayer)(								/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						A_long 				layer_indexL);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerMaskedBounds)(
						AEGP_LayerH 		layerH,			/* >> */
						AEGP_LTimeMode		time_mode,		/* >> */
						const A_Time	 	*timePT,		/* >> */
						A_FloatRect			*boundsPR);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerObjectType)(
						AEGP_LayerH 		layerH,				/* >> */
						AEGP_ObjectType 	*object_type);		/* << */

	SPAPI A_Err	(*AEGP_IsLayer3D)(
						AEGP_LayerH 		layerH,				/* >> */
						A_Boolean 			*is_3DPB);			/* << */

	SPAPI A_Err	(*AEGP_IsLayer2D)(
						AEGP_LayerH 		layerH,				/* >> */
						A_Boolean 			*is_2DPB);			/* << */

	SPAPI A_Err	(*AEGP_IsVideoActive)(
						AEGP_LayerH 		layerH,				/* >> */
						AEGP_LTimeMode		time_mode,			/* >> */
						const A_Time	 	*timePT,			/* >> */
						A_Boolean			*is_activePB);		/* << */

	SPAPI A_Err	(*AEGP_IsLayerUsedAsTrackMatte)(
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			fill_must_be_activeB,	/* >> */
						A_Boolean			*is_track_mattePB);		/* << */

	SPAPI A_Err	(*AEGP_DoesLayerHaveTrackMatte)(
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			*has_track_mattePB);	/* << */

	SPAPI A_Err	(*AEGP_ConvertCompToLayerTime)(
					AEGP_LayerH		layerH,							/* >> */
					const A_Time	*comp_timePT,					/* >> */
					A_Time			*layer_timePT);					/* << */

	SPAPI A_Err	(*AEGP_ConvertLayerToCompTime)(
					AEGP_LayerH		layerH,							/* >> */
					const A_Time	*layer_timePT,					/* >> */
					A_Time			*comp_timePT) ;					/* << */

	SPAPI A_Err	(*AEGP_GetLayerDancingRandValue)(
					AEGP_LayerH		layerH,							/* >> */
					const A_Time	*comp_timePT,					/* >> */
					A_long			*rand_valuePL);					/* << */

	SPAPI A_Err	(*AEGP_GetLayerID)(
					AEGP_LayerH				layerH,				/* >> */
					AEGP_LayerIDVal			*id_valP);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerToWorldXform)(
				AEGP_LayerH				aegp_layerH,		/* >> */
				const A_Time			*comp_timeP,		/* >> */
				A_Matrix4				*transform);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerToWorldXformFromView)(
				AEGP_LayerH				aegp_layerH,		/* >> */
				const A_Time			*view_timeP,		/* >> */
				const A_Time			*comp_timeP,		/* >> */
				A_Matrix4				*transform);		/* << */

	SPAPI A_Err (*AEGP_SetLayerName)(
				AEGP_LayerH				aegp_layerH,		/* >> */
				const A_UTF16Char		*new_nameZ);				/* >> null terminated UTF16 */

	SPAPI A_Err	(*AEGP_GetLayerParent)(
				const AEGP_LayerH		layerH,				/* >> */
				AEGP_LayerH				*parent_layerPH);	/* << NULL if no parent */

	SPAPI A_Err (*AEGP_SetLayerParent)(
				AEGP_LayerH				layerH,				/* >> */
				const AEGP_LayerH		parent_layerH0);	/* >> */

	SPAPI A_Err (*AEGP_DeleteLayer)(
				AEGP_LayerH				layerH);			/* >>  	UNDOABLE */

	SPAPI A_Err (*AEGP_DuplicateLayer)(
				AEGP_LayerH				orig_layerH,			/* >> */
				AEGP_LayerH				*duplicate_layerPH);	/* << */

	SPAPI A_Err (*AEGP_GetLayerFromLayerID)(
				AEGP_CompH				parent_compH,			/* >> */
				AEGP_LayerIDVal			id,						/* >> */
				AEGP_LayerH				*layerPH);				/* << */

	SPAPI A_Err (*AEGP_GetLayerLabel)(
				AEGP_LayerH				layerH,					/* >> */
				AEGP_LabelID			*labelP);				/* << */

	SPAPI A_Err (*AEGP_SetLayerLabel)(		/* UNDOABLE */
				AEGP_LayerH				layerH,					/* >> */
				AEGP_LabelID			label);					/* >> */

	SPAPI A_Err	(*AEGP_GetLayerSamplingQuality)(
				AEGP_LayerH					layerH,					/* >> */
				AEGP_LayerSamplingQuality	*qualityP);				/* << */

	/* Option is explicitly set on the layer independent of layer quality. 
	If you want to force it on you must also set the layer quality to 
	AEGP_LayerQual_BEST with AEGP_SetLayerQuality. Otherwise it will only be using
	the specified layer sampling quality whenever the layer quality is set to AEGP_LayerQual_BEST*/
	SPAPI A_Err	(*AEGP_SetLayerSamplingQuality)(			/* UNDOABLE */
				AEGP_LayerH					layerH,					/* >> */
				AEGP_LayerSamplingQuality	quality);				/* >> */

	SPAPI A_Err (*AEGP_GetTrackMatteLayer)(
				const AEGP_LayerH		layerH,					/* >> */
				AEGP_LayerH				*track_matte_layerPH);	/* << NULL if no track matte layer */

	SPAPI A_Err (*AEGP_SetTrackMatte)(
				AEGP_LayerH				layerH,					/* >> */
				const AEGP_LayerH		track_matte_layerH0,	/* >> */
				const AEGP_TrackMatte	track_matte_type);		/* >> */

	SPAPI A_Err (*AEGP_RemoveTrackMatte)(
				AEGP_LayerH				layerH);				/* >> */

} AEGP_LayerSuite9;





/* -------------------------------------------------------------------- */


enum {
	/*
	 	WARNING!!
	 	don't reorder these items, don't add in the middle
	 	these IDs are saved to disk!
	 	
	 	only ever add to the end of the list, right before AEGP_LayerStream_NUMTYPES
	 */
	
	AEGP_LayerStream_NONE = -1,
	AEGP_LayerStream_ANCHORPOINT,
	AEGP_LayerStream_POSITION,
	AEGP_LayerStream_SCALE,
	AEGP_LayerStream_ROTATION,
	AEGP_LayerStream_ROTATE_Z = AEGP_LayerStream_ROTATION, 		/* for 3D streams */
	AEGP_LayerStream_OPACITY,
	AEGP_LayerStream_AUDIO,
	AEGP_LayerStream_MARKER,
	AEGP_LayerStream_TIME_REMAP,
	AEGP_LayerStream_ROTATE_X,
	AEGP_LayerStream_ROTATE_Y,
	AEGP_LayerStream_ORIENTATION,

	// only valid for AEGP_ObjectType == AEGP_ObjectType_CAMERA
	AEGP_LayerStream_ZOOM,
	AEGP_LayerStream_DEPTH_OF_FIELD,
	AEGP_LayerStream_FOCUS_DISTANCE,
	AEGP_LayerStream_APERTURE,
	AEGP_LayerStream_BLUR_LEVEL,

	// only valid for AEGP_ObjectType == AEGP_ObjectType_LIGHT
	AEGP_LayerStream_INTENSITY,
	AEGP_LayerStream_COLOR,
	AEGP_LayerStream_CONE_ANGLE,
	AEGP_LayerStream_CONE_FEATHER,
	AEGP_LayerStream_SHADOW_DARKNESS,
	AEGP_LayerStream_SHADOW_DIFFUSION,

	// only valid for AEGP_ObjectType == AEGP_ObjectType_AV
	AEGP_LayerStream_ACCEPTS_SHADOWS,
	AEGP_LayerStream_ACCEPTS_LIGHTS,
	AEGP_LayerStream_AMBIENT_COEFF,
	AEGP_LayerStream_DIFFUSE_COEFF,
	AEGP_LayerStream_SPECULAR_INTENSITY,
	AEGP_LayerStream_SPECULAR_SHININESS,

	AEGP_LayerStream_CASTS_SHADOWS, 		// LIGHT, and AV only, no CAMERA
	AEGP_LayerStream_LIGHT_TRANSMISSION,	// AV Layer only
	AEGP_LayerStream_METAL,			 		// AV layer only

	AEGP_LayerStream_SOURCE_TEXT,

	// only valid for AEGP_ObjectType == AEGP_ObjectType_CAMERA
	AEGP_LayerStream_IRIS_SHAPE,
	AEGP_LayerStream_IRIS_ROTATION,
	AEGP_LayerStream_IRIS_ROUNDNESS,
	AEGP_LayerStream_IRIS_ASPECT_RATIO,
	AEGP_LayerStream_IRIS_DIFFRACTION_FRINGE,
	AEGP_LayerStream_IRIS_HIGHLIGHT_GAIN,
	AEGP_LayerStream_IRIS_HIGHLIGHT_THRESHOLD,
	AEGP_LayerStream_IRIS_HIGHLIGHT_SATURATION,

	// only valid for AEGP_ObjectType == AEGP_ObjectType_LIGHT
	AEGP_LayerStream_LIGHT_FALLOFF_TYPE,
	AEGP_LayerStream_LIGHT_FALLOFF_START,
	AEGP_LayerStream_LIGHT_FALLOFF_DISTANCE,

	// only valid for AEGP_ObjectType == AEGP_ObjectType_AV
	AEGP_LayerStream_REFLECTION_INTENSITY,
	AEGP_LayerStream_REFLECTION_SHARPNESS,
	AEGP_LayerStream_REFLECTION_ROLLOFF,
	AEGP_LayerStream_TRANSPARENCY_COEFF,
	AEGP_LayerStream_TRANSPARENCY_ROLLOFF,
	AEGP_LayerStream_INDEX_OF_REFRACTION,
	
	AEGP_LayerStream_EXTRUSION_BEVEL_STYLE,
	AEGP_LayerStream_EXTRUSION_BEVEL_DIRECTION,
	AEGP_LayerStream_EXTRUSION_BEVEL_DEPTH,
	AEGP_LayerStream_EXTRUSION_HOLE_BEVEL_DEPTH,
	AEGP_LayerStream_EXTRUSION_DEPTH,
	AEGP_LayerStream_PLANE_CURVATURE,
	AEGP_LayerStream_PLANE_SUBDIVISION,

	/*********************************************************/
	AEGP_LayerStream_NUMTYPES,
	AEGP_LayerStream_BEGIN	= AEGP_LayerStream_NONE + 1,
	AEGP_LayerStream_END	= AEGP_LayerStream_NUMTYPES

};
typedef A_long				AEGP_LayerStream;

enum {
	AEGP_MaskStream_OUTLINE = 400,
	AEGP_MaskStream_OPACITY,
	AEGP_MaskStream_FEATHER,
	AEGP_MaskStream_EXPANSION,

	// useful for iteration
	AEGP_MaskStream_BEGIN = AEGP_MaskStream_OUTLINE,
	AEGP_MaskStream_END =	AEGP_MaskStream_EXPANSION+1
};
typedef A_long				AEGP_MaskStream;


enum {
	AEGP_StreamFlag_NONE			= 0,
	AEGP_StreamFlag_HAS_MIN			= 0x01,
	AEGP_StreamFlag_HAS_MAX			= 0x02,
	AEGP_StreamFlag_IS_SPATIAL		= 0x04
};
typedef A_long			AEGP_StreamFlags;


typedef A_FpLong		AEGP_OneDVal;

typedef struct {
	A_FpLong	x,y;
} AEGP_TwoDVal;			// if audio, rt is x, left is y

typedef struct {
	A_FpLong	x,y,z;
} AEGP_ThreeDVal;

typedef A_FpLong		AEGP_FourDVal[4];

typedef A_Handle		AEGP_ArbBlockVal;

enum {
	AEGP_KeyInterp_NONE = 0,
	AEGP_KeyInterp_LINEAR,
	AEGP_KeyInterp_BEZIER,
	AEGP_KeyInterp_HOLD,

	AEGP_Interp_NUM_VALUES
};
typedef A_long	AEGP_KeyframeInterpolationType;

/* AEGP_KeyInterpMask -- allowed interpolation mask constants and type
 */
enum {
	AEGP_KeyInterpMask_NONE				= 0,
	AEGP_KeyInterpMask_LINEAR			= 1 << 0,
	AEGP_KeyInterpMask_BEZIER			= 1 << 1,
	AEGP_KeyInterpMask_HOLD				= 1 << 2,
	AEGP_KeyInterpMask_CUSTOM			= 1 << 3,

	AEGP_KeyInterpMask_ANY				= 0xFFFF
};
typedef A_long	AEGP_KeyInterpolationMask;

typedef struct {
	A_FpLong	speedF;
	A_FpLong	influenceF;
} AEGP_KeyframeEase;


typedef union {
	AEGP_FourDVal			four_d;
	AEGP_ThreeDVal			three_d;
	AEGP_TwoDVal			two_d;
	AEGP_OneDVal			one_d;
	AEGP_ColorVal			color;
	AEGP_ArbBlockVal		arbH;
	AEGP_MarkerValP			markerP;
	AEGP_LayerIDVal			layer_id;
	AEGP_MaskIDVal			mask_id;
	AEGP_MaskOutlineValH	mask;
	AEGP_TextDocumentH		text_documentH;
} AEGP_StreamVal2;

typedef struct {
	AEGP_StreamRefH 	streamH;
	AEGP_StreamVal2		val;
} AEGP_StreamValue2;

enum {
	AEGP_StreamType_NO_DATA,
	AEGP_StreamType_ThreeD_SPATIAL,
	AEGP_StreamType_ThreeD,
	AEGP_StreamType_TwoD_SPATIAL,
	AEGP_StreamType_TwoD,
	AEGP_StreamType_OneD,
	AEGP_StreamType_COLOR,
	AEGP_StreamType_ARB,
	AEGP_StreamType_MARKER,
	AEGP_StreamType_LAYER_ID,
	AEGP_StreamType_MASK_ID,
	AEGP_StreamType_MASK,
	AEGP_StreamType_TEXT_DOCUMENT
};
typedef A_long				AEGP_StreamType;


#define kAEGPStreamSuite				"AEGP Stream Suite"
#define kAEGPStreamSuiteVersion6		11 /* frozen in AE 22.5 */

typedef struct AEGP_StreamSuite6 {
	// the only diff from this vs. last rev the new AEGP_GetUniqueStreamID function, which given an AEGP_StreamRef will
	// return the corresponding unique identifier for it.

	SPAPI A_Err (*AEGP_IsStreamLegal)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerStream	which_stream,			/* >> */
						A_Boolean*			is_legalP);				/* << */


	SPAPI A_Err (*AEGP_CanVaryOverTime)(
						AEGP_StreamRefH streamH,					/* >> */
						A_Boolean* can_varyPB);						/* << */

	SPAPI A_Err (*AEGP_GetValidInterpolations)(
						AEGP_StreamRefH				streamH,					/* >> */
						AEGP_KeyInterpolationMask*	valid_interpolationsP);		/* << */

	SPAPI A_Err	(*AEGP_GetNewLayerStream)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerStream	which_stream,			/* >> */
						AEGP_StreamRefH 	*streamPH);				/* << must be disposed by caller! */

	SPAPI A_Err	(*AEGP_GetEffectNumParamStreams)(
						AEGP_EffectRefH		effect_refH,			/* >> */
						A_long				*num_paramsPL);			/* << */

	SPAPI A_Err	(*AEGP_GetNewEffectStreamByIndex)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_EffectRefH		effect_refH,			/* >> */
						PF_ParamIndex		param_index,			/* >> valid in range [0 to AEGP_GetEffectNumParamStreams - 1], where 0 is the effect's input layer */
						AEGP_StreamRefH 	*streamPH);				/* << must be disposed by caller! */

	SPAPI A_Err	(*AEGP_GetNewMaskStream)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_MaskRefH		mask_refH,				/* >> */
						AEGP_MaskStream		which_stream,			/* >> */
						AEGP_StreamRefH 	*mask_streamPH);		/* << must be disposed by caller! */

	SPAPI A_Err	(*AEGP_DisposeStream)(
						AEGP_StreamRefH 	streamH);				/* >> */

	SPAPI A_Err	(*AEGP_GetStreamName)(
						AEGP_PluginID			pluginID,				// in
						AEGP_StreamRefH 	streamH,				/* >> */
						A_Boolean			force_englishB,			/* >> */
						AEGP_MemHandle		*utf_stream_namePH);		// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle

	SPAPI A_Err	(*AEGP_GetStreamUnitsText)(
						AEGP_StreamRefH 	streamH,				/* >> */
						A_Boolean			force_englishB,			/* >> */
						A_char				*unitsZ);				/* << space for A_char[AEGP_MAX_STREAM_UNITS_SIZE] */

	SPAPI A_Err	(*AEGP_GetStreamProperties)(
						AEGP_StreamRefH 	streamH,				/* >> */
						AEGP_StreamFlags 	*flagsP,				/* << */
						A_FpLong 			*minP0,					/* << */
						A_FpLong 			*maxP0);				/* << */

	SPAPI A_Err	(*AEGP_IsStreamTimevarying)(						/* takes expressions into account */
						AEGP_StreamRefH 	streamH,				/* >> */
						A_Boolean			*is_timevaryingPB);		/* << */

	SPAPI A_Err	(*AEGP_GetStreamType)(
						AEGP_StreamRefH 	streamH,				/* >> */
						AEGP_StreamType		*stream_typeP);			/* << */

	SPAPI A_Err	(*AEGP_GetNewStreamValue)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_StreamRefH 	streamH,				/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						const A_Time		*timePT,				/* >> */
						A_Boolean			pre_expressionB,		/* >> sample the stream before evaluating the expression */
						AEGP_StreamValue2	*valueP);				/* << must be disposed */

	SPAPI A_Err	(*AEGP_DisposeStreamValue)(
						AEGP_StreamValue2	*valueP);				/* <> */


	SPAPI A_Err	(*AEGP_SetStreamValue)(								// only legal to call when AEGP_GetStreamNumKFs==0 or NO_DATA
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_StreamRefH 	streamH,				/* >> */
						AEGP_StreamValue2	*valueP);				/* << */

	// this is only valid on streams with primitive types. It is illegal on
	// AEGP_ArbBlockVal || AEGP_MarkerValP || AEGP_MaskOutlineValH

	SPAPI A_Err	(*AEGP_GetLayerStreamValue)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerStream	which_stream,			/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						const A_Time		*timePT,				/* >> */
						A_Boolean			pre_expressionB,		/* >> sample the stream before evaluating the expression */
						AEGP_StreamVal2		*stream_valP,			/* << */
						AEGP_StreamType 	*stream_typeP0);		/* << */

	SPAPI A_Err	(*AEGP_GetExpressionState)(							/* expressions can be disabled automatically by the parser on playback */
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_StreamRefH 	streamH,				/* >> */
						A_Boolean			*enabledPB);			/* >> */

	SPAPI A_Err	(*AEGP_SetExpressionState)(							/* expressions can be disabled automatically by the parser on playback */
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_StreamRefH 	streamH,				/* >> */
						A_Boolean			enabledB);				/* >> */

	SPAPI A_Err(*AEGP_GetExpression)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_StreamRefH 	streamH,				/* >> */
						AEGP_MemHandle		*unicodeHZ);			/* << must be disposed with AEGP_FreeMemHandle */

	SPAPI A_Err(*AEGP_SetExpression)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_StreamRefH 	streamH,				/* >> */
						const A_UTF16Char*	expressionP);			/* >> not adopted */

	SPAPI A_Err (*AEGP_DuplicateStreamRef)(					// must dispose yourself
						AEGP_PluginID		aegp_plugin_id,			// in
						AEGP_StreamRefH		streamH,				// in
						AEGP_StreamRefH		*dup_streamPH);			// out
    
	SPAPI A_Err (*AEGP_GetUniqueStreamID)(
						AEGP_StreamRefH		streamH,				// in
						int32_t				*outID);				// out
    
} AEGP_StreamSuite6;


/* -------------------------------------------------------------------- */
/*	new Dynamic Streams API for AE6

	Used to access new tracker, text, & paint streams. Eventually
	will work for all streams & groups on a layer.

*/

#define AEGP_MAX_STREAM_MATCH_NAME_SIZE		40


enum {
	AEGP_StreamGroupingType_NONE = -1,
	AEGP_StreamGroupingType_LEAF,
	AEGP_StreamGroupingType_NAMED_GROUP,
	AEGP_StreamGroupingType_INDEXED_GROUP
};
typedef A_long			AEGP_StreamGroupingType;

enum {
	AEGP_DynStreamFlag_ACTIVE_EYEBALL				= 1L << 0,	// read/write
	AEGP_DynStreamFlag_HIDDEN						= 1L << 1,	// read/write, shown in UI at the moment?
	AEGP_DynStreamFlag_DISABLED						= 1L << 4,	// read-only, greyed out in UI?
	AEGP_DynStreamFlag_ELIDED						= 1L << 5,	// read-only, user never sees, children still seen and not indented
	AEGP_DynStreamFlag_SHOWN_WHEN_EMPTY				= 1L << 10,	// read-only, should this group be shown when empty?
	AEGP_DynStreamFlag_SKIP_REVEAL_WHEN_UNHIDDEN	= 1L << 16	// read-only, do not auto reveal this property when un-hidden
};
typedef A_u_long		AEGP_DynStreamFlags;

//	Here are some matchnames for use with
//	AEGP_GetNewStreamRefByMatchname().

#define	AEGP_StreamGroupName_MASK_PARADE		"ADBE Mask Parade"
#define	AEGP_StreamGroupName_MASK_ATOM			"ADBE Mask Atom"
#define	AEGP_StreamName_MASK_FEATHER			"ADBE Mask Feather"
#define	AEGP_StreamName_MASK_OPACITY			"ADBE Mask Opacity"
#define AEGP_StreamName_MASK_OFFSET				"ADBE Mask Offset"
#define AEGP_StreamGroupName_EFFECT_PARADE		"ADBE Effect Parade"
#define AEGP_StreamGroupName_LAYER				"ADBE Abstract Layer"
#define AEGP_StreamGroupName_AV_LAYER			"ADBE AV Layer"
#define AEGP_StreamGroupName_TEXT_LAYER			"ADBE Text Layer"
#define AEGP_StreamGroupName_CAMERA_LAYER		"ADBE Camera Layer"
#define AEGP_StreamGroupName_LIGHT_LAYER		"ADBE Light Layer"
#define AEGP_StreamGroupName_AUDIO				"ADBE Audio Group"
#define AEGP_StreamGroupName_MATERIAL_OPTIONS	"ADBE Material Options Group"
#define AEGP_StreamGroupName_TRANSFORM			"ADBE Transform Group"
#define AEGP_StreamGroupName_LIGHT_OPTIONS		"ADBE Light Options Group"
#define AEGP_StreamGroupName_CAMERA_OPTIONS		"ADBE Camera Options Group"

#define kAEGPDynamicStreamSuite				"AEGP Dynamic Stream Suite"
#define kAEGPDynamicStreamSuiteVersion4		5	/* frozen in AE 9.0 */

typedef struct AEGP_DynamicStreamSuite4 {

	SPAPI A_Err	(*AEGP_GetNewStreamRefForLayer)(						// used to start recursive walk of layer,
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						AEGP_LayerH				layerH,					/* >> */
						AEGP_StreamRefH 		*streamPH);				/* << must be disposed by caller! */

	SPAPI A_Err	(*AEGP_GetNewStreamRefForMask)(						// used to start recursive walk of layer,
		AEGP_PluginID			aegp_plugin_id,			/* >> */
		AEGP_MaskRefH			maskH,					/* >> */
		AEGP_StreamRefH 		*streamPH);				/* << must be disposed by caller! */


	SPAPI A_Err (*AEGP_GetStreamDepth)(									// layer is depth 0
						AEGP_StreamRefH			streamH,				/* >> */
						A_long					*depthPL);				/* << */


	SPAPI A_Err	(*AEGP_GetStreamGroupingType)(
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_StreamGroupingType	*group_typeP);			/* << */

	SPAPI A_Err	(*AEGP_GetNumStreamsInGroup)(	// error on leaf
						AEGP_StreamRefH			streamH,				/* >> */
						A_long					*num_streamsPL);		/* << */


	SPAPI A_Err	(*AEGP_GetDynamicStreamFlags)(
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_DynStreamFlags		*stream_flagsP);		/* << */

	SPAPI A_Err	(*AEGP_SetDynamicStreamFlag)(
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_DynStreamFlags		one_flag,				/* >> */
						A_Boolean				undoableB,				/* true if you want this to be an undoable change */
																		/* if false, the only legal flag is AEGP_DynStreamFlag_HIDDEN */
						A_Boolean				setB);					/* >> */


	SPAPI A_Err	(*AEGP_GetNewStreamRefByIndex)(		// legal for namedgroup, indexedgroup, not leaf
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						AEGP_StreamRefH			parent_groupH,			/* >> */
						A_long					indexL,					/* >> */
						AEGP_StreamRefH 		*streamPH);				/* << must be disposed by caller! */

	SPAPI A_Err	(*AEGP_GetNewStreamRefByMatchname)(	// legal for namedgroup
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						AEGP_StreamRefH			parent_groupH,			/* >> */
						const A_char			*utf8_match_nameZ,		/* >> */
						AEGP_StreamRefH 		*streamPH);				/* << must be disposed by caller! */

	SPAPI A_Err	(*AEGP_DeleteStream)(		/* UNDOABLE, only valid for children of AEGP_StreamGroupingType_INDEXED_GROUP */
						AEGP_StreamRefH			streamH);			/* >> */ // must still dispose the streamref later

	SPAPI A_Err	(*AEGP_ReorderStream)(		/* UNDOABLE, only valid for children of AEGP_StreamGroupingType_INDEXED_GROUP */
						AEGP_StreamRefH			streamH,			/* <> updated to refer to newly ordered stream */
						A_long 					new_indexL);		/* >> */

	SPAPI A_Err (*AEGP_DuplicateStream)(	/* UNDOABLE, only valid for children of AEGP_StreamGroupingType_INDEXED_GROUP */
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						AEGP_StreamRefH			streamH,				/* >> */
						A_long					*new_indexPL0);			/* << */

	/* GetStreamName is in main kAEGPStreamSuite, and works on dynamic streams including groups */

	SPAPI A_Err	(*AEGP_SetStreamName)(		/* UNDOABLE, only valid for children of AEGP_StreamGroupingType_INDEXED_GROUP */
						AEGP_StreamRefH			streamH,				/* >> */
						const A_UTF16Char		*nameZ);				/* >> null terminated UTF16 */

	SPAPI A_Err (*AEGP_CanAddStream)(
						AEGP_StreamRefH			group_streamH,			/* >> */
						const A_char			*utf8_match_nameZ,		/* >> make note: this is now defined as a UTF8 string! */
						A_Boolean				*can_addPB);			/* << */

	SPAPI A_Err (*AEGP_AddStream)(				/* UNDOABLE, only valid for AEGP_StreamGroupingType_INDEXED_GROUP */
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						AEGP_StreamRefH			indexed_group_streamH,	/* >> */
						const A_char			*utf8_match_nameZ,		/* >> make note: this is now defined as a UTF8 string! */
						AEGP_StreamRefH			*streamPH0);			/* << must be disposed by caller! */

	SPAPI A_Err (*AEGP_GetMatchName)(
						AEGP_StreamRefH			streamH,				/* >> */
						A_char					*utf8_match_nameZ);		/* << UTF8!! use A_char[AEGP_MAX_STREAM_MATCH_NAME_SIZE] for buffer */

	SPAPI A_Err (*AEGP_GetNewParentStreamRef)(
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_StreamRefH			*parent_streamPH);		/* << must be disposed by caller! */

	SPAPI A_Err (*AEGP_GetStreamIsModified)(	// i.e. changed from defaults, like the UU key
						AEGP_StreamRefH			streamH,				/* >> */
						A_Boolean				*modifiedPB);			/* << */

	SPAPI A_Err (*AEGP_GetStreamIndexInParent)(	// only valid for children of AEGP_StreamGroupingType_INDEXED_GROUP
						AEGP_StreamRefH			streamH,				/* >> */
						A_long 					*indexPL);				/* << */

	// Valid on leaf streams only. Returns true if this stream is a multidimensional stream
	// that can have its dimensions separated, though they may not be currently separated.
	// Terminology: A Leader is the stream that can be separated, a Follower is one
	// of N automatically streams that correspond to the N dimensions of the Leader.
	// A Leader isn't always separated, call AEGP_AreDimensionsSeparated to find out if it is.
	// As of 8/20/2007, the only stream that is ever separarated is the layer's Position property.
	// Please *do not* write code assuming that, we anticipate allowing separation of more streams in the future.
	SPAPI A_Err (*AEGP_IsSeparationLeader)(
						AEGP_StreamRefH			streamH,			/* >> */
						A_Boolean 				*leaderPB);			/* << */

	// Valid on leaf streams only. Returns true if AEGP_IsSeparationLeader() is true and the
	// dimensions are currently separated. If this is the case, this stream will have
	// AEGP_DynStreamFlag_HIDDEN set, and AEGP_GetSeparationFollower() will help you find the individual
	// dimension streams. However, some simple APIs can continue to be used on this leader, and
	// they will simply automatically propagate to the follower, including:
	//
	//		AEGP_GetNewStreamValue
	//		AEGP_SetStreamValue
	//		AEGP_GetLayerStreamValue
	//
	// Methods such as AEGP_GetNewKeyframeValue that work on keyframe indices will most definitely *not* work on the Leader property,
	// you will need to retrieve and operate on the Followers explicitly.
	SPAPI A_Err (*AEGP_AreDimensionsSeparated)(
						AEGP_StreamRefH		leader_streamH,			/* >> */
						A_Boolean 			*separatedPB);			/* << */

	// Valid only if AEGP_IsSeparationLeader() is true.
	SPAPI A_Err (*AEGP_SetDimensionsSeparated)(
						AEGP_StreamRefH		leader_streamH,			/* >> */
						A_Boolean 			separatedB);			/* << */

	// Retrieve the Follower stream corresponding to a given dimension of the Leader stream. dimS
	// can range from 0 to AEGP_GetStreamValueDimensionality(leader_streamH) - 1.
	SPAPI A_Err (*AEGP_GetSeparationFollower)(
						AEGP_StreamRefH		leader_streamH,			/* >> */
						A_short				dimS,					/* >> */
						AEGP_StreamRefH 	*follower_streamPH);	/* << */

	// Valid on leaf streams only. Returns true if this stream is a one dimensional property
	// that represents one of the dimensions of a Leader. You can retrieve stream from the Leader
	// using AEGP_GetSeparationFollower().
	SPAPI A_Err (*AEGP_IsSeparationFollower)(
						AEGP_StreamRefH		streamH,				/* >> */
						A_Boolean 			*followerPB);			/* << */

	// Valid on separation Followers only, returns the Leader it is part of
	SPAPI A_Err (*AEGP_GetSeparationLeader)(
						AEGP_StreamRefH		follower_streamH,		/* >> */
						AEGP_StreamRefH 	*leader_streamPH);		/* << */

	// Valid on separation Followers only, returns which dimension of the Leader it corresponds to
	SPAPI A_Err (*AEGP_GetSeparationDimension)(
						AEGP_StreamRefH		follower_streamH,		/* >> */
						A_short				*dimPS);				/* << */

} AEGP_DynamicStreamSuite4;



/* -------------------------------------------------------------------- */

typedef A_long AEGP_KeyframeIndex;

enum {
	AEGP_KeyframeFlag_NONE					= 0x00,
	AEGP_KeyframeFlag_TEMPORAL_CONTINUOUS	= 0x01,
	AEGP_KeyframeFlag_TEMPORAL_AUTOBEZIER	= 0x02,
	AEGP_KeyframeFlag_SPATIAL_CONTINUOUS	= 0x04,
	AEGP_KeyframeFlag_SPATIAL_AUTOBEZIER	= 0x08,
	AEGP_KeyframeFlag_ROVING				= 0x10
};
typedef A_long	AEGP_KeyframeFlags;


enum {
	AEGP_NumKF_NO_DATA		= -1
};

#define kAEGPKeyframeSuite				"AEGP Keyframe Suite"
#define kAEGPKeyframeSuiteVersion5		5 	/* frozen in 22.5 */

typedef struct AEGP_KeyframeSuite5 {
	//	the only diff from this vs. last rev is the addition of new keyframe label utils

	// returns AEGP_NumKF_NO_DATA if it's a AEGP_StreamType_NO_DATA, and you can't retrieve any values
	// returns zero if no keyframes (but might have an expression, so not necessarily constant)
	SPAPI A_Err	(*AEGP_GetStreamNumKFs)(
						AEGP_StreamRefH 		streamH,				/* >> */
						A_long					*num_kfsPL);			/* << */


	SPAPI A_Err (*AEGP_GetKeyframeTime)(
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						AEGP_LTimeMode			time_mode,				/* >> */
						A_Time					*timePT);				/* << */

	// leaves stream unchanged if a keyframe already exists at specified time
	SPAPI A_Err (*AEGP_InsertKeyframe)(									/* UNDOABLE */
						AEGP_StreamRefH			streamH,				/* <> */
						AEGP_LTimeMode			time_mode,				/* >> */
						const A_Time			*timePT,				/* >> */
						AEGP_KeyframeIndex		*key_indexP);			/* << */

	SPAPI A_Err (*AEGP_DeleteKeyframe)(									/* UNDOABLE */
						AEGP_StreamRefH			streamH,				/* <> */
						AEGP_KeyframeIndex		key_index);				/* >> */

	SPAPI A_Err (*AEGP_GetNewKeyframeValue)(							// dispose using AEGP_DisposeStreamValue()
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						AEGP_StreamValue2		*valueP);				/* << */

	SPAPI A_Err (*AEGP_SetKeyframeValue)(								/* UNDOABLE */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						const AEGP_StreamValue2	*valueP);				/* >>  not adopted */

	SPAPI A_Err (*AEGP_GetStreamValueDimensionality)(
						AEGP_StreamRefH			streamH,				/* >> */
						A_short					*value_dimPS);			/* << */

	SPAPI A_Err (*AEGP_GetStreamTemporalDimensionality)(
						AEGP_StreamRefH			streamH,				/* >> */
						A_short					*temporal_dimPS);		/* << */

	SPAPI A_Err (*AEGP_GetNewKeyframeSpatialTangents)(					// dispose using AEGP_DisposeStreamValue()
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						AEGP_StreamValue2		*in_tanP0,				/* << */
						AEGP_StreamValue2		*out_tanP0);			/* << */

	SPAPI A_Err (*AEGP_SetKeyframeSpatialTangents)(						/* UNDOABLE */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						const AEGP_StreamValue2	*in_tanP0,				/* >>  not adopted */
						const AEGP_StreamValue2	*out_tanP0);			/* >>  not adopted */

	SPAPI A_Err (*AEGP_GetKeyframeTemporalEase)(
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						A_long					dimensionL,				/* >> ranges from 0..TemporalDimensionality-1 */
						AEGP_KeyframeEase		*in_easeP0,				/* << */
						AEGP_KeyframeEase		*out_easeP0);			/* << */

	SPAPI A_Err (*AEGP_SetKeyframeTemporalEase)(						/* UNDOABLE */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						A_long					dimensionL,				/* >> ranges from 0..TemporalDimensionality-1 */
						const AEGP_KeyframeEase	*in_easeP0,				/* >> not adopted */
						const AEGP_KeyframeEase	*out_easeP0);			/* >> not adopted */

	SPAPI A_Err (*AEGP_GetKeyframeFlags)(
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						AEGP_KeyframeFlags		*flagsP);				/* << */

	SPAPI A_Err (*AEGP_SetKeyframeFlag)(								/* UNDOABLE */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						AEGP_KeyframeFlags		flag,					/* >> set one flag at a time */
						A_Boolean				true_falseB);			/* >> */

	SPAPI A_Err (*AEGP_GetKeyframeInterpolation)(
						AEGP_StreamRefH					streamH,		/* >> */
						AEGP_KeyframeIndex				key_index,		/* >> */
						AEGP_KeyframeInterpolationType	*in_interpP0,	/* << */
						AEGP_KeyframeInterpolationType	*out_interpP0);	/* << */

	SPAPI A_Err (*AEGP_SetKeyframeInterpolation)(						/* UNDOABLE */
						AEGP_StreamRefH					streamH,		/* >> */
						AEGP_KeyframeIndex				key_index,		/* >> */
						AEGP_KeyframeInterpolationType	in_interp,		/* >> */
						AEGP_KeyframeInterpolationType	out_interp);	/* >> */

	SPAPI A_Err (*AEGP_StartAddKeyframes)(
						AEGP_StreamRefH			streamH,
						AEGP_AddKeyframesInfoH	*akPH);			/* << */


	SPAPI A_Err (*AEGP_AddKeyframes)(
						AEGP_AddKeyframesInfoH	akH,			/* <> */
						AEGP_LTimeMode          time_mode,		/* >> */
						const A_Time            *timePT,		/* >> */
						A_long					*key_indexPL);	/* >> */

	SPAPI A_Err (*AEGP_SetAddKeyframe)(
						AEGP_AddKeyframesInfoH	akH,			/* <> */
						A_long					key_indexL,		/* >> */
						const AEGP_StreamValue2	*valueP);		/* >> */

	SPAPI A_Err (*AEGP_EndAddKeyframes)(						/* UNDOABLE */
						A_Boolean				addB,
						AEGP_AddKeyframesInfoH	akH);			/* >> */

	
	SPAPI A_Err(*AEGP_GetKeyframeLabelColorIndex)(				/* UNDOABLE */
						AEGP_StreamRefH			streamH,		/* >> */
						AEGP_KeyframeIndex		key_index,		/* >> */
						A_long					* key_labelP);	/* >> */

	SPAPI A_Err(*AEGP_SetKeyframeLabelColorIndex)(				/* UNDOABLE */
						AEGP_StreamRefH			streamH,		/* >> */
						AEGP_KeyframeIndex		key_index,		/* >> */
						A_long					key_label);		/* >> */


} AEGP_KeyframeSuite5;

/* -------------------------------------------------------------------- */

#define kAEGPTextDocumentSuite				"AEGP Text Document Suite"
#define kAEGPTextDocumentSuiteVersion1		1 /* frozen in AE 6.0 */

typedef struct AEGP_TextDocumentSuite1 {

	SPAPI A_Err	(*AEGP_GetNewText)(
						AEGP_PluginID			aegp_plugin_id,		/* >> */
						AEGP_TextDocumentH		text_documentH,		/* >> */
						AEGP_MemHandle			*unicodePH);		/* << handle of A_u_short, UTF16, NULL terminated. must be disposed with AEGP_FreeMemHandle */

	SPAPI A_Err	(*AEGP_SetText)(
						AEGP_TextDocumentH		text_documentH,		/* >> */
						const A_u_short			*unicodePS,			/* >> */
						A_long					lengthL);			/* >> number of characters */

} AEGP_TextDocumentSuite1;

/* -------------------------------------------------------------------- */

#define kAEGPMarkerSuite				"AEGP Marker Suite"
#define kAEGPMarkerSuiteVersion3		3 /* frozen in AE 16.0 */

enum {
	AEGP_MarkerString_NONE,

	AEGP_MarkerString_COMMENT,
	AEGP_MarkerString_CHAPTER,
	AEGP_MarkerString_URL,
	AEGP_MarkerString_FRAME_TARGET,
	AEGP_MarkerString_CUE_POINT_NAME,

	AEGP_MarkerString_NUMTYPES
};
typedef A_long AEGP_MarkerStringType;

enum {
	AEGP_MarkerFlag_NONE			= 0x00000000,
	AEGP_MarkerFlag_NAVIGATION		= 0x00000001,	//	if this bit is zero, then the marker is for "Event" rather than "Navigation"
	AEGP_MarkerFlag_PROTECT_REGION	= 0x00000002	//	if this bit is 1, then the marker is for a protected region  (protected against timestretching, when existing on a precomp layer)
};
typedef A_long	AEGP_MarkerFlagType;

typedef struct AEGP_MarkerSuite3 {

	SPAPI A_Err	(*AEGP_NewMarker)(
						AEGP_MarkerValP			*markerPP);

	SPAPI A_Err	(*AEGP_DisposeMarker)(
						AEGP_MarkerValP			markerP);

	SPAPI A_Err	(*AEGP_DuplicateMarker)(
						AEGP_MarkerValP			markerP, 			// >>
						AEGP_MarkerValP			*new_markerP);		// <<

	SPAPI A_Err	(*AEGP_SetMarkerFlag)(
						AEGP_MarkerValP			markerP,			// >>
						AEGP_MarkerFlagType		flagType,			// >>
						A_Boolean				valueB);			// >>

	SPAPI A_Err	(*AEGP_GetMarkerFlag)(
						AEGP_ConstMarkerValP	markerP,			// >>
						AEGP_MarkerFlagType		flagType,			// >>
							A_Boolean				*valueBP);			// <<

	SPAPI A_Err	(*AEGP_GetMarkerString)(
						AEGP_PluginID			aegp_plugin_id,		/* >> */
						AEGP_ConstMarkerValP	markerP,			// >>
						AEGP_MarkerStringType	strType,			// >>
						AEGP_MemHandle			*unicodePH);		/* << handle of A_u_short, UTF16, NULL terminated, must be disposed with AEGP_FreeMemHandle */

	SPAPI A_Err	(*AEGP_SetMarkerString)(
						AEGP_MarkerValP			markerP,			// <<>>
						AEGP_MarkerStringType	strType,			// >>
						const A_u_short			*unicodeP,			// >>
						A_long					lengthL);			// >> number of characters

	SPAPI A_Err	(*AEGP_CountCuePointParams)(
						AEGP_ConstMarkerValP	markerP,			// >>
						A_long					*paramsLP);			// <<

	SPAPI A_Err	(*AEGP_GetIndCuePointParam)(
						AEGP_PluginID			aegp_plugin_id,		// >>
						AEGP_ConstMarkerValP	markerP,			// >>
						A_long					param_indexL,		// >> must be between 0 and count - 1. else error
						AEGP_MemHandle			*unicodeKeyPH,		// << handle of A_u_short, UTF16, NULL terminated, must be disposed with AEGP_FreeMemHandle
						AEGP_MemHandle			*unicodeValuePH);	// << handle of A_u_short, UTF16, NULL terminated, must be disposed with AEGP_FreeMemHandle

	SPAPI A_Err	(*AEGP_SetIndCuePointParam)(
						AEGP_MarkerValP			markerP,			// >>
						A_long					param_indexL,		// must be between 0 and count - 1. else error
						const A_u_short			*unicodeKeyP,		// >> UTF16
						A_long					key_lengthL,		// >> number of characters
						const A_u_short			*unicodeValueP,		// >> UTF16
						A_long					value_lengthL);		// >> number of characters

	//	this call is followed by AEGP_SetIndCuePointParam() to actually set the data
	//	the ONLY thing this function does is reserve the space for the param, at the provided index
	SPAPI A_Err	(*AEGP_InsertCuePointParam)(
						AEGP_MarkerValP			markerP,			// >>
						A_long					param_indexL);		// must be between 0 and count. else error

	SPAPI A_Err	(*AEGP_DeleteIndCuePointParam)(
						AEGP_MarkerValP			markerP,			// >>
						A_long					param_indexL);		// must be between 0 and count - 1. else error

	SPAPI A_Err	(*AEGP_SetMarkerDuration)(
						AEGP_MarkerValP			markerP,			// >>
						const A_Time			*durationPT);		// >>


	SPAPI A_Err	(*AEGP_GetMarkerDuration)(
						AEGP_ConstMarkerValP	markerP,			// >>
						A_Time					*durationPT);		// <<

	SPAPI A_Err (*AEGP_SetMarkerLabel)(
						AEGP_MarkerValP			markerP,			// >>
						A_long		            value);				// >>

	SPAPI A_Err (*AEGP_GetMarkerLabel)(
						AEGP_ConstMarkerValP	markerP,			// >>
						A_long			        *valueP);		    // <<

} AEGP_MarkerSuite3;


/* -------------------------------------------------------------------- */

#define kAEGPTextLayerSuite				"AEGP Text Layer Suite"
#define kAEGPTextLayerSuiteVersion1		1 /* frozen in AE 6.0 */

typedef struct AEGP_TextLayerSuite1 {

	SPAPI A_Err	(*AEGP_GetNewTextOutlines)(
						AEGP_LayerH				layerH,				/* >> must be a text layer */
						const A_Time			*layer_timePT,		/* >> */
						AEGP_TextOutlinesH		*outlinesPH);		/* << must be disposed with AEGP_DisposeTextOutlines */

	SPAPI A_Err	(*AEGP_DisposeTextOutlines)(
						AEGP_TextOutlinesH		outlinesH);			/* >> */

	SPAPI A_Err	(*AEGP_GetNumTextOutlines)(
						AEGP_TextOutlinesH		outlinesH,			/* >> */
						A_long					*num_outlinesPL);	/* << */

	SPAPI A_Err	(*AEGP_GetIndexedTextOutline)(
						AEGP_TextOutlinesH		outlinesH,			/* >> */
						A_long					path_indexL,		/* >> */
						PF_PathOutlinePtr		*pathPP);			/* << DO NOT DISPOSE */

} AEGP_TextLayerSuite1;


/* -------------------------------------------------------------------- */


typedef A_long	AEGP_InstalledEffectKey;
#define AEGP_InstalledEffectKey_NONE	0

#define RQ_ITEM_INDEX_NONE				-1

enum {
	AEGP_EffectFlags_NONE			=0,
	AEGP_EffectFlags_ACTIVE			=0x01L << 0,
	AEGP_EffectFlags_AUDIO_ONLY		=0x01L << 1,
	AEGP_EffectFlags_AUDIO_TOO		=0x01L << 2,
	AEGP_EffectFlags_MISSING		=0x01L << 3
};
typedef A_long	AEGP_EffectFlags;

typedef A_long AEGP_EffectIndex;


#define kAEGPEffectSuite				"AEGP Effect Suite"
#define kAEGPEffectSuiteVersion4		4 /* frozen in AE 13.0 */

typedef struct AEGP_EffectSuite4 {

	SPAPI A_Err	(*AEGP_GetLayerNumEffects)(
						AEGP_LayerH			layerH,					/* >> */
						A_long				*num_effectsPL);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerEffectByIndex)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_LayerH			layerH,					/* >> */
						AEGP_EffectIndex	layer_effect_indexL,	/* >> */
						AEGP_EffectRefH		*effectPH);				/* <<  MUST dispose with DisposeEffect*/

	SPAPI A_Err (*AEGP_GetInstalledKeyFromLayerEffect)(
						AEGP_EffectRefH		effect_refH,					/* >> */
						AEGP_InstalledEffectKey	*installed_effect_keyP);	/* << */

	SPAPI A_Err (*AEGP_GetEffectParamUnionByIndex)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_EffectRefH		effect_refH,			/* >> */
						PF_ParamIndex		param_index,			/* >> valid in range [0 to AEGP_GetEffectNumParamStreams - 1], where 0 is the effect's input layer */
						PF_ParamType		*param_typeP,			/* << */
						PF_ParamDefUnion	*uP0);					/* << DO NOT USE THE VALUE FROM THIS PARAMDEF! */

	SPAPI A_Err (*AEGP_GetEffectFlags)(
						AEGP_EffectRefH		effect_refH,			/* >> */
						AEGP_EffectFlags	*effect_flagsP);		/* << */

	SPAPI A_Err (*AEGP_SetEffectFlags)(
						AEGP_EffectRefH		effect_refH,			/* >> */
						AEGP_EffectFlags	effect_flags_set_mask,	/* >> */
						AEGP_EffectFlags	effect_flags);			/* >> */

	SPAPI A_Err	(*AEGP_ReorderEffect)(								/* UNDOABLE */
						AEGP_EffectRefH 	effect_refH,			/* >> */
						A_long 				effect_indexL);			/* >> */

	/** new command parameter addded. To get old behaviour pass in PF_Cmd_COMPLETELY_GENERAL for effect_command **/
	SPAPI A_Err (*AEGP_EffectCallGeneric)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_EffectRefH		effect_refH,			/* >> */
						const A_Time		*timePT,				/* >> Use the timebase of the layer to which effect is applied. */
						PF_Cmd				effect_cmd,				/* >> new parameter from version 2 */
						void				*effect_extraPV);		/* <> */

	SPAPI A_Err (*AEGP_DisposeEffect)(
						AEGP_EffectRefH	effect_refH );				/* >> */

	SPAPI A_Err (*AEGP_ApplyEffect)(
						AEGP_PluginID		aegp_plugin_id,				/* >> */
						AEGP_LayerH			layerH,						/* >> */
						AEGP_InstalledEffectKey	installed_effect_key,	/* >> */
						AEGP_EffectRefH		*effect_refPH);				/* <<  MUST BE DISPOSED with AEGP_DisposeEffect */

	SPAPI A_Err	(*AEGP_DeleteLayerEffect)(
						AEGP_EffectRefH 	effect_refH);				/* >>  undoable */

	SPAPI A_Err (*AEGP_GetNumInstalledEffects)(
						A_long 				*num_installed_effectsPL);	/* << */

	// pass in AEGP_InstalledEffectKey_NONE for installed_effect_key to get first effect key

	SPAPI A_Err (*AEGP_GetNextInstalledEffect)(
									AEGP_InstalledEffectKey	installed_effect_key,	/* >> */
									AEGP_InstalledEffectKey	*next_effectPH);		/* << */

	SPAPI A_Err	(*AEGP_GetEffectName)(
						AEGP_InstalledEffectKey		installed_effect_key,	/* >> */
						A_char						*nameZ);				/* << space for A_char[AEGP_MAX_EFFECT_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetEffectMatchName)(
						AEGP_InstalledEffectKey		installed_effect_key,	/* >> */
						A_char						*utf8_match_nameZ);		/* << UTF8!! space for A_char[AEGP_MAX_EFFECT_MATCH_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetEffectCategory)(
						AEGP_InstalledEffectKey		installed_effect_key,	/* >> */
						A_char						*categoryZ);			/* << space for A_char[AEGP_MAX_EFFECT_CATEGORY_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_DuplicateEffect)(
						AEGP_EffectRefH		original_effect_refH,			/* >> */
						AEGP_EffectRefH		*duplicate_effect_refPH);		/* << */

	/** new in AE 13.0: effect masks */
	SPAPI A_Err	(*AEGP_NumEffectMask)(
						AEGP_EffectRefH		effect_refH,	/* >> */
						A_u_long			*num_masksPL);	/* << */

	SPAPI A_Err	(*AEGP_GetEffectMaskID)(
						AEGP_EffectRefH		effect_refH,	/* >> */
						A_u_long			mask_indexL,	/* >> */
						AEGP_MaskIDVal		*id_valP);		/* << */

	SPAPI A_Err	(*AEGP_AddEffectMask)(						/* UNDOABLE */
						AEGP_EffectRefH		effect_refH,	/* >> */
						AEGP_MaskIDVal		id_val,			/* >> */
						AEGP_StreamRefH 	*streamPH0);	/* << must be disposed by caller! */

	SPAPI A_Err	(*AEGP_RemoveEffectMask)(					/* UNDOABLE */
					AEGP_EffectRefH		effect_refH,		/* >> */
					AEGP_MaskIDVal		id_val);			/* >> */

	SPAPI A_Err	(*AEGP_SetEffectMask)(						/* UNDOABLE */
					AEGP_EffectRefH		effect_refH,		/* >> */
					A_u_long			mask_indexL,		/* >> */
					AEGP_MaskIDVal		id_val,				/* >> */
					AEGP_StreamRefH 	*streamPH0);		/* << must be disposed by caller! */
} AEGP_EffectSuite4;


/* -------------------------------------------------------------------- */

typedef A_long	AEGP_MaskIndex;

enum {
	AEGP_MaskMBlur_SAME_AS_LAYER,
	AEGP_MaskMBlur_OFF,
	AEGP_MaskMBlur_ON
};
typedef A_u_char AEGP_MaskMBlur; // This must be A_u_char, used in disk safe BEE_MaskInfo

enum {
	AEGP_MaskFeatherFalloff_SMOOTH,
	AEGP_MaskFeatherFalloff_LINEAR
};
typedef A_u_char AEGP_MaskFeatherFalloff; // This must be A_u_char, used in disk safe BEE_MaskInfo

enum {
	AEGP_MaskFeatherInterp_NORMAL,
	AEGP_MaskFeatherInterp_HOLD_CW
};
typedef A_u_char AEGP_MaskFeatherInterp;

enum {
	AEGP_MaskFeatherType_OUTER,
	AEGP_MaskFeatherType_INNER
};
typedef A_u_char AEGP_MaskFeatherType;

#define kAEGPMaskSuite					"AEGP Layer Mask Suite"
#define kAEGPMaskSuiteVersion6			7 /* frozen AE 11 */

typedef struct AEGP_MaskSuite6 {

	SPAPI A_Err	(*AEGP_GetLayerNumMasks)(
						AEGP_LayerH				aegp_layerH,		/* >> */
						A_long					*num_masksPL);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerMaskByIndex)(
						AEGP_LayerH				aegp_layerH,		/* >> */
						AEGP_MaskIndex			mask_indexL,		/* >> */
						AEGP_MaskRefH			*maskPH);			/* << must be disposed by calling AEGP_DisposeMask() */

	SPAPI A_Err	(*AEGP_DisposeMask)(
						AEGP_MaskRefH			mask_refH);			/* >> */

	SPAPI A_Err	(*AEGP_GetMaskInvert)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						A_Boolean				*invertPB);			/* << */

	SPAPI A_Err (*AEGP_SetMaskInvert)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						A_Boolean				invertB);			/* << */

	SPAPI A_Err	(*AEGP_GetMaskMode)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						PF_MaskMode				*modeP);			/* << */

	SPAPI A_Err (*AEGP_SetMaskMode)(
						AEGP_MaskRefH			maskH,				/* >> */
						PF_MaskMode				mode);				/* >> */

	SPAPI A_Err (*AEGP_GetMaskMotionBlurState)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						AEGP_MaskMBlur			*blur_stateP);		/* << */

	SPAPI A_Err (*AEGP_SetMaskMotionBlurState)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						AEGP_MaskMBlur			blur_state);		/* >> */

	SPAPI A_Err (*AEGP_GetMaskFeatherFalloff)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						AEGP_MaskFeatherFalloff *feather_falloffP);	/* << */

	SPAPI A_Err (*AEGP_SetMaskFeatherFalloff)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						AEGP_MaskFeatherFalloff	feather_falloffP);	/* >> */

	// AEGP_GetMaskName/SetMaskName are obsoleted. Use AEGP_GetNewDynamicStreamForMask
	// and the name functions there

	SPAPI A_Err	(*AEGP_GetMaskID)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						AEGP_MaskIDVal			*id_valP);			/* << */

	SPAPI A_Err (*AEGP_CreateNewMask)(								/* UNDOABLE */
						AEGP_LayerH				layerH,				/* >> */
						AEGP_MaskRefH			*mask_refPH,		/* << */
						A_long					*mask_indexPL0);	/* << */

	SPAPI A_Err (*AEGP_DeleteMaskFromLayer)(						/* UNDOABLE */
						AEGP_MaskRefH			mask_refH);			/* >> still need to Dispose MaskRefH */

	SPAPI A_Err (*AEGP_GetMaskColor)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						AEGP_ColorVal			*colorP);			/* << */

	SPAPI A_Err (*AEGP_SetMaskColor)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						const AEGP_ColorVal		*colorP);			/* >> */

	SPAPI A_Err	(*AEGP_GetMaskLockState)(
						AEGP_MaskRefH			mask_refH,			/* <> */
						A_Boolean				*is_lockedPB);		/* >> */

	SPAPI A_Err	(*AEGP_SetMaskLockState)(
						AEGP_MaskRefH			mask_refH,			/* <> */
						A_Boolean				lockB);				/* >> */

	SPAPI A_Err (*AEGP_GetMaskIsRotoBezier)(
						AEGP_MaskRefH			mask_refH,			/* <> */
						A_Boolean				*is_roto_bezierPB);	/* << */

	SPAPI A_Err (*AEGP_SetMaskIsRotoBezier)(
						AEGP_MaskRefH			mask_refH,			/* <> */
						A_Boolean				is_roto_bezierB);	/* >> */

	SPAPI A_Err (*AEGP_DuplicateMask)(
						AEGP_MaskRefH			orig_mask_refH,			/* >> */
						AEGP_MaskRefH			*duplicate_mask_refPH);	/* << */

} AEGP_MaskSuite6;


/* -------------------------------------------------------------------- */

typedef struct {
	A_long					segment;			/* mask segment where feather is located	*/
	PF_FpLong				segment_sF;			/* 0-1: feather location on segment			*/
	PF_FpLong				radiusF;			/* negative value allowed if type == AEGP_MaskFeatherType_INNER */
	PF_FpShort				ui_corner_angleF;	/* 0-1: angle of UI handle on corners		*/
	PF_FpShort				tensionF;			/* 0-1: tension of boundary at feather pt	*/
	AEGP_MaskFeatherInterp	interp;
	AEGP_MaskFeatherType	type;				
} AEGP_MaskFeather;

typedef A_long	AEGP_FeatherIndex;

typedef PF_PathVertex		AEGP_MaskVertex;

typedef A_long	AEGP_VertexIndex;
#define AEGP_VertexIndex_END 10922

#define kAEGPMaskOutlineSuite				"AEGP Mask Outline Suite"
#define kAEGPMaskOutlineSuiteVersion3		5 /* frozen in AE 11 */

typedef struct AEGP_MaskOutlineSuite3 {

	SPAPI A_Err	(*AEGP_IsMaskOutlineOpen)(
						AEGP_MaskOutlineValH		mask_outlineH,		/* >> */
						A_Boolean					*openPB);			/* << */

	SPAPI A_Err (*AEGP_SetMaskOutlineOpen)(
						AEGP_MaskOutlineValH		mask_outlineH,		/* >> */
						A_Boolean					openB);				/* >> */

	// N segments means there are segments [0..N-1]; segment J is defined by vertex J & J+1
	SPAPI A_Err	(*AEGP_GetMaskOutlineNumSegments)(
						AEGP_MaskOutlineValH		mask_outlineH,		/* >> */
						A_long						*num_segmentsPL);	/* << */

	// which_pointL range: [0..num_segments]; for closed masks vertex[0] == vertex[num_segments]
	SPAPI A_Err	(*AEGP_GetMaskOutlineVertexInfo)(
						AEGP_MaskOutlineValH		mask_outlineH,		/* >> */
						AEGP_VertexIndex			which_pointL,		/* >> */
						AEGP_MaskVertex				*vertexP);			/* << tangents are relative to position */

	// Setting vertex 0 is special. Its in tangent will actually set the out tangent
	// of the last vertex in the outline.
	SPAPI A_Err	(*AEGP_SetMaskOutlineVertexInfo)(
						AEGP_MaskOutlineValH		mask_outlineH,		/* >> */
						AEGP_VertexIndex			which_pointL,		/* >> must already exists (use Create) */
						const AEGP_MaskVertex		*vertexP);			/* >> tangents are relative to position */

	SPAPI A_Err (*AEGP_CreateVertex)(
						AEGP_MaskOutlineValH		mask_outlineH,		/* >> */
						AEGP_VertexIndex			insert_position);	/* >> will insert at this index. moving other verticies index++*/

	SPAPI A_Err (*AEGP_DeleteVertex)(
						AEGP_MaskOutlineValH		mask_outlineH,		/* >> */
						AEGP_VertexIndex			index);				/* >> */


	SPAPI A_Err	(*AEGP_GetMaskOutlineNumFeathers)(
						AEGP_MaskOutlineValH		mask_outlineH,		/* >> */
						A_long						*num_feathersPL);	/* << */

	SPAPI A_Err	(*AEGP_GetMaskOutlineFeatherInfo)(
						AEGP_MaskOutlineValH		mask_outlineH,		/* >> */
						AEGP_FeatherIndex			which_featherL,		/* >> */
						AEGP_MaskFeather			*featherP);			/* << */

	SPAPI A_Err	(*AEGP_SetMaskOutlineFeatherInfo)(
						AEGP_MaskOutlineValH		mask_outlineH,		/* >> */
						AEGP_VertexIndex			which_featherL,		/* >> must already exists (use Create) */
						const AEGP_MaskFeather		*featherP);			/* >> */

	SPAPI A_Err (*AEGP_CreateMaskOutlineFeather)(
						AEGP_MaskOutlineValH		mask_outlineH,		/* >> */
						const AEGP_MaskFeather		*featherP0,			/* >> */
						AEGP_FeatherIndex			*insert_positionP);	/* << index of new feather */

	SPAPI A_Err (*AEGP_DeleteMaskOutlineFeather)(
						AEGP_MaskOutlineValH		mask_outlineH,		/* >> */
						AEGP_FeatherIndex			index);				/* >> */

} AEGP_MaskOutlineSuite3;


/* -------------------------------------------------------------------- */


typedef	FIEL_Label AEGP_InterlaceLabel;

enum {
	AEGP_AlphaPremul 		= 0x1,		/* otherwise straight */
	AEGP_AlphaInverted		= 0x2,		/*  255 = transparent */
	AEGP_AlphaIgnore		= 0x4
};
typedef A_u_long	AEGP_AlphaFlags;

typedef struct {
	AEGP_AlphaFlags	flags;
	A_u_char		redCu;		// color that was matted (if premul)
	A_u_char		greenCu;
	A_u_char		blueCu;
} AEGP_AlphaLabel;

enum {
	AEGP_PulldownPhase_NO_PULLDOWN = 0,
	AEGP_PulldownPhase_WSSWW = 1,
	AEGP_PulldownPhase_SSWWW,
	AEGP_PulldownPhase_SWWWS,
	AEGP_PulldownPhase_WWWSS,
	AEGP_PulldownPhase_WWSSW,
	AEGP_PulldownPhase_WWWSW,
	AEGP_PulldownPhase_WWSWW,
	AEGP_PulldownPhase_WSWWW,
	AEGP_PulldownPhase_SWWWW,
	AEGP_PulldownPhase_WWWWS
};
typedef A_long AEGP_PulldownPhase;

typedef struct {
	A_long			loops;
	A_long			reserved;		/* set to 0; reserved for future use (palindrome, etc.) */
} AEGP_LoopBehavior;

typedef struct {
	AEGP_InterlaceLabel		il;
	AEGP_AlphaLabel			al;
	AEGP_PulldownPhase		pd;
	AEGP_LoopBehavior		loop;
	A_Ratio					pix_aspect_ratio;
	A_FpLong				native_fpsF;
	A_FpLong				conform_fpsF;
	A_long					depthL;
	A_Boolean				motion_dB;
} AEGP_FootageInterp;

#define AEGP_FOOTAGE_LAYER_NAME_LEN		(63)
#define AEGP_LayerIndex_UNKNOWN			(-2)
#define AEGP_LayerIndex_MERGED			(-1)
#define AEGP_LayerID_UNKNOWN			(-1)

enum {
	AEGP_LayerDrawStyle_LAYER_BOUNDS = 0,
	AEGP_LayerDrawStyle_DOCUMENT_BOUNDS
};

typedef A_long AEGP_LayerDrawStyle;


typedef struct {
	A_long					layer_idL;									/* unique ID for layer, as contained in a Photoshop document's 'lyid' resource. */
																		/* pass AEGP_LayerID_UNKNOWN if you don't know this */
	A_long					layer_indexL;								/* zero-based layer index. pass AEGP_LayerIndex_MERGED for merged layers */
	A_char					nameAC[AEGP_FOOTAGE_LAYER_NAME_LEN + 1];	/* used for sequences and backup for linking  */
	AEGP_LayerDrawStyle		layer_draw_style;

} AEGP_FootageLayerKey;

#define AEGP_ANY_FRAME -1

typedef struct {
	A_Boolean	all_in_folderB;                 /* TRUE means intepret as a sequence, FALSE means still frame.
												   If FALSE, other parameters in this structure have no effect. */
	A_Boolean	force_alphabeticalB;			/* if TRUE, filenames of sequence will be forced to alphabetical order */
	A_long		start_frameL;                   /* first frame of sequence, AEGP_ANY_FRAME means earliest frame found */
	A_long		end_frameL;						/* last frame of sequence, AEGP_ANY_FRAME means last frame found */
} AEGP_FileSequenceImportOptions;

enum {
	AEGP_FootageSignature_NONE = -1,		// invalid sig
	AEGP_FootageSignature_MISSING = 0,		// placeholder
	AEGP_FootageSignature_SOLID = 'Soli'
};
typedef A_long AEGP_FootageSignature;


#define AEGP_FOOTAGE_MAIN_FILE_INDEX		0

#define kAEGPFootageSuite				"AEGP Footage Suite"

#define kAEGPFootageSuiteVersion5		11 /* frozen in AE 10.0 */


enum {
	AEGP_InterpretationStyle_NO_DIALOG_GUESS = 0,		// FALSE for backwards compatability:  will guess alpha interpretation even if file contains unknown alpha interpretation and user pref says to ask user
	AEGP_InterpretationStyle_DIALOG_OK = 1,				// TRUE for backwards comptability. Optionally can show a dialog.
	AEGP_InterpretationStyle_NO_DIALOG_NO_GUESS = 2  // used for replace footage implementation
};
typedef A_u_char AEGP_InterpretationStyle;

typedef struct AEGP_FootageSuite5 {

	SPAPI A_Err	(*AEGP_GetMainFootageFromItem)(						/* error if item isn't AEGP_ItemType_FOOTAGE! */
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_FootageH		*footagePH);			/* << */

	SPAPI A_Err	(*AEGP_GetProxyFootageFromItem)(					/* error if has_proxy is false! (note, item could still be a comp) */
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_FootageH		*proxy_footagePH);		/* << */

	SPAPI A_Err	(*AEGP_GetFootageNumFiles)(
						AEGP_FootageH		footageH,				/* >> */
						A_long				*num_main_filesPL0,		/* << */
						A_long				*files_per_framePL0);	/* << includes main file. e.g. 1 for no aux data */

	SPAPI A_Err	(*AEGP_GetFootagePath)(
						AEGP_FootageH		footageH,				/* >> */
						A_long				frame_numL,				/* >> range is 0 to num_main_files */
						A_long			 	file_indexL,			/* >> AEGP_FOOTAGE_MAIN_FILE_INDEX is main file */
						AEGP_MemHandle		*unicode_pathPH);		// << empty string if no file. handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle

	SPAPI A_Err (*AEGP_GetFootageSignature)(
						AEGP_FootageH			footageH,			/* >> */
						AEGP_FootageSignature	*sigP);				/* << like filetype, but also for non-file types like solids, etc. */

	SPAPI A_Err	(*AEGP_NewFootage)(
						AEGP_PluginID				aegp_plugin_id,		/* >> */
						const A_UTF16Char			*pathZ,				// >> null terminated unicode path with platform separators
						const AEGP_FootageLayerKey	*layer_infoP0,		/* >> optional layer info; pass NULL for merged layers */
						const AEGP_FileSequenceImportOptions *sequence_optionsP0, /* >> optional sequence info; passing NULL means not a sequence */
						AEGP_InterpretationStyle	interp_style,		/* >> (in) */
  						void 						*reserved,			/* >> pass NULL */
						AEGP_FootageH				*footagePH);		/* << caller owns until disposed or added to project */

	SPAPI A_Err	(*AEGP_AddFootageToProject)(						/* UNDOABLE */
						AEGP_FootageH		footageH,				/* >> will be adopted by project, may not be added more than once */
						AEGP_ItemH 			folderH,				/* >> add to this folder */
						AEGP_ItemH			*added_itemPH0);		/* << */

	SPAPI A_Err	(*AEGP_SetItemProxyFootage)(						/* UNDOABLE */
						AEGP_FootageH		footageH,				/* >> will be adopted by project, may not be set more than once */
						AEGP_ItemH 			itemH);					/* >> set for this item */

	SPAPI A_Err	(*AEGP_ReplaceItemMainFootage)(						/* UNDOABLE */
						AEGP_FootageH		footageH,				/* >> will be adopted by project, may not be set more than once */
						AEGP_ItemH 			itemH);					/* >> replace main footage for this item */

	SPAPI A_Err	(*AEGP_DisposeFootage)(
						AEGP_FootageH		footageH);				/* >> do not dipose footage that is owned or has been adopted by project */

	SPAPI A_Err (*AEGP_GetFootageInterpretation)(
						AEGP_ItemH 			itemH,					/* >> note: item that contains footage */
						A_Boolean			proxyB,					/* >> TRUE = get proxy interp; FALSE = get main interp */
						AEGP_FootageInterp	*interpP);				/* << */

	SPAPI A_Err (*AEGP_SetFootageInterpretation)(					/* UNDOABLE */
						AEGP_ItemH 			itemH,					/* >> note: item that contains footage */
						A_Boolean			proxyB,					/* >> TRUE = set proxy interp; FALSE = set main interp */
						const AEGP_FootageInterp	*interpP);		/* >> */

	SPAPI A_Err (*AEGP_GetFootageLayerKey) (
						AEGP_FootageH			footageH,			/* >> */
						AEGP_FootageLayerKey	*layerKeyP);		/* << the footages layer info */

	SPAPI A_Err (*AEGP_NewPlaceholderFootage)(						/* doesn't modify project, creates footage with AEGP_FootageSignature_MISSING */
						AEGP_PluginID		plugin_id,				/* >> */
						const A_char		*nameZ,					/* >> 	 file name, not the path! */
						A_long				width,					/* >> */
						A_long				height,					/* >> */
						const A_Time		*durationPT,			/* >> */
						AEGP_FootageH		*footagePH);			/* << caller owns until disposed or added to project */

	SPAPI A_Err	(*AEGP_NewPlaceholderFootageWithPath)(				/* doesn't modify project, creates footage with AEGP_FootageSignature_MISSING */
						AEGP_PluginID		plugin_id,				/* >> */
						const A_UTF16Char	*pathZ,					// >> null terminated unicode path with platform separators
						AEGP_Platform		path_platform,			/* >>  Mac or Win */
						AEIO_FileType		file_type, 				// >>  AEIO_FileType_NONE is now a warning condition. If you pass AEIO_FileType_ANY, then path MUST exist.  if path may not exist: pass AEIO_FileType_DIR for folder, or AEIO_FileType_GENERIC for a file
						A_long				widthL,					/* >> */
						A_long				heightL,				/* >> */
						const	A_Time		*durationPT,			/* >> */
						AEGP_FootageH		*footagePH);			/* << caller owns until disposed or added to project */

	SPAPI A_Err (*AEGP_NewSolidFootage)(							/* doesn't modify project, creates footage with AEGP_FootageSignature_SOLID */
						const A_char		*nameZ,					/* >> 	 file name, not the path! */
						A_long				width,					/* >> */
						A_long				height,					/* >> */
						const AEGP_ColorVal	*colorP,				/* >> */
						AEGP_FootageH		*footagePH);			/* << caller owns until disposed or added to project */

	SPAPI A_Err	(*AEGP_GetSolidFootageColor)(						/* error if footage isn't AEGP_FootageSignature_SOLID */
						AEGP_ItemH 			itemH,					/* >> note: item that contains footage */
						A_Boolean			proxyB,					/* >> TRUE = get proxy solid color; FALSE = get main solid color */
						AEGP_ColorVal		*colorP);				/* << */

	SPAPI A_Err	(*AEGP_SetSolidFootageColor)(						/* UNDOABLE, error if footage isn't AEGP_FootageSignature_SOLID */
						AEGP_ItemH 			itemH,					/* >> note: item that contains footage */
						A_Boolean			proxyB,					/* >> TRUE = set proxy solid color; FALSE = set main solid color */
						const AEGP_ColorVal	*colorP);				/* >> */

	SPAPI A_Err (*AEGP_SetSolidFootageDimensions)(					/* UNDOABLE, error if footage isn't AEGP_FootageSignature_SOLID */
						AEGP_ItemH 			itemH,					/* >> note: item that contains footage */
						A_Boolean			proxyB,					/* >> TRUE = set proxy solid size; FALSE = set main solid size */
						A_long				widthL,					/* >> min 1, max 30,000 */
						A_long				heightL);				/* >> min 1, max 30,000 */

	SPAPI A_Err (*AEGP_GetFootageSoundDataFormat)(
					AEGP_FootageH			footageH,				/* >> */
					AEGP_SoundDataFormat*	sound_formatP);			/* << */

	SPAPI A_Err (*AEGP_GetFootageSequenceImportOptions)(
					AEGP_FootageH						footageH,		/* >> */
					AEGP_FileSequenceImportOptions		*optionsP);		/* << */

} AEGP_FootageSuite5;

/* -------------------------------------------------------------------- */


typedef A_long	AEGP_Command;

#define AEGP_Command_ALL		0

enum {
	AEGP_WindType_NONE,
	AEGP_WindType_PROJECT,
	AEGP_WindType_COMP,
	AEGP_WindType_TIME_LAYOUT,
	AEGP_WindType_LAYER,
	AEGP_WindType_FOOTAGE,
	AEGP_WindType_RENDER_QUEUE,
	AEGP_WindType_QT,
	AEGP_WindType_DIALOG,
	AEGP_WindType_FLOWCHART,
	AEGP_WindType_EFFECT,
	AEGP_WindType_OTHER
};
typedef A_LegacyEnumType AEGP_WindowType;


enum {
	AEGP_HP_BeforeAE 		= 0x1,		// call hook before AE handles event (if AE handles)
	AEGP_HP_AfterAE			= 0x2		// call hook after AE handles event (if AE handles)
};
typedef A_u_long	AEGP_HookPriority;


typedef A_Err		(*AEGP_CommandHook)(
						AEGP_GlobalRefcon	plugin_refconP,			/* >> */
						AEGP_CommandRefcon	refconP,				/* >> */
						AEGP_Command		command,				/* >> */
						AEGP_HookPriority	hook_priority,			/* >> currently always AEGP_HP_BeforeAE */
						A_Boolean			already_handledB,		/* >> */
						A_Boolean			*handledPB);			/* << whether you handled */

typedef A_Err		(*AEGP_UpdateMenuHook)(
						AEGP_GlobalRefcon		plugin_refconP,		/* >> */
						AEGP_UpdateMenuRefcon	refconP,			/* >> */
						AEGP_WindowType			active_window);		/* >> */

typedef A_Err		(*AEGP_DeathHook)(
						AEGP_GlobalRefcon	plugin_refconP,			/* >> */
						AEGP_DeathRefcon	refconP);				/* >> */

typedef A_Err		(*AEGP_VersionHook)(							/* As of 5.0, not called */
						AEGP_GlobalRefcon	plugin_refconP,			/* >> */
						AEGP_VersionRefcon	refconP,				/* >> */
						A_u_long 			*pf_versionPLu);		/* << use PF_VERSION() macro to build and PF_Version_XXX() macros to access */

					// one line description. when displaying, AE will prepend name and version information.
					// this will be used to display a list of about info for all plugins

typedef A_Err		(*AEGP_AboutStringHook)(						/* As of 5.0, not called */
						AEGP_GlobalRefcon	plugin_refconP,			/* >> */
						AEGP_AboutStringRefcon	refconP,			/* >> */
						A_char				*aboutZ);				/* << space for A_char[AEGP_MAX_ABOUT_STRING_SIZE] */

					// bring up a dialog and tell us about yourself
typedef A_Err		(*AEGP_AboutHook)(								/* As of 5.0, not called */
						AEGP_GlobalRefcon	plugin_refconP,			/* >> */
						AEGP_AboutRefcon	refconP);				/* >> */

typedef A_Err		(*AEGP_IdleHook)(
						AEGP_GlobalRefcon	plugin_refconP,			/* >> */
						AEGP_IdleRefcon		refconP,				/* >> */
						A_long 				*max_sleepPL);			/* <> in 1/60 of a second*/




#define kAEGPRegisterSuite				"AEGP Register Suite"
#define kAEGPRegisterSuiteVersion5		6 /* frozen AE 10.0 */

typedef struct AEGP_RegisterSuite5 {

	SPAPI A_Err	(*AEGP_RegisterCommandHook)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_HookPriority	hook_priority,			/* >> */
						AEGP_Command		command,				/* >> use AEGP_Command_ALL to get all commands */
						AEGP_CommandHook	command_hook_func,		/* >> */
						AEGP_CommandRefcon	refconP);				/* >> */

	// this will be called anytime any menu is about to be drawn. it isn't specific to a menu so you
	// must enable all appropriate menu items when this hook is called.

	SPAPI A_Err	(*AEGP_RegisterUpdateMenuHook)(
						AEGP_PluginID			plugin_id,				/* >> */
						AEGP_UpdateMenuHook		update_menu_hook_func,	/* >> */
						AEGP_UpdateMenuRefcon	refconP);				/* >> */

	SPAPI A_Err	(*AEGP_RegisterDeathHook)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_DeathHook		death_hook_func,		/* >> */
						AEGP_DeathRefcon	refconP);				/* >> */

	SPAPI A_Err	(*AEGP_RegisterVersionHook)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_VersionHook	version_hook_func,		/* >> */
						AEGP_VersionRefcon	refconP);				/* >> */

	SPAPI A_Err	(*AEGP_RegisterAboutStringHook)(
						AEGP_PluginID			aegp_plugin_id,				/* >> */
						AEGP_AboutStringHook	about_string_hook_func,		/* >> */
						AEGP_AboutStringRefcon	refconP);					/* >> */

	SPAPI A_Err	(*AEGP_RegisterAboutHook)(
						AEGP_PluginID		aegp_plugin_id,					/* >> */
						AEGP_AboutHook		about_hook_func,				/* >> */
						AEGP_AboutRefcon	refconP);						/* >> */

	SPAPI A_Err	 (*AEGP_RegisterArtisan) (
						A_Version					api_version,			/* >> */
						A_Version					artisan_version,		/* >> */
						AEGP_PluginID				aegp_plugin_id,			/* >> */
						void						*aegp_refconPV,			/* <> */
						const A_char				*utf8_match_nameZ,		/* >> */
						const A_char				*artisan_nameZ,			/* >> */
						PR_ArtisanEntryPoints		*entry_funcs);			/* >> */

	SPAPI A_Err	 (*AEGP_RegisterIO) (
						AEGP_PluginID				aegp_plugin_id,			/* >> */
						AEGP_IORefcon				aegp_refconP,			/* >> */
						const AEIO_ModuleInfo		*io_infoP,				/* >> */
						const AEIO_FunctionBlock4	*aeio_fcn_blockP);		/* >> */

	SPAPI A_Err	(*AEGP_RegisterIdleHook)(
						AEGP_PluginID		aegp_plugin_id,					/* >> */
						AEGP_IdleHook		idle_hook_func,					/* >> */
						AEGP_IdleRefcon		refconP);						/* >> */


	SPAPI A_Err (*AEGP_RegisterTracker)(
						A_Version					api_version,			/* >> */
						A_Version					tracker_version,		/* >> */
						AEGP_PluginID				aegp_plugin_id,			/* >> */
						const	AEGP_GlobalRefcon	refconP,				/* >> */
						const A_char				*utf8_match_nameZ,		/* >> */
						const A_char				*tracker_nameZ,			/* >> */
						const PT_TrackerEntryPoints	*entry_pointsP);		/* >> */

	SPAPI A_Err	 (*AEGP_RegisterInteractiveArtisan) (
						A_Version					api_version,			/* >> */
						A_Version					artisan_version,		/* >> */
						AEGP_PluginID				aegp_plugin_id,			/* >> */
						void						*aegp_refconPV,			/* <> */
						const A_char				*utf8_match_nameZ,		/* >> */
						const A_char				*artisan_nameZ,			/* >> */
						PR_ArtisanEntryPoints		*entry_funcs);			/* >> */

	// Call this to register as many strings as you like for name-replacement
	// when presets are loaded. Any time a Property name is found, or referred
	// to in an expression, and it starts with an ASCII tab character ('\t'), followed
	// by one of the english names, it will be replaced with the localized name. (In
	// English the tab character will simply be removed).
	SPAPI A_Err	 (*AEGP_RegisterPresetLocalizationString) (
						const A_char				*english_nameZ,			/* >> */
						const A_char				*localized_nameZ);		/* >> */



} AEGP_RegisterSuite5;


/* -------------------------------------------------------------------- */


enum {
	AEGP_Menu_NONE,
	AEGP_Menu_APPLE,
	AEGP_Menu_FILE,
	AEGP_Menu_EDIT,
	AEGP_Menu_COMPOSITION,
	AEGP_Menu_LAYER,
	AEGP_Menu_EFFECT,
	AEGP_Menu_WINDOW,
	AEGP_Menu_FLOATERS,
	AEGP_Menu_KF_ASSIST,
	AEGP_Menu_IMPORT,
	AEGP_Menu_SAVE_FRAME_AS,
	AEGP_Menu_PREFS,
	AEGP_Menu_EXPORT,
	AEGP_Menu_ANIMATION,
	AEGP_Menu_PURGE,
	//the following menu options only valid for AE 12.0 and up
	AEGP_Menu_NEW
};
typedef A_LegacyEnumType AEGP_MenuID;


#define AEGP_MENU_INSERT_SORTED			(-2)
#define AEGP_MENU_INSERT_AT_BOTTOM		(-1)
#define AEGP_MENU_INSERT_AT_TOP			0


#define kAEGPCommandSuite				"AEGP Command Suite"
#define kAEGPCommandSuiteVersion1		1 /* frozen in AE 5.0 */

typedef struct AEGP_CommandSuite1 {

	SPAPI A_Err	(*AEGP_GetUniqueCommand)(
						AEGP_Command		*unique_commandP);		/* << */

	SPAPI A_Err	(*AEGP_InsertMenuCommand)(
						AEGP_Command		command,				/* >> */
						const A_char 		*nameZ,					/* >> */
						AEGP_MenuID 		menu_id,				/* >> */
						A_long 				after_itemL);			/* >> */

	SPAPI A_Err	(*AEGP_RemoveMenuCommand)(
						AEGP_Command		command);				/* >> */

	SPAPI A_Err	(*AEGP_SetMenuCommandName)(
						AEGP_Command		command,				/* >> */
						const A_char		*nameZ);				/* >> */

	SPAPI A_Err	(*AEGP_EnableCommand)(
						AEGP_Command		command);				/* >> */

	SPAPI A_Err	(*AEGP_DisableCommand)(
						AEGP_Command		command);				/* >> */

	SPAPI A_Err	(*AEGP_CheckMarkMenuCommand)(
						AEGP_Command		command,				/* >> */
						A_Boolean			checkB);				/* >> */

	SPAPI A_Err	(*AEGP_DoCommand)(
						AEGP_Command		command);				/* >> */

} AEGP_CommandSuite1;




/* -------------------------------------------------------------------- */


typedef struct {
	A_long				reservedAL[12];
} AEGP_ErrReportState;


enum {
	AEGP_GetPathTypes_PLUGIN = 0,		// (Not Implemented) The path to the executable of the plugin itself.
	AEGP_GetPathTypes_USER_PLUGIN,		// The suite specific location of user specific plugins.
	AEGP_GetPathTypes_ALLUSER_PLUGIN,	// The suite specific location of plugins shared by all users.
	AEGP_GetPathTypes_APP				// The After Effects exe or .app location.  Not plugin specific.
	};
typedef A_u_long AEGP_GetPathTypes;


#define kAEGPUtilitySuite				"AEGP Utility Suite"
#define kAEGPUtilitySuiteVersion6		13 /* frozen in AE 12.0 */

typedef struct AEGP_UtilitySuite6 {

	SPAPI A_Err	(*AEGP_ReportInfo)(										/* displays dialog with name of plugin followed by info string. See also: ReportInfoUnicode */
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						const A_char			*info_stringZ);			/* >> */
	
	SPAPI A_Err	(*AEGP_ReportInfoUnicode)(								/* displays dialog with name of plugin followed by info string */
										  AEGP_PluginID			aegp_plugin_id,			/* >> */
										  const A_UTF16Char		*info_stringP);			/* >> */

	SPAPI A_Err	(*AEGP_GetDriverPluginInitFuncVersion)(
						A_short					*major_versionPS,		/* << */
						A_short					*minor_versionPS);		/* << */

	SPAPI A_Err	(*AEGP_GetDriverImplementationVersion)(
						A_short					*major_versionPS,		/* << */
						A_short					*minor_versionPS);		/* << */

	SPAPI A_Err	(*AEGP_StartQuietErrors)(
						AEGP_ErrReportState		*err_stateP);			/* << */

	SPAPI A_Err	(*AEGP_EndQuietErrors)(
						A_Boolean				report_quieted_errorsB,	/* >> currently reports last quieted error */
						AEGP_ErrReportState		*err_stateP);			/* >> */

	SPAPI A_Err (*AEGP_GetLastErrorMessage)(
						A_long					buffer_size,			/* >> size of character buffer */
						A_char					*error_string,					/* << */
						A_Err					*error_num);				/* << */

	SPAPI A_Err	(*AEGP_StartUndoGroup)(									/* MUST be balanced with call to AEGP_EndUndoGroup() */
						const A_char			*undo_nameZ);			/* >> */

	SPAPI A_Err	(*AEGP_EndUndoGroup)(void);

	SPAPI A_Err (*AEGP_RegisterWithAEGP)(
						AEGP_GlobalRefcon 		global_refcon,			/* >> global refcon passed in command handlers */
						const A_char			*plugin_nameZ,			/* >> name of this plugin. AEGP_MAX_PLUGIN_NAME_SIZE */
						AEGP_PluginID			*plugin_id);			/* << id for plugin to use in other AEGP calls */

	SPAPI A_Err (*AEGP_GetMainHWND)(
						void					*main_hwnd);			/* << */

	SPAPI A_Err (*AEGP_ShowHideAllFloaters)(
						A_Boolean				include_tool_palB);		/* >> */

	SPAPI A_Err (*AEGP_PaintPalGetForeColor)(
						AEGP_ColorVal			*fore_colorP);			/* << */

	SPAPI A_Err (*AEGP_PaintPalGetBackColor)(
						AEGP_ColorVal			*back_colorP);			/* << */

	SPAPI A_Err (*AEGP_PaintPalSetForeColor)(
						const AEGP_ColorVal		*fore_colorP);			/* >> */

	SPAPI A_Err (*AEGP_PaintPalSetBackColor)(
						const AEGP_ColorVal		*back_colorP);			/* >> */

	SPAPI A_Err (*AEGP_CharPalGetFillColor)(
						A_Boolean				*is_fill_color_definedPB,	/*  << */
                        AEGP_ColorVal			*fill_colorP); 				/* << only valid if is_fill_color_definedPB == TRUE */

	SPAPI A_Err (*AEGP_CharPalGetStrokeColor)(
						A_Boolean				*is_stroke_color_definedPB, /*  << */
                        AEGP_ColorVal			*stroke_colorP); 			/* << only valid if is_stroke_color_definedPB == TRUE */

	SPAPI A_Err (*AEGP_CharPalSetFillColor)(
						const AEGP_ColorVal		*fill_colorP);				/* >> */

	SPAPI A_Err (*AEGP_CharPalSetStrokeColor)(
						const AEGP_ColorVal		*stroke_colorP);			/* >> */

	SPAPI A_Err (*AEGP_CharPalIsFillColorUIFrontmost)(						/* Otherwise, StrokeColor is frontmost */
						A_Boolean				*is_fill_color_selectedPB);	/* << */

	SPAPI A_Err (*AEGP_ConvertFpLongToHSFRatio)(
						A_FpLong				numberF,					/* >> */
						A_Ratio					*ratioPR);					/* << */

	SPAPI A_Err (*AEGP_ConvertHSFRatioToFpLong)(
						A_Ratio					ratioR,						/* << */
						A_FpLong				*numberPF);					/* >> */

	// this routine is safe to call from the non-main
	// thread. It is asynchronous and will return before the idle handler is called.
	// The Suite routines to get this pointer are not
	// thread safe, therefore you need to save it off
	// in the main thread for use by the child thread.
	SPAPI A_Err (*AEGP_CauseIdleRoutinesToBeCalled)(void);


	// Determine if after effects is running in a mode where there is no
	// user interface, and attempting to interact with the user (via a modal dialog)
	// will hang the application.
	// This will not change during a run. Use it to optimize your plugin at startup
	// to not create a user interface and make AE launch faster, and not break
	// when running multiple instances of a service.
	SPAPI	A_Err  (*AEGP_GetSuppressInteractiveUI)(A_Boolean* ui_is_suppressedPB); // out

	// this call writes text to the console if one is available.  One is guaranteed to be available
	// if ui_is_suppressedB == true.
	// In general use the call AEGP_ReportInfo() as it will write to the console in
	// non-interactive modes, and use a dialog in interactive modes.
	SPAPI	A_Err  (*AEGP_WriteToOSConsole)(const A_char* textZ);				// in

	// this writes an entry into the debug log, or to the command line if launched
	// with the -debug flag.
	SPAPI	A_Err  (*AEGP_WriteToDebugLog)(const A_char* subsystemZ,	// in
								const A_char* event_typeZ,				// in
								const A_char * infoZ);					// in


	SPAPI	A_Err  (*AEGP_IsScriptingAvailable)(A_Boolean* outAvailablePB);

	// Execute a script.
	// The script text can either be in UTF-8, or the current
	// application encoding.
	// The result is the result string if OK. It is optional.
	// The error is the error string if an error occurred. It is optional.
	// the result and error are in the encoding specified by platform_encodingB
	SPAPI	A_Err  (*AEGP_ExecuteScript)(AEGP_PluginID			inPlugin_id,
										const A_char* inScriptZ,		// in
										const A_Boolean platform_encodingB,	// in
										AEGP_MemHandle* outResultPH0,
										AEGP_MemHandle* outErrorStringPH0);

	SPAPI A_Err (*AEGP_HostIsActivated)(A_Boolean	*is_activatedPB);

	SPAPI A_Err (*AEGP_GetPluginPlatformRef)(AEGP_PluginID	plug_id, void** plat_refPPV); // on the Mac, it is a CFBundleRef to your mach-o plugin or NULL for a CFM plug-in; on Windows it is set to NULL for now

	SPAPI A_Err (*AEGP_UpdateFontList)(void); // Rescan the system font list.  This will return quickly if the font list hasn't changed.
	
	// return a particular path associated with the plugin
	SPAPI A_Err (*AEGP_GetPluginPaths)( 
							AEGP_PluginID		aegp_plugin_id,			// >> which plugin we are talking about
							AEGP_GetPathTypes	path_type,				// >> which path type to retrieve
							AEGP_MemHandle		*unicode_pathPH);		// << UTF16 mem handle must be disposed with AEGP_FreeMemHandle

} AEGP_UtilitySuite6;



/* -------------------------------------------------------------------- */


#define kAEGPMathSuite				"AEGP Math Suite"
#define kAEGPMathSuiteVersion1		1	/* frozen AE 15.0 */

typedef struct AEGP_MathSuite1 {
	
	// Matrices
	// right-hand rule, Y down, origin in upper left corner of comp.
	
	SPAPI A_Err(*AEGP_IdentityMatrix4)(A_Matrix4  *matrixP);
	
	SPAPI A_Err(*AEGP_MultiplyMatrix4)(const A_Matrix4 *A, const A_Matrix4 *B, A_Matrix4     *resultP);
	
	SPAPI A_Err(*AEGP_Matrix3ToMatrix4)(const A_Matrix3 *A, A_Matrix4     *B);
	
	SPAPI A_Err(*AEGP_MultiplyMatrix4by3)(const A_Matrix4 *A, const A_Matrix3 *B, A_Matrix4     *resultP);
	
	SPAPI A_Err(*AEGP_MatrixDecompose4)(const A_Matrix4 *A, A_FloatPoint3* posVP, A_FloatPoint3* scaleVP, A_FloatPoint3* shearVP, A_FloatPoint3* rotVP);
	
} AEGP_MathSuite1;


/* -------------------------------------------------------------------- */



typedef struct _PF_OpaqueBlendingTables	*PF_EffectBlendingTables;

#define kAEGPColorSettingsSuite			"PF Color Settings Suite"
#define kAEGPColorSettingsSuiteVersion5	6	// frozen in AE 23.2; Add APIs to get OCIO Config file, Display and Working Color Space information

typedef struct AEGP_ColorSettingsSuite5 {

	 SPAPI	A_Err (*AEGP_GetBlendingTables)(
		PR_RenderContextH 		render_contextH,
		PF_EffectBlendingTables *blending_tables);
		
	SPAPI	A_Err (*AEGP_DoesViewHaveColorSpaceXform)(
		AEGP_ItemViewP	viewP,			// >>
		A_Boolean		*has_xformPB);	// <<
		
	SPAPI	A_Err (*AEGP_XformWorkingToViewColorSpace)(
		AEGP_ItemViewP	viewP,		// >>
		AEGP_WorldH		srcH,		// in
		AEGP_WorldH		dstH);		// out; must be the same size (can be the same as source)
		
	SPAPI	A_Err (*AEGP_GetNewWorkingSpaceColorProfile)(
		AEGP_PluginID		aegp_plugin_id,					// >>
		AEGP_CompH			compH,							// >> 
		AEGP_ColorProfileP	*color_profilePP);				// << caller must dispose with AEGP_DisposeColorProfile
		
	SPAPI	A_Err (*AEGP_GetNewColorProfileFromICCProfile)(
		AEGP_PluginID		aegp_plugin_id,		// >>
		A_long				icc_sizeL,			// >>	icc profile size
		const	void		*icc_dataPV,		// >>	icc profile
		AEGP_ColorProfileP	*color_profilePP);	// <<	builds AEGP_ColorProfile from icc profile; caller must dispose with AEGP_DisposeColorProfile
		
	SPAPI	A_Err (*AEGP_GetNewICCProfileFromColorProfile)(
		AEGP_PluginID			aegp_plugin_id,		// >>
		AEGP_ConstColorProfileP	color_profileP,		// >>
		AEGP_MemHandle			*icc_profilePH);	// <<	extract icc profile from AEGP_ColorProfile; caller must dispose with AEGP_FreeMemHandle
		
	SPAPI	A_Err (*AEGP_GetNewColorProfileDescription)(
		AEGP_PluginID			aegp_plugin_id,		// >>
		AEGP_ConstColorProfileP	color_profileP,		// >>
		AEGP_MemHandle			*unicode_descPH);	// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle 
		
	SPAPI	A_Err (*AEGP_DisposeColorProfile)(
		AEGP_ColorProfileP	color_profileP);	// >>
		
	SPAPI	A_Err (*AEGP_GetColorProfileApproximateGamma)(
		AEGP_ConstColorProfileP	color_profileP,		// >>
		A_FpShort				*approx_gammaP);	// <<
		
	SPAPI	A_Err (*AEGP_IsRGBColorProfile)(
		AEGP_ConstColorProfileP	color_profileP,		// <<
		A_Boolean				*is_rgbPB);			// >>
	
	SPAPI	A_Err (*AEGP_SetWorkingColorSpace)(
		AEGP_PluginID			aegp_plugin_id,
		AEGP_CompH				compH,				// >>
		AEGP_ConstColorProfileP	color_profileP);	// >>
		
	SPAPI	A_Err (*AEGP_IsOCIOColorManagementUsed)(
		AEGP_PluginID			aegp_plugin_id,					// >>
		A_Boolean				*is_OCIOColorManagementUsedPB);	// <<

	SPAPI	A_Err (*AEGP_GetOCIOConfigurationFile)(
		AEGP_PluginID			aegp_plugin_id,		// >>
		AEGP_MemHandle			*config_filePH);	// <<
	
	SPAPI	A_Err (*AEGP_GetOCIOConfigurationFilePath)(
		AEGP_PluginID			aegp_plugin_id,			// >>
		AEGP_MemHandle			*config_filePH);		// <<

	SPAPI	A_Err (*AEGPD_GetOCIOWorkingColorSpace)(
		AEGP_PluginID	aegp_plugin_id,						// >>
		AEGP_MemHandle	*ocio_working_colorspaceH);			// <<

	SPAPI	A_Err (*AEGPD_GetOCIODisplayColorSpace)(
		AEGP_PluginID	aegp_plugin_id,					// >>
		AEGP_MemHandle	*ocio_displayH,					// <<
		AEGP_MemHandle	*ocio_viewH);					// <<
} AEGP_ColorSettingsSuite5;


/* -------------------------------------------------------------------- */
/*
	Render Queue Suite
	Used to add, remove, and modify items in the reder queue.

  */

#define kAEGPRenderQueueSuite			"AEGP Render Queue Suite"
#define kAEGPRenderQueueSuiteVersion1	1 /* frozen in AE 5.0 */

enum {
	AEGP_RenderQueueState_STOPPED,
	AEGP_RenderQueueState_PAUSED,
	AEGP_RenderQueueState_RENDERING
};

typedef A_u_long AEGP_RenderQueueState;

enum {
	AEGP_RenderItemStatus_NONE = -2,

	AEGP_RenderItemStatus_WILL_CONTINUE,	//	-1
	AEGP_RenderItemStatus_NEEDS_OUTPUT, 	//	0
	AEGP_RenderItemStatus_UNQUEUED, 		//	1 ready to be rendered, but not included in the queue
	AEGP_RenderItemStatus_QUEUED, 			//	2 ready AND queued
	AEGP_RenderItemStatus_RENDERING,
	AEGP_RenderItemStatus_USER_STOPPED,
	AEGP_RenderItemStatus_ERR_STOPPED,
	AEGP_RenderItemStatus_DONE,

	AEGP_RenderItemStatus_LAST_PLUS_ONE
};

typedef	A_long	AEGP_RenderItemStatusType;

typedef struct AEGP_RenderQueueSuite1 {
	SPAPI A_Err (*AEGP_AddCompToRenderQueue)(
					AEGP_CompH	comp,		/* >> */
					const A_char*	pathZ);

	// not legal to go from STOPPED to PAUSED.
	SPAPI A_Err (*AEGP_SetRenderQueueState)(
					AEGP_RenderQueueState	state);	/* >> */

	SPAPI A_Err (*AEGP_GetRenderQueueState)(
					AEGP_RenderQueueState	*stateP); /* << */

} AEGP_RenderQueueSuite1;

/* -------------------------------------------------------------------- */

enum {
	AEGP_LogType_NONE = -1,
	AEGP_LogType_ERRORS_ONLY,
	AEGP_LogType_PLUS_SETTINGS,
	AEGP_LogType_PER_FRAME_INFO,
	AEGP_LogType_NUM_TYPES
};

typedef A_long AEGP_LogType;

enum {
	AEGP_Embedding_NONE = -1,
	AEGP_Embedding_NOTHING,
	AEGP_Embedding_LINK,
	AEGP_Embedding_LINK_AND_COPY,
	AEGP_Embedding_NUM_TYPES
};

typedef A_long AEGP_EmbeddingType;

enum {
	AEGP_PostRenderOptions_NONE = -1,
	AEGP_PostRenderOptions_IMPORT,
	AEGP_PostRenderOptions_IMPORT_AND_REPLACE_USAGE,
	AEGP_PostRenderOptions_SET_PROXY,
	AEGP_PostRenderOptions_NUM_OPTIONS
};

typedef A_long AEGP_PostRenderAction;

enum {
	AEGP_OutputType_NONE = 0,
	AEGP_OutputType_VIDEO = 1L << 0,
	AEGP_OutputType_AUDIO = 1L << 1,
	AEGP_OutputType_NUM_TYPES
};

typedef A_long AEGP_OutputTypes;

enum {
	AEGP_VideoChannels_NONE 	= -1,
	AEGP_VideoChannels_RGB,
	AEGP_VideoChannels_RGBA,
	AEGP_VideoChannels_ALPHA,
	AEGP_VideoChannels_NUMTYPES
};

typedef A_long AEGP_VideoChannels;

enum {
	AEGP_StretchQual_NONE = -1,

	AEGP_StretchQual_LOW,
	AEGP_StretchQual_HIGH,

	AEGP_StretchQual_NUMTYPES
};
typedef	A_long	AEGP_StretchQuality;

enum {
	AEGP_OutputColorType_STRAIGHT = -1,
	AEGP_OutputColorType_PREMUL
};

typedef A_long AEGP_OutputColorType;

#define kAEGPRQItemSuite				"AEGP Render Queue Item Suite"
#define kAEGPRQItemSuiteVersion4		5	/* frozen in AE 14.1 */

typedef struct AEGP_RQItemSuite4 {

	SPAPI A_Err	(*AEGP_GetNumRQItems)(
						A_long				*num_itemsPL);		/* << */

	/*	NOTE: 	All AEGP_RQItemRefH are invalidated by ANY
				re-ordering, addition or removal of render
				items. DO NOT CACHE THEM.
	*/

	SPAPI A_Err (*AEGP_GetRQItemByIndex)(
						A_long				rq_item_index,		/* >> */
						AEGP_RQItemRefH		*rq_item_refPH);	/* << */

	SPAPI A_Err (*AEGP_GetNextRQItem)(							/* Pass RQ_ITEM_INDEX_NONE for current_rq_itemH to get first RQItemH. */
						AEGP_RQItemRefH		current_rq_itemH,	/* >> */
						AEGP_RQItemRefH		*next_rq_itemH);	/* << */

	SPAPI A_Err (*AEGP_GetNumOutputModulesForRQItem)(
						AEGP_RQItemRefH		rq_itemH,			/* >> */
						A_long				*num_outmodsPL);	/* << */

	SPAPI A_Err (*AEGP_GetRenderState)(
						AEGP_RQItemRefH				rq_itemH,	/* >> */
						AEGP_RenderItemStatusType	*statusP);	/* << */

	/*
		the following now returns:
		Err_PARAMETER if you try to call while AEGP_RenderQueueState != AEGP_RenderQueueState_STOPPED

		if that's okay then:
		Err_RANGE if you pass a status that is illegal in any case
		Err_PARAMETER if you try to pass a status that doesn't make sense right now (eg: trying to Que something for which you haven't set the output path)
	*/
	SPAPI A_Err (*AEGP_SetRenderState)(
						AEGP_RQItemRefH				rq_itemH,	/* >> */
						AEGP_RenderItemStatusType	status);	/* >> */

	SPAPI A_Err (*AEGP_GetStartedTime)(
						AEGP_RQItemRefH		rq_itemH,			/* >> */
						A_Time				*started_timePT);	/* <<	Returns {0,1} if not started. */

	SPAPI A_Err (*AEGP_GetElapsedTime)(
						AEGP_RQItemRefH		rq_itemH,			/* >> */
						A_Time				*render_timePT);	/* << 	Returns {0,1} if not rendered. */

	SPAPI A_Err	(*AEGP_GetLogType)(
						AEGP_RQItemRefH		rq_itemH,			/* >> */
						AEGP_LogType		*logtypeP);			/* << */

	SPAPI A_Err	(*AEGP_SetLogType)(
						AEGP_RQItemRefH		rq_itemH,			/* >> */
						AEGP_LogType		logtype);			/* << */

	SPAPI A_Err	(*AEGP_RemoveOutputModule)(
						AEGP_RQItemRefH			rq_itemH,		/* >> */
						AEGP_OutputModuleRefH	outmodH);		/* >> */

	SPAPI A_Err (*AEGP_GetComment)(
						AEGP_RQItemRefH			rq_itemH,		/* >> */
						AEGP_MemHandle			*unicodeH);		/* << */

	SPAPI A_Err (*AEGP_SetComment)(
						AEGP_RQItemRefH			rq_itemH,		/* >> */
						const A_UTF16Char		*commentZ);		/* >> */

	SPAPI A_Err (*AEGP_GetCompFromRQItem)(
						AEGP_RQItemRefH			rq_itemH,		/* >> */
						AEGP_CompH				*compPH);		/* << */

	SPAPI A_Err (*AEGP_DeleteRQItem)(
						AEGP_RQItemRefH			rq_itemH);		/* <> 	   UNDOABLE */

} AEGP_RQItemSuite4;


#define kAEGPOutputModuleSuite			"AEGP Output Module Suite"
#define kAEGPOutputModuleSuiteVersion4	4 /* frozen in AE 10.0 */

typedef struct AEGP_OutputModuleSuite4 {

	/*	NOTE: 	All AEGP_OutputModuleRefHs are invalidated by ANY
				re-ordering, addition or removal of output modules
				from a render item. DO NOT CACHE THEM.
	*/

	SPAPI A_Err (*AEGP_GetOutputModuleByIndex)(
						AEGP_RQItemRefH			rq_itemH,			/* >> */
						A_long					outmod_indexL,		/* >> */
						AEGP_OutputModuleRefH	*outmodPH);			/* << */

	SPAPI A_Err	(*AEGP_GetEmbedOptions)(
						AEGP_RQItemRefH			rq_itemH,			/* >> */
						AEGP_OutputModuleRefH	outmodH,			/* >> */
						AEGP_EmbeddingType		*embed_optionsP);	/* << */

	SPAPI A_Err	(*AEGP_SetEmbedOptions)(
						AEGP_RQItemRefH			rq_itemH,			/* >> */
						AEGP_OutputModuleRefH	outmodH,			/* >> */
						AEGP_EmbeddingType		embed_options);		/* >> */

	SPAPI A_Err	(*AEGP_GetPostRenderAction)(
						AEGP_RQItemRefH			rq_itemH,				/* >> */
						AEGP_OutputModuleRefH	outmodH,				/* >> */
						AEGP_PostRenderAction	*post_render_actionP);	/* << */

	SPAPI A_Err	(*AEGP_SetPostRenderAction)(
						AEGP_RQItemRefH			rq_itemH,				/* >> */
						AEGP_OutputModuleRefH	outmodH,				/* >> */
						AEGP_PostRenderAction	post_render_action);	/* >> */

	SPAPI A_Err	(*AEGP_GetEnabledOutputs)(
						AEGP_RQItemRefH			rq_itemH,			/* >> */
						AEGP_OutputModuleRefH	outmodH,			/* >> */
						AEGP_OutputTypes		*enabled_typesP);	/* << */

	SPAPI A_Err	(*AEGP_SetEnabledOutputs)(
						AEGP_RQItemRefH			rq_itemH,			/* >> */
						AEGP_OutputModuleRefH	outmodH,			/* >> */
						AEGP_OutputTypes		enabled_types);		/* >> */

	SPAPI A_Err (*AEGP_GetOutputChannels)(
						AEGP_RQItemRefH			rq_itemH,			/* >> */
						AEGP_OutputModuleRefH	outmodH,			/* >> */
						AEGP_VideoChannels		*output_channelsP);	/* << */

	SPAPI A_Err (*AEGP_SetOutputChannels)(
						AEGP_RQItemRefH			rq_itemH,			/* >> */
						AEGP_OutputModuleRefH	outmodH,			/* >> */
						AEGP_VideoChannels		output_channels);	/* >> */

	SPAPI A_Err (*AEGP_GetStretchInfo)(
						AEGP_RQItemRefH			rq_itemH,			/* >> */
						AEGP_OutputModuleRefH	outmodH,			/* >> */
						A_Boolean				*is_enabledPB,		/* << */
						AEGP_StretchQuality		*stretch_qualityP,	/* << */
						A_Boolean				*lockedPB);			/* << */

	SPAPI A_Err	(*AEGP_SetStretchInfo)(
						AEGP_RQItemRefH			rq_itemH,			/* >> */
						AEGP_OutputModuleRefH	outmodH,			/* >> */
						A_Boolean				is_enabledB,		/* >> */
						AEGP_StretchQuality		stretch_quality);	/* >> */

	SPAPI A_Err	(*AEGP_GetCropInfo)(
						AEGP_RQItemRefH			rq_itemH,			/* >> */
						AEGP_OutputModuleRefH	outmodH,			/* >> */
						A_Boolean				*is_enabledBP,		/* << */
						A_Rect					*crop_rectP);		/* << */

	SPAPI A_Err (*AEGP_SetCropInfo)(
						AEGP_RQItemRefH			rq_itemH,			/* >> */
						AEGP_OutputModuleRefH	outmodH,			/* >> */
						A_Boolean				enableB,			/* >> */
						A_Rect					crop_rect);			/* >> */

	SPAPI A_Err (*AEGP_GetSoundFormatInfo)(
						AEGP_RQItemRefH			rq_itemH,				/* >> */
						AEGP_OutputModuleRefH	outmodH,				/* >> */
						AEGP_SoundDataFormat	*sound_format_infoP,	/* << */
						A_Boolean				*audio_enabledPB);		/* << */

	SPAPI A_Err (*AEGP_SetSoundFormatInfo)(
						AEGP_RQItemRefH			rq_itemH,			/* >> */
						AEGP_OutputModuleRefH	outmodH,			/* >> */
						AEGP_SoundDataFormat	sound_format_info,	/* >> */
						A_Boolean				audio_enabledB);	/* >> */

	SPAPI A_Err	(*AEGP_GetOutputFilePath)(
						AEGP_RQItemRefH			rq_itemH,					/* >> */
						AEGP_OutputModuleRefH	outmodH,					/* >> */
						AEGP_MemHandle			*unicode_pathPH);			// << empty string if not specified. handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle

	SPAPI A_Err	(*AEGP_SetOutputFilePath)(
						AEGP_RQItemRefH			rq_itemH,			/* >> */
						AEGP_OutputModuleRefH	outmodH,			/* >> */
						const A_UTF16Char		*pathZ);				// >> null terminated unicode path with platform separators

	SPAPI A_Err (*AEGP_AddDefaultOutputModule)(
						AEGP_RQItemRefH			rq_itemH,			/* >> */
						AEGP_OutputModuleRefH	*outmodPH);			/* << */

	SPAPI A_Err	(*AEGP_GetExtraOutputModuleInfo)(
						AEGP_RQItemRefH			rq_itemH,
						AEGP_OutputModuleRefH	outmodH,
						AEGP_MemHandle			*format_unicodePH, 		/* << handle of A_u_short, (contains null terminated UTF16 string) must be disposed with AEGP_FreeMemHandle */
						AEGP_MemHandle			*info__unicodePH,		/* << handle of A_u_short, (contains null terminated UTF16 string) must be disposed with AEGP_FreeMemHandle */
						A_Boolean				*is_sequenceBP,
						A_Boolean				*multi_frameBP);

} AEGP_OutputModuleSuite4;

/* -------------------------------------------------------------------- */

/**
 ** Canvas Suite
 ** Used by artisans to render layers
 **/

#define kAEGPCanvasSuite				"AEGP Canvas Suite"
#define kAEGPCanvasSuiteVersion8		14	/* frozen in AE 12.0*/


enum {
	AEGP_RenderHints_NONE = 0,
	AEGP_RenderHints_IGNORE_EXTENTS = 0x1,
	AEGP_RenderHints_NO_TRANSFER_MODE = 0x2		// prevents application of opacity & transfer mode; for RenderLayer calls
};
typedef A_u_long AEGP_RenderHints;


enum {
	AEGP_RenderReceiptStatus_INVALID	= 0,
	AEGP_RenderReceiptStatus_VALID,
	AEGP_RenderReceiptStatus_VALID_BUT_INCOMPLETE
};
typedef A_u_long	AEGP_RenderReceiptStatus;


enum {
	AEGP_BinType_NONE = -1,
	AEGP_BinType_2D   = 0,
	AEGP_BinType_3D   = 1
};
typedef A_long	AEGP_BinType;


typedef void * AEGP_PlatformWindowRef;



enum  {
	AEGP_DisplayChannel_NONE = 0,
	AEGP_DisplayChannel_RED,
	AEGP_DisplayChannel_GREEN,
	AEGP_DisplayChannel_BLUE,
	AEGP_DisplayChannel_ALPHA,
	AEGP_DisplayChannel_RED_ALT,
	AEGP_DisplayChannel_GREEN_ALT,
	AEGP_DisplayChannel_BLUE_ALT,
	AEGP_DisplayChannel_ALPHA_ALT,
	AEGP_DisplayChannel_NUM_ITEMS
};
typedef A_long AEGP_DisplayChannelType; // disk safe

enum {
	AEGP_RenderNumEffects_ALL_EFFECTS = -1
};

typedef A_short AEGP_NumEffectsToRenderType;


typedef struct AEGP_CanvasSuite8 {

	SPAPI A_Err	(*AEGP_GetCompToRender)(
						PR_RenderContextH 		render_contextH,   	/* >> */
						AEGP_CompH				*compPH);			/* << */

	SPAPI A_Err	(*AEGP_GetNumLayersToRender)(
				const	PR_RenderContextH	render_contextH,		/* >> */
						A_long				*num_to_renderPL);		/* << */


	SPAPI A_Err	(*AEGP_GetNthLayerContextToRender)(
				const	PR_RenderContextH			render_contextH,	/* >> */
						A_long						n,					/* >> */
						AEGP_RenderLayerContextH	*layer_contextPH);	/* << */

	SPAPI A_Err	(*AEGP_GetLayerFromLayerContext)(
				const	PR_RenderContextH			render_contextH,	/* >> */
						AEGP_RenderLayerContextH	layer_contextH,		/* >> */
						AEGP_LayerH					*layerPH);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerAndSubLayerFromLayerContext)(
				const	PR_RenderContextH			render_contextH,	/* >> */
						AEGP_RenderLayerContextH	layer_contextH,		/* >> */
						AEGP_LayerH					*layerPH,			/* << */
						AEGP_SubLayerIndex			*sublayerP);		/* << */

	/**
	 ** With collapsed geometrics "on" this gives the layer in the root comp
	 ** contining the layer context. With collapsed geometrics off
	 ** this is the same as AEGP_GetLayerFromLayerContext.
	 **
	 **/
	SPAPI A_Err	(*AEGP_GetTopLayerFromLayerContext)(
				const	PR_RenderContextH			render_contextH,
						AEGP_RenderLayerContextH	layer_contextH,
						AEGP_LayerH					*layerPH);

	SPAPI A_Err	(*AEGP_GetCompRenderTime)(
						PR_RenderContextH	render_contextH,	/* >> */
						A_Time				*time,				/* << */
						A_Time				*time_step);

	SPAPI A_Err	(*AEGP_GetCompDestinationBuffer)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_CompH					compH,				/* >> */
						AEGP_WorldH					*dst);				/* << */

	SPAPI A_Err	(*AEGP_GetROI)(
						PR_RenderContextH			render_contextH,	/* <> */
						A_LegacyRect						*roiPR);			/* << */

	// for rendering the texture map of a layer
	SPAPI A_Err	(*AEGP_RenderTexture)(
						PR_RenderContextH			render_contextH,		/* <> */
						AEGP_RenderLayerContextH	layer_contextH,			/* >> */
						AEGP_RenderHints			render_hints,			/* >> */
						A_FloatPoint				*suggested_scaleP0,		/* >> */
						A_FloatRect					*suggested_src_rectP0, 	/* >> */
						A_Matrix3					*src_matrixP0,			/* << */
						AEGP_WorldH					*dstPH);				/* <> */


	SPAPI A_Err	(*AEGP_DisposeTexture)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_RenderLayerContextH	layer_contextH,		/* >> */
						AEGP_WorldH					dstH0);				/* <> */

	SPAPI A_Err	(*AEGP_GetFieldRender)(
						PR_RenderContextH 			render_contextH,   	/* >> */
						PF_Field					*field);			/* << */

	// not thread safe on MacOS
	// only call when thread ID = 0
	SPAPI A_Err	(*AEGP_ReportArtisanProgress)(
					PR_RenderContextH 				render_contextH,   	/* >> */
					A_long							countL,				/* >> */
					A_long							totalL);			/* >> */

	SPAPI A_Err	(*AEGP_GetRenderDownsampleFactor)(
						PR_RenderContextH			render_contextH,	/* >> */
						AEGP_DownsampleFactor		*dsfP);				/* << */

	SPAPI A_Err	(*AEGP_SetRenderDownsampleFactor)(
						PR_RenderContextH			render_contextH,	/* >> */
						AEGP_DownsampleFactor		*dsfP);				/* >> */

	SPAPI A_Err	(*AEGP_IsBlankCanvas)(
						PR_RenderContextH			render_contextH,	/* >> */
						A_Boolean					*is_blankPB);		/* << */

	SPAPI A_Err (*AEGP_GetRenderLayerToWorldXform)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timeP,		/* >> */
					A_Matrix4						*transform);		/* << */

	SPAPI A_Err (*AEGP_GetRenderLayerBounds)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timeP,		/* >> */
					A_LegacyRect							*boundsP);			/* << */

	SPAPI A_Err (*AEGP_GetRenderOpacity)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timePT,		/* >> */
					A_FpLong						*opacityPF);		/* << */

	SPAPI A_Err (*AEGP_IsRenderLayerActive)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timePT,		/* >> */
					A_Boolean						*activePB);			/* << */

	// set the layer index. If total > 0, set it too.
	SPAPI A_Err	(*AEGP_SetArtisanLayerProgress)(
					PR_RenderContextH 				render_contextH,   	/* >> */
					A_long							countL,				/* >> */
					A_long							num_layersL);

	// for track mattes.
	// Returns a comp-size buffer, which must be disposed thru AEGP_Dispose in World suite
	SPAPI A_Err	(*AEGP_RenderLayerPlus)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_LayerH 				layerH,				/* >> */
						AEGP_RenderLayerContextH 	layer_contextH,		/* >> */
						AEGP_RenderHints			render_hints,		/* >> */
						AEGP_WorldH					*render_bufferPH);	/* <<  must be disposed with AEGP_DisposeWorld */


	SPAPI A_Err	(*AEGP_GetTrackMatteContext)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_RenderLayerContextH 	fill_contextH,		/* << */
						AEGP_RenderLayerContextH	*matte_contextPH);	/* >> */

	// new for 6.0 --get receipt with the returned texture
	// use receipt to determine if a subsequent call to render
	// this layer can be skipped (because the artisan cached it)
	SPAPI A_Err	(*AEGP_RenderTextureWithReceipt)(
						PR_RenderContextH			render_contextH,		/* <> */
						AEGP_RenderLayerContextH	layer_contextH,			/* >> */
						AEGP_RenderHints			render_hints,			/* >> */
						AEGP_NumEffectsToRenderType	num_effectsS,			/* >>  number of effect to render, -1 for all */
						A_FloatPoint				*suggested_scaleP0,		/* >> */
						A_FloatRect					*suggested_src_rectP0, 	/* >> */
						A_Matrix3					*src_matrixP0,			/* << */
						AEGP_RenderReceiptH			*render_receiptPH, 	 	/* << must be disposed with AEGP_DisposeRenderReceipt */
						AEGP_WorldH					*dstPH);				/* << */



	SPAPI A_Err	(*AEGP_GetNumberOfSoftwareEffects)(
						PR_RenderContextH			render_contextH,		/* <> */
						AEGP_RenderLayerContextH	layer_contextH,			/* >> */
						A_short						*num_software_effectsPS);

	SPAPI A_Err	(*AEGP_RenderLayerPlusWithReceipt)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_LayerH 				layerH,				/* >> */
						AEGP_RenderLayerContextH 	layer_contextH,		/* >> */
						AEGP_RenderHints			render_hints,		/* >> */
						AEGP_RenderReceiptH			*render_receiptPH,  /* << must be disposed with AEGP_DisposeRenderReceipt */
						AEGP_WorldH					*render_bufferPH);	/* << */

	SPAPI A_Err	(*AEGP_DisposeRenderReceipt)(
						AEGP_RenderReceiptH			render_receiptH);	/* >> */


	/* modified for 7.0 - added num_effects to check against */
	SPAPI A_Err	(*AEGP_CheckRenderReceipt)(
						PR_RenderContextH			current_render_contextH,	/* in */
						AEGP_RenderLayerContextH	current_layer_contextH,		/* in */
						AEGP_RenderReceiptH			old_render_receiptH,		/* in */
						A_Boolean					check_geometricsB,			/* in */
						AEGP_NumEffectsToRenderType	num_effectsS,				/* in */
						AEGP_RenderReceiptStatus	*receipt_statusP);			/* out */


	/* new in 7.0 generate a receipt for a layer as asd if the first num_effectsS have been rendered */
	SPAPI A_Err	(*AEGP_GenerateRenderReceipt)(
						PR_RenderContextH			current_render_contextH,	/* >> */
						AEGP_RenderLayerContextH	current_layer_contextH,		/* >> */
						AEGP_NumEffectsToRenderType	num_effectsS,				/* in */
						AEGP_RenderReceiptH			*render_receiptPH);			/* << */

	SPAPI A_Err	(*AEGP_GetNumBinsToRender)(
				const	PR_RenderContextH	render_contextH,			/* >> */
						A_long				*num_bins_to_renderPL);		/* << */


	SPAPI A_Err	(*AEGP_SetNthBin)(
				const	PR_RenderContextH			render_contextH,	/* >> */
						A_long						n);					/* >> */

	SPAPI A_Err	(*AEGP_GetBinType)(
				const	PR_RenderContextH			render_contextH,	/* >> */
						AEGP_BinType				*bin_typeP);		/* << */

	SPAPI A_Err (*AEGP_GetRenderLayerToWorldXform2D3D)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timeP,		/* >> */
					A_Boolean						only_2dB,			/* >> */
					A_Matrix4						*transform);		/* << */


	// interactive artisan information
	// handle to the on-screen window
	SPAPI A_Err (*AEGP_GetPlatformWindowRef)(
				const PR_RenderContextH				render_contextH,	/* >> */
				AEGP_PlatformWindowRef				*window_refP);		/* << */


	// the dsf src to frame scale factors
	SPAPI A_Err (*AEGP_GetViewportScale)(
				const PR_RenderContextH				render_contextH,	/* >> */
				A_FpLong							*scale_xPF,			/* << */
				A_FpLong							*scale_yPF);		/* << */


	// the dsf src to frame translate
	SPAPI A_Err (*AEGP_GetViewportOrigin)(
				const PR_RenderContextH				render_contextH,	/* >> */
				A_long								*origin_xPL,		/* << */
				A_long								*origin_yPL);		/* << */


	SPAPI A_Err (*AEGP_GetViewportRect)(
				const PR_RenderContextH				render_contextH,	/* >> */
				A_LegacyRect								*viewport_rectPR);	/* << */


	SPAPI A_Err (*AEGP_GetFallowColor)(
				const PR_RenderContextH				render_contextH,	/* >> */
				PF_Pixel8							*fallow_colorP);	/* << */

	SPAPI A_Err (*AEGP_GetInteractiveBuffer)(
				const PR_RenderContextH				render_contextH,	/* >> */
				AEGP_WorldH							*buffer);			/* << */

	SPAPI A_Err (*AEGP_GetInteractiveCheckerboard)(
				const PR_RenderContextH				render_contextH,	/* in */
				A_Boolean							*checkerboard_onPB);/* out */

	SPAPI A_Err (*AEGP_GetInteractiveCheckerboardColors)(
				const PR_RenderContextH				render_contextH,			/* in */
				PF_Pixel							*checkerboard_color1P,		/* out */
				PF_Pixel							*checkerboard_color2P);		/* out */

	SPAPI A_Err (*AEGP_GetInteractiveCheckerboardSize)(
				const PR_RenderContextH				render_contextH,			/* in */
				A_u_long							*checkerboard_widthPLu,		/* out - width of square*/
				A_u_long							*checkerboard_heightPLu);	/* out - height of square*/

	SPAPI A_Err (*AEGP_GetInteractiveCachedBuffer)(
				const PR_RenderContextH				render_contextH,			/* >> */
				AEGP_WorldH							*buffer);					/* << */


	// should we call AEGP_RenderLayer or AEGP_RenderTexture
	SPAPI A_Err (*AEGP_ArtisanMustRenderAsLayer)(
				const PR_RenderContextH				render_contextH,			/* >> */
				AEGP_RenderLayerContextH			layer_contextH,
				A_Boolean							*use_render_texturePB);


	SPAPI A_Err (*AEGP_GetInteractiveDisplayChannel)(
				const PR_RenderContextH				render_contextH,			/* >> */
				AEGP_DisplayChannelType				*display_channelP);			/* << */

	SPAPI A_Err (*AEGP_GetInteractiveExposure)(
				const PR_RenderContextH				render_contextH,			/* >> */
				A_FpLong							*exposurePF);				/* << */


	SPAPI A_Err (*AEGP_GetColorTransform)(
				const PR_RenderContextH				render_contextH,	/* >> */
				A_Boolean							*cms_onB,
				A_u_long							*xform_keyLu,
				void								*xformP);


	SPAPI A_Err	(*AEGP_GetCompShutterTime)(
						PR_RenderContextH	render_contextH,	/* >> */
						A_Time				*shutter_time,		/* << */
						A_Time				*shutter_dur);

	// uses remapping if any
	SPAPI A_Err	(*AEGP_MapCompToLayerTime)(
						PR_RenderContextH			render_contextH,	/* in */
						AEGP_RenderLayerContextH	layer_contextH,		/* in*/
						const A_Time				*comp_timePT,		/* in */
						A_Time						*layer_timePT);		/* out */

} AEGP_CanvasSuite8;







/**
 ** Artisan utility suite
 **
 **/
#define kAEGPArtisanUtilSuite				"AEGP Artisan Util Suite"
#define kAEGPArtisanUtilSuiteVersion1		1 /* frozen in AE 5.0 */


typedef struct AEGP_ArtisanUtilSuite1 {


	SPAPI A_Err	(*AEGP_GetGlobalContextFromInstanceContext)(
		const PR_InstanceContextH		instance_contextH,			/* >> */
			  PR_GlobalContextH			*global_contextPH);			/* << */


	SPAPI A_Err	(*AEGP_GetInstanceContextFromRenderContext)(
		const PR_RenderContextH			render_contextH,			/* >> */
			  PR_InstanceContextH		*instance_contextPH);		/* << */



	SPAPI A_Err	(*AEGP_GetInstanceContextFromQueryContext)(
		const PR_QueryContextH			query_contextH,				/* >> */
			  PR_InstanceContextH		*instance_contextPH);		/* << */


	SPAPI A_Err	(*AEGP_GetGlobalData)(
		const PR_GlobalContextH			global_contextH,			/* >> */
			  PR_GlobalDataH			*global_dataPH);			/* << */


	SPAPI A_Err	(*AEGP_GetInstanceData)(
		const PR_InstanceContextH		instance_contextH,			/* >> */
			  PR_InstanceDataH			*instance_dataPH);			/* << */

	SPAPI A_Err	(*AEGP_GetRenderData)(
		const PR_RenderContextH			render_contextH,			/* >> */
			  PR_RenderDataH			*render_dataPH);			/* << */

} AEGP_ArtisanUtilSuite1;



#define kAEGPCameraSuite				"AEGP Camera Suite"
#define kAEGPCameraSuiteVersion2		2 /* frozen in AE 5.5 */

typedef struct AEGP_CameraSuite2 {

		SPAPI A_Err	(*AEGP_GetCamera)(
						PR_RenderContextH 		render_contextH,   	/* >> */
						const A_Time			*comp_timeP,		/* >> */
						AEGP_LayerH				*camera_layerPH);	/* << */

		SPAPI A_Err	(*AEGP_GetCameraType)(
						AEGP_LayerH				camera_layerH,		/* >> */
						AEGP_CameraType			*camera_typeP);		/* << */


		SPAPI A_Err (*AEGP_GetDefaultCameraDistanceToImagePlane)(
						AEGP_CompH				compH,				/* >> */
						A_FpLong				*dist_to_planePF);	/* << */

		//	If a camera is created using aegp, then you must set the film size units.
		// 	No default is provided.

		SPAPI A_Err	(*AEGP_GetCameraFilmSize)(
						AEGP_LayerH				camera_layerH,			/* >> */
						AEGP_FilmSizeUnits		*film_size_unitsP,		/* << */
						A_FpLong				*film_sizePF0);			/* << in pixels */

		SPAPI A_Err	(*AEGP_SetCameraFilmSize)(
						AEGP_LayerH				camera_layerH,			/* >> */
						AEGP_FilmSizeUnits		film_size_units,		/* >> */
						A_FpLong				*film_sizePF0);			/* >> in pixels */

} AEGP_CameraSuite2;

#define kAEGPLightSuite				"AEGP Light Suite"
#define kAEGPLightSuiteVersion2		2 /* frozen in AE 5.5 */

typedef struct AEGP_LightSuite2 {

	SPAPI A_Err	(*AEGP_GetLightType)(
						AEGP_LayerH				light_layerH,		/* >> */
						AEGP_LightType			*light_typeP);		/* << */

	SPAPI A_Err	(*AEGP_SetLightType)(
					AEGP_LayerH				light_layerH,			/* >> */
					AEGP_LightType			light_type);			/* >> */

} AEGP_LightSuite2;



/**
 ** Query Xform suite
 ** Called by artisans during a response to a Query
 **/

#define kAEGPQueryXformSuite				"AEGP QueryXform Suite"
#define kAEGPQueryXformSuiteVersion2		4 /* frozen in AE 6.0 */


/**
 ** the type of source or dst transformation wanted
 **/
enum {
	AEGP_Query_Xform_LAYER,
	AEGP_Query_Xform_WORLD,
	AEGP_Query_Xform_VIEW,
	AEGP_Query_Xform_SCREEN
};

typedef A_u_long AEGP_QueryXformType;



typedef struct AEGP_QueryXformSuite2 {

	SPAPI A_Err	(*AEGP_QueryXformGetSrcType)(
					PR_QueryContextH		query_contextH,		/* <> */
					AEGP_QueryXformType		*src_type);			/* << */

	SPAPI A_Err	(*AEGP_QueryXformGetDstType)(
					PR_QueryContextH		query_contextH,		/* <> */
					AEGP_QueryXformType		*dst_type);			/* << */

	SPAPI A_Err	(*AEGP_QueryXformGetLayer)(
						PR_QueryContextH	query_contextH,		/* <> */
						AEGP_LayerH			*layerPH);			/* << */

	SPAPI A_Err	(*AEGP_QueryXformGetComp)(
						PR_QueryContextH	query_contextH,		/* <> */
						AEGP_CompH			*compPH);			/* << */

	SPAPI A_Err	(*AEGP_QueryXformGetTransformTime)(
						PR_QueryContextH	query_contextH,		/* <> */
						A_Time				*time);				/* << */

	SPAPI A_Err	(*AEGP_QueryXformGetViewTime)(
						PR_QueryContextH	query_contextH,		/* <> */
						A_Time				*time);				/* << */

	SPAPI A_Err	(*AEGP_QueryXformGetCamera)(
						PR_QueryContextH	query_contextH,		/* <> */
						AEGP_LayerH			*camera_layerPH);	/* << */

	SPAPI A_Err	(*AEGP_QueryXformGetXform)(
						PR_QueryContextH	query_contextH,		/* <> */
						A_Matrix4			*xform);			/* << */

	SPAPI A_Err	(*AEGP_QueryXformSetXform)(
						PR_QueryContextH	query_contextH,		/* <> */
						A_Matrix4			*xform);			/* >> */

	SPAPI A_Err	(*AEGP_QueryWindowRef)(
						PR_QueryContextH	query_contextH,		/* <> */
						AEGP_PlatformWindowRef	*window_refP);	/* >> */

	SPAPI A_Err	(*AEGP_QueryWindowClear)(
						PR_QueryContextH		query_contextH,		/* <> */
						AEGP_PlatformWindowRef	*window_refP,		/* out */
						A_LegacyRect					*boundsPR);			/* out */

	SPAPI A_Err	(*AEGP_QueryFrozenProxy)(
						PR_QueryContextH		query_contextH,		/* <> */
						A_Boolean				*onPB);				/* out */

	SPAPI A_Err	(*AEGP_QuerySwapBuffer)(
						PR_QueryContextH		query_contextH,		/* <> */
						AEGP_PlatformWindowRef	*window_refP,		/* out */
						AEGP_WorldH				*dest_bufferp);		/* out */

	SPAPI A_Err	(*AEGP_QueryDrawProcs)(
						PR_QueryContextH		query_contextH,		/* <> */
						PR_InteractiveDrawProcs	*window_refP);		/* in */


	SPAPI A_Err	(*AEGP_QueryPrepareForLineDrawing)(
						PR_QueryContextH		query_contextH,		/* <> */
						AEGP_PlatformWindowRef	*window_refP,
						A_LegacyRect			*viewportP,
						A_LPoint				*originP,
						A_FloatPoint			*scaleP);		/* in */

	SPAPI A_Err	(*AEGP_QueryUnprepareForLineDrawing)(
						PR_QueryContextH		query_contextH,		/* <> */
						AEGP_PlatformWindowRef	*window_refP);		/* in */

	SPAPI A_Err	(*AEGP_QueryGetData)(
						PR_QueryContextH		query_contextH,		/* <> */
						A_long					i,					/* in */
						void					**dataPP);			/* out */

	SPAPI A_Err	(*AEGP_QuerySetData)(
						PR_QueryContextH		query_contextH,		/* <> */
						A_long					i,					/* in */
						void					*dataP);			/* in */


}AEGP_QueryXformSuite2;


/* -------------------------------------------------------------------- */



#define kAEGPCompositeSuite				"AEGP Composite Suite"
#define kAEGPCompositeSuiteVersion2		4 /* frozen in AE 10.0 */

typedef struct AEGP_CompositeSuite2 {

	SPAPI A_Err (*AEGP_ClearAlphaExceptRect)(
				A_Rect					*clipped_dest_rectPR, 	/* >> */
				PF_EffectWorld			*dstP);					/* <> */

	SPAPI A_Err  (*AEGP_PrepTrackMatte)(
				A_long				num_pix,			/* >> */
				A_Boolean			deepB,				/* >> */
		const	PF_Pixel			*src_mask,			/* >> */
				PF_MaskFlags		mask_flags,			/* >> */
				PF_Pixel			*dst_mask);			/* << */

	SPAPI A_Err (*AEGP_TransferRect)(
				PF_Quality				quality,			/* >> */
				PF_ModeFlags			m_flags,			/* >> */
				PF_Field				field,				/* >> */
		const	A_Rect					*src_rec,			/* >> */
		const	PF_EffectWorld			*src_world,			/* >> */
		const	PF_CompositeMode		*comp_mode,			/* >> */
				PF_EffectBlendingTables	blend_tablesP0,		/* >>, pass NULL to blend in workingspace*/
		const	PF_MaskWorld			*mask_world0,		/* >> */
				A_long					dest_x,				/* >> */
				A_long					dest_y,				/* >> */
				PF_EffectWorld			*dst_world);		/* <> */

	SPAPI A_Err (*AEGP_CopyBits_LQ) (
				PF_EffectWorld				*src_worldP,	/* >> */
				A_Rect 						*src_r,			/* pass NULL for whole world */
				A_Rect						*dst_r,			/* pass NULL for whole world */
				PF_EffectWorld				*dst_worldP);	/* <> */

	SPAPI A_Err (*AEGP_CopyBits_HQ_Straight) (
				PF_EffectWorld				*src,			/* >> */
				A_Rect 						*src_r,			/* pass NULL for whole world */
				A_Rect						*dst_r,			/* pass NULL for whole world */
				PF_EffectWorld				*dst);			/* <> */

	SPAPI A_Err (*AEGP_CopyBits_HQ_Premul) (
				PF_EffectWorld				*src,			/* >> */
				A_Rect 						*src_r,			/* pass NULL for whole world */
				A_Rect						*dst_r,			/* pass NULL for whole world */
				PF_EffectWorld				*dst);			/* <> */

} AEGP_CompositeSuite2;



/* -------------------------------------------------------------------- */

#define kAEGPIterateSuite				"AEGP Iterate Suite"
#define kAEGPIterateSuiteVersion2		2 /* frozen in AE 22.0 */

typedef struct AEGP_IterateSuite2 {

	SPAPI A_Err (*AEGP_GetNumThreads)(
			A_long	*num_threadsPL);


	SPAPI A_Err (*AEGP_IterateGeneric)(
			A_long			iterationsL,						/* >> */		// can be PF_Iterations_ONCE_PER_PROCESSOR
			void			*refconPV,							/* >> */
			A_Err			(*fn_func)(	void 	*refconPV,		/* >> */
										A_long 	thread_indexL,	/* >> */
										A_long 	i,				/* >> */
										A_long 	iterationsL));	/* >> */

} AEGP_IterateSuite2;

// 	Export the name of this function in your PiPL resource's EntryPoint

typedef A_Err (AEGP_PluginInitFuncPrototype)(
					struct SPBasicSuite		*pica_basicP,			/* >> */
					A_long				 	driver_major_versionL,	/* >> */
					A_long					driver_minor_versionL,	/* >> */
					AEGP_PluginID			aegp_plugin_id,			/* >> */
					AEGP_GlobalRefcon		*plugin_refconP);		/* << will be passed to all hooks! */

typedef AEGP_PluginInitFuncPrototype	*AEGP_PluginInitFunc;


/* -------------------------------------------------------------------- */

/** AEGPPFInterfaceSuite1

	These are basically wrappers for constructing various AEGP objects from
	the information available to an effect plug-in so that various other AEGP suites
	may be used.

	AEGP_GetEffectLayer				-- get AEGP_LayerH corresponding to layer that effect is applied to
	AEGP_GetNewEffectForEffect		-- get AEGP_EffectRefH corresponding to effect
	AEGP_ConvertEffectToCompTime	-- return comp time from time units passed to effect (layer time)
	AEGP_GetEffectCamera			-- get camera AEGP_LayerH which defines current 3D view
									-- NOTE : this may be null if no camera is defined

	AEGP_GetEffectCameraMatrix		-- use this to get the geometry for the camera.

	These may only be called during PF_Cmd_FRAME_SETUP, PF_Cmd_RENDER,
	and PF_Cmd_EVENT::PF_Event_DRAW
**/

#define kAEGPPFInterfaceSuite			"AEGP PF Interface Suite"
#define kAEGPPFInterfaceSuiteVersion1	1 /* frozen in AE 5.0 */


typedef struct AEGP_PFInterfaceSuite1 {

	SPAPI A_Err	(*AEGP_GetEffectLayer)(
								PF_ProgPtr			effect_pp_ref,			/* >> */
								AEGP_LayerH			*layerPH);				/* << */

	SPAPI A_Err	(*AEGP_GetNewEffectForEffect)(								/* must be disposed using AEGP_DisposeEffect */
								AEGP_PluginID		aegp_plugin_id,			/* >> */
								PF_ProgPtr			effect_pp_ref,			/* >> */
								AEGP_EffectRefH		*effect_refPH);			/* << */

	SPAPI A_Err	(*AEGP_ConvertEffectToCompTime)(
								PF_ProgPtr			effect_pp_ref,			/* >> */
								A_long				what_timeL,				/* >> */
								A_u_long			time_scaleLu,			/* from PF_InData */
								A_Time				*comp_timePT);			/* << */

	SPAPI A_Err	(*AEGP_GetEffectCamera)(
								PF_ProgPtr			effect_pp_ref,			/* >> */
								const A_Time		*comp_timePT,			/* >> */
								AEGP_LayerH			*camera_layerPH);		/* << */

	SPAPI A_Err	(*AEGP_GetEffectCameraMatrix)(
								PF_ProgPtr			effect_pp_ref,			/* >> */
								const A_Time		*comp_timePT,			/* >> */
								A_Matrix4			*camera_matrixP,		/* <> */
								A_FpLong			*dist_to_image_planePF,	/* <> */
								A_short				*image_plane_widthPL,	/* <> */
								A_short				*image_plane_heightPL);	/* <> */
} AEGP_PFInterfaceSuite1;

//	PIN_FileSize
typedef	A_u_longlong	AEIO_FileSize;

#define kAEGPIOInSuite			"AEGP IO In Suite"
#define kAEGPIOInSuiteVersion5	6 /* frozen in AE 12 */

typedef struct AEGP_IOInSuite5 {

	SPAPI A_Err	(*AEGP_GetInSpecOptionsHandle)(
						AEIO_InSpecH	inH,					/* >> */
						void			**optionsPPV);			/* << */

	SPAPI A_Err	(*AEGP_SetInSpecOptionsHandle)(
						AEIO_InSpecH	inH,					/* >> */
						void			*optionsPV,				/* >> */
						void			**old_optionsPPV);		/* << */

	SPAPI A_Err	(*AEGP_GetInSpecFilePath)(
						AEIO_InSpecH	inH,					/* >> */
						AEGP_MemHandle	*unicode_pathPH);		// << handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle

	SPAPI A_Err	(*AEGP_GetInSpecNativeFPS)(
						AEIO_InSpecH	inH,					/* >> */
						A_Fixed			*native_fpsP);			/* << */

	SPAPI A_Err	(*AEGP_SetInSpecNativeFPS)(
						AEIO_InSpecH	inH,					/* >> */
						A_Fixed			native_fps);			/* >> */

	SPAPI A_Err	(*AEGP_GetInSpecDepth)(
						AEIO_InSpecH	inH,					/* >> */
						A_short			*depthPS);				/* << */

	SPAPI A_Err	(*AEGP_SetInSpecDepth)(
						AEIO_InSpecH	inH,					/* >> */
						A_short			depthS);				/* >> */

	SPAPI A_Err	(*AEGP_GetInSpecSize)(
						AEIO_InSpecH	inH,					/* >> */
						AEIO_FileSize	*sizePL);				/* << */

	SPAPI A_Err	(*AEGP_SetInSpecSize)(
						AEIO_InSpecH	inH,					/* >> */
						AEIO_FileSize	sizeL);					/* >> */

	SPAPI A_Err	(*AEGP_GetInSpecInterlaceLabel)(
						AEIO_InSpecH		inH,				/* >> */
						FIEL_Label	 		*interlaceP);		/* << */

	SPAPI A_Err	(*AEGP_SetInSpecInterlaceLabel)(
						AEIO_InSpecH		inH,				/* >> */
						const FIEL_Label	*interlaceP);		/* << */

	SPAPI A_Err	(*AEGP_GetInSpecAlphaLabel)(
						AEIO_InSpecH			inH,			/* >> */
						AEIO_AlphaLabel			*alphaP);		/* << */

	SPAPI A_Err	(*AEGP_SetInSpecAlphaLabel)(
						AEIO_InSpecH			inH,			/* >> */
						const AEIO_AlphaLabel	*alphaP);		/* << */

	SPAPI A_Err	(*AEGP_GetInSpecDuration)(
						AEIO_InSpecH	inH,					/* >> */
						A_Time			*durationP);			/* << */

	SPAPI A_Err	(*AEGP_SetInSpecDuration)(
						AEIO_InSpecH	inH,					/* >> */
						const A_Time	*durationP);			/* >> */

	SPAPI A_Err	(*AEGP_GetInSpecDimensions)(
						AEIO_InSpecH	inH,					/* >> */
						A_long			*widthPL0,				/* << */
						A_long			*heightPL0);

	SPAPI A_Err	(*AEGP_SetInSpecDimensions)(
						AEIO_InSpecH	inH,					/* >> */
						A_long			widthL,					/* >> */
						A_long			heightL);				/* >> */

	SPAPI A_Err	(*AEGP_InSpecGetRationalDimensions)(
						AEIO_InSpecH				inH,		/* >> */
						const AEIO_RationalScale	*rs0,		/* << */
						A_long						*width0,	/* << */
						A_long						*height0,	/* << */
						A_Rect						*r0);		/* << */

	SPAPI A_Err	(*AEGP_GetInSpecHSF)(
						AEIO_InSpecH	inH,					/* >> */
						A_Ratio			*hsfP);					/* << */

	SPAPI A_Err	(*AEGP_SetInSpecHSF)(
						AEIO_InSpecH	inH,					/* >> */
						const A_Ratio	*hsfP);					/* >> */

	SPAPI A_Err	(*AEGP_GetInSpecSoundRate)(
						AEIO_InSpecH	inH,					/* >> */
						A_FpLong		*ratePF);				/* << */

	SPAPI A_Err	(*AEGP_SetInSpecSoundRate)(
						AEIO_InSpecH	inH,					/* >> */
						A_FpLong		rateF);					/* >> */

	SPAPI A_Err	(*AEGP_GetInSpecSoundEncoding)(
						AEIO_InSpecH		inH,				/* >> */
						AEIO_SndEncoding	*encodingP);		/* << */

	SPAPI A_Err	(*AEGP_SetInSpecSoundEncoding)(
						AEIO_InSpecH		inH,				/* >> */
						AEIO_SndEncoding	encoding);			/* >> */

	SPAPI A_Err	(*AEGP_GetInSpecSoundSampleSize)(
						AEIO_InSpecH		inH,				/* >> */
						AEIO_SndSampleSize	*bytes_per_sampleP);/* << */

	SPAPI A_Err	(*AEGP_SetInSpecSoundSampleSize)(
						AEIO_InSpecH		inH,				/* >> */
						AEIO_SndSampleSize	bytes_per_sample);	/* >> */

	SPAPI A_Err	(*AEGP_GetInSpecSoundChannels)(
						AEIO_InSpecH		inH,				/* >> */
						AEIO_SndChannels	*num_channelsP);	/* << */

	SPAPI A_Err	(*AEGP_SetInSpecSoundChannels)(
						AEIO_InSpecH		inH,				/* >> */
						AEIO_SndChannels	num_channels);		/* >> */

	SPAPI A_Err	(*AEGP_AddAuxExtMap)(
						const A_char		*extension,			/* >> */
						A_long				file_type,			/* >> */
						A_long				creator);			/* >> */

	// In case of RGB data, if there is an embedded icc profile, build AEGP_ColorProfile out of this icc profile using AEGP_GetNewColorProfileFromICCProfile and pass it to
	// AEGP_SetInSpecEmbeddedColorProfile, with profile description set to NULL.
	//
	// In case of non-RGB data, if there is an embedded non-RGB icc profile or you know the color space the data is in, pass its description as a null-terminated unicode string
	// to AEGP_SetInSpecEmbeddedColorProfile, with color profile set to NULL. Doing this disables color management UI that allows user to affect
	// profile choice in the application UI.
	//
	// If you are unpacking non-RGB data directly into working space (to get working space use AEGP_GetNewWorkingSpaceColorProfile), you are done.
	//
	// If you are unpacking non-RGB data into specific RGB color space, you must pass the profile describing this space to AEGP_SetInSpecAssignedColorProfile.
	// Otherwise, your RGB data will be incorrectly interpreted as being in working space.
	//
	// Either color profile or profile description should be NULL in AEGP_SetInSpecEmbeddedColorProfile. You cannot use both.
	SPAPI A_Err (*AEGP_SetInSpecEmbeddedColorProfile)(
						AEIO_InSpecH			inH,				// <<
						AEGP_ConstColorProfileP	color_profileP0,	// <<
						const	A_UTF16Char		*profile_descP0);	// <<	pointer to a null-terminated unicode string

	// Assign valid RGB profile to the footage
	SPAPI A_Err (*AEGP_SetInSpecAssignedColorProfile)(
						AEIO_InSpecH			inH,				// <<
						AEGP_ConstColorProfileP	color_profileP);	// <<
	
	
	SPAPI A_Err	(*AEGP_GetInSpecNativeStartTime)(
										   AEIO_InSpecH	inH,					/* >> */
										   A_Time		*startTimeP);			/* << */
	
	SPAPI A_Err	(*AEGP_SetInSpecNativeStartTime)(
										   AEIO_InSpecH	inH,					/* >> */
										   const A_Time	*startTimeP);			/* >> */
	
	SPAPI A_Err	(*AEGP_ClearInSpecNativeStartTime)(
											AEIO_InSpecH	inH);				/* >> */
	
	SPAPI A_Err	(*AEGP_GetInSpecNativeDisplayDropFrame)(
										   AEIO_InSpecH	inH,						/* >> */
										   A_Boolean		*displayDropFrameBP);	/* << */
	
	SPAPI A_Err	(*AEGP_SetInSpecNativeDisplayDropFrame)(
										   AEIO_InSpecH	inH,						/* >> */
										   A_Boolean		displayDropFrameB);		/* >> */
	
	SPAPI A_Err	(*AEGP_SetInSpecStillSequenceNativeFPS)(
										   AEIO_InSpecH	inH,					/* >> */
										   A_Fixed		native_still_seq_fps);	/* >> */

} AEGP_IOInSuite5;

#define kAEGPIOOutSuite			"AEGP IO Out Suite"
#define kAEGPIOOutSuiteVersion5	8 /* frozen in AE 17.0 */

typedef struct AEGP_IOOutSuite5 {
	SPAPI A_Err	(*AEGP_GetOutSpecOptionsHandle)(
						AEIO_OutSpecH	outH,					/* >> */
						void			**optionsPPV);			/* << */

	SPAPI A_Err	(*AEGP_SetOutSpecOptionsHandle)(
						AEIO_OutSpecH	outH,					/* >> */
						void			*optionsPV,				/* >> */
						void			**old_optionsPPVO);		/* <> */

	SPAPI A_Err	(*AEGP_GetOutSpecFilePath)(
						AEIO_OutSpecH	outH,					/* >> */
						AEGP_MemHandle	*unicode_pathPH,		// << handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle
						A_Boolean		*file_reservedPB);		/* << If the file is reserved, do not create the file.
																	  Otherwise, multi-machine rendering can fail.
																	  If true, an empty file has already been created. */

	SPAPI A_Err	(*AEGP_GetOutSpecFPS)(
						AEIO_OutSpecH	outH,					/* >> */
						A_Fixed			*native_fpsP);			/* << */

	SPAPI A_Err	(*AEGP_SetOutSpecNativeFPS)(
						AEIO_OutSpecH	outH,					/* >> */
						A_Fixed			native_fpsP);			/* >> */

	SPAPI A_Err	(*AEGP_GetOutSpecDepth)(
						AEIO_OutSpecH	outH,					/* >> */
						A_short			*depthPS);				/* << */

	SPAPI A_Err	(*AEGP_SetOutSpecDepth)(
						AEIO_OutSpecH	outH,					/* >> */
						A_short			depthPS);				/* >> */

	SPAPI A_Err	(*AEGP_GetOutSpecInterlaceLabel)(
						AEIO_OutSpecH		outH,				/* >> */
						FIEL_Label			*interlaceP);		/* << */

	SPAPI A_Err	(*AEGP_SetOutSpecInterlaceLabel)(
						AEIO_OutSpecH		outH,				/* >> */
						const FIEL_Label	*interlaceP);		/* >> */

	SPAPI A_Err	(*AEGP_GetOutSpecAlphaLabel)(
						AEIO_OutSpecH		outH,				/* >> */
						AEIO_AlphaLabel		*alphaP);			/* << */

	SPAPI A_Err	(*AEGP_SetOutSpecAlphaLabel)(
						AEIO_OutSpecH			outH,			/* >> */
						const AEIO_AlphaLabel	*alphaP);		/* >> */

	SPAPI A_Err	(*AEGP_GetOutSpecDuration)(
						AEIO_OutSpecH	outH,					/* >> */
						A_Time			*durationP);			/* << */

	SPAPI A_Err	(*AEGP_SetOutSpecDuration)(
						AEIO_OutSpecH	outH,					/* >> */
						const A_Time	*durationP);			/* >> */

	SPAPI A_Err	(*AEGP_GetOutSpecDimensions)(
						AEIO_OutSpecH	outH,					/* >> */
						A_long			*widthPL,				/* << */
						A_long			*heightPL);				/* << */

	SPAPI A_Err	(*AEGP_GetOutSpecHSF)(
						AEIO_OutSpecH	outH,					/* >> */
						A_Ratio			*hsfP);					/* << */

	SPAPI A_Err	(*AEGP_SetOutSpecHSF)(
						AEIO_OutSpecH	outH,					/* >> */
						const A_Ratio	*hsfP);					/* >> */

	SPAPI A_Err	(*AEGP_GetOutSpecSoundRate)(
						AEIO_OutSpecH	outH,					/* >> */
						A_FpLong		*ratePF);				/* << */

	SPAPI A_Err	(*AEGP_SetOutSpecSoundRate)(
						AEIO_OutSpecH	outH,					/* >> */
						A_FpLong		rateF);					/* >> */

	SPAPI A_Err	(*AEGP_GetOutSpecSoundEncoding)(
						AEIO_OutSpecH		outH,				/* >> */
						AEIO_SndEncoding	*encodingP);		/* << */

	SPAPI A_Err	(*AEGP_SetOutSpecSoundEncoding)(
						AEIO_OutSpecH		outH,				/* >> */
						AEIO_SndEncoding	encoding);			/* >> */

	SPAPI A_Err	(*AEGP_GetOutSpecSoundSampleSize)(
						AEIO_OutSpecH		outH,				/* >> */
						AEIO_SndSampleSize	*bytes_per_sampleP);/* << */

	SPAPI A_Err	(*AEGP_SetOutSpecSoundSampleSize)(
						AEIO_OutSpecH		outH,				/* >> */
						AEIO_SndSampleSize	bytes_per_sample);	/* >> */

	SPAPI A_Err	(*AEGP_GetOutSpecSoundChannels)(
						AEIO_OutSpecH		outH,				/* >> */
						AEIO_SndChannels	*num_channelsP);	/* << */

	SPAPI A_Err	(*AEGP_SetOutSpecSoundChannels)(
						AEIO_OutSpecH		outH,				/* >> */
						AEIO_SndChannels	num_channels);		/* >> */

	SPAPI A_Err	(*AEGP_GetOutSpecIsStill)(
						AEIO_OutSpecH		outH,				/* >> */
						A_Boolean			*is_stillPB);		/* << */

	SPAPI A_Err	(*AEGP_GetOutSpecPosterTime)(
						AEIO_OutSpecH		outH,				/* >> */
						A_Time				*poster_timeP);		/* << */

	SPAPI A_Err	(*AEGP_GetOutSpecStartFrame)(
						AEIO_OutSpecH		outH,				/* >> */
						A_long				*start_frameP);		/* << */

	SPAPI A_Err	(*AEGP_GetOutSpecPullDown)(
						AEIO_OutSpecH		outH,				/* >> */
						AEIO_Pulldown		*pulldownP);		/* << */

	SPAPI A_Err	(*AEGP_GetOutSpecIsMissing)(
						AEIO_OutSpecH		outH,				/* >> */
						A_Boolean			*missingPB);		/* << */

	// see if you need to embed outspec's color profile as an icc profile
	SPAPI A_Err (*AEGP_GetOutSpecShouldEmbedICCProfile)(
						AEIO_OutSpecH		outH,				// >>
						A_Boolean			*embedPB);			// <<

	// query outspec's color profile
	SPAPI A_Err (*AEGP_GetNewOutSpecColorProfile)(
						AEGP_PluginID		aegp_plugin_id,		// >>
						AEIO_OutSpecH		outH,				// >>
						AEGP_ColorProfileP	*color_profilePP);	// <<	output color space; caller must dispose with AEGP_DisposeColorProfile

	// Fails if rq_itemP is not found.
	// This API would also fail if the outH is not a confirmed outH and is a copy.
	// e.g. if the Output Module settings dialog is Open.
	SPAPI A_Err	(*AEGP_GetOutSpecOutputModule)(
						AEIO_OutSpecH		outH,				/* >> */
						AEGP_RQItemRefH		*rq_itemP,			/* << */
						AEGP_OutputModuleRefH *om_refP);		/* << */
	
	SPAPI A_Err	(*AEGP_GetOutSpecStartTime)(
						AEIO_OutSpecH	outH,					/* >> */
						A_Time			*outStartTimePT);		/* << */
	
	SPAPI A_Err	(*AEGP_GetOutSpecFrameTime)(					// relative to start time
						AEIO_OutSpecH	outH,					/* >> */
						A_Time			*outFrameTimePT);		/* << */
	
	SPAPI A_Err	(*AEGP_GetOutSpecIsDropFrame)(
						AEIO_OutSpecH	outH,					/* >> */
						A_Boolean		*outIsDropFramePB);		/* << */


} AEGP_IOOutSuite5;



/*	This suite allows you to take advantage of going through AE Import Dialog
	and being treated as a native format type
*/

typedef	A_long	AE_FIM_ImportFlavorRef;

#define	AE_FIM_ImportFlavorRef_NONE	AEGP_Index_NONE

#define	AE_FIM_MAX_FLAVOR_NAME_LEN		63

enum {
	AE_FIM_ImportFlag_NONE 	= 	0x0,
	AE_FIM_ImportFlag_COMP	=	0x2
};
typedef	A_long	AE_FIM_ImportFlags;

enum {
	AE_FIM_SpecialAction_NONE				=	-1,
	AE_FIM_SpecialAction_DRAG_N_DROP_FILE	=	2
};
typedef	A_long	AE_FIM_SpecialAction;


typedef	struct	AE_FIM_RefconTag		*AE_FIM_Refcon;

typedef	struct	AE_FIM_ImportOptionsTag	*AE_FIM_ImportOptions;

// callbacks
typedef A_Err (*AE_FIM_ImportFileCB)(
							const A_UTF16Char	*pathZ,						// >> null terminated unicode path with platform separators
							AE_FIM_ImportOptions		imp_options,		/* >> 	opaque structure; in the future could be expanded with query functions*/
							AE_FIM_SpecialAction		action,				/* >> 	is it a special kind of import situation? */
							AEGP_ItemH					itemH,				/* >> 	meaning varies depending on AE_FIM_SpecialAction */
																			//		both for no special action and drag'n'drop it is
																			//		a folder where imported item should go
							AE_FIM_Refcon				refcon);			/* >> 	the client defines this and it is stored with import callbacks */



typedef A_Err (*AE_FIM_VerifyImportableCB)(
							const A_UTF16Char	*pathZ,						// >> null terminated unicode path with platform separators
							AE_FIM_Refcon		refcon,				/* >> 	the client defines this and it is stored with import callbacks */
							A_Boolean			*importablePB);		/* << */


typedef struct {
	AE_FIM_Refcon				refcon;		// points to whatever you want; stored and passed back with the callbacks
	AE_FIM_ImportFileCB			import_cb;
	AE_FIM_VerifyImportableCB	verify_cb;
} AE_FIM_ImportCallbacks;

#define	kAEGPFIMSuite			"AEGP File Import Manager Suite"
#define	kAEGPFIMSuiteVersion4	4 /* frozen in AE 17.0 */


typedef struct {
	SPAPI A_Err (*AEGP_RegisterImportFlavor)(
				const A_char 				*nameZ,		// format name you'd like to appear
													// in AE's Import Dialog Format pop-up
													// menu.
													// Limited to AE_FIM_MAX_IMPORT_FLAVOR_NAME_LEN.
													// Everything after that will be truncated.
				AE_FIM_ImportFlavorRef	*imp_refP);	// On return it is set to a valid opaque ref.
													// If error occured, it will be returned to
													// the caller and ref will be set to a special
													// value - AE_FIM_ImportFlavorRef_NONE.

	SPAPI A_Err (*AEGP_RegisterImportFlavorFileTypes)(
				AE_FIM_ImportFlavorRef	imp_ref,		// Received from AEGP_RegisterImportFlavor
				A_long					num_filekindsL,	// number of supported file types for this format
				const	AEIO_FileKind	*kindsAP,		// Array of supported file types for this format
				A_long					num_fileextsL,	// number of supported file exts for this format
				const	AEIO_FileKind	*extsAP);		// Array of supported file exts for this format


	SPAPI A_Err (*AEGP_RegisterImportFlavorImportCallbacks)(
				AE_FIM_ImportFlavorRef	imp_ref,			// Received from AEGP_RegisterImportFlavor
				AE_FIM_ImportFlags		single_flag,		// You can register callbacks only per single flag
															// this also registers the flag with the import flavor
				const	AE_FIM_ImportCallbacks	*imp_cbsP);	// Callbacks your format installs per each flag

	// optionally call once from AE_FIM_ImportFileCB.  This is used by the application when re-importing
	// from the render queue and replacing an existing item.
	SPAPI A_Err (*AEGP_SetImportedItem)(
			AE_FIM_ImportOptions		imp_options,		/* <> */
			AEGP_ItemH					imported_itemH);	/* >> */
	
	SPAPI A_Err (*AEGP_FileSequenceImportOptionsFromFIMImportOptions)(
			const AE_FIM_ImportOptions		imp_options,			/* >> */
			AEGP_FileSequenceImportOptions	*seq_import_optionsP);	/* << */

} AEGP_FIMSuite4;



/* --------------------------- Persistent Data Suite ------------------------------*/
/*
The persist data suite allows you to store persistant data with the application.

The data entries are accessed by SectionKey, ValueKey pairs. It is recommended
that plugins use their matchname as their SectionKey, or the prefix if using multiple
section names. THe available data types are void*, floating point numbers, and strings.

Void* unstructured data allows you to store any kind of data. You must pass in a size in
bytes along with the data.

String data supports the full 8 bit space, only 0x00 is reserved for string ending.
This makes them ideal for storing UTF-8 encoded strings, ISO 8859-1, and plain ASCII.
Both Section keys and Value keys are of this type.

FpLongs are stored with 6 decimal places of precision. There is no provision
for specifying a different precision.

Right now the only persistent data host is the application.

*/

#define	kAEGPPersistentDataSuite			"AEGP Persistent Data Suite"
#define	kAEGPPersistentDataSuiteVersion4	4 /* frozen in AE 12.0 */

typedef struct {
	// get a handle of the application blob,
	// modifying this will modify the application
	SPAPI A_Err (*AEGP_GetApplicationBlob)(
		AEGP_PersistentType		blob_type, 			/* >> new in AE 12 */
		AEGP_PersistentBlobH	*blobPH);			/* << */

	// section and value key management
	SPAPI A_Err (*AEGP_GetNumSections)(
						AEGP_PersistentBlobH	blobH,				/* >> */
						A_long					*num_sectionPL);	/* << */

	SPAPI A_Err (*AEGP_GetSectionKeyByIndex)(
						AEGP_PersistentBlobH	blobH,				/* >> */
						A_long					section_index,		/* >> */
						A_long					max_section_size,	/* >> */
						A_char					*section_keyZ);		/* << */

	SPAPI A_Err	(*AEGP_DoesKeyExist)(
						AEGP_PersistentBlobH	blobH,				/* >> */
						const A_char			*section_keyZ,		/* >> */
						const A_char			*value_keyZ,		/* >> */
						A_Boolean				*existsPB);			/* << */

	SPAPI A_Err (*AEGP_GetNumKeys)(
						AEGP_PersistentBlobH	blobH,				/* >> */
						const A_char			*section_keyZ,		/* >> */
						A_long					*num_keysPL);		/* << */

	SPAPI A_Err (*AEGP_GetValueKeyByIndex)(
						AEGP_PersistentBlobH	blobH,				/* >> */
						const A_char			*section_keyZ,		/* >> */
						A_long					key_index,			/* >> */
						A_long					max_key_size,		/* >> */
						A_char					*value_keyZ);		/* << */

	// data access and manipulation

	// For the entry points below, if a given key is not found,
	//	the default value is both written to the blobH and
	//	returned as the value; if no default is provided, a blank value will be written
	//	and returned

	SPAPI A_Err (*AEGP_GetDataHandle)(
						AEGP_PluginID			plugin_id,
						AEGP_PersistentBlobH	blobH,			/* >> */
						const A_char			*section_keyZ,	/* >> */
						const A_char			*value_keyZ,	/* >> */
						AEGP_MemHandle			defaultH0,		/* >> never adopted, NULL means no default data */
						AEGP_MemHandle			*valuePH);		/* << newly allocated, owned by caller, NULL if would be zero sized handle */

	SPAPI A_Err (*AEGP_GetData)(
						AEGP_PersistentBlobH	blobH,			/* >> */
						const A_char			*section_keyZ,	/* >> */
						const A_char			*value_keyZ,	/* >> */
						A_u_long				data_sizeLu,	/* >> bufPV & default must be this big, if pref isn't then the default will be used */
						const void				*defaultPV0,	/* >> NULL means all zeros for default */
						void					*bufPV);		/* << */

	SPAPI A_Err (*AEGP_GetString)(
						AEGP_PersistentBlobH	blobH,					/* >> */
						const A_char			*section_keyZ,			/* >> */
						const A_char			*value_keyZ,			/* >> */
						const A_char			*defaultZ0,				/* >> NULL means '\0' is the default */
						A_u_long				buf_sizeLu,				/* >> size of buffer. Behavior dependent on actual_buf_sizeLu0 */
						A_char					*bufZ,					/* << will be "" if buf_size is too small */
						A_u_long				*actual_buf_sizeLu0);	/* << actual size needed to store the buffer (includes terminating NULL). Pass NULL for error reporting if size mismatch.*/

	SPAPI A_Err (*AEGP_GetLong)(
						AEGP_PersistentBlobH	blobH,			/* >> */
						const A_char			*section_keyZ,	/* >> */
						const A_char			*value_keyZ,	/* >> */
						A_long					defaultL,		/* >> */
						A_long					*valuePL);		/* << */

	SPAPI A_Err	(*AEGP_GetFpLong)(
						AEGP_PersistentBlobH	blobH,			/* >> */
						const A_char			*section_keyZ,	/* >> */
						const A_char			*value_keyZ,	/* >> */
						A_FpLong				defaultF,		/* >> */
						A_FpLong				*valuePF);		/* << */

	SPAPI A_Err	(*AEGP_GetTime)(
						AEGP_PersistentBlobH	blobH,			/* >> */
						const A_char			*section_keyZ,	/* >> */
						const A_char			*value_keyZ,	/* >> */
						const A_Time			*defaultPT0,	/* >> */
						A_Time					*valuePT);		/* << */
	
	SPAPI A_Err	(*AEGP_GetARGB)(
						AEGP_PersistentBlobH	blobH,			/* >> */
						const A_char			*section_keyZ,	/* >> */
						const A_char			*value_keyZ,	/* >> */
						const PF_PixelFloat		*defaultP0,		/* >> */
						PF_PixelFloat			*valueP);		/* << */

	// setters
	SPAPI A_Err	(*AEGP_SetDataHandle)(
						AEGP_PersistentBlobH	blobH,			/* >> */
						const A_char			*section_keyZ,	/* >> */
						const A_char			*value_keyZ,	/* >> */
						const AEGP_MemHandle	valueH);		/* >> not adopted */

	SPAPI A_Err	(*AEGP_SetData)(
						AEGP_PersistentBlobH	blobH,			/* >> */
						const A_char			*section_keyZ,	/* >> */
						const A_char			*value_keyZ,	/* >> */
						A_u_long				data_sizeLu,	/* >> */
						const void				*dataPV);		/* >> */

	SPAPI A_Err	(*AEGP_SetString)(
						AEGP_PersistentBlobH	blobH,			/* >> */
						const A_char			*section_keyZ,	/* >> */
						const A_char			*value_keyZ,	/* >> */
						const A_char			*strZ);			/* >> */

	SPAPI A_Err	(*AEGP_SetLong)(
						AEGP_PersistentBlobH	blobH,			/* >> */
						const A_char			*section_keyZ,	/* >> */
						const A_char			*value_keyZ,	/* >> */
						A_long					valueL);		/* >> */

	SPAPI A_Err	(*AEGP_SetFpLong)(
						AEGP_PersistentBlobH	blobH,			/* >> */
						const A_char			*section_keyZ,	/* >> */
						const A_char			*value_keyZ,	/* >> */
						A_FpLong				valueF);		/* >> */

	SPAPI A_Err	(*AEGP_SetTime)(
						AEGP_PersistentBlobH	blobH,			/* >> */
						const A_char			*section_keyZ,	/* >> */
						const A_char			*value_keyZ,	/* >> */
						const A_Time			*valuePT);		/* >> */

	SPAPI A_Err	(*AEGP_SetARGB)(
						AEGP_PersistentBlobH	blobH,			/* >> */
						const A_char			*section_keyZ,	/* >> */
						const A_char			*value_keyZ,	/* >> */
						const PF_PixelFloat		*valueP);		/* >> */

	SPAPI A_Err	(*AEGP_DeleteEntry)(							/* no error if entry not found */
						AEGP_PersistentBlobH	blobH,			/* >> */
						const A_char			*section_keyZ,	/* >> */
						const A_char			*value_keyZ);	/* >> */

	SPAPI A_Err	(*AEGP_GetPrefsDirectory)(
						AEGP_MemHandle			*unicode_pathPH);		// << empty string if no file. handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle

} AEGP_PersistentDataSuite4;


// AEGP_CollectionSuite1

#define	kAEGPCollectionSuite					"AEGP Collection Suite"
#define	kAEGPCollectionSuiteVersion2			2 /* frozen in AE 6.5 */

enum  {
	AEGP_CollectionItemType_NONE,

	AEGP_CollectionItemType_LAYER,
	AEGP_CollectionItemType_MASK,
	AEGP_CollectionItemType_EFFECT,
	AEGP_CollectionItemType_STREAM,
	AEGP_CollectionItemType_KEYFRAME,
	AEGP_CollectionItemType_MASK_VERTEX,
	AEGP_CollectionItemType_STREAMREF,

	AEGP_CollectionItemType_END,
	AEGP_CollectionItemType_BEGIN = AEGP_CollectionItemType_LAYER
};
typedef A_LegacyEnumType AEGP_CollectionItemType;

typedef struct {
	AEGP_LayerH	layerH;		/* comp derived from layerH */
} AEGP_LayerCollectionItem;

typedef struct {
	AEGP_LayerH		layerH;		/* containing layer */
	AEGP_MaskIndex	index;		/* index to layer. 	*/
}AEGP_MaskCollectionItem;

typedef struct {
	AEGP_LayerH			layerH;		/* containing layer		*/
	AEGP_EffectIndex	index;		/* index to the effect	*/
}AEGP_EffectCollectionItem;

enum  {
	AEGP_StreamCollectionItemType_NONE,
	AEGP_StreamCollectionItemType_LAYER,
	AEGP_StreamCollectionItemType_MASK,
	AEGP_StreamCollectionItemType_EFFECT,
	AEGP_StreamCollectionItemType_END,
	AEGP_StreamCollectionItemType_BEGIN = AEGP_StreamCollectionItemType_LAYER
};
typedef A_LegacyEnumType AEGP_StreamCollectionItemType;

typedef struct {
	AEGP_MaskCollectionItem		mask;
	AEGP_MaskStream				mask_stream;
} AEGP_MaskStreamCollectionItem;

typedef struct {
	AEGP_EffectCollectionItem	effect;
	A_long						param_index;
} AEGP_EffectStreamCollectionItem;

typedef struct {
	AEGP_LayerH						layerH;
	AEGP_LayerStream				layer_stream;
} AEGP_LayerStreamCollectionItem;

typedef struct {
	AEGP_StreamCollectionItemType	type;
	union {
		AEGP_LayerStreamCollectionItem	layer_stream;
		AEGP_MaskStreamCollectionItem	mask_stream;
		AEGP_EffectStreamCollectionItem	effect_stream;
	} u;
}AEGP_StreamCollectionItem;

typedef struct {
	AEGP_MaskCollectionItem	mask_sel;	/* the mask must be selected for a vertex to be selected */
	AEGP_VertexIndex		index;
}AEGP_MaskVertexCollectionItem;

typedef struct {
	AEGP_StreamCollectionItem	stream_coll;
	AEGP_KeyframeIndex	index;
}AEGP_KeyframeCollectionItem;

typedef struct {
	AEGP_CollectionItemType	type;
	// the union is not used for AEGP_CollectionItemType_STREAMREF
	union {
		AEGP_LayerCollectionItem		layer;
		AEGP_MaskCollectionItem			mask;
		AEGP_EffectCollectionItem		effect;
		AEGP_StreamCollectionItem		stream;
		AEGP_MaskVertexCollectionItem	mask_vertex;
		AEGP_KeyframeCollectionItem		keyframe;
	} u;

	AEGP_StreamRefH						stream_refH; // valid for all types
} AEGP_CollectionItemV2;

typedef struct {
	SPAPI A_Err (*AEGP_NewCollection)(									/* dispose with dispose collection */
						AEGP_PluginID	plugin_id,						/* >> */
						AEGP_Collection2H *collectionPH);				/* << */

	SPAPI A_Err (*AEGP_DisposeCollection)(
						AEGP_Collection2H collectionH);					/* >> */

	SPAPI A_Err	(*AEGP_GetCollectionNumItems)(							/* constant time */
						AEGP_Collection2H	collectionH,				/* >> */
						A_u_long		*num_itemsPL);					/* << */

	SPAPI A_Err	(*AEGP_GetCollectionItemByIndex)(						/* constant time */
						AEGP_Collection2H	collectionH,				/* >> */
						A_u_long			indexL,						/* >> */
						AEGP_CollectionItemV2	*collection_itemP);			/* << */

	SPAPI A_Err (*AEGP_CollectionPushBack)(								/* constant time */
						AEGP_Collection2H			collectionH,		/* <> */
						const AEGP_CollectionItemV2	*collection_itemP);	/* >> NOTE:	The passed AEGP_CollectionItemV2, as well as all the AEGP_StreamRefH's
																					it references, will be adopted by AE; DO NOT dispose of it! */

	SPAPI A_Err (*AEGP_CollectionErase)(								/* O(n) */
						AEGP_Collection2H	collectionH,				/* <> */
						A_u_long			index_firstL,				/* >> */
						A_u_long			index_lastL);				/* >> */

} AEGP_CollectionSuite2;


enum
{
	AEGP_WorldType_NONE,
	AEGP_WorldType_8,
	AEGP_WorldType_16,
	AEGP_WorldType_32
};

typedef A_long AEGP_WorldType;


#define	kAEGPWorldSuite					"AEGP World Suite"
#define	kAEGPWorldSuiteVersion3			3 /* frozen in AE 7.0 */

typedef struct {
	SPAPI A_Err (*AEGP_New)(
						AEGP_PluginID	plugin_id,			/* >> */
						AEGP_WorldType	type,				/* >> */
						A_long			widthL,				/* >> */
						A_long			heightL,			/* >> */
						AEGP_WorldH		*worldPH);			/* << */

	SPAPI A_Err (*AEGP_Dispose)(
						AEGP_WorldH		worldH);			/* >> */

	SPAPI A_Err (*AEGP_GetType)(
						AEGP_WorldH		worldH,				/* >> */
						AEGP_WorldType	*typeP);			/* << */

	SPAPI A_Err (*AEGP_GetSize)(
						AEGP_WorldH		worldH,				/* >> */
						A_long			*widthPL,			/* << */
						A_long			*heightPL);			/* << */

	SPAPI A_Err (*AEGP_GetRowBytes)(
						AEGP_WorldH		worldH,				/* >> */
						A_u_long			*row_bytesPL);	/* << */

	SPAPI A_Err (*AEGP_GetBaseAddr8)(
						AEGP_WorldH		worldH,				/* >> error if the worldH is not AEGP_WorldType_8 */
						PF_Pixel8		**base_addrP);		/* << */

	SPAPI A_Err (*AEGP_GetBaseAddr16)(
		AEGP_WorldH		worldH,				/* >> error if the worldH is not AEGP_WorldType_16 */
		PF_Pixel16		**base_addrP);		/* << */

	SPAPI A_Err (*AEGP_GetBaseAddr32)(
		AEGP_WorldH		worldH,				/* >> error if the worldH is not AEGP_WorldType_32 */
		PF_PixelFloat	**base_addrP);		/* << */

	SPAPI A_Err (*AEGP_FillOutPFEffectWorld)(				/*	Provided so you can use some of the PF routines with an AEGPWorld. Pass NULL as the ProgPtr to the PF routines.*/
						AEGP_WorldH		worldH,				/* >> */
						PF_EffectWorld	*pf_worldP);		/* << */

	SPAPI A_Err (*AEGP_FastBlur)(
						A_FpLong		radiusF,			/* >> */
						PF_ModeFlags	mode,				/* >> */
						PF_Quality		quality,			/* >> */
						AEGP_WorldH		worldH);			/* <>  only for user allocated worlds; not for checked-out frames which are read only */

	SPAPI A_Err (*AEGP_NewPlatformWorld)(
		AEGP_PluginID	plugin_id,			/* >> */
		AEGP_WorldType	type,				/* >> */
		A_long			widthL,				/* >> */
		A_long			heightL,			/* >> */
		AEGP_PlatformWorldH		*worldPH);			/* << */

	SPAPI A_Err (*AEGP_DisposePlatformWorld)(
		AEGP_PlatformWorldH		worldH);			/* >> */

	SPAPI A_Err (*AEGP_NewReferenceFromPlatformWorld)(
		AEGP_PluginID	plugin_id,			/* >> */
		AEGP_PlatformWorldH platform_worldH, // >>
		AEGP_WorldH		*worldPH);			/* << */


} AEGP_WorldSuite3;


/* AEGP_RenderOptionsSuite

*/

enum {
	AEGP_MatteMode_STRAIGHT = 0,
	AEGP_MatteMode_PREMUL_BLACK,
	AEGP_MatteMode_PREMUL_BG_COLOR
};
typedef A_long AEGP_MatteMode;

enum {
	AEGP_ChannelOrder_ARGB = 0,
	AEGP_ChannelOrder_BGRA
};
typedef A_char AEGP_ChannelOrder;

enum {
	AEGP_ItemQuality_DRAFT = 0,					/* footage only. perform faster decode at expense of quality and draft-quality deinterlacing. */
	AEGP_ItemQuality_BEST						/* footage only. perform full decode and resampled deinterlacing */
};
typedef A_char AEGP_ItemQuality;

#define	kAEGPRenderOptionsSuite					"AEGP Render Options Suite"
#define	kAEGPRenderOptionsSuiteVersion4			4 /* frozen in AE 10.5 */

typedef struct {
	// fills out
	// Time to 0
	// Time step to the frame duration
	// field render to none
	// depth is best resolution of item
	SPAPI A_Err (*AEGP_NewFromItem)(
					AEGP_PluginID		plugin_id,			/* >> */
					AEGP_ItemH			itemH,				/* >> */
					AEGP_RenderOptionsH	*optionsPH);		/* << */

	SPAPI A_Err (*AEGP_Duplicate)(
					AEGP_PluginID		plugin_id,			/* >> */
					AEGP_RenderOptionsH	optionsH,			/* >> */
					AEGP_RenderOptionsH	*copyPH);			/* << */

	SPAPI A_Err (*AEGP_Dispose)(
					AEGP_RenderOptionsH	optionsH);			/* >> */

	SPAPI A_Err (*AEGP_SetTime)(							/* the render time */
					AEGP_RenderOptionsH	optionsH,			/* <> */
					A_Time				time);				/* >> */

	SPAPI A_Err (*AEGP_GetTime)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					A_Time				*timeP);			/* << */

	SPAPI A_Err (*AEGP_SetTimeStep)(						/* duration of the frame; important for motion blur. */
					AEGP_RenderOptionsH	optionsH,			/* <> */
					A_Time				time_step);			/* >> */

	SPAPI A_Err (*AEGP_GetTimeStep)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					A_Time				*timePT);			/* << */

	SPAPI A_Err (*AEGP_SetFieldRender)(						/* How fields are to be handled. */
					AEGP_RenderOptionsH	optionsH,			/* <> */
					PF_Field			field_render);		/* >> */

	SPAPI A_Err (*AEGP_GetFieldRender)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					PF_Field			*field_renderP);	/* << */


	SPAPI A_Err (*AEGP_SetWorldType)(
					AEGP_RenderOptionsH	optionsH,			/* <> */
					AEGP_WorldType		type);				/* >> */

	SPAPI A_Err (*AEGP_GetWorldType)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					AEGP_WorldType		*typeP);			/* << */


	// 1 == 100%
	// 2 == 50%
	// ...
	SPAPI A_Err (*AEGP_SetDownsampleFactor)(
					AEGP_RenderOptionsH	optionsH,			/* <> */
					A_short		x,							/* >> */
					A_short		y);							/* >> */

	SPAPI A_Err (*AEGP_GetDownsampleFactor)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					A_short				*xP,				/* >> */
					A_short				*yP);				/* << */

	SPAPI A_Err	(*AEGP_SetRegionOfInterest)(
					AEGP_RenderOptionsH	optionsH,			/* <> */
					const A_LRect		*roiP);				/* >>  {0,0,0,0} for all*/

	SPAPI A_Err (*AEGP_GetRegionOfInterest)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					A_LRect				*roiP);				/* << */

	SPAPI A_Err	(*AEGP_SetMatteMode)(
					AEGP_RenderOptionsH	optionsH,			/* <> */
					AEGP_MatteMode		mode);				/* >> */

	SPAPI A_Err (*AEGP_GetMatteMode)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					AEGP_MatteMode		*modeP);			/* << */

	SPAPI A_Err	(*AEGP_SetChannelOrder)(
					AEGP_RenderOptionsH optionsH,			/* <> */
					AEGP_ChannelOrder	channel_order);		/* >> */

	SPAPI A_Err (*AEGP_GetChannelOrder)(
					AEGP_RenderOptionsH optionsH,			/* >> */
					AEGP_ChannelOrder	*channelP);			/* << */

	SPAPI A_Err (*AEGP_GetRenderGuideLayers)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					A_Boolean			*will_renderPB);	/* << */

	SPAPI A_Err (*AEGP_SetRenderGuideLayers)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					A_Boolean			render_themB);		/* >> */

	/* AEGP_ItemType_FOOTAGE can be decoded at different with different
	   quality levels. Ignore for other AEGP_ItemType
	   */

	SPAPI A_Err (*AEGP_GetRenderQuality)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					AEGP_ItemQuality	*qualityP);			/* << */

	SPAPI A_Err (*AEGP_SetRenderQuality)(
					AEGP_RenderOptionsH	optionsH,		/* >> */
					AEGP_ItemQuality	quality);		/* >> */
} AEGP_RenderOptionsSuite4;


#define	kAEGPLayerRenderOptionsSuite					"AEGP Layer Render Options Suite"
#define	kAEGPLayerRenderOptionsSuiteVersion2			2 /* frozen in 13.5 */

typedef struct {
	// optionsPH must be disposed by calling code
	//
	// fills out
	// Time to the layer's current time
	// Time step to layer's frame duration
	// ROI to the layer's nominal bounds
	// EffectsToRender to "all"
	SPAPI A_Err (*AEGP_NewFromLayer)(
					AEGP_PluginID				plugin_id,		/* >> */
					AEGP_LayerH					layerH,			/* >> */
					AEGP_LayerRenderOptionsH	*optionsPH);	/* << */

	// optionsPH must be disposed by calling code
	// like AEGP_NewFromLayer, but sets EffectsToRender to be the index fof effectH
	SPAPI A_Err (*AEGP_NewFromUpstreamOfEffect)(
					AEGP_PluginID				plugin_id,		/* >> */
					AEGP_EffectRefH				effectH,		/* >> */
					AEGP_LayerRenderOptionsH	*optionsPH);	/* << */

	// optionsPH must be disposed by calling code
	// like AEGP_NewFromLayer, but sets EffectsToRender to include the effect output
	// THIS MAY ONLY BE CALLED FROM THE UI THREAD
	SPAPI A_Err (*AEGP_NewFromDownstreamOfEffect)(
												AEGP_PluginID				plugin_id,		/* >> */
												AEGP_EffectRefH				effectH,		/* >> */
												AEGP_LayerRenderOptionsH	*optionsPH);	/* << */

	// copyPH must be disposed by calling code
	SPAPI A_Err (*AEGP_Duplicate)(
					AEGP_PluginID				plugin_id,		/* >> */
					AEGP_LayerRenderOptionsH	optionsH,		/* >> */
					AEGP_LayerRenderOptionsH	*copyPH);		/* << */

	SPAPI A_Err (*AEGP_Dispose)(
					AEGP_LayerRenderOptionsH	optionsH);		/* >> */

	SPAPI A_Err (*AEGP_SetTime)(								/* the render time */
					AEGP_LayerRenderOptionsH	optionsH,		/* <> */
					A_Time						time);			/* >> */

	SPAPI A_Err (*AEGP_GetTime)(
					AEGP_LayerRenderOptionsH	optionsH,		/* >> */
					A_Time				*timeP);				/* << */

	SPAPI A_Err (*AEGP_SetTimeStep)(							/* duration of the frame; important for motion blur. */
					AEGP_LayerRenderOptionsH	optionsH,		/* <> */
					A_Time						time_step);		/* >> */

	SPAPI A_Err (*AEGP_GetTimeStep)(
					AEGP_LayerRenderOptionsH	optionsH,		/* >> */
					A_Time						*timePT);		/* << */

	SPAPI A_Err (*AEGP_SetWorldType)(
					AEGP_LayerRenderOptionsH	optionsH,		/* <> */
					AEGP_WorldType				type);			/* >> */

	SPAPI A_Err (*AEGP_GetWorldType)(
					AEGP_LayerRenderOptionsH	optionsH,		/* >> */
					AEGP_WorldType				*typeP);		/* << */

	// 1 == 100%
	// 2 == 50%
	// ...
	SPAPI A_Err (*AEGP_SetDownsampleFactor)(
					AEGP_LayerRenderOptionsH	optionsH,		/* <> */
					A_short						x,				/* >> */
					A_short						y);				/* >> */

	SPAPI A_Err (*AEGP_GetDownsampleFactor)(
					AEGP_LayerRenderOptionsH	optionsH,		/* >> */
					A_short						*xP,			/* >> */
					A_short						*yP);			/* << */

	SPAPI A_Err	(*AEGP_SetMatteMode)(
					AEGP_LayerRenderOptionsH	optionsH,		/* <> */
					AEGP_MatteMode				mode);			/* >> */

	SPAPI A_Err (*AEGP_GetMatteMode)(
					AEGP_LayerRenderOptionsH	optionsH,		/* >> */
					AEGP_MatteMode				*modeP);		/* << */
} AEGP_LayerRenderOptionsSuite2;


#define	kAEGPRenderSuite					"AEGP Render Suite"
#define	kAEGPRenderSuiteVersion5			8 /* frozen in 13.5 */

typedef A_u_longlong AEGP_AsyncRequestId;

typedef A_Err (*AEGP_RenderSuiteCheckForCancel)(
					void 		*refcon,
					A_Boolean 	*cancelPB);

typedef A_Err (*AEGP_AsyncFrameReadyCallback)(
					AEGP_AsyncRequestId				request_id,				// this will be the AEGP_AsyncRequestId that was returned from AEGP_RenderAndCheckoutLayerFrame_Async
					A_Boolean						was_canceled,			// will be set to true if this request was canceled via a call to AEGP_CancelAsyncRequest
					A_Err							error,					// will be set to A_Err_NONE (0) if successful
					AEGP_FrameReceiptH 				receiptH,				// frame data (only if successful)
					AEGP_AsyncFrameRequestRefcon	refconP0);				// this is the AEGP_AsyncFrameRequestRefcon that was (optionally) passed in to AEGP_RenderAndCheckoutLayerFrame_Async

typedef struct {
	// IMPORTANT: use of this call on the UI thread should be considered DEPRECATED except in a very narrow  use case:
	// a) the plugin requires this frame to make database change (e.g. an auto color button on an effect)
	// b) the user explicitly requested this operation (e.g. this is not a passive redraw of UI because something else changed)
	// This is to avoid having poor interactivity while the user is doing other unrelated things.
	// Asynchronous APIs should be used on the UI thread except in this specific case
	// On the UI thread, if the frame takes longer than 2 seconds, a progress dialog will automatically open to allow the user to cancel
	// On a render thread, these calls will work as normal with no progress dialog

	// See IMPORTANT note above about using this synchronous call on the UI thread which is considered DEPRECATED behavior
	SPAPI A_Err (*AEGP_RenderAndCheckoutFrame)(
					AEGP_RenderOptionsH				optionsH,					/* >> */
					AEGP_RenderSuiteCheckForCancel	cancel_functionP0,			/* >> optional*/
					AEGP_CancelRefcon				cancel_function_refconP0, 	/* >> optional */
					AEGP_FrameReceiptH				*receiptPH);				/* << check in using AEGP_CheckinFrame to release memory */

		// render_plain_layer_frameB was confusing and is not the design we want going forward
		// eventually this will be replaced with new RenderOptions calls. Until that is available, this will behave as if render_plain_layer_frameB is "false"
		// (upstream effect render). If the "true" behavior for adjustment layer mask is desired, see kAEGPRenderSuiteVersion4 that still has this flag

	// See IMPORTANT note above about using this synchronous call on the UI thread which is considered DEPRECATED behavior
	SPAPI A_Err (*AEGP_RenderAndCheckoutLayerFrame)(
					AEGP_LayerRenderOptionsH			optionsH,					/* >> */
					AEGP_RenderSuiteCheckForCancel		cancel_functionP0,			/* >> optional*/
					AEGP_CancelRefcon					cancel_function_refconP0,	/* >> optional */
					AEGP_FrameReceiptH					*receiptPH);				/* << check in using AEGP_CheckinFrame to release memory */

	SPAPI A_Err (*AEGP_RenderAndCheckoutLayerFrame_Async)(
					AEGP_LayerRenderOptionsH			optionsH,						/* >> */
					AEGP_AsyncFrameReadyCallback		callback,						/* >> this will be called when the frame is ready (guaranteed to be called unless AE is shutting down) */
					AEGP_AsyncFrameRequestRefcon		request_completion_refconP0,	/* >> optional.  if included, it will be passed into the above callback */
					AEGP_AsyncRequestId					*asyncRequestIdP);				/* << Id associated with frame request.  Can be used to cancel early */

	SPAPI A_Err (*AEGP_CancelAsyncRequest)(
					AEGP_AsyncRequestId					asyncRequestId);				/* >> */

	SPAPI A_Err (*AEGP_CheckinFrame)(
					AEGP_FrameReceiptH		receiptH);							/* >> */

	/*	This returns a read only world that is not-owned by the plugin.
		Call CheckinFrame to release the world when you are done reading from it.
	*/

	SPAPI A_Err (*AEGP_GetReceiptWorld)(
					AEGP_FrameReceiptH		receiptH,							/* >> */
					AEGP_WorldH				*worldPH);							/* << */

	SPAPI A_Err (*AEGP_GetRenderedRegion)(
					AEGP_FrameReceiptH		receiptH,							/* >> */
					A_LRect					*rendered_regionP);					/* << */

	SPAPI A_Err (*AEGP_IsRenderedFrameSufficient)(
						AEGP_RenderOptionsH rendered_optionsH,					/* >> */
						AEGP_RenderOptionsH proposed_optionsH,					/* >> */
						A_Boolean			*rendered_is_sufficientPB);			/* << */

	// See IMPORTANT note above about using this synchronous call on the UI thread which is considered DEPRECATED behavior
	SPAPI A_Err (*AEGP_RenderNewItemSoundData)( 								/* Works on Compositions and Footage items. */
					AEGP_ItemH						itemH,						/* >> */
					const A_Time					*start_timePT,				/* >> */
					const A_Time					*durationPT,				/* >> */
					const AEGP_SoundDataFormat		*sound_formatP,				/* >> */
					AEGP_RenderSuiteCheckForCancel	cancel_functionP0,			/* >> optional*/
					AEGP_CancelRefcon				cancel_function_refconP0, 	/* >> optional */
					AEGP_SoundDataH					*new_sound_dataPH);			/* << AEGP_SoundDataH must be disposed. Returns NULL if no audio */


	// returns the current timestamp of the project.this is increased any time something is touched in the project
	// that affects rendering
	SPAPI A_Err (*AEGP_GetCurrentTimestamp)(
							AEGP_TimeStamp * time_stampP); // out

	// Lets you know if the video of the item has changed since the input time stamp.
	// Is not affected by audio.
	SPAPI A_Err (*AEGP_HasItemChangedSinceTimestamp)(AEGP_ItemH itemH,					// in
													const A_Time * start_timeP,			// in
													const A_Time* durationP,			//in
													const AEGP_TimeStamp * time_stampP, //in
													A_Boolean * item_has_changedPB);	//out

	// checks whether this frame would be worth rendering externally and
	// checking in to the cache. a speculative renderer should check this twice:
	// (1) before sending the frame out to render
	// (2) when it is complete, before calling AEGP_NewPlatformWorld and checking in.
	// (don't forget to call AEGP_HasItemChangedSinceTimestamp also!)
	SPAPI A_Err (*AEGP_IsItemWorthwhileToRender)(	AEGP_RenderOptionsH roH,					// in
												const AEGP_TimeStamp* time_stampP,		// in
												A_Boolean *worthwhile_to_renderPB);	// out

	// ticks_to_render is the approximate amount of time needed to render the frame
	// on this machine. it is 60Hz.
	SPAPI A_Err (*AEGP_CheckinRenderedFrame)( AEGP_RenderOptionsH roH,					// in
												const AEGP_TimeStamp* time_stampP,		// in
												A_u_long ticks_to_renderL,				// in
												AEGP_PlatformWorldH	imageH);			// in (adopted)
												
	SPAPI A_Err (*AEGP_GetReceiptGuid) (AEGP_FrameReceiptH receiptH, 	// in
											AEGP_MemHandle *guidMH);	// out, must be disposed
} AEGP_RenderSuite5;



// AsyncManager render suite.  For render requests that are managed by AE rather than explicitly by plugin callbacks (as in some cases in AEGP_RenderSuite5+)
// As of 13.5 the only way to get an AsyncManager is via PF_GetContextAsyncManager in PF_EffectCustomUISuite2.  (This Async Manager is PF_Event_DRAW specific
// but there may be others in the future)

#define kAEGPRenderAsyncManagerSuite                       "AEGP Render Asyc Manager Suite"
#define kAEGPRenderAsyncManagerSuiteVersion1       1       /* frozen in 13.5 */


typedef struct {
	
	// An AsyncManager automatically handles possibly multiple async render requests
	// The first use of this in for async requests in CUSTOM_UI of PF_EventDRAW.  See PF_OutFlags2_CUSTOM_UI_ASYNC_MANAGER
	// The purpose_id is a unique constant number that helps the manager understand when it can automatically cancel
	// old requests (because they have the same purpose id and the RO has changed)
	
	SPAPI A_Err (*AEGP_CheckoutOrRender_ItemFrame_AsyncManager)( PF_AsyncManagerP  async_managerP,	// >> the async manager to ask for the render
																 A_u_long			purpose_id,		// >> a unique id to identify requests for the same usage (e.g. to hint cancellation of old)
																 AEGP_RenderOptionsH ro,			// >> the description of the item frame to render
																 AEGP_FrameReceiptH  *out_receiptPH );	// << on success, the rendered frame.  Can succeed and have no pixels (no world)
	
	SPAPI A_Err (*AEGP_CheckoutOrRender_LayerFrame_AsyncManager)( PF_AsyncManagerP  async_managerP,	// >> the async manager to ask for the render
																 A_u_long purpose_id,				// >> a unique id to identify requests for the same usage (e.g. to hint cancellation of old)
																 AEGP_LayerRenderOptionsH lro,		// >> the description of the layer frame to render
																 AEGP_FrameReceiptH    *out_receiptPH );  // << on success, the rendered frame.  Can succeed and have no pixels (no world)
	
	
	
} AEGP_RenderAsyncManagerSuite1;




#define	kAEGPTrackerSuite			"AEGP Tracker Suite"
#define	kAEGPTrackerSuiteVersion1	1    /* frozen in AE 6.0 */


typedef	struct {
	SPAPI A_Err (*AEGP_GetNumFeatures)(
					const	PT_TrackingContextPtr	contextP,				/* >> */
					A_long							*num_featuresPL);		/* << */

	SPAPI A_Err (*AEGP_GetFeatureRegionByIndex)(
					const	PT_TrackingContextPtr	contextP,				/* >> */
					PT_Index						index,					/* >> */
					A_FloatRect						*rectP);				/* << */

	SPAPI A_Err (*AEGP_GetSearchRegionByIndex)(
					const	PT_TrackingContextPtr	contextP,				/* >> */
					PT_Index						index,					/* >> */
					A_FloatRect						*rectP);				/* << */

	SPAPI A_Err (*AEGP_GetFeatureWorldByIndex)(
					const	PT_TrackingContextPtr	contextP,				/* >> */
					PT_Index						index,					/* >> */
					AEGP_WorldH						*feature_worldPH);		/* << */

	SPAPI A_Err (*AEGP_GetFrameWorld)(
					const	PT_TrackingContextPtr	contextP,				/* >> */
					AEGP_WorldH						*frame_worldPH);		/* << */

	SPAPI A_Err (*AEGP_GetTrackerSourceDimensions)(
					const	PT_TrackingContextPtr	contextP,				/* >> */
					A_long							*widthPL,				/* << */
					A_long							*heightPL);

	SPAPI A_Err (*AEGP_SetFeatureRegionByIndex)(
					const	PT_TrackingContextPtr	contextP,				/* >> */
					PT_Index						index,					/* >> */
					const	A_FloatRect				*rectP);				/* >> */

	SPAPI A_Err (*AEGP_SetAccuracyByIndex)(
					const	PT_TrackingContextPtr	contextP,				/* >> */
					PT_Index						index,					/* >> */
					A_FpLong						accuracyF);				/* >> */

	SPAPI A_Err (*AEGP_ShouldTrackFeature)(
					const	PT_TrackingContextPtr	contextP,				/* >> */
					PT_Index						index,					/* >> */
					A_Boolean						*trackPB);				/* << */

} AEGP_TrackerSuite1;


#define	kAEGPTrackerUtilitySuite			"AEGP Tracker Utility Suite"
#define	kAEGPTrackerUtilitySuiteVersion1	1 /* frozen in AE 6.0 */

typedef struct {
	SPAPI A_Err (*AEGP_HasUserCancelled)(
					const	PT_TrackingContextPtr	contextP,				/* >> */
					A_Boolean						*user_cancelledPB);		/* << */

	SPAPI A_Err (*AEGP_GetTrackerFromTrackerInstance)(
					const	PT_TrackerInstancePtr	tracker_instanceP,		/* >> */
					PT_TrackerPtr					*trackerPP);			/* << */

	SPAPI A_Err (*AEGP_GetTrackerInstanceFromTrackingContext)(
					const	PT_TrackingContextPtr	contextP,				/* >> */
					PT_TrackerInstancePtr			*tracker_instancePP);	/* << */

	SPAPI A_Err (*AEGP_GetGlobalData)(
					const	PT_TrackerPtr			trackerP,				/* >> */
					AEGP_MemHandle					*global_dataPH);		/* << */

	SPAPI A_Err (*AEGP_GetInstanceData)(
					const	PT_TrackerInstancePtr	tracker_instanceP,		/* >> */
					AEGP_MemHandle					*instance_dataPH);		/* << */	// currently has to be flat (no handles inside the handle)

	SPAPI A_Err (*AEGP_GetTrackData)(
					const	PT_TrackingContextPtr	contextP,				/* >> */
					AEGP_MemHandle					*track_dataPH);			/* << */
} AEGP_TrackerUtilitySuite1;



#define kAEGPRenderQueueMonitorSuite				"AEGP RenderQueue Monitor Suite"
#define kAEGPRenderQueueMonitorSuiteVersion1		1 /* frozen AE 11.0 */

typedef struct _AEGP_RQM_Refcon			*AEGP_RQM_Refcon;
typedef A_u_longlong					AEGP_RQM_SessionId;
typedef A_u_longlong					AEGP_RQM_ItemId;
typedef A_u_longlong					AEGP_RQM_FrameId;

typedef enum
{
	AEGP_RQM_FinishedStatus_UNKNOWN,
	AEGP_RQM_FinishedStatus_SUCCEEDED,
	AEGP_RQM_FinishedStatus_ABORTED,
	AEGP_RQM_FinishedStatus_ERRED
} AEGP_RQM_FinishedStatus;

typedef struct _AEGP_RQM_BasicData {
	const struct SPBasicSuite	*pica_basicP;
	A_long						aegp_plug_id;
	AEGP_RQM_Refcon				aegp_refconPV;
} AEGP_RQM_BasicData;

typedef struct _AEGP_RQM_FunctionBlock1 {
	A_Err (*AEGP_RQM_RenderJobStarted)(AEGP_RQM_BasicData *basic_dataP, AEGP_RQM_SessionId jobid);
	A_Err (*AEGP_RQM_RenderJobEnded)(AEGP_RQM_BasicData *basic_dataP, AEGP_RQM_SessionId jobid);
	A_Err (*AEGP_RQM_RenderJobItemStarted)(AEGP_RQM_BasicData *basic_dataP, AEGP_RQM_SessionId jobid, AEGP_RQM_ItemId itemid);
	A_Err (*AEGP_RQM_RenderJobItemUpdated)(AEGP_RQM_BasicData *basic_dataP, AEGP_RQM_SessionId jobid, AEGP_RQM_ItemId itemid, AEGP_RQM_FrameId frameid);
	A_Err (*AEGP_RQM_RenderJobItemEnded)(AEGP_RQM_BasicData *basic_dataP, AEGP_RQM_SessionId jobid, AEGP_RQM_ItemId itemid, AEGP_RQM_FinishedStatus fstatus);
	A_Err (*AEGP_RQM_RenderJobItemReportLog)(AEGP_RQM_BasicData *basic_dataP, AEGP_RQM_SessionId jobid, AEGP_RQM_ItemId itemid, A_Boolean isError, AEGP_MemHandle logbuf);
} AEGP_RQM_FunctionBlock1;

typedef struct AEGP_RenderQueueMonitorSuite1 {

	SPAPI A_Err	 (*AEGP_RegisterListener) (
						AEGP_PluginID					aegp_plugin_id,			/* >> */
						AEGP_RQM_Refcon					aegp_refconP,			/* >> */
						const AEGP_RQM_FunctionBlock1 *	fcn_blockP);			/* >> */

	SPAPI A_Err	 (*AEGP_DeregisterListener) (
						AEGP_PluginID					aegp_plugin_id,			/* >> */
						AEGP_RQM_Refcon					aegp_refconP);			/* >> */

	SPAPI A_Err	 (*AEGP_GetProjectName)(
						AEGP_RQM_SessionId 				sessid,					// >>
						AEGP_MemHandle					*utf_project_namePH0);	// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle

	SPAPI A_Err	 (*AEGP_GetAppVersion)(
						AEGP_RQM_SessionId 				sessid,					// >>
						AEGP_MemHandle					*utf_app_versionPH0);	// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle

	SPAPI A_Err	 (*AEGP_GetNumJobItems)(
						AEGP_RQM_SessionId 				sessid,					// >>
						A_long							*num_jobitemsPL);		// <<

	SPAPI A_Err	 (*AEGP_GetJobItemID)(
						AEGP_RQM_SessionId 				sessid,					// >>
						A_long							jobItemIndex,			// >>
						AEGP_RQM_ItemId					*jobItemID);			// <<

	SPAPI A_Err	 (*AEGP_GetNumJobItemRenderSettings)(
						AEGP_RQM_SessionId 				sessid,					// >>
						AEGP_RQM_ItemId					itemid,					// >>
						A_long							*num_settingsPL);		// <<

	SPAPI A_Err	 (*AEGP_GetJobItemRenderSetting)(
						AEGP_RQM_SessionId 				sessid,					// >>
						AEGP_RQM_ItemId					itemid,					// >>
						A_long							settingIndex,			// >>
						AEGP_MemHandle					*utf_setting_namePH0,	// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle
						AEGP_MemHandle					*utf_setting_valuePH0);	// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle

	SPAPI A_Err	 (*AEGP_GetNumJobItemOutputModules)(
						AEGP_RQM_SessionId 				sessid,					// >>
						AEGP_RQM_ItemId					itemid,					// >>
						A_long							*num_outputmodulesPL);	// <<

	SPAPI A_Err	 (*AEGP_GetNumJobItemOutputModuleSettings)(
						AEGP_RQM_SessionId 				sessid,					// >>
						AEGP_RQM_ItemId					itemid,					// >>
						A_long							outputModuleIndex,		// >>
						A_long							*num_settingsPL);		// <<

	SPAPI A_Err	 (*AEGP_GetJobItemOutputModuleSetting)(
						AEGP_RQM_SessionId 				sessid,					// >>
						AEGP_RQM_ItemId					itemid,					// >>
						A_long							outputModuleIndex,		// >>
						A_long							settingIndex,			// >>
						AEGP_MemHandle					*utf_setting_namePH0,	// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle
						AEGP_MemHandle					*utf_setting_valuePH0);	// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle

	SPAPI A_Err	 (*AEGP_GetNumJobItemOutputModuleWarnings)(
						AEGP_RQM_SessionId 				sessid,					// >>
						AEGP_RQM_ItemId					itemid,					// >>
						A_long							outputModuleIndex,		// >>
						A_long							*num_warningsPL);		// <<

	SPAPI A_Err	 (*AEGP_GetJobItemOutputModuleWarning)(
						AEGP_RQM_SessionId 				sessid,					// >>
						AEGP_RQM_ItemId					itemid,					// >>
						A_long							outputModuleIndex,		// >>
						A_long							warningIndex,			// >>
						AEGP_MemHandle					*utf_warning_valuePH0);	// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle

	SPAPI A_Err	 (*AEGP_GetNumJobItemFrameProperties)(
							AEGP_RQM_SessionId 				sessid,					// >>
							AEGP_RQM_ItemId					itemid,					// >>
							AEGP_RQM_FrameId				frameid,				// >>
							A_long							*num_propertiesPL);		// <<

	SPAPI A_Err	 (*AEGP_GetJobItemFrameProperty)(
							AEGP_RQM_SessionId 				sessid,					// >>
							AEGP_RQM_ItemId					itemid,					// >>
							AEGP_RQM_FrameId				frameid,				// >>
							A_long							propertyIndex,			// >>
							AEGP_MemHandle					*utf_property_namePH0,	// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle
							AEGP_MemHandle					*utf_property_valuePH0);// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle

	SPAPI A_Err	 (*AEGP_GetNumJobItemOutputModuleProperties)(
							AEGP_RQM_SessionId 				sessid,					// >>
							AEGP_RQM_ItemId					itemid,					// >>
							A_long							outputModuleIndex,		// >>
							A_long							*num_propertiesPL);		// <<

	SPAPI A_Err	 (*AEGP_GetJobItemOutputModuleProperty)(
							AEGP_RQM_SessionId 				sessid,					// >>
							AEGP_RQM_ItemId					itemid,					// >>
							A_long							outputModuleIndex,		// >>
							A_long							propertyIndex,			// >>
							AEGP_MemHandle					*utf_property_namePH0,	// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle
							AEGP_MemHandle					*utf_property_valuePH0);// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle

	SPAPI A_Err	 (*AEGP_GetJobItemFrameThumbnail)(
							AEGP_RQM_SessionId 				sessid,					// >>
							AEGP_RQM_ItemId					itemid,					// >>
							AEGP_RQM_FrameId				frameid,				// >>
							A_long							*widthPL,				// <> 	pass in the maximum width, returns the actual width
							A_long							*heightPL,				// <>	pass in the maximum height, returns the actual height
							AEGP_MemHandle					*thumbnailPH0);			// <<	handle of an image memory block in JPEG format

} AEGP_RenderQueueMonitorSuite1;



/* -------------------------------------------------------------------- */

typedef const void *PF_ConstPtr;
typedef const PF_ConstPtr *PF_ConstHandle;

#define kPFEffectSequenceDataSuite				"PF Effect Sequence Data Suite"
#define kPFEffectSequenceDataSuiteVersion1		1 /* frozen in 18.2 */

typedef struct PF_EffectSequenceDataSuite1 {
	
	SPAPI PF_Err	(*PF_GetConstSequenceData)(	PF_ProgPtr		effect_ref,
												PF_ConstHandle *sequence_data);	/* >> */

} PF_EffectSequenceDataSuite1;




#include <AE_GeneralPlugPost.h>


/****************************************************************/
/* include old versions of the suites							*/
/****************************************************************/
#include <AE_GeneralPlugOld.h>

#endif

```

---

<h2>Begin File: AE_GeneralPlugOld.h</h2>

```cpp
/*******************************************************************/
/*                                                                 */
/*                      ADOBE CONFIDENTIAL                         */
/*                   _ _ _ _ _ _ _ _ _ _ _ _ _                     */
/*                                                                 */
/* Copyright 2007 Adobe Systems Incorporated                       */
/* All Rights Reserved.                                            */
/*                                                                 */
/* NOTICE:  All information contained herein is, and remains the   */
/* property of Adobe Systems Incorporated and its suppliers, if    */
/* any.  The intellectual and technical concepts contained         */
/* herein are proprietary to Adobe Systems Incorporated and its    */
/* suppliers and may be covered by U.S. and Foreign Patents,       */
/* patents in process, and are protected by trade secret or        */
/* copyright law.  Dissemination of this information or            */
/* reproduction of this material is strictly forbidden unless      */
/* prior written permission is obtained from Adobe Systems         */
/* Incorporated.                                                   */
/*                                                                 */
/*******************************************************************/

/*******************************************************************/
/*																   */
/* this file contains the old or deprecated versions of the suites */
/* listed in AE_GeneralPlug.h									   */
/*******************************************************************/


#include <AE_GeneralPlugPre.h>

typedef struct {	// note: unused values are still stored in settings and used when cycling through
					//	the 3 types using cmd/ctrl-click on timecode
	AEGP_TimeDisplayType	time_display_type;
	A_char					timebaseC;			// only used for AEGP_TimeDisplayType_TIMECODE, 1 to 100
	A_Boolean				non_drop_30B;		// only used for AEGP_TimeDisplayType_TIMECODE,
												//	when timebaseC == 30 && item framerate == 29.97, use drop frame or non-drop?
	A_char					frames_per_footC;	// only used for AEGP_TimeDisplayType_FEET_AND_FRAMES
	A_long					starting_frameL;	// usually 0 or 1, not used for AEGP_TimeDisplayType_TIMECODE
} AEGP_TimeDisplay;

/**
 ** Canvas Suite
 ** Used by artisans to render layers
 **/

#define kAEGPCanvasSuiteVersion1		4	/* frozen in AE 5.0 */

typedef struct AEGP_CanvasSuite1 {

	SPAPI A_Err	(*AEGP_GetCompToRender)(
						PR_RenderContextH 		render_contextH,   	/* >> */
						AEGP_CompH				*compPH);			/* << */

	SPAPI A_Err	(*AEGP_GetNumLayersToRender)(
				const	PR_RenderContextH	render_contextH,
						A_long				*num_to_renderPL);


	SPAPI A_Err	(*AEGP_GetNthLayerContextToRender)(
				const	PR_RenderContextH			render_contextH,	/* >> */
						A_long						n,					/* >> */
						AEGP_RenderLayerContextH	*layer_contextPH);	/* << */

	SPAPI A_Err	(*AEGP_GetLayerFromLayerContext)(
				const	PR_RenderContextH			render_contextH,
						AEGP_RenderLayerContextH	layer_contextH,
						AEGP_LayerH					*layerPH);

	SPAPI A_Err	(*AEGP_GetCompRenderTime)(
						PR_RenderContextH	render_contextH,	/* >> */
						A_Time				*time,				/* << */
						A_Time				*time_step);

	SPAPI A_Err	(*AEGP_GetCompDestinationBuffer)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_CompH					compH,				/* >> */
						PF_EffectWorld					*dst);				/* <> */

	SPAPI A_Err	(*AEGP_GetROI)(
						PR_RenderContextH			render_contextH,	/* <> */
						A_LegacyRect						*roiPR);			/* << */

	/// for rendering track mattes
	SPAPI A_Err	(*AEGP_RenderLayer)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_LayerH					layerH,				/* >> */
						AEGP_RenderHints			render_hints,		/* >> */
						PF_EffectWorld					*render_bufferP);	/* >> */

	// for rendering the texture map of a layer
	SPAPI A_Err	(*AEGP_RenderTexture)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_RenderLayerContextH	layer_contextH,		/* >> */
						AEGP_RenderHints			render_hints,		/* >> */
						A_FloatPoint				*suggested_scaleP0,	/* >> */
						A_FloatRect					*suggested_src_rectP0, /* >> */
						A_Matrix3					*src_matrixP0,		/* << */
						PF_EffectWorld					*dst);				/* <> */


	SPAPI A_Err	(*AEGP_DisposeTexture)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_RenderLayerContextH	layer_contextH,		/* >> */
						PF_EffectWorld					*dst0);				/* <> */

	SPAPI A_Err	(*AEGP_GetFieldRender)(
						PR_RenderContextH 			render_contextH,   	/* >> */
						PF_Field					*field);			/* << */

	// not thread safe on MacOS
	// only call when thread ID = 0
	SPAPI A_Err	(*AEGP_ReportArtisanProgress)(
					PR_RenderContextH 				render_contextH,   	/* >> */
					A_long							countL,				/* >> */
					A_long							totalL);			/* >> */

	SPAPI A_Err	(*AEGP_GetRenderDownsampleFactor)(
						PR_RenderContextH			render_contextH,	/* >> */
						AEGP_DownsampleFactor		*dsfP);				/* << */

	SPAPI A_Err	(*AEGP_IsBlankCanvas)(
						PR_RenderContextH			render_contextH,	/* >> */
						A_Boolean					*is_blankPB);		/* << */

	SPAPI A_Err (*AEGP_GetRenderLayerToWorldXform)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timeP,		/* >> */
					A_Matrix4						*transform);			/* << */

	SPAPI A_Err (*AEGP_GetRenderLayerBounds)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timeP,		/* >> */
					A_LegacyRect							*boundsP);			/* << */

	SPAPI A_Err (*AEGP_GetRenderOpacity)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timePT,		/* >> */
					A_FpLong						*opacityPF);		/* << */

	SPAPI A_Err (*AEGP_IsRenderLayerActive)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timePT,		/* >> */
					A_Boolean						*activePB);			/* << */

	// set the layer index. If total > 0, set it too.
	SPAPI A_Err	(*AEGP_SetArtisanLayerProgress)(
					PR_RenderContextH 				render_contextH,   	/* >> */
					A_long							countL,				/* >> */
					A_long							num_layersL);

} AEGP_CanvasSuite1;

/********************************************************************/

#define kAEGPRQItemSuiteVersion3		4	/* frozen in AE 7.0 */

typedef struct AEGP_RQItemSuite3 {

	SPAPI A_Err	(*AEGP_GetNumRQItems)(
						A_long				*num_itemsPL);		/* << */

	/*	NOTE: 	All AEGP_RQItemRefH are invalidated by ANY
				re-ordering, addition or removal of render
				items. DO NOT CACHE THEM.
	*/

	SPAPI A_Err (*AEGP_GetRQItemByIndex)(
						A_long				rq_item_index,		/* >> */
						AEGP_RQItemRefH		*rq_item_refPH);	/* << */

	SPAPI A_Err (*AEGP_GetNextRQItem)(							/* Pass RQ_ITEM_INDEX_NONE for current_rq_itemH to get first RQItemH. */
						AEGP_RQItemRefH		current_rq_itemH,	/* >> */
						AEGP_RQItemRefH		*next_rq_itemH);	/* << */

	SPAPI A_Err (*AEGP_GetNumOutputModulesForRQItem)(
						AEGP_RQItemRefH		rq_itemH,			/* >> */
						A_long				*num_outmodsPL);	/* << */

	SPAPI A_Err (*AEGP_GetRenderState)(
						AEGP_RQItemRefH				rq_itemH,	/* >> */
						AEGP_RenderItemStatusType	*statusP);	/* << */

	/*
		the following now returns:
		Err_PARAMETER if you try to call while AEGP_RenderQueueState != AEGP_RenderQueueState_STOPPED

		if that's okay then:
		Err_RANGE if you pass a status that is illegal in any case
		Err_PARAMETER if you try to pass a status that doesn't make sense right now (eg: trying to Que something for which you haven't set the output path)
	*/
	SPAPI A_Err (*AEGP_SetRenderState)(
						AEGP_RQItemRefH				rq_itemH,	/* >> */
						AEGP_RenderItemStatusType	status);	/* >> */

	SPAPI A_Err (*AEGP_GetStartedTime)(
						AEGP_RQItemRefH		rq_itemH,			/* >> */
						A_Time				*started_timePT);	/* <<	Returns {0,1} if not started. */

	SPAPI A_Err (*AEGP_GetElapsedTime)(
						AEGP_RQItemRefH		rq_itemH,			/* >> */
						A_Time				*render_timePT);	/* << 	Returns {0,1} if not rendered. */

	SPAPI A_Err	(*AEGP_GetLogType)(
						AEGP_RQItemRefH		rq_itemH,			/* >> */
						AEGP_LogType		*logtypeP);			/* << */

	SPAPI A_Err	(*AEGP_SetLogType)(
						AEGP_RQItemRefH		rq_itemH,			/* >> */
						AEGP_LogType		logtype);			/* << */

	SPAPI A_Err	(*AEGP_RemoveOutputModule)(
						AEGP_RQItemRefH			rq_itemH,		/* >> */
						AEGP_OutputModuleRefH	outmodH);		/* >> */

	SPAPI A_Err (*AEGP_GetComment)(
						AEGP_RQItemRefH			rq_itemH,		/* >> */
						A_char					*commentZ);		/* << 		up to A_char[AEGP_MAX_RQITEM_COMMENT_SIZE] */

	SPAPI A_Err (*AEGP_SetComment)(
						AEGP_RQItemRefH			rq_itemH,		/* >> */
						const A_char			*commentZ);		/* >> 		up to A_char[AEGP_MAX_RQITEM_COMMENT_SIZE] */

	SPAPI A_Err (*AEGP_GetCompFromRQItem)(
						AEGP_RQItemRefH			rq_itemH,		/* >> */
						AEGP_CompH				*compPH);		/* << */

	SPAPI A_Err (*AEGP_DeleteRQItem)(
						AEGP_RQItemRefH			rq_itemH);		/* <> 	   UNDOABLE */

} AEGP_RQItemSuite3;

#define kAEGPRQItemSuiteVersion2		3	/* frozen in AE 6.5 */

typedef struct AEGP_RQItemSuite2 {

	SPAPI A_Err	(*AEGP_GetNumRQItems)(
						A_long				*num_itemsPL);		/* << */

	/*	NOTE: 	All AEGP_RQItemRefH are invalidated by ANY
				re-ordering, addition or removal of render
				items. DO NOT CACHE THEM.
	*/

	SPAPI A_Err (*AEGP_GetRQItemByIndex)(
						A_long				rq_item_index,		/* >> */
						AEGP_RQItemRefH		*rq_item_refPH);	/* << */

	SPAPI A_Err (*AEGP_GetNextRQItem)(							/* Pass NULL for current_rq_itemH to get first RQItemH. */
						AEGP_RQItemRefH		current_rq_itemH,	/* >> */
						AEGP_RQItemRefH		*next_rq_itemH);	/* << */

	SPAPI A_Err (*AEGP_GetNumOutputModulesForRQItem)(
						AEGP_RQItemRefH		rq_itemH,			/* >> */
						A_long				*num_outmodsPL);	/* << */

	SPAPI A_Err (*AEGP_GetRenderState)(
						AEGP_RQItemRefH				rq_itemH,	/* >> */
						AEGP_RenderItemStatusType	*statusP);	/* << */

	/*
		the following now returns:
		Err_PARAMETER if you try to call while AEGP_RenderQueueState != AEGP_RenderQueueState_STOPPED

		if that's okay then:
		Err_RANGE if you pass a status that is illegal in any case
		Err_PARAMETER if you try to pass a status that doesn't make sense right now (eg: trying to Que something for which you haven't set the output path)
	*/
	SPAPI A_Err (*AEGP_SetRenderState)(
						AEGP_RQItemRefH				rq_itemH,	/* >> */
						AEGP_RenderItemStatusType	status);	/* >> */

	SPAPI A_Err (*AEGP_GetStartedTime)(
						AEGP_RQItemRefH		rq_itemH,			/* >> */
						A_Time				*started_timePT);	/* <<	Returns {0,1} if not started. */

	SPAPI A_Err (*AEGP_GetElapsedTime)(
						AEGP_RQItemRefH		rq_itemH,			/* >> */
						A_Time				*render_timePT);	/* << 	Returns {0,1} if not rendered. */

	SPAPI A_Err	(*AEGP_GetLogType)(
						AEGP_RQItemRefH		rq_itemH,			/* >> */
						AEGP_LogType		*logtypeP);			/* << */

	SPAPI A_Err	(*AEGP_SetLogType)(
						AEGP_RQItemRefH		rq_itemH,			/* >> */
						AEGP_LogType		logtype);			/* << */

	SPAPI A_Err	(*AEGP_RemoveOutputModule)(
						AEGP_RQItemRefH			rq_itemH,		/* >> */
						AEGP_OutputModuleRefH	outmodH);		/* >> */

	SPAPI A_Err (*AEGP_GetComment)(
						AEGP_RQItemRefH			rq_itemH,		/* >> */
						A_char					*commentZ);		/* << 		up to A_char[AEGP_MAX_RQITEM_COMMENT_SIZE] */

	SPAPI A_Err (*AEGP_SetComment)(
						AEGP_RQItemRefH			rq_itemH,		/* >> */
						const A_char			*commentZ);		/* >> 		up to A_char[AEGP_MAX_RQITEM_COMMENT_SIZE] */

	SPAPI A_Err (*AEGP_GetCompFromRQItem)(
						AEGP_RQItemRefH			rq_itemH,		/* >> */
						AEGP_CompH				*compPH);		/* << */

} AEGP_RQItemSuite2;

#define kAEGPRQItemSuiteVersion1		1	/* frozen in AE 6.0 */

typedef struct AEGP_RQItemSuite1 {

	SPAPI A_Err	(*AEGP_GetNumRQItems)(
						A_long				*num_itemsPL);		/* << */

	/*	NOTE: 	All AEGP_RQItemRefH are invalidated by ANY
				re-ordering, addition or removal of render
				items. DO NOT CACHE THEM.
	*/

	SPAPI A_Err (*AEGP_GetRQItemByIndex)(
						A_long				rq_item_index,		/* >> */
						AEGP_RQItemRefH		*rq_item_refPH);	/* << */

	SPAPI A_Err (*AEGP_GetNextRQItem)(							/* Pass NULL for current_rq_itemH to get first RQItemH. */
						AEGP_RQItemRefH		current_rq_itemH,	/* >> */
						AEGP_RQItemRefH		*next_rq_itemH);	/* << */

	SPAPI A_Err (*AEGP_GetNumOutputModulesForRQItem)(
						AEGP_RQItemRefH		rq_itemH,			/* >> */
						A_long				*num_outmodsPL);	/* << */

	SPAPI A_Err (*AEGP_GetRenderState)(
						AEGP_RQItemRefH				rq_itemH,	/* >> */
						AEGP_RenderItemStatusType	*statusP);	/* << */

	SPAPI A_Err (*AEGP_SetRenderState)(							/* Will return error if called while (AEGP_RenderQueueState != AEGP_RenderQueueState_STOPPED). */
						AEGP_RQItemRefH				rq_itemH,	/* >> */
						AEGP_RenderItemStatusType	status);	/* >> */

	SPAPI A_Err (*AEGP_GetStartedTime)(
						AEGP_RQItemRefH		rq_itemH,			/* >> */
						A_Time				*started_timePT);	/* <<	Returns {0,0} if not started. */

	SPAPI A_Err (*AEGP_GetElapsedTime)(
						AEGP_RQItemRefH		rq_itemH,			/* >> */
						A_Time				*render_timePT);	/* << 	Returns {0,0} if not rendered. */

	SPAPI A_Err	(*AEGP_GetLogType)(
						AEGP_RQItemRefH		rq_itemH,			/* >> */
						AEGP_LogType		*logtypeP);			/* << */

	SPAPI A_Err	(*AEGP_SetLogType)(
						AEGP_RQItemRefH		rq_itemH,			/* >> */
						AEGP_LogType		logtype);			/* << */

	SPAPI A_Err	(*AEGP_RemoveOutputModule)(
						AEGP_RQItemRefH			rq_itemH,		/* >> */
						AEGP_OutputModuleRefH	outmodH);		/* >> */

	SPAPI A_Err (*AEGP_GetComment)(
						AEGP_RQItemRefH			rq_itemH,		/* >> */
						A_char					*commentZ);		/* << 		up to A_char[AEGP_MAX_RQITEM_COMMENT_SIZE] */

	SPAPI A_Err (*AEGP_SetComment)(
						AEGP_RQItemRefH			rq_itemH,		/* >> */
						const A_char			*commentZ);		/* >> 		up to A_char[AEGP_MAX_RQITEM_COMMENT_SIZE] */

} AEGP_RQItemSuite1;



#define kAEGPCanvasSuiteVersion2		6 /* frozen in AE 5.5 */

typedef struct AEGP_CanvasSuite2 {

	SPAPI A_Err	(*AEGP_GetCompToRender)(
						PR_RenderContextH 		render_contextH,   	/* >> */
						AEGP_CompH				*compPH);			/* << */

	SPAPI A_Err	(*AEGP_GetNumLayersToRender)(
				const	PR_RenderContextH	render_contextH,
						A_long				*num_to_renderPL);


	SPAPI A_Err	(*AEGP_GetNthLayerContextToRender)(
				const	PR_RenderContextH			render_contextH,	/* >> */
						A_long						n,					/* >> */
						AEGP_RenderLayerContextH	*layer_contextPH);	/* << */

	SPAPI A_Err	(*AEGP_GetLayerFromLayerContext)(
				const	PR_RenderContextH			render_contextH,
						AEGP_RenderLayerContextH	layer_contextH,
						AEGP_LayerH					*layerPH);

	/**
	 ** With collapsed geometrics "on" this gives the layer in the root comp
	 ** contining the layer context. With collapsed geometrics off
	 ** this is the same as AEGP_GetLayerFromLayerContext.
	 **
	 **/
	SPAPI A_Err	(*AEGP_GetTopLayerFromLayerContext)(
				const	PR_RenderContextH			render_contextH,
						AEGP_RenderLayerContextH	layer_contextH,
						AEGP_LayerH					*layerPH);

	SPAPI A_Err	(*AEGP_GetCompRenderTime)(
						PR_RenderContextH	render_contextH,	/* >> */
						A_Time				*time,				/* << */
						A_Time				*time_step);

	SPAPI A_Err	(*AEGP_GetCompDestinationBuffer)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_CompH					compH,				/* >> */
						PF_EffectWorld					*dst);				/* <> */

	SPAPI A_Err	(*AEGP_GetROI)(
						PR_RenderContextH			render_contextH,	/* <> */
						A_LegacyRect						*roiPR);			/* << */

	/// for rendering track mattes
	SPAPI A_Err	(*AEGP_RenderLayer)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_LayerH					layerH,				/* >> */
						AEGP_RenderHints			render_hints,		/* >> */
						PF_EffectWorld					*render_bufferP);	/* >> */

	// for rendering the texture map of a layer
	SPAPI A_Err	(*AEGP_RenderTexture)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_RenderLayerContextH	layer_contextH,		/* >> */
						AEGP_RenderHints			render_hints,		/* >> */
						A_FloatPoint				*suggested_scaleP0,	/* >> */
						A_FloatRect					*suggested_src_rectP0, /* >> */
						A_Matrix3					*src_matrixP0,		/* << */
						PF_EffectWorld					*dst);				/* <> */


	SPAPI A_Err	(*AEGP_DisposeTexture)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_RenderLayerContextH	layer_contextH,		/* >> */
						PF_EffectWorld					*dst0);				/* <> */

	SPAPI A_Err	(*AEGP_GetFieldRender)(
						PR_RenderContextH 			render_contextH,   	/* >> */
						PF_Field					*field);			/* << */

	// not thread safe on MacOS
	// only call when thread ID = 0
	SPAPI A_Err	(*AEGP_ReportArtisanProgress)(
					PR_RenderContextH 				render_contextH,   	/* >> */
					A_long							countL,				/* >> */
					A_long							totalL);			/* >> */

	SPAPI A_Err	(*AEGP_GetRenderDownsampleFactor)(
						PR_RenderContextH			render_contextH,	/* >> */
						AEGP_DownsampleFactor		*dsfP);				/* << */

	SPAPI A_Err	(*AEGP_IsBlankCanvas)(
						PR_RenderContextH			render_contextH,	/* >> */
						A_Boolean					*is_blankPB);		/* << */

	SPAPI A_Err (*AEGP_GetRenderLayerToWorldXform)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timeP,		/* >> */
					A_Matrix4						*transform);			/* << */

	SPAPI A_Err (*AEGP_GetRenderLayerBounds)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timeP,		/* >> */
					A_LegacyRect							*boundsP);			/* << */

	SPAPI A_Err (*AEGP_GetRenderOpacity)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timePT,		/* >> */
					A_FpLong						*opacityPF);		/* << */

	SPAPI A_Err (*AEGP_IsRenderLayerActive)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timePT,		/* >> */
					A_Boolean						*activePB);			/* << */

	// set the layer index. If total > 0, set it too.
	SPAPI A_Err	(*AEGP_SetArtisanLayerProgress)(
					PR_RenderContextH 				render_contextH,   	/* >> */
					A_long							countL,				/* >> */
					A_long							num_layersL);

	SPAPI A_Err	(*AEGP_RenderLayerPlus)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_LayerH 				layerH,				/* >> */
						AEGP_RenderLayerContextH 	layer_contextH,		/* >> */
						AEGP_RenderHints			render_hints,		/* >> */
						PF_EffectWorld					*render_bufferP);	/* << */


	SPAPI A_Err	(*AEGP_GetTrackMatteContext)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_RenderLayerContextH 	fill_contextH,		/* << */
						AEGP_RenderLayerContextH	*matte_contextPH);	/* >> */

} AEGP_CanvasSuite2;



#define kAEGPCanvasSuiteVersion4		9	/* frozen AE 6.0 */

typedef struct AEGP_CanvasSuite4 {

	SPAPI A_Err	(*AEGP_GetCompToRender)(
						PR_RenderContextH 		render_contextH,   	/* >> */
						AEGP_CompH				*compPH);			/* << */

	SPAPI A_Err	(*AEGP_GetNumLayersToRender)(
				const	PR_RenderContextH	render_contextH,		/* >> */
						A_long				*num_to_renderPL);		/* << */


	SPAPI A_Err	(*AEGP_GetNthLayerContextToRender)(
				const	PR_RenderContextH			render_contextH,	/* >> */
						A_long						n,					/* >> */
						AEGP_RenderLayerContextH	*layer_contextPH);	/* << */

	SPAPI A_Err	(*AEGP_GetLayerFromLayerContext)(
				const	PR_RenderContextH			render_contextH,	/* >> */
						AEGP_RenderLayerContextH	layer_contextH,		/* >> */
						AEGP_LayerH					*layerPH);			/* << */

	/**
	 ** With collapsed geometrics "on" this gives the layer in the root comp
	 ** contining the layer context. With collapsed geometrics off
	 ** this is the same as AEGP_GetLayerFromLayerContext.
	 **
	 **/
	SPAPI A_Err	(*AEGP_GetTopLayerFromLayerContext)(
				const	PR_RenderContextH			render_contextH,
						AEGP_RenderLayerContextH	layer_contextH,
						AEGP_LayerH					*layerPH);

	SPAPI A_Err	(*AEGP_GetCompRenderTime)(
						PR_RenderContextH	render_contextH,	/* >> */
						A_Time				*time,				/* << */
						A_Time				*time_step);

	SPAPI A_Err	(*AEGP_GetCompDestinationBuffer)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_CompH					compH,				/* >> */
						AEGP_WorldH					*dst);				/* << */

	SPAPI A_Err	(*AEGP_GetROI)(
						PR_RenderContextH			render_contextH,	/* <> */
						A_LegacyRect						*roiPR);			/* << */

	// for rendering the texture map of a layer
	SPAPI A_Err	(*AEGP_RenderTexture)(
						PR_RenderContextH			render_contextH,		/* <> */
						AEGP_RenderLayerContextH	layer_contextH,			/* >> */
						AEGP_RenderHints			render_hints,			/* >> */
						A_FloatPoint				*suggested_scaleP0,		/* >> */
						A_FloatRect					*suggested_src_rectP0, 	/* >> */
						A_Matrix3					*src_matrixP0,			/* << */
						AEGP_WorldH					*dstPH);				/* <> */


	SPAPI A_Err	(*AEGP_DisposeTexture)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_RenderLayerContextH	layer_contextH,		/* >> */
						AEGP_WorldH					dstH0);				/* <> */

	SPAPI A_Err	(*AEGP_GetFieldRender)(
						PR_RenderContextH 			render_contextH,   	/* >> */
						PF_Field					*field);			/* << */

	// not thread safe on MacOS
	// only call when thread ID = 0
	SPAPI A_Err	(*AEGP_ReportArtisanProgress)(
					PR_RenderContextH 				render_contextH,   	/* >> */
					A_long							countL,				/* >> */
					A_long							totalL);			/* >> */

	SPAPI A_Err	(*AEGP_GetRenderDownsampleFactor)(
						PR_RenderContextH			render_contextH,	/* >> */
						AEGP_DownsampleFactor		*dsfP);				/* << */

	SPAPI A_Err	(*AEGP_SetRenderDownsampleFactor)(
						PR_RenderContextH			render_contextH,	/* >> */
						AEGP_DownsampleFactor		*dsfP);				/* >> */

	SPAPI A_Err	(*AEGP_IsBlankCanvas)(
						PR_RenderContextH			render_contextH,	/* >> */
						A_Boolean					*is_blankPB);		/* << */

	SPAPI A_Err (*AEGP_GetRenderLayerToWorldXform)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timeP,		/* >> */
					A_Matrix4						*transform);		/* << */

	SPAPI A_Err (*AEGP_GetRenderLayerBounds)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timeP,		/* >> */
					A_LegacyRect							*boundsP);			/* << */

	SPAPI A_Err (*AEGP_GetRenderOpacity)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timePT,		/* >> */
					A_FpLong						*opacityPF);		/* << */

	SPAPI A_Err (*AEGP_IsRenderLayerActive)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timePT,		/* >> */
					A_Boolean						*activePB);			/* << */

	// set the layer index. If total > 0, set it too.
	SPAPI A_Err	(*AEGP_SetArtisanLayerProgress)(
					PR_RenderContextH 				render_contextH,   	/* >> */
					A_long							countL,				/* >> */
					A_long							num_layersL);

	// for track mattes.
	// Returns a comp-size buffer, which must be disposed thru AEGP_Dispose in World suite
	SPAPI A_Err	(*AEGP_RenderLayerPlus)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_LayerH 				layerH,				/* >> */
						AEGP_RenderLayerContextH 	layer_contextH,		/* >> */
						AEGP_RenderHints			render_hints,		/* >> */
						AEGP_WorldH					*render_bufferPH);	/* <<  must be disposed with AEGP_DisposeWorld */


	SPAPI A_Err	(*AEGP_GetTrackMatteContext)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_RenderLayerContextH 	fill_contextH,		/* << */
						AEGP_RenderLayerContextH	*matte_contextPH);	/* >> */

	// new for 6.0 --get receipt with the returned texture
	// use receipt to determine if a subsequent call to render
	// this layer can be skipped (because the artisan cached it)
	SPAPI A_Err	(*AEGP_RenderTextureWithReceipt)(
						PR_RenderContextH			render_contextH,		/* <> */
						AEGP_RenderLayerContextH	layer_contextH,			/* >> */
						AEGP_RenderHints			render_hints,			/* >> */
						A_FloatPoint				*suggested_scaleP0,		/* >> */
						A_FloatRect					*suggested_src_rectP0, 	/* >> */
						A_Matrix3					*src_matrixP0,			/* << */
						AEGP_RenderReceiptH			*render_receiptPH, 	 	/* << must be disposed with AEGP_DisposeRenderReceipt */
						AEGP_WorldH					*dstPH);				/* << */

	SPAPI A_Err	(*AEGP_RenderLayerPlusWithReceipt)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_LayerH 				layerH,				/* >> */
						AEGP_RenderLayerContextH 	layer_contextH,		/* >> */
						AEGP_RenderHints			render_hints,		/* >> */
						AEGP_RenderReceiptH			*render_receiptPH,  /* << must be disposed with AEGP_DisposeRenderReceipt */
						AEGP_WorldH					*render_bufferPH);	/* << */

	SPAPI A_Err	(*AEGP_DisposeRenderReceipt)(
						AEGP_RenderReceiptH			render_receiptH);	/* >> */


	SPAPI A_Err	(*AEGP_CheckRenderReceipt)(
						PR_RenderContextH			current_render_contextH,	/* >> */
						AEGP_RenderLayerContextH	current_layer_contextH,		/* >> */
						AEGP_RenderReceiptH			old_render_receiptH,		/* >> */
						A_Boolean					check_aceB,					/* >> */
						AEGP_RenderReceiptStatus	*receipt_statusP);			/* << */


	SPAPI A_Err	(*AEGP_GetNumBinsToRender)(
				const	PR_RenderContextH	render_contextH,			/* >> */
						A_long				*num_bins_to_renderPL);		/* << */


	SPAPI A_Err	(*AEGP_SetNthBin)(
				const	PR_RenderContextH			render_contextH,	/* >> */
						A_long						n);					/* >> */

	SPAPI A_Err	(*AEGP_GetBinType)(
				const	PR_RenderContextH			render_contextH,	/* >> */
						AEGP_BinType				*bin_typeP);		/* << */

	SPAPI A_Err (*AEGP_GetRenderLayerToWorldXform2D3D)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timeP,		/* >> */
					A_Boolean						only_2dB,			/* >> */
					A_Matrix4						*transform);		/* << */


	// interactive artisan information
	// handle to the on-screen window
	SPAPI A_Err (*AEGP_GetPlatformWindowRef)(
				const PR_RenderContextH				render_contextH,	/* >> */
				AEGP_PlatformWindowRef				*window_refP);		/* << */


	// the dsf src to frame scale factors
	SPAPI A_Err (*AEGP_GetViewportScale)(
				const PR_RenderContextH				render_contextH,	/* >> */
				A_FpLong							*scale_xPF,			/* << */
				A_FpLong							*scale_yPF);		/* << */


	// the dsf src to frame translate
	SPAPI A_Err (*AEGP_GetViewportOrigin)(
				const PR_RenderContextH				render_contextH,	/* >> */
				A_long								*origin_xPL,		/* << */
				A_long								*origin_yPL);		/* << */


	SPAPI A_Err (*AEGP_GetViewportRect)(
				const PR_RenderContextH				render_contextH,	/* >> */
				A_LegacyRect								*viewport_rectPR);	/* << */


	SPAPI A_Err (*AEGP_GetFallowColor)(
				const PR_RenderContextH				render_contextH,	/* >> */
				PF_Pixel8							*fallow_colorP);	/* << */

	SPAPI A_Err (*AEGP_GetInteractiveBuffer)(
				const PR_RenderContextH				render_contextH,	/* >> */
				AEGP_WorldH							*buffer);			/* << */

	SPAPI A_Err (*AEGP_GetInteractiveCheckerboard)(
				const PR_RenderContextH				render_contextH,	/* in */
				A_Boolean							*checkerboard_onPB);/* out */

	SPAPI A_Err (*AEGP_GetInteractiveCheckerboardColors)(
				const PR_RenderContextH				render_contextH,			/* in */
				PF_Pixel							*checkerboard_color1P,		/* out */
				PF_Pixel							*checkerboard_color2P);		/* out */

	SPAPI A_Err (*AEGP_GetInteractiveCheckerboardSize)(
				const PR_RenderContextH				render_contextH,			/* in */
				A_u_long							*checkerboard_widthPLu,		/* out - width of square*/
				A_u_long							*checkerboard_heightPLu);	/* out - height of square*/

	SPAPI A_Err (*AEGP_GetInteractiveCachedBuffer)(
				const PR_RenderContextH				render_contextH,	/* >> */
				AEGP_WorldH							*buffer);			/* << */


	// should we call AEGP_RenderLayer or AEGP_RenderTexture
	SPAPI A_Err (*AEGP_ArtisanMustRenderAsLayer)(
				const PR_RenderContextH				render_contextH,	/* >> */
				AEGP_RenderLayerContextH			layer_contextH,
				A_Boolean							*use_render_texturePB);

} AEGP_CanvasSuite4;



#define kAEGPCanvasSuiteVersion5		10	/* frozen in AE 6.5 */

typedef struct AEGP_CanvasSuite5 {

	SPAPI A_Err	(*AEGP_GetCompToRender)(
						PR_RenderContextH 		render_contextH,   	/* >> */
						AEGP_CompH				*compPH);			/* << */

	SPAPI A_Err	(*AEGP_GetNumLayersToRender)(
				const	PR_RenderContextH	render_contextH,		/* >> */
						A_long				*num_to_renderPL);		/* << */


	SPAPI A_Err	(*AEGP_GetNthLayerContextToRender)(
				const	PR_RenderContextH			render_contextH,	/* >> */
						A_long						n,					/* >> */
						AEGP_RenderLayerContextH	*layer_contextPH);	/* << */

	SPAPI A_Err	(*AEGP_GetLayerFromLayerContext)(
				const	PR_RenderContextH			render_contextH,	/* >> */
						AEGP_RenderLayerContextH	layer_contextH,		/* >> */
						AEGP_LayerH					*layerPH);			/* << */

	/**
	 ** With collapsed geometrics "on" this gives the layer in the root comp
	 ** contining the layer context. With collapsed geometrics off
	 ** this is the same as AEGP_GetLayerFromLayerContext.
	 **
	 **/
	SPAPI A_Err	(*AEGP_GetTopLayerFromLayerContext)(
				const	PR_RenderContextH			render_contextH,
						AEGP_RenderLayerContextH	layer_contextH,
						AEGP_LayerH					*layerPH);

	SPAPI A_Err	(*AEGP_GetCompRenderTime)(
						PR_RenderContextH	render_contextH,	/* >> */
						A_Time				*time,				/* << */
						A_Time				*time_step);

	SPAPI A_Err	(*AEGP_GetCompDestinationBuffer)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_CompH					compH,				/* >> */
						AEGP_WorldH					*dst);				/* << */

	SPAPI A_Err	(*AEGP_GetROI)(
						PR_RenderContextH			render_contextH,	/* <> */
						A_LegacyRect						*roiPR);			/* << */

	// for rendering the texture map of a layer
	SPAPI A_Err	(*AEGP_RenderTexture)(
						PR_RenderContextH			render_contextH,		/* <> */
						AEGP_RenderLayerContextH	layer_contextH,			/* >> */
						AEGP_RenderHints			render_hints,			/* >> */
						A_FloatPoint				*suggested_scaleP0,		/* >> */
						A_FloatRect					*suggested_src_rectP0, 	/* >> */
						A_Matrix3					*src_matrixP0,			/* << */
						AEGP_WorldH					*dstPH);				/* <> */


	SPAPI A_Err	(*AEGP_DisposeTexture)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_RenderLayerContextH	layer_contextH,		/* >> */
						AEGP_WorldH					dstH0);				/* <> */

	SPAPI A_Err	(*AEGP_GetFieldRender)(
						PR_RenderContextH 			render_contextH,   	/* >> */
						PF_Field					*field);			/* << */

	// not thread safe on MacOS
	// only call when thread ID = 0
	SPAPI A_Err	(*AEGP_ReportArtisanProgress)(
					PR_RenderContextH 				render_contextH,   	/* >> */
					A_long							countL,				/* >> */
					A_long							totalL);			/* >> */

	SPAPI A_Err	(*AEGP_GetRenderDownsampleFactor)(
						PR_RenderContextH			render_contextH,	/* >> */
						AEGP_DownsampleFactor		*dsfP);				/* << */

	SPAPI A_Err	(*AEGP_SetRenderDownsampleFactor)(
						PR_RenderContextH			render_contextH,	/* >> */
						AEGP_DownsampleFactor		*dsfP);				/* >> */

	SPAPI A_Err	(*AEGP_IsBlankCanvas)(
						PR_RenderContextH			render_contextH,	/* >> */
						A_Boolean					*is_blankPB);		/* << */

	SPAPI A_Err (*AEGP_GetRenderLayerToWorldXform)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timeP,		/* >> */
					A_Matrix4						*transform);		/* << */

	SPAPI A_Err (*AEGP_GetRenderLayerBounds)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timeP,		/* >> */
					A_LegacyRect							*boundsP);			/* << */

	SPAPI A_Err (*AEGP_GetRenderOpacity)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timePT,		/* >> */
					A_FpLong						*opacityPF);		/* << */

	SPAPI A_Err (*AEGP_IsRenderLayerActive)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timePT,		/* >> */
					A_Boolean						*activePB);			/* << */

	// set the layer index. If total > 0, set it too.
	SPAPI A_Err	(*AEGP_SetArtisanLayerProgress)(
					PR_RenderContextH 				render_contextH,   	/* >> */
					A_long							countL,				/* >> */
					A_long							num_layersL);

	// for track mattes.
	// Returns a comp-size buffer, which must be disposed thru AEGP_Dispose in World suite
	SPAPI A_Err	(*AEGP_RenderLayerPlus)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_LayerH 				layerH,				/* >> */
						AEGP_RenderLayerContextH 	layer_contextH,		/* >> */
						AEGP_RenderHints			render_hints,		/* >> */
						AEGP_WorldH					*render_bufferPH);	/* <<  must be disposed with AEGP_DisposeWorld */


	SPAPI A_Err	(*AEGP_GetTrackMatteContext)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_RenderLayerContextH 	fill_contextH,		/* << */
						AEGP_RenderLayerContextH	*matte_contextPH);	/* >> */

	// new for 6.0 --get receipt with the returned texture
	// use receipt to determine if a subsequent call to render
	// this layer can be skipped (because the artisan cached it)
	SPAPI A_Err	(*AEGP_RenderTextureWithReceipt)(
						PR_RenderContextH			render_contextH,		/* <> */
						AEGP_RenderLayerContextH	layer_contextH,			/* >> */
						AEGP_RenderHints			render_hints,			/* >> */
						A_FloatPoint				*suggested_scaleP0,		/* >> */
						A_FloatRect					*suggested_src_rectP0, 	/* >> */
						A_Matrix3					*src_matrixP0,			/* << */
						AEGP_RenderReceiptH			*render_receiptPH, 	 	/* << must be disposed with AEGP_DisposeRenderReceipt */
						AEGP_WorldH					*dstPH);				/* << */

	SPAPI A_Err	(*AEGP_RenderLayerPlusWithReceipt)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_LayerH 				layerH,				/* >> */
						AEGP_RenderLayerContextH 	layer_contextH,		/* >> */
						AEGP_RenderHints			render_hints,		/* >> */
						AEGP_RenderReceiptH			*render_receiptPH,  /* << must be disposed with AEGP_DisposeRenderReceipt */
						AEGP_WorldH					*render_bufferPH);	/* << */

	SPAPI A_Err	(*AEGP_DisposeRenderReceipt)(
						AEGP_RenderReceiptH			render_receiptH);	/* >> */


	SPAPI A_Err	(*AEGP_CheckRenderReceipt)(
						PR_RenderContextH			current_render_contextH,	/* >> */
						AEGP_RenderLayerContextH	current_layer_contextH,		/* >> */
						AEGP_RenderReceiptH			old_render_receiptH,		/* >> */
						A_Boolean					check_geometricsB,					/* >> */
						AEGP_RenderReceiptStatus	*receipt_statusP);			/* << */


	SPAPI A_Err	(*AEGP_GetNumBinsToRender)(
				const	PR_RenderContextH	render_contextH,			/* >> */
						A_long				*num_bins_to_renderPL);		/* << */


	SPAPI A_Err	(*AEGP_SetNthBin)(
				const	PR_RenderContextH			render_contextH,	/* >> */
						A_long						n);					/* >> */

	SPAPI A_Err	(*AEGP_GetBinType)(
				const	PR_RenderContextH			render_contextH,	/* >> */
						AEGP_BinType				*bin_typeP);		/* << */

	SPAPI A_Err (*AEGP_GetRenderLayerToWorldXform2D3D)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timeP,		/* >> */
					A_Boolean						only_2dB,			/* >> */
					A_Matrix4						*transform);		/* << */


	// interactive artisan information
	// handle to the on-screen window
	SPAPI A_Err (*AEGP_GetPlatformWindowRef)(
				const PR_RenderContextH				render_contextH,	/* >> */
				AEGP_PlatformWindowRef				*window_refP);		/* << */


	// the dsf src to frame scale factors
	SPAPI A_Err (*AEGP_GetViewportScale)(
				const PR_RenderContextH				render_contextH,	/* >> */
				A_FpLong							*scale_xPF,			/* << */
				A_FpLong							*scale_yPF);		/* << */


	// the dsf src to frame translate
	SPAPI A_Err (*AEGP_GetViewportOrigin)(
				const PR_RenderContextH				render_contextH,	/* >> */
				A_long								*origin_xPL,		/* << */
				A_long								*origin_yPL);		/* << */


	SPAPI A_Err (*AEGP_GetViewportRect)(
				const PR_RenderContextH				render_contextH,	/* >> */
				A_LegacyRect								*viewport_rectPR);	/* << */


	SPAPI A_Err (*AEGP_GetFallowColor)(
				const PR_RenderContextH				render_contextH,	/* >> */
				PF_Pixel8							*fallow_colorP);	/* << */

	SPAPI A_Err (*AEGP_GetInteractiveBuffer)(
				const PR_RenderContextH				render_contextH,	/* >> */
				AEGP_WorldH							*buffer);			/* << */

	SPAPI A_Err (*AEGP_GetInteractiveCheckerboard)(
				const PR_RenderContextH				render_contextH,	/* in */
				A_Boolean							*checkerboard_onPB);/* out */

	SPAPI A_Err (*AEGP_GetInteractiveCheckerboardColors)(
				const PR_RenderContextH				render_contextH,			/* in */
				PF_Pixel							*checkerboard_color1P,		/* out */
				PF_Pixel							*checkerboard_color2P);		/* out */

	SPAPI A_Err (*AEGP_GetInteractiveCheckerboardSize)(
				const PR_RenderContextH				render_contextH,			/* in */
				A_u_long							*checkerboard_widthPLu,		/* out - width of square*/
				A_u_long							*checkerboard_heightPLu);	/* out - height of square*/

	SPAPI A_Err (*AEGP_GetInteractiveCachedBuffer)(
				const PR_RenderContextH				render_contextH,	/* >> */
				AEGP_WorldH							*buffer);			/* << */


	// should we call AEGP_RenderLayer or AEGP_RenderTexture
	SPAPI A_Err (*AEGP_ArtisanMustRenderAsLayer)(
				const PR_RenderContextH				render_contextH,	/* >> */
				AEGP_RenderLayerContextH			layer_contextH,
				A_Boolean							*use_render_texturePB);


	SPAPI A_Err (*AEGP_GetInteractiveDisplayChannel)(
				const PR_RenderContextH				render_contextH,	/* >> */
				AEGP_DisplayChannelType				*display_channelP);			/* << */

} AEGP_CanvasSuite5;


#define kAEGPCanvasSuiteVersion6		11	/* frozen in AE 7.0 */

typedef struct AEGP_CanvasSuite6 {

	SPAPI A_Err	(*AEGP_GetCompToRender)(
		PR_RenderContextH 		render_contextH,   	/* >> */
		AEGP_CompH				*compPH);			/* << */

	SPAPI A_Err	(*AEGP_GetNumLayersToRender)(
		const	PR_RenderContextH	render_contextH,		/* >> */
		A_long				*num_to_renderPL);		/* << */


	SPAPI A_Err	(*AEGP_GetNthLayerContextToRender)(
		const	PR_RenderContextH			render_contextH,	/* >> */
		A_long						n,					/* >> */
		AEGP_RenderLayerContextH	*layer_contextPH);	/* << */

	SPAPI A_Err	(*AEGP_GetLayerFromLayerContext)(
		const	PR_RenderContextH			render_contextH,	/* >> */
		AEGP_RenderLayerContextH	layer_contextH,		/* >> */
		AEGP_LayerH					*layerPH);			/* << */

	/**
	** With collapsed geometrics "on" this gives the layer in the root comp
	** contining the layer context. With collapsed geometrics off
	** this is the same as AEGP_GetLayerFromLayerContext.
	**
	**/
	SPAPI A_Err	(*AEGP_GetTopLayerFromLayerContext)(
		const	PR_RenderContextH			render_contextH,
		AEGP_RenderLayerContextH	layer_contextH,
		AEGP_LayerH					*layerPH);

	SPAPI A_Err	(*AEGP_GetCompRenderTime)(
		PR_RenderContextH	render_contextH,	/* >> */
		A_Time				*time,				/* << */
		A_Time				*time_step);

	SPAPI A_Err	(*AEGP_GetCompDestinationBuffer)(
		PR_RenderContextH			render_contextH,	/* <> */
		AEGP_CompH					compH,				/* >> */
		AEGP_WorldH					*dst);				/* << */

	SPAPI A_Err	(*AEGP_GetROI)(
		PR_RenderContextH			render_contextH,	/* <> */
		A_LegacyRect						*roiPR);			/* << */

	// for rendering the texture map of a layer
	SPAPI A_Err	(*AEGP_RenderTexture)(
		PR_RenderContextH			render_contextH,		/* <> */
		AEGP_RenderLayerContextH	layer_contextH,			/* >> */
		AEGP_RenderHints			render_hints,			/* >> */
		A_FloatPoint				*suggested_scaleP0,		/* >> */
		A_FloatRect					*suggested_src_rectP0, 	/* >> */
		A_Matrix3					*src_matrixP0,			/* << */
		AEGP_WorldH					*dstPH);				/* <> */


	SPAPI A_Err	(*AEGP_DisposeTexture)(
		PR_RenderContextH			render_contextH,	/* <> */
		AEGP_RenderLayerContextH	layer_contextH,		/* >> */
		AEGP_WorldH					dstH0);				/* <> */

	SPAPI A_Err	(*AEGP_GetFieldRender)(
		PR_RenderContextH 			render_contextH,   	/* >> */
		PF_Field					*field);			/* << */

	// not thread safe on MacOS
	// only call when thread ID = 0
	SPAPI A_Err	(*AEGP_ReportArtisanProgress)(
		PR_RenderContextH 				render_contextH,   	/* >> */
		A_long							countL,				/* >> */
		A_long							totalL);			/* >> */

	SPAPI A_Err	(*AEGP_GetRenderDownsampleFactor)(
		PR_RenderContextH			render_contextH,	/* >> */
		AEGP_DownsampleFactor		*dsfP);				/* << */

	SPAPI A_Err	(*AEGP_SetRenderDownsampleFactor)(
		PR_RenderContextH			render_contextH,	/* >> */
		AEGP_DownsampleFactor		*dsfP);				/* >> */

	SPAPI A_Err	(*AEGP_IsBlankCanvas)(
		PR_RenderContextH			render_contextH,	/* >> */
		A_Boolean					*is_blankPB);		/* << */

	SPAPI A_Err (*AEGP_GetRenderLayerToWorldXform)(
		PR_RenderContextH				render_contextH,	/* >> */
		AEGP_RenderLayerContextH		layer_contextH,		/* >> */
		const A_Time					*comp_timeP,		/* >> */
		A_Matrix4						*transform);		/* << */

	SPAPI A_Err (*AEGP_GetRenderLayerBounds)(
		PR_RenderContextH				render_contextH,	/* >> */
		AEGP_RenderLayerContextH		layer_contextH,		/* >> */
		const A_Time					*comp_timeP,		/* >> */
		A_LegacyRect							*boundsP);			/* << */

	SPAPI A_Err (*AEGP_GetRenderOpacity)(
		PR_RenderContextH				render_contextH,	/* >> */
		AEGP_RenderLayerContextH		layer_contextH,		/* >> */
		const A_Time					*comp_timePT,		/* >> */
		A_FpLong						*opacityPF);		/* << */

	SPAPI A_Err (*AEGP_IsRenderLayerActive)(
		PR_RenderContextH				render_contextH,	/* >> */
		AEGP_RenderLayerContextH		layer_contextH,		/* >> */
		const A_Time					*comp_timePT,		/* >> */
		A_Boolean						*activePB);			/* << */

	// set the layer index. If total > 0, set it too.
	SPAPI A_Err	(*AEGP_SetArtisanLayerProgress)(
		PR_RenderContextH 				render_contextH,   	/* >> */
		A_long							countL,				/* >> */
		A_long							num_layersL);

	// for track mattes.
	// Returns a comp-size buffer, which must be disposed thru AEGP_Dispose in World suite
	SPAPI A_Err	(*AEGP_RenderLayerPlus)(
		PR_RenderContextH			render_contextH,	/* <> */
		AEGP_LayerH 				layerH,				/* >> */
		AEGP_RenderLayerContextH 	layer_contextH,		/* >> */
		AEGP_RenderHints			render_hints,		/* >> */
		AEGP_WorldH					*render_bufferPH);	/* <<  must be disposed with AEGP_DisposeWorld */


	SPAPI A_Err	(*AEGP_GetTrackMatteContext)(
		PR_RenderContextH			render_contextH,	/* <> */
		AEGP_RenderLayerContextH 	fill_contextH,		/* << */
		AEGP_RenderLayerContextH	*matte_contextPH);	/* >> */

	// new for 6.0 --get receipt with the returned texture
	// use receipt to determine if a subsequent call to render
	// this layer can be skipped (because the artisan cached it)
	SPAPI A_Err	(*AEGP_RenderTextureWithReceipt)(
		PR_RenderContextH			render_contextH,		/* <> */
		AEGP_RenderLayerContextH	layer_contextH,			/* >> */
		AEGP_RenderHints			render_hints,			/* >> */
		AEGP_NumEffectsToRenderType	num_effectsS,			/* >>  number of effect to render, -1 for all */
		A_FloatPoint				*suggested_scaleP0,		/* >> */
		A_FloatRect					*suggested_src_rectP0, 	/* >> */
		A_Matrix3					*src_matrixP0,			/* << */
		AEGP_RenderReceiptH			*render_receiptPH, 	 	/* << must be disposed with AEGP_DisposeRenderReceipt */
		AEGP_WorldH					*dstPH);				/* << */



	SPAPI A_Err	(*AEGP_GetNumberOfSoftwareEffects)(
		PR_RenderContextH			render_contextH,		/* <> */
		AEGP_RenderLayerContextH	layer_contextH,			/* >> */
		A_short						*num_software_effectsPS);

	SPAPI A_Err	(*AEGP_RenderLayerPlusWithReceipt)(
		PR_RenderContextH			render_contextH,	/* <> */
		AEGP_LayerH 				layerH,				/* >> */
		AEGP_RenderLayerContextH 	layer_contextH,		/* >> */
		AEGP_RenderHints			render_hints,		/* >> */
		AEGP_RenderReceiptH			*render_receiptPH,  /* << must be disposed with AEGP_DisposeRenderReceipt */
		AEGP_WorldH					*render_bufferPH);	/* << */

	SPAPI A_Err	(*AEGP_DisposeRenderReceipt)(
		AEGP_RenderReceiptH			render_receiptH);	/* >> */


	/* modified for 7.0 - added num_effects to check against */
	SPAPI A_Err	(*AEGP_CheckRenderReceipt)(
		PR_RenderContextH			current_render_contextH,	/* in */
		AEGP_RenderLayerContextH	current_layer_contextH,		/* in */
		AEGP_RenderReceiptH			old_render_receiptH,		/* in */
		A_Boolean					check_geometricsB,			/* in */
		AEGP_NumEffectsToRenderType	num_effectsS,				/* in */
		AEGP_RenderReceiptStatus	*receipt_statusP);			/* out */


	/* new in 7.0 generate a receipt for a layer as asd if the first num_effectsS have been rendered */
	SPAPI A_Err	(*AEGP_GenerateRenderReceipt)(
		PR_RenderContextH			current_render_contextH,	/* >> */
		AEGP_RenderLayerContextH	current_layer_contextH,		/* >> */
		AEGP_NumEffectsToRenderType	num_effectsS,				/* in */
		AEGP_RenderReceiptH			*render_receiptPH);			/* << */

	SPAPI A_Err	(*AEGP_GetNumBinsToRender)(
		const	PR_RenderContextH	render_contextH,			/* >> */
		A_long				*num_bins_to_renderPL);		/* << */


	SPAPI A_Err	(*AEGP_SetNthBin)(
		const	PR_RenderContextH			render_contextH,	/* >> */
		A_long						n);					/* >> */

	SPAPI A_Err	(*AEGP_GetBinType)(
		const	PR_RenderContextH			render_contextH,	/* >> */
		AEGP_BinType				*bin_typeP);		/* << */

	SPAPI A_Err (*AEGP_GetRenderLayerToWorldXform2D3D)(
		PR_RenderContextH				render_contextH,	/* >> */
		AEGP_RenderLayerContextH		layer_contextH,		/* >> */
		const A_Time					*comp_timeP,		/* >> */
		A_Boolean						only_2dB,			/* >> */
		A_Matrix4						*transform);		/* << */


	// interactive artisan information
	// handle to the on-screen window
	SPAPI A_Err (*AEGP_GetPlatformWindowRef)(
		const PR_RenderContextH				render_contextH,	/* >> */
		AEGP_PlatformWindowRef				*window_refP);		/* << */


	// the dsf src to frame scale factors
	SPAPI A_Err (*AEGP_GetViewportScale)(
		const PR_RenderContextH				render_contextH,	/* >> */
		A_FpLong							*scale_xPF,			/* << */
		A_FpLong							*scale_yPF);		/* << */


	// the dsf src to frame translate
	SPAPI A_Err (*AEGP_GetViewportOrigin)(
		const PR_RenderContextH				render_contextH,	/* >> */
		A_long								*origin_xPL,		/* << */
		A_long								*origin_yPL);		/* << */


	SPAPI A_Err (*AEGP_GetViewportRect)(
		const PR_RenderContextH				render_contextH,	/* >> */
		A_LegacyRect								*viewport_rectPR);	/* << */


	SPAPI A_Err (*AEGP_GetFallowColor)(
		const PR_RenderContextH				render_contextH,	/* >> */
		PF_Pixel8							*fallow_colorP);	/* << */

	SPAPI A_Err (*AEGP_GetInteractiveBuffer)(
		const PR_RenderContextH				render_contextH,	/* >> */
		AEGP_WorldH							*buffer);			/* << */

	SPAPI A_Err (*AEGP_GetInteractiveCheckerboard)(
		const PR_RenderContextH				render_contextH,	/* in */
		A_Boolean							*checkerboard_onPB);/* out */

	SPAPI A_Err (*AEGP_GetInteractiveCheckerboardColors)(
		const PR_RenderContextH				render_contextH,			/* in */
		PF_Pixel							*checkerboard_color1P,		/* out */
		PF_Pixel							*checkerboard_color2P);		/* out */

	SPAPI A_Err (*AEGP_GetInteractiveCheckerboardSize)(
		const PR_RenderContextH				render_contextH,			/* in */
		A_u_long							*checkerboard_widthPLu,		/* out - width of square*/
		A_u_long							*checkerboard_heightPLu);	/* out - height of square*/

	SPAPI A_Err (*AEGP_GetInteractiveCachedBuffer)(
		const PR_RenderContextH				render_contextH,	/* >> */
		AEGP_WorldH							*buffer);			/* << */


	// should we call AEGP_RenderLayer or AEGP_RenderTexture
	SPAPI A_Err (*AEGP_ArtisanMustRenderAsLayer)(
		const PR_RenderContextH				render_contextH,	/* >> */
		AEGP_RenderLayerContextH			layer_contextH,
		A_Boolean							*use_render_texturePB);


	SPAPI A_Err (*AEGP_GetInteractiveDisplayChannel)(
		const PR_RenderContextH				render_contextH,	/* >> */
		AEGP_DisplayChannelType				*display_channelP);			/* << */


} AEGP_CanvasSuite6;



#define kAEGPCanvasSuiteVersion7		13	/* frozen in AE 8.0, source code-compatible additions in 64-bit AE 10.0*/

typedef struct AEGP_CanvasSuite7 {

	SPAPI A_Err	(*AEGP_GetCompToRender)(
						PR_RenderContextH 		render_contextH,   	/* >> */
						AEGP_CompH				*compPH);			/* << */

	SPAPI A_Err	(*AEGP_GetNumLayersToRender)(
				const	PR_RenderContextH	render_contextH,		/* >> */
						A_long				*num_to_renderPL);		/* << */


	SPAPI A_Err	(*AEGP_GetNthLayerContextToRender)(
				const	PR_RenderContextH			render_contextH,	/* >> */
						A_long						n,					/* >> */
						AEGP_RenderLayerContextH	*layer_contextPH);	/* << */

	SPAPI A_Err	(*AEGP_GetLayerFromLayerContext)(
				const	PR_RenderContextH			render_contextH,	/* >> */
						AEGP_RenderLayerContextH	layer_contextH,		/* >> */
						AEGP_LayerH					*layerPH);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerAndSubLayerFromLayerContext)(
				const	PR_RenderContextH			render_contextH,	/* >> */
						AEGP_RenderLayerContextH	layer_contextH,		/* >> */
						AEGP_LayerH					*layerPH,			/* << */
						AEGP_SubLayerIndex			*sublayerP);		/* << */

	/**
	 ** With collapsed geometrics "on" this gives the layer in the root comp
	 ** contining the layer context. With collapsed geometrics off
	 ** this is the same as AEGP_GetLayerFromLayerContext.
	 **
	 **/
	SPAPI A_Err	(*AEGP_GetTopLayerFromLayerContext)(
				const	PR_RenderContextH			render_contextH,
						AEGP_RenderLayerContextH	layer_contextH,
						AEGP_LayerH					*layerPH);

	SPAPI A_Err	(*AEGP_GetCompRenderTime)(
						PR_RenderContextH	render_contextH,	/* >> */
						A_Time				*time,				/* << */
						A_Time				*time_step);

	SPAPI A_Err	(*AEGP_GetCompDestinationBuffer)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_CompH					compH,				/* >> */
						AEGP_WorldH					*dst);				/* << */

	SPAPI A_Err	(*AEGP_GetROI)(
						PR_RenderContextH			render_contextH,	/* <> */
						A_LegacyRect						*roiPR);			/* << */

	// for rendering the texture map of a layer
	SPAPI A_Err	(*AEGP_RenderTexture)(
						PR_RenderContextH			render_contextH,		/* <> */
						AEGP_RenderLayerContextH	layer_contextH,			/* >> */
						AEGP_RenderHints			render_hints,			/* >> */
						A_FloatPoint				*suggested_scaleP0,		/* >> */
						A_FloatRect					*suggested_src_rectP0, 	/* >> */
						A_Matrix3					*src_matrixP0,			/* << */
						AEGP_WorldH					*dstPH);				/* <> */


	SPAPI A_Err	(*AEGP_DisposeTexture)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_RenderLayerContextH	layer_contextH,		/* >> */
						AEGP_WorldH					dstH0);				/* <> */

	SPAPI A_Err	(*AEGP_GetFieldRender)(
						PR_RenderContextH 			render_contextH,   	/* >> */
						PF_Field					*field);			/* << */

	// not thread safe on MacOS
	// only call when thread ID = 0
	SPAPI A_Err	(*AEGP_ReportArtisanProgress)(
					PR_RenderContextH 				render_contextH,   	/* >> */
					A_long							countL,				/* >> */
					A_long							totalL);			/* >> */

	SPAPI A_Err	(*AEGP_GetRenderDownsampleFactor)(
						PR_RenderContextH			render_contextH,	/* >> */
						AEGP_DownsampleFactor		*dsfP);				/* << */

	SPAPI A_Err	(*AEGP_SetRenderDownsampleFactor)(
						PR_RenderContextH			render_contextH,	/* >> */
						AEGP_DownsampleFactor		*dsfP);				/* >> */

	SPAPI A_Err	(*AEGP_IsBlankCanvas)(
						PR_RenderContextH			render_contextH,	/* >> */
						A_Boolean					*is_blankPB);		/* << */

	SPAPI A_Err (*AEGP_GetRenderLayerToWorldXform)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timeP,		/* >> */
					A_Matrix4						*transform);		/* << */

	SPAPI A_Err (*AEGP_GetRenderLayerBounds)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timeP,		/* >> */
					A_LegacyRect							*boundsP);			/* << */

	SPAPI A_Err (*AEGP_GetRenderOpacity)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timePT,		/* >> */
					A_FpLong						*opacityPF);		/* << */

	SPAPI A_Err (*AEGP_IsRenderLayerActive)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timePT,		/* >> */
					A_Boolean						*activePB);			/* << */

	// set the layer index. If total > 0, set it too.
	SPAPI A_Err	(*AEGP_SetArtisanLayerProgress)(
					PR_RenderContextH 				render_contextH,   	/* >> */
					A_long							countL,				/* >> */
					A_long							num_layersL);

	// for track mattes.
	// Returns a comp-size buffer, which must be disposed thru AEGP_Dispose in World suite
	SPAPI A_Err	(*AEGP_RenderLayerPlus)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_LayerH 				layerH,				/* >> */
						AEGP_RenderLayerContextH 	layer_contextH,		/* >> */
						AEGP_RenderHints			render_hints,		/* >> */
						AEGP_WorldH					*render_bufferPH);	/* <<  must be disposed with AEGP_DisposeWorld */


	SPAPI A_Err	(*AEGP_GetTrackMatteContext)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_RenderLayerContextH 	fill_contextH,		/* << */
						AEGP_RenderLayerContextH	*matte_contextPH);	/* >> */

	// new for 6.0 --get receipt with the returned texture
	// use receipt to determine if a subsequent call to render
	// this layer can be skipped (because the artisan cached it)
	SPAPI A_Err	(*AEGP_RenderTextureWithReceipt)(
						PR_RenderContextH			render_contextH,		/* <> */
						AEGP_RenderLayerContextH	layer_contextH,			/* >> */
						AEGP_RenderHints			render_hints,			/* >> */
						AEGP_NumEffectsToRenderType	num_effectsS,			/* >>  number of effect to render, -1 for all */
						A_FloatPoint				*suggested_scaleP0,		/* >> */
						A_FloatRect					*suggested_src_rectP0, 	/* >> */
						A_Matrix3					*src_matrixP0,			/* << */
						AEGP_RenderReceiptH			*render_receiptPH, 	 	/* << must be disposed with AEGP_DisposeRenderReceipt */
						AEGP_WorldH					*dstPH);				/* << */



	SPAPI A_Err	(*AEGP_GetNumberOfSoftwareEffects)(
						PR_RenderContextH			render_contextH,		/* <> */
						AEGP_RenderLayerContextH	layer_contextH,			/* >> */
						A_short						*num_software_effectsPS);

	SPAPI A_Err	(*AEGP_RenderLayerPlusWithReceipt)(
						PR_RenderContextH			render_contextH,	/* <> */
						AEGP_LayerH 				layerH,				/* >> */
						AEGP_RenderLayerContextH 	layer_contextH,		/* >> */
						AEGP_RenderHints			render_hints,		/* >> */
						AEGP_RenderReceiptH			*render_receiptPH,  /* << must be disposed with AEGP_DisposeRenderReceipt */
						AEGP_WorldH					*render_bufferPH);	/* << */

	SPAPI A_Err	(*AEGP_DisposeRenderReceipt)(
						AEGP_RenderReceiptH			render_receiptH);	/* >> */


	/* modified for 7.0 - added num_effects to check against */
	SPAPI A_Err	(*AEGP_CheckRenderReceipt)(
						PR_RenderContextH			current_render_contextH,	/* in */
						AEGP_RenderLayerContextH	current_layer_contextH,		/* in */
						AEGP_RenderReceiptH			old_render_receiptH,		/* in */
						A_Boolean					check_geometricsB,			/* in */
						AEGP_NumEffectsToRenderType	num_effectsS,				/* in */
						AEGP_RenderReceiptStatus	*receipt_statusP);			/* out */


	/* new in 7.0 generate a receipt for a layer as asd if the first num_effectsS have been rendered */
	SPAPI A_Err	(*AEGP_GenerateRenderReceipt)(
						PR_RenderContextH			current_render_contextH,	/* >> */
						AEGP_RenderLayerContextH	current_layer_contextH,		/* >> */
						AEGP_NumEffectsToRenderType	num_effectsS,				/* in */
						AEGP_RenderReceiptH			*render_receiptPH);			/* << */

	SPAPI A_Err	(*AEGP_GetNumBinsToRender)(
				const	PR_RenderContextH	render_contextH,			/* >> */
						A_long				*num_bins_to_renderPL);		/* << */


	SPAPI A_Err	(*AEGP_SetNthBin)(
				const	PR_RenderContextH			render_contextH,	/* >> */
						A_long						n);					/* >> */

	SPAPI A_Err	(*AEGP_GetBinType)(
				const	PR_RenderContextH			render_contextH,	/* >> */
						AEGP_BinType				*bin_typeP);		/* << */

	SPAPI A_Err (*AEGP_GetRenderLayerToWorldXform2D3D)(
					PR_RenderContextH				render_contextH,	/* >> */
					AEGP_RenderLayerContextH		layer_contextH,		/* >> */
					const A_Time					*comp_timeP,		/* >> */
					A_Boolean						only_2dB,			/* >> */
					A_Matrix4						*transform);		/* << */


	// interactive artisan information
	// handle to the on-screen window
	SPAPI A_Err (*AEGP_GetPlatformWindowRef)(
				const PR_RenderContextH				render_contextH,	/* >> */
				AEGP_PlatformWindowRef				*window_refP);		/* << */


	// the dsf src to frame scale factors
	SPAPI A_Err (*AEGP_GetViewportScale)(
				const PR_RenderContextH				render_contextH,	/* >> */
				A_FpLong							*scale_xPF,			/* << */
				A_FpLong							*scale_yPF);		/* << */


	// the dsf src to frame translate
	SPAPI A_Err (*AEGP_GetViewportOrigin)(
				const PR_RenderContextH				render_contextH,	/* >> */
				A_long								*origin_xPL,		/* << */
				A_long								*origin_yPL);		/* << */


	SPAPI A_Err (*AEGP_GetViewportRect)(
				const PR_RenderContextH				render_contextH,	/* >> */
				A_LegacyRect								*viewport_rectPR);	/* << */


	SPAPI A_Err (*AEGP_GetFallowColor)(
				const PR_RenderContextH				render_contextH,	/* >> */
				PF_Pixel8							*fallow_colorP);	/* << */

	SPAPI A_Err (*AEGP_GetInteractiveBuffer)(
				const PR_RenderContextH				render_contextH,	/* >> */
				AEGP_WorldH							*buffer);			/* << */

	SPAPI A_Err (*AEGP_GetInteractiveCheckerboard)(
				const PR_RenderContextH				render_contextH,	/* in */
				A_Boolean							*checkerboard_onPB);/* out */

	SPAPI A_Err (*AEGP_GetInteractiveCheckerboardColors)(
				const PR_RenderContextH				render_contextH,			/* in */
				PF_Pixel							*checkerboard_color1P,		/* out */
				PF_Pixel							*checkerboard_color2P);		/* out */

	SPAPI A_Err (*AEGP_GetInteractiveCheckerboardSize)(
				const PR_RenderContextH				render_contextH,			/* in */
				A_u_long							*checkerboard_widthPLu,		/* out - width of square*/
				A_u_long							*checkerboard_heightPLu);	/* out - height of square*/

	SPAPI A_Err (*AEGP_GetInteractiveCachedBuffer)(
				const PR_RenderContextH				render_contextH,			/* >> */
				AEGP_WorldH							*buffer);					/* << */


	// should we call AEGP_RenderLayer or AEGP_RenderTexture
	SPAPI A_Err (*AEGP_ArtisanMustRenderAsLayer)(
				const PR_RenderContextH				render_contextH,			/* >> */
				AEGP_RenderLayerContextH			layer_contextH,
				A_Boolean							*use_render_texturePB);


	SPAPI A_Err (*AEGP_GetInteractiveDisplayChannel)(
				const PR_RenderContextH				render_contextH,			/* >> */
				AEGP_DisplayChannelType				*display_channelP);			/* << */

	SPAPI A_Err (*AEGP_GetInteractiveExposure)(
				const PR_RenderContextH				render_contextH,			/* >> */
				A_FpLong							*exposurePF);				/* << */


	SPAPI A_Err (*AEGP_GetColorTransform)(
				const PR_RenderContextH				render_contextH,	/* >> */
				A_Boolean							*cms_onB,
				A_u_long							*xform_keyLu,
				void								*xformP);


	SPAPI A_Err	(*AEGP_GetCompShutterTime)(
						PR_RenderContextH	render_contextH,	/* >> */
						A_Time				*shutter_time,		/* << */
						A_Time				*shutter_dur);

} AEGP_CanvasSuite7;




#define kAEGPMaskOutlineSuite				"AEGP Mask Outline Suite"
#define kAEGPMaskOutlineSuiteVersion2		3 /* frozen in AE 5.5 */

typedef struct AEGP_MaskOutlineSuite2 {

	SPAPI A_Err	(*AEGP_IsMaskOutlineOpen)(
						AEGP_MaskOutlineValH		mask_outlineH,		/* >> */
						A_Boolean					*openPB);			/* << */

	SPAPI A_Err (*AEGP_SetMaskOutlineOpen)(
						AEGP_MaskOutlineValH		mask_outlineH,		/* >> */
						A_Boolean					openB);				/* >> */

	// N segments means there are segments [0..N-1]; segment J is defined by vertex J & J+1
	SPAPI A_Err	(*AEGP_GetMaskOutlineNumSegments)(
						AEGP_MaskOutlineValH		mask_outlineH,		/* >> */
						A_long						*num_segmentsPL);	/* << */

	// which_pointL range: [0..num_segments]; for closed masks vertex[0] == vertex[num_segments]
	SPAPI A_Err	(*AEGP_GetMaskOutlineVertexInfo)(
						AEGP_MaskOutlineValH		mask_outlineH,		/* >> */
						AEGP_VertexIndex			which_pointL,		/* >> */
						AEGP_MaskVertex				*vertexP);			/* << tangents are relative to position */

	// Setting vertex 0 is special. Its in tangent will actually set the out tangent
	// of the last vertex in the outline.
	SPAPI A_Err	(*AEGP_SetMaskOutlineVertexInfo)(
						AEGP_MaskOutlineValH		mask_outlineH,		/* >> */
						AEGP_VertexIndex			which_pointL,		/* >> must already exists (use Create) */
						const AEGP_MaskVertex		*vertexP);			/* >> tangents are relative to position */

	SPAPI A_Err (*AEGP_CreateVertex)(
						AEGP_MaskOutlineValH	mask_outlineH,			/* >> */
						AEGP_VertexIndex		insert_position);		/* >> will insert at this index. moving other verticies index++*/

	SPAPI A_Err (*AEGP_DeleteVertex)(
						AEGP_MaskOutlineValH	mask_outlineH,			/* >> */
						AEGP_VertexIndex		index);					/* >> */

} AEGP_MaskOutlineSuite2;

#define kAEGPMaskOutlineSuiteVersion1		2 /* frozen in AE 5.0 */

typedef struct AEGP_MaskOutlineSuite1 {

	SPAPI A_Err	(*AEGP_IsMaskOutlineOpen)(
						AEGP_MaskOutlineValH		mask_outlineH,		/* >> */
						A_Boolean					*openPB);			/* << */

	// N segments means there are segments [0..N-1]; segment J is defined by vertex J & J+1
	SPAPI A_Err	(*AEGP_GetMaskOutlineNumSegments)(
						AEGP_MaskOutlineValH		mask_outlineH,		/* >> */
						A_long						*num_segmentsPL);	/* << */

	// which_pointL range: [0..num_segments]; for closed masks vertex[0] == vertex[num_segments]
	SPAPI A_Err	(*AEGP_GetMaskOutlineVertexInfo)(
						AEGP_MaskOutlineValH		mask_outlineH,		/* >> */
						AEGP_VertexIndex			which_pointL,		/* >> */
						AEGP_MaskVertex				*vertexP);			/* << tangents are relative to position */

	// Setting vertex 0 is special. Its in tangent will actually set the out tangent
	// of the last vertex in the outline.
	SPAPI A_Err	(*AEGP_SetMaskOutlineVertexInfo)(
						AEGP_MaskOutlineValH		mask_outlineH,		/* >> */
						AEGP_VertexIndex			which_pointL,		/* >> must already exists (use Create) */
						const AEGP_MaskVertex				*vertexP);	/* >> tangents are relative to position */

	SPAPI A_Err (*AEGP_CreateVertex)(
						AEGP_MaskOutlineValH	mask_outlineH,			/* >> */
						AEGP_VertexIndex		insert_position);		/* >> will insert at this index. moving other verticies index++*/

	SPAPI A_Err (*AEGP_DeleteVertex)(
						AEGP_MaskOutlineValH	mask_outlineH,			/* >> */
						AEGP_VertexIndex		index);					/* >> */

} AEGP_MaskOutlineSuite1;


#define kAEGPCompSuite				"AEGP Comp Suite"
#define kAEGPCompSuiteVersion10		21 /* frozen in AE 12 */

typedef struct AEGP_CompSuite10 {
	
	SPAPI A_Err	(*AEGP_GetCompFromItem)(							// error if item isn't AEGP_ItemType_COMP!
										AEGP_ItemH 			itemH,					/* >> */
										AEGP_CompH			*compPH);				/* << */
	
	SPAPI A_Err	(*AEGP_GetItemFromComp)(
										AEGP_CompH			compH,					/* >> */
										AEGP_ItemH 			*itemPH);				/* << */
	
	SPAPI A_Err	(*AEGP_GetCompDownsampleFactor)(
												AEGP_CompH				compH,				/* >> */
												AEGP_DownsampleFactor	*dsfP);				/* << */
	
	SPAPI A_Err	(*AEGP_SetCompDownsampleFactor)(
												AEGP_CompH					compH,			/* <> */
												const AEGP_DownsampleFactor	*dsfP);			/* >> */
	
	SPAPI A_Err	(*AEGP_GetCompBGColor)(
									   AEGP_CompH			compH,					/* >> */
									   AEGP_ColorVal		*bg_colorP);			/* << */
	
	SPAPI A_Err (*AEGP_SetCompBGColor)(
									   AEGP_CompH				compH,				/* >> */
									   const AEGP_ColorVal		*bg_colorP);		/* >> */
	
	SPAPI A_Err	(*AEGP_GetCompFlags)(
									 AEGP_CompH			compH,					/* >> */
									 AEGP_CompFlags		*comp_flagsP);			/* << */
	
	/*Opens the comp*/
	SPAPI A_Err	(*AEGP_GetShowLayerNameOrSourceName)(
													 AEGP_CompH 				compH,					/* >> */
													 A_Boolean				*layer_names_shownPB);	/* << true if layer names, false if source names */
	
	/*Opens the comp*/
	SPAPI A_Err	(*AEGP_SetShowLayerNameOrSourceName)(
													 AEGP_CompH 				compH,					/* >> */
													 A_Boolean				show_layer_namesB);		/* >> true to show layer names, false to show source names */
	
	/*Opens the comp*/
	SPAPI A_Err	(*AEGP_GetShowBlendModes)(
										  AEGP_CompH 				compH,					/* >> */
										  A_Boolean				*blend_modes_shownPB);	/* << */
	
	/*Opens the comp*/
	SPAPI A_Err	(*AEGP_SetShowBlendModes)(
										  AEGP_CompH 				compH,					/* >> */
										  A_Boolean				show_blend_modesB);		/* << */
	
	SPAPI A_Err	(*AEGP_GetCompFramerate)(
										 AEGP_CompH			compH,					/* >> */
										 A_FpLong			*fpsPF);				/* << */
	
	SPAPI A_Err (*AEGP_SetCompFrameRate)(
										 AEGP_CompH			compH,					/* >> */
										 const A_FpLong		*fpsPF);				/* >> */
	
	SPAPI A_Err	(*AEGP_GetCompShutterAnglePhase)(
												 AEGP_CompH			compH,					/* >> */
												 A_Ratio				*angle,					/* << */
												 A_Ratio				*phase);				/* << */
	
	SPAPI A_Err	(*AEGP_GetCompShutterFrameRange)(
												 AEGP_CompH			compH,					/* >> */
												 const A_Time		*comp_timeP,			/* >> */
												 A_Time				*start,					/* << */
												 A_Time				*duration);				/* << */
	
	SPAPI A_Err	(*AEGP_GetCompSuggestedMotionBlurSamples)(
														  AEGP_CompH			compH,					/* >> */
														  A_long				*samplesPL);			/* << */
	
	SPAPI A_Err	(*AEGP_SetCompSuggestedMotionBlurSamples)(			/* UNDOABLE */
														  AEGP_CompH			compH,					/* >> */
														  A_long				samplesL);				/* >> */
	
	SPAPI A_Err	(*AEGP_GetCompMotionBlurAdaptiveSampleLimit)(
															 AEGP_CompH			compH,					/* >> */
															 A_long				*samplesPL);			/* << */
	
	SPAPI A_Err	(*AEGP_SetCompMotionBlurAdaptiveSampleLimit)(			/* UNDOABLE */
															 AEGP_CompH			compH,					/* >> */
															 A_long				samplesL);				/* >> */
	
	SPAPI A_Err	(*AEGP_GetCompWorkAreaStart)(
											 AEGP_CompH			compH,					/* >> */
											 A_Time 				*work_area_startPT);	/* << */
	
	SPAPI A_Err	(*AEGP_GetCompWorkAreaDuration)(
												AEGP_CompH			compH,					/* >> */
												A_Time 				*work_area_durationPT);	/* << */
	
	SPAPI A_Err	(*AEGP_SetCompWorkAreaStartAndDuration)(			/* UNDOABLE */
														AEGP_CompH			compH,					/* >> */
														const A_Time 		*work_area_startPT,		/* >> */
														const A_Time 		*work_area_durationPT);	/* >> */
	
	SPAPI A_Err (*AEGP_CreateSolidInComp)(
										  const A_UTF16Char		*utf_nameZ,			/* >> */
										  A_long				width,					/* >> */
										  A_long				height,					/* >> */
										  const AEGP_ColorVal	*color,					/* >> */
										  AEGP_CompH			parent_compH,			/* >> */
										  const A_Time		*durationPT0,			/* >> */
										  AEGP_LayerH			*new_solidPH);			/* << */
	
	SPAPI A_Err (*AEGP_CreateCameraInComp)(
										   const A_UTF16Char		*utf_nameZ,			/* >> */
										   A_FloatPoint		center_point,			/* >> */
										   AEGP_CompH			parent_compH,			/* >> */
										   AEGP_LayerH			*new_cameraPH);			/* << */
	
	SPAPI A_Err (*AEGP_CreateLightInComp)(
										  const A_UTF16Char		*utf_nameZ,			/* >> */
										  A_FloatPoint		center_point,			/* >> */
										  AEGP_CompH			parent_compH,			/* >> */
										  AEGP_LayerH			*new_lightPH);			/* << */
	
	SPAPI A_Err (*AEGP_CreateComp)(
								   AEGP_ItemH			parent_folderH0,		/* >> */
								   const A_UTF16Char		*utf_nameZ,			/* >> */
								   A_long				widthL,					/* >> */
								   A_long				heightL,				/* >> */
								   const A_Ratio		*pixel_aspect_ratioPRt,	/* >> */
								   const A_Time		*durationPT,			/* >> */
								   const A_Ratio		*frameratePRt,			/* >> */
								   AEGP_CompH			*new_compPH);			/* << */
	
	SPAPI A_Err	(*AEGP_GetNewCollectionFromCompSelection)(
														  AEGP_PluginID		plugin_id,				/* >> */
														  AEGP_CompH			compH,					/* >> */
														  AEGP_Collection2H	*collectionPH);			/* << */
	
	SPAPI A_Err (*AEGP_SetSelection)(
									 AEGP_CompH			compH,					/* >> */
									 AEGP_Collection2H	collectionH);			/* >> not adopted */
	
	SPAPI A_Err (*AEGP_GetCompDisplayStartTime)(
												AEGP_CompH			compH,					/* >> */
												A_Time				*start_timePT);			/* << */
	
	SPAPI A_Err (*AEGP_SetCompDisplayStartTime)(					/*	NOT Undoable! */
												AEGP_CompH			compH,					/* >> */
												const A_Time		*start_timePT);			/* >> */
	
	SPAPI A_Err (*AEGP_SetCompDuration)(
										AEGP_CompH			compH,					/* >> */
										const A_Time		*durationPT);			/* >> */
	
	SPAPI A_Err (*AEGP_CreateNullInComp)(
										 const A_UTF16Char		*utf_nameZ,			/* >> */
										 AEGP_CompH			parent_compH,			/* >> */
										 const A_Time		*durationPT0,			/* >> */
										 AEGP_LayerH			*new_null_solidPH);		/* << */
	
	SPAPI A_Err (*AEGP_SetCompPixelAspectRatio)(
												AEGP_CompH			compH,					/* >> */
												const A_Ratio		*pix_aspectratioPRt);	/* >> */
	
	SPAPI A_Err (*AEGP_CreateTextLayerInComp)(
											  AEGP_CompH			parent_compH,			/* >> */
											  A_Boolean			select_new_layerB,		/* >> */
											  AEGP_LayerH			*new_text_layerPH);		/* << */
	
	SPAPI A_Err (*AEGP_CreateBoxTextLayerInComp)(
												 AEGP_CompH			parent_compH,			/* >> */
												 A_Boolean			select_new_layerB,		/* >> */
												 A_FloatPoint		box_dimensions,			/* >> */ // (width and height)
												 AEGP_LayerH			*new_text_layerPH);		/* << */
	
	SPAPI A_Err (*AEGP_SetCompDimensions)(
										  AEGP_CompH			compH,					/* >> */
										  A_long				widthL,					/* >> */
										  A_long				heightL);				/* >> */
	
	SPAPI A_Err (*AEGP_DuplicateComp)(
									  AEGP_CompH			compH,					/* >> */
									  AEGP_CompH			*new_compPH);			/* << */
	
	SPAPI A_Err	(*AEGP_GetCompFrameDuration)(
											 AEGP_CompH			compH,    				/* >> */
											 A_Time				*timeP);				/* << */
	
	SPAPI A_Err (*AEGP_GetMostRecentlyUsedComp)(
												AEGP_CompH			*compPH);				/* << If compPH returns NULL, there's no available comp */
	
	SPAPI A_Err (*AEGP_CreateVectorLayerInComp)(
												AEGP_CompH			parent_compH,			/* >> */
												AEGP_LayerH			*new_vector_layerPH);	/* << */
	
	SPAPI A_Err (*AEGP_GetNewCompMarkerStream)(
											   AEGP_PluginID		aegp_plugin_id,			/* >> */
											   AEGP_CompH			parent_compH,			/* >> */
											   AEGP_StreamRefH		*streamPH);				/* << must be disposed by caller */
	
	SPAPI A_Err (*AEGP_GetCompDisplayDropFrame)(
												AEGP_CompH			compH,					/* >> */
												A_Boolean			*dropFramePB);			/* << */
	
	SPAPI A_Err (*AEGP_SetCompDisplayDropFrame)(
												AEGP_CompH			compH,					/* >> */
												A_Boolean			dropFrameB);			/* << */
	
} AEGP_CompSuite10;


#define kAEGPCompSuiteVersion9		19 /* frozen in AE 11 */

typedef struct AEGP_CompSuite9 {

	SPAPI A_Err	(*AEGP_GetCompFromItem)(							// error if item isn't AEGP_ItemType_COMP!
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_CompH			*compPH);				/* << */

	SPAPI A_Err	(*AEGP_GetItemFromComp)(
						AEGP_CompH			compH,					/* >> */
						AEGP_ItemH 			*itemPH);				/* << */

	SPAPI A_Err	(*AEGP_GetCompDownsampleFactor)(
						AEGP_CompH				compH,				/* >> */
						AEGP_DownsampleFactor	*dsfP);				/* << */

	SPAPI A_Err	(*AEGP_SetCompDownsampleFactor)(
						AEGP_CompH					compH,			/* <> */
						const AEGP_DownsampleFactor	*dsfP);			/* >> */

	SPAPI A_Err	(*AEGP_GetCompBGColor)(
						AEGP_CompH			compH,					/* >> */
						AEGP_ColorVal		*bg_colorP);			/* << */

	SPAPI A_Err (*AEGP_SetCompBGColor)(
						AEGP_CompH				compH,				/* >> */
						const AEGP_ColorVal		*bg_colorP);		/* >> */

	SPAPI A_Err	(*AEGP_GetCompFlags)(
						AEGP_CompH			compH,					/* >> */
						AEGP_CompFlags		*comp_flagsP);			/* << */

	SPAPI A_Err	(*AEGP_GetCompFramerate)(
						AEGP_CompH			compH,					/* >> */
						A_FpLong			*fpsPF);				/* << */

	SPAPI A_Err (*AEGP_SetCompFrameRate)(
						AEGP_CompH			compH,					/* >> */
						const A_FpLong		*fpsPF);				/* >> */

	SPAPI A_Err	(*AEGP_GetCompShutterAnglePhase)(
						AEGP_CompH			compH,					/* >> */
						A_Ratio				*angle,					/* << */
						A_Ratio				*phase);				/* << */

	SPAPI A_Err	(*AEGP_GetCompShutterFrameRange)(
						AEGP_CompH			compH,					/* >> */
						const A_Time		*comp_timeP,			/* >> */
						A_Time				*start,					/* << */
						A_Time				*duration);				/* << */

	SPAPI A_Err	(*AEGP_GetCompSuggestedMotionBlurSamples)(
						AEGP_CompH			compH,					/* >> */
						A_long				*samplesPL);			/* << */

	SPAPI A_Err	(*AEGP_SetCompSuggestedMotionBlurSamples)(			/* UNDOABLE */
						AEGP_CompH			compH,					/* >> */
						A_long				samplesL);				/* >> */

	SPAPI A_Err	(*AEGP_GetCompWorkAreaStart)(
						AEGP_CompH			compH,					/* >> */
						A_Time 				*work_area_startPT);	/* << */

	SPAPI A_Err	(*AEGP_GetCompWorkAreaDuration)(
						AEGP_CompH			compH,					/* >> */
						A_Time 				*work_area_durationPT);	/* << */

	SPAPI A_Err	(*AEGP_SetCompWorkAreaStartAndDuration)(			/* UNDOABLE */
						AEGP_CompH			compH,					/* >> */
						const A_Time 		*work_area_startPT,		/* >> */
						const A_Time 		*work_area_durationPT);	/* >> */

	SPAPI A_Err (*AEGP_CreateSolidInComp)(
						const A_UTF16Char		*utf_nameZ,			/* >> */
						A_long				width,					/* >> */
						A_long				height,					/* >> */
						const AEGP_ColorVal	*color,					/* >> */
						AEGP_CompH			parent_compH,			/* >> */
						const A_Time		*durationPT0,			/* >> */
						AEGP_LayerH			*new_solidPH);			/* << */

	SPAPI A_Err (*AEGP_CreateCameraInComp)(
						const A_UTF16Char		*utf_nameZ,			/* >> */
						A_FloatPoint		center_point,			/* >> */
						AEGP_CompH			parent_compH,			/* >> */
						AEGP_LayerH			*new_cameraPH);			/* << */

	SPAPI A_Err (*AEGP_CreateLightInComp)(
						const A_UTF16Char		*utf_nameZ,			/* >> */
						A_FloatPoint		center_point,			/* >> */
						AEGP_CompH			parent_compH,			/* >> */
						AEGP_LayerH			*new_lightPH);			/* << */

	SPAPI A_Err (*AEGP_CreateComp)(
						AEGP_ItemH			parent_folderH0,		/* >> */
						const A_UTF16Char		*utf_nameZ,			/* >> */
						A_long				widthL,					/* >> */
						A_long				heightL,				/* >> */
						const A_Ratio		*pixel_aspect_ratioPRt,	/* >> */
						const A_Time		*durationPT,			/* >> */
						const A_Ratio		*frameratePRt,			/* >> */
						AEGP_CompH			*new_compPH);			/* << */

	SPAPI A_Err	(*AEGP_GetNewCollectionFromCompSelection)(
						AEGP_PluginID		plugin_id,				/* >> */
						AEGP_CompH			compH,					/* >> */
						AEGP_Collection2H	*collectionPH);			/* << */

	SPAPI A_Err (*AEGP_SetSelection)(
						AEGP_CompH			compH,					/* >> */
						AEGP_Collection2H	collectionH);			/* >> not adopted */

	SPAPI A_Err (*AEGP_GetCompDisplayStartTime)(
						AEGP_CompH			compH,					/* >> */
						A_Time				*start_timePT);			/* << */

	SPAPI A_Err (*AEGP_SetCompDisplayStartTime)(					/*	NOT Undoable! */
						AEGP_CompH			compH,					/* >> */
						const A_Time		*start_timePT);			/* >> */

	SPAPI A_Err (*AEGP_SetCompDuration)(
						AEGP_CompH			compH,					/* >> */
						const A_Time		*durationPT);			/* >> */

	SPAPI A_Err (*AEGP_CreateNullInComp)(
						const A_UTF16Char		*utf_nameZ,			/* >> */
						AEGP_CompH			parent_compH,			/* >> */
						const A_Time		*durationPT0,			/* >> */
						AEGP_LayerH			*new_null_solidPH);		/* << */

	SPAPI A_Err (*AEGP_SetCompPixelAspectRatio)(
						AEGP_CompH			compH,					/* >> */
						const A_Ratio		*pix_aspectratioPRt);	/* >> */

	SPAPI A_Err (*AEGP_CreateTextLayerInComp)(
						AEGP_CompH			parent_compH,			/* >> */
						A_Boolean			select_new_layerB,		/* >> */
						AEGP_LayerH			*new_text_layerPH);		/* << */

	SPAPI A_Err (*AEGP_CreateBoxTextLayerInComp)(
						AEGP_CompH			parent_compH,			/* >> */
						A_Boolean			select_new_layerB,		/* >> */
						A_FloatPoint		box_dimensions,			/* >> */ // (width and height)
						AEGP_LayerH			*new_text_layerPH);		/* << */

	SPAPI A_Err (*AEGP_SetCompDimensions)(
						AEGP_CompH			compH,					/* >> */
						A_long				widthL,					/* >> */
						A_long				heightL);				/* >> */

	SPAPI A_Err (*AEGP_DuplicateComp)(
						AEGP_CompH			compH,					/* >> */
						AEGP_CompH			*new_compPH);			/* << */

	SPAPI A_Err	(*AEGP_GetCompFrameDuration)(
						AEGP_CompH			compH,    				/* >> */
						A_Time				*timeP);				/* << */

	SPAPI A_Err (*AEGP_GetMostRecentlyUsedComp)(
						AEGP_CompH			*compPH);				/* << If compPH returns NULL, there's no available comp */

	SPAPI A_Err (*AEGP_CreateVectorLayerInComp)(
						AEGP_CompH			parent_compH,			/* >> */
						AEGP_LayerH			*new_vector_layerPH);	/* << */

	SPAPI A_Err (*AEGP_GetNewCompMarkerStream)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_CompH			parent_compH,			/* >> */
						AEGP_StreamRefH		*streamPH);				/* << must be disposed by caller */

	SPAPI A_Err (*AEGP_GetCompDisplayDropFrame)(
						AEGP_CompH			compH,					/* >> */
						A_Boolean			*dropFramePB);			/* << */

	SPAPI A_Err (*AEGP_SetCompDisplayDropFrame)(
						AEGP_CompH			compH,					/* >> */
						A_Boolean			dropFrameB);			/* << */


} AEGP_CompSuite9;


#define kAEGPCompSuiteVersion8		18 /* frozen in AE 10.5 */

typedef struct AEGP_CompSuite8 {

	SPAPI A_Err	(*AEGP_GetCompFromItem)(							// error if item isn't AEGP_ItemType_COMP!
		AEGP_ItemH 			itemH,					/* >> */
		AEGP_CompH			*compPH);				/* << */

	SPAPI A_Err	(*AEGP_GetItemFromComp)(
		AEGP_CompH			compH,					/* >> */
		AEGP_ItemH 			*itemPH);				/* << */

	SPAPI A_Err	(*AEGP_GetCompDownsampleFactor)(
		AEGP_CompH				compH,				/* >> */
		AEGP_DownsampleFactor	*dsfP);				/* << */

	SPAPI A_Err	(*AEGP_SetCompDownsampleFactor)(
		AEGP_CompH					compH,			/* <> */
		const AEGP_DownsampleFactor	*dsfP);			/* >> */

	SPAPI A_Err	(*AEGP_GetCompBGColor)(
		AEGP_CompH			compH,					/* >> */
		AEGP_ColorVal		*bg_colorP);			/* << */

	SPAPI A_Err (*AEGP_SetCompBGColor)(
		AEGP_CompH				compH,				/* >> */
		const AEGP_ColorVal		*bg_colorP);		/* >> */

	SPAPI A_Err	(*AEGP_GetCompFlags)(
		AEGP_CompH			compH,					/* >> */
		AEGP_CompFlags		*comp_flagsP);			/* << */

	SPAPI A_Err	(*AEGP_GetCompFramerate)(
		AEGP_CompH			compH,					/* >> */
		A_FpLong			*fpsPF);				/* << */

	SPAPI A_Err (*AEGP_SetCompFrameRate)(
		AEGP_CompH			compH,					/* >> */
		const A_FpLong		*fpsPF);				/* >> */

	SPAPI A_Err	(*AEGP_GetCompShutterAnglePhase)(
		AEGP_CompH			compH,					/* >> */
		A_Ratio				*angle,					/* << */
		A_Ratio				*phase);				/* << */

	SPAPI A_Err	(*AEGP_GetCompShutterFrameRange)(
		AEGP_CompH			compH,					/* >> */
		const A_Time		*comp_timeP,			/* >> */
		A_Time				*start,					/* << */
		A_Time				*duration);				/* << */

	SPAPI A_Err	(*AEGP_GetCompSuggestedMotionBlurSamples)(
		AEGP_CompH			compH,					/* >> */
		A_long				*samplesPL);			/* << */

	SPAPI A_Err	(*AEGP_SetCompSuggestedMotionBlurSamples)(			/* UNDOABLE */
		AEGP_CompH			compH,					/* >> */
		A_long				samplesL);				/* >> */

	SPAPI A_Err	(*AEGP_GetCompWorkAreaStart)(
		AEGP_CompH			compH,					/* >> */
		A_Time 				*work_area_startPT);	/* << */

	SPAPI A_Err	(*AEGP_GetCompWorkAreaDuration)(
		AEGP_CompH			compH,					/* >> */
		A_Time 				*work_area_durationPT);	/* << */

	SPAPI A_Err	(*AEGP_SetCompWorkAreaStartAndDuration)(			/* UNDOABLE */
		AEGP_CompH			compH,					/* >> */
		const A_Time 		*work_area_startPT,		/* >> */
		const A_Time 		*work_area_durationPT);	/* >> */

	SPAPI A_Err (*AEGP_CreateSolidInComp)(
		const A_UTF16Char		*utf_nameZ,			/* >> */
		A_long				width,					/* >> */
		A_long				height,					/* >> */
		const AEGP_ColorVal	*color,					/* >> */
		AEGP_CompH			parent_compH,			/* >> */
		const A_Time		*durationPT0,			/* >> */
		AEGP_LayerH			*new_solidPH);			/* << */

	SPAPI A_Err (*AEGP_CreateCameraInComp)(
		const A_UTF16Char		*utf_nameZ,			/* >> */
		A_FloatPoint		center_point,			/* >> */
		AEGP_CompH			parent_compH,			/* >> */
		AEGP_LayerH			*new_cameraPH);			/* << */

	SPAPI A_Err (*AEGP_CreateLightInComp)(
		const A_UTF16Char		*utf_nameZ,			/* >> */
		A_FloatPoint		center_point,			/* >> */
		AEGP_CompH			parent_compH,			/* >> */
		AEGP_LayerH			*new_lightPH);			/* << */

	SPAPI A_Err (*AEGP_CreateComp)(
		AEGP_ItemH			parent_folderH0,		/* >> */
		const A_UTF16Char		*utf_nameZ,			/* >> */
		A_long				widthL,					/* >> */
		A_long				heightL,				/* >> */
		const A_Ratio		*pixel_aspect_ratioPRt,	/* >> */
		const A_Time		*durationPT,			/* >> */
		const A_Ratio		*frameratePRt,			/* >> */
		AEGP_CompH			*new_compPH);			/* << */

	SPAPI A_Err	(*AEGP_GetNewCollectionFromCompSelection)(
		AEGP_PluginID		plugin_id,				/* >> */
		AEGP_CompH			compH,					/* >> */
		AEGP_Collection2H	*collectionPH);			/* << */

	SPAPI A_Err (*AEGP_SetSelection)(
		AEGP_CompH			compH,					/* >> */
		AEGP_Collection2H	collectionH);			/* >> not adopted */

	SPAPI A_Err (*AEGP_GetCompDisplayStartTime)(
		AEGP_CompH			compH,					/* >> */
		A_Time				*start_timePT);			/* << */

	SPAPI A_Err (*AEGP_SetCompDisplayStartTime)(					/*	NOT Undoable! */
		AEGP_CompH			compH,					/* >> */
		const A_Time		*start_timePT);			/* >> */

	SPAPI A_Err (*AEGP_SetCompDuration)(
		AEGP_CompH			compH,					/* >> */
		const A_Time		*durationPT);			/* >> */

	SPAPI A_Err (*AEGP_CreateNullInComp)(
		const A_UTF16Char		*utf_nameZ,			/* >> */
		AEGP_CompH			parent_compH,			/* >> */
		const A_Time		*durationPT0,			/* >> */
		AEGP_LayerH			*new_null_solidPH);		/* << */

	SPAPI A_Err (*AEGP_SetCompPixelAspectRatio)(
		AEGP_CompH			compH,					/* >> */
		const A_Ratio		*pix_aspectratioPRt);	/* >> */

	SPAPI A_Err (*AEGP_CreateTextLayerInComp)(
		AEGP_CompH			parent_compH,			/* >> */
		AEGP_LayerH			*new_text_layerPH);		/* << */

	SPAPI A_Err (*AEGP_CreateBoxTextLayerInComp)(
		AEGP_CompH			parent_compH,			/* >> */
		A_FloatPoint		box_dimensions,			/* >> */ // (width and height)
		AEGP_LayerH			*new_text_layerPH);		/* << */

	SPAPI A_Err (*AEGP_SetCompDimensions)(
		AEGP_CompH			compH,					/* >> */
		A_long				widthL,					/* >> */
		A_long				heightL);				/* >> */

	SPAPI A_Err (*AEGP_DuplicateComp)(
		AEGP_CompH			compH,					/* >> */
		AEGP_CompH			*new_compPH);			/* << */

	SPAPI A_Err	(*AEGP_GetCompFrameDuration)(
		AEGP_CompH			compH,    				/* >> */
		A_Time				*timeP);				/* << */

	SPAPI A_Err (*AEGP_GetMostRecentlyUsedComp)(
		AEGP_CompH			*compPH);				/* << If compPH returns NULL, there's no available comp */

	SPAPI A_Err (*AEGP_CreateVectorLayerInComp)(
		AEGP_CompH			parent_compH,			/* >> */
		AEGP_LayerH			*new_vector_layerPH);	/* << */

	SPAPI A_Err (*AEGP_GetNewCompMarkerStream)(
		AEGP_PluginID		aegp_plugin_id,			/* >> */
		AEGP_CompH			parent_compH,			/* >> */
		AEGP_StreamRefH		*streamPH);				/* << must be disposed by caller */

	SPAPI A_Err (*AEGP_GetCompDisplayDropFrame)(
		AEGP_CompH			compH,					/* >> */
		A_Boolean			*dropFramePB);			/* << */

	SPAPI A_Err (*AEGP_SetCompDisplayDropFrame)(
		AEGP_CompH			compH,					/* >> */
		A_Boolean			dropFrameB);			/* << */


} AEGP_CompSuite8;



#define kAEGPCompSuiteVersion7		15 /* frozen in AE 9.0 */

typedef struct AEGP_CompSuite7 {

	SPAPI A_Err	(*AEGP_GetCompFromItem)(							// error if item isn't AEGP_ItemType_COMP!
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_CompH			*compPH);				/* << */

	SPAPI A_Err	(*AEGP_GetItemFromComp)(
						AEGP_CompH			compH,					/* >> */
						AEGP_ItemH 			*itemPH);				/* << */

	SPAPI A_Err	(*AEGP_GetCompDownsampleFactor)(
						AEGP_CompH				compH,				/* >> */
						AEGP_DownsampleFactor	*dsfP);				/* << */

	SPAPI A_Err	(*AEGP_SetCompDownsampleFactor)(
						AEGP_CompH					compH,			/* <> */
						const AEGP_DownsampleFactor	*dsfP);			/* >> */

	SPAPI A_Err	(*AEGP_GetCompBGColor)(
						AEGP_CompH			compH,					/* >> */
						AEGP_ColorVal		*bg_colorP);			/* << */

	SPAPI A_Err (*AEGP_SetCompBGColor)(
						AEGP_CompH				compH,				/* >> */
						const AEGP_ColorVal		*bg_colorP);		/* >> */

	SPAPI A_Err	(*AEGP_GetCompFlags)(
						AEGP_CompH			compH,					/* >> */
						AEGP_CompFlags		*comp_flagsP);			/* << */

	SPAPI A_Err	(*AEGP_GetCompFramerate)(
						AEGP_CompH			compH,					/* >> */
						A_FpLong			*fpsPF);				/* << */

	SPAPI A_Err (*AEGP_SetCompFrameRate)(
						AEGP_CompH			compH,					/* >> */
						const A_FpLong		*fpsPF);				/* >> */

	SPAPI A_Err	(*AEGP_GetCompShutterAnglePhase)(
						AEGP_CompH			compH,					/* >> */
						A_Ratio				*angle,					/* << */
						A_Ratio				*phase);				/* << */

	SPAPI A_Err	(*AEGP_GetCompShutterFrameRange)(
						AEGP_CompH			compH,					/* >> */
						const A_Time		*comp_timeP,			/* >> */
						A_Time				*start,					/* << */
						A_Time				*duration);				/* << */

	SPAPI A_Err	(*AEGP_GetCompSuggestedMotionBlurSamples)(
						AEGP_CompH			compH,					/* >> */
						A_long				*samplesPL);			/* << */

	SPAPI A_Err	(*AEGP_SetCompSuggestedMotionBlurSamples)(			/* UNDOABLE */
						AEGP_CompH			compH,					/* >> */
						A_long				samplesL);				/* >> */

	SPAPI A_Err	(*AEGP_GetCompWorkAreaStart)(
						AEGP_CompH			compH,					/* >> */
						A_Time 				*work_area_startPT);	/* << */

	SPAPI A_Err	(*AEGP_GetCompWorkAreaDuration)(
						AEGP_CompH			compH,					/* >> */
						A_Time 				*work_area_durationPT);	/* << */

	SPAPI A_Err	(*AEGP_SetCompWorkAreaStartAndDuration)(			/* UNDOABLE */
						AEGP_CompH			compH,					/* >> */
						const A_Time 		*work_area_startPT,		/* >> */
						const A_Time 		*work_area_durationPT);	/* >> */

	SPAPI A_Err (*AEGP_CreateSolidInComp)(
						const A_UTF16Char		*utf_nameZ,			/* >> */
						A_long				width,					/* >> */
						A_long				height,					/* >> */
						const AEGP_ColorVal	*color,					/* >> */
						AEGP_CompH			parent_compH,			/* >> */
						const A_Time		*durationPT0,			/* >> */
						AEGP_LayerH			*new_solidPH);			/* << */

	SPAPI A_Err (*AEGP_CreateCameraInComp)(
						const A_UTF16Char		*utf_nameZ,			/* >> */
						A_FloatPoint		center_point,			/* >> */
						AEGP_CompH			parent_compH,			/* >> */
						AEGP_LayerH			*new_cameraPH);			/* << */

	SPAPI A_Err (*AEGP_CreateLightInComp)(
						const A_UTF16Char		*utf_nameZ,			/* >> */
						A_FloatPoint		center_point,			/* >> */
						AEGP_CompH			parent_compH,			/* >> */
						AEGP_LayerH			*new_lightPH);			/* << */

	SPAPI A_Err (*AEGP_CreateComp)(
						AEGP_ItemH			parent_folderH0,		/* >> */
						const A_UTF16Char		*utf_nameZ,			/* >> */
						A_long				widthL,					/* >> */
						A_long				heightL,				/* >> */
						const A_Ratio		*pixel_aspect_ratioPRt,	/* >> */
						const A_Time		*durationPT,			/* >> */
						const A_Ratio		*frameratePRt,			/* >> */
						AEGP_CompH			*new_compPH);			/* << */

	SPAPI A_Err	(*AEGP_GetNewCollectionFromCompSelection)(
						AEGP_PluginID		plugin_id,				/* >> */
						AEGP_CompH			compH,					/* >> */
						AEGP_Collection2H	*collectionPH);			/* << */

	SPAPI A_Err (*AEGP_SetSelection)(
						AEGP_CompH			compH,					/* >> */
						AEGP_Collection2H	collectionH);			/* >> not adopted */

	SPAPI A_Err (*AEGP_GetCompDisplayStartTime)(
						AEGP_CompH			compH,					/* >> */
						A_Time				*start_timePT);			/* << */

	SPAPI A_Err (*AEGP_SetCompDisplayStartTime)(					/*	NOT Undoable! */
						AEGP_CompH			compH,					/* >> */
						const A_Time		*start_timePT);			/* >> */

	SPAPI A_Err (*AEGP_SetCompDuration)(
						AEGP_CompH			compH,					/* >> */
						const A_Time		*durationPT);			/* >> */

	SPAPI A_Err (*AEGP_CreateNullInComp)(
						const A_UTF16Char		*utf_nameZ,			/* >> */
						AEGP_CompH			parent_compH,			/* >> */
						const A_Time		*durationPT0,			/* >> */
						AEGP_LayerH			*new_null_solidPH);		/* << */

	SPAPI A_Err (*AEGP_SetCompPixelAspectRatio)(
						AEGP_CompH			compH,					/* >> */
						const A_Ratio		*pix_aspectratioPRt);	/* >> */

	SPAPI A_Err (*AEGP_CreateTextLayerInComp)(
						AEGP_CompH			parent_compH,			/* >> */
						AEGP_LayerH			*new_text_layerPH);		/* << */

	SPAPI A_Err (*AEGP_SetCompDimensions)(
						AEGP_CompH			compH,					/* >> */
						A_long				widthL,					/* >> */
						A_long				heightL);				/* >> */

	SPAPI A_Err (*AEGP_DuplicateComp)(
						AEGP_CompH			compH,					/* >> */
						AEGP_CompH			*new_compPH);			/* << */

	SPAPI A_Err	(*AEGP_GetCompFrameDuration)(
						AEGP_CompH			compH,    				/* >> */
						A_Time				*timeP);				/* << */

	SPAPI A_Err (*AEGP_GetMostRecentlyUsedComp)(
						AEGP_CompH			*compPH);				/* << If compPH returns NULL, there's no available comp */

	SPAPI A_Err (*AEGP_CreateVectorLayerInComp)(
						AEGP_CompH			parent_compH,			/* >> */
						AEGP_LayerH			*new_vector_layerPH);	/* << */

	SPAPI A_Err (*AEGP_GetNewCompMarkerStream)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_CompH			parent_compH,			/* >> */
						AEGP_StreamRefH		*streamPH);				/* << must be disposed by caller */

} AEGP_CompSuite7;


#define kAEGPCompSuiteVersion6		14 /* frozen in AE 8.0 */

typedef struct AEGP_CompSuite6 {

	SPAPI A_Err	(*AEGP_GetCompFromItem)(							// error if item isn't AEGP_ItemType_COMP!
		AEGP_ItemH 			itemH,					/* >> */
		AEGP_CompH			*compPH);				/* << */

	SPAPI A_Err	(*AEGP_GetItemFromComp)(
		AEGP_CompH			compH,					/* >> */
		AEGP_ItemH 			*itemPH);				/* << */

	SPAPI A_Err	(*AEGP_GetCompDownsampleFactor)(
		AEGP_CompH				compH,				/* >> */
		AEGP_DownsampleFactor	*dsfP);				/* << */

	SPAPI A_Err	(*AEGP_SetCompDownsampleFactor)(
		AEGP_CompH					compH,			/* <> */
		const AEGP_DownsampleFactor	*dsfP);			/* >> */

	SPAPI A_Err	(*AEGP_GetCompBGColor)(
		AEGP_CompH			compH,					/* >> */
		AEGP_ColorVal		*bg_colorP);			/* << */

	SPAPI A_Err (*AEGP_SetCompBGColor)(
		AEGP_CompH				compH,				/* >> */
		const AEGP_ColorVal		*bg_colorP);		/* >> */

	SPAPI A_Err	(*AEGP_GetCompFlags)(
		AEGP_CompH			compH,					/* >> */
		AEGP_CompFlags		*comp_flagsP);			/* << */

	SPAPI A_Err	(*AEGP_GetCompFramerate)(
		AEGP_CompH			compH,					/* >> */
		A_FpLong			*fpsPF);				/* << */

	SPAPI A_Err (*AEGP_SetCompFrameRate)(
		AEGP_CompH			compH,					/* >> */
		const A_FpLong		*fpsPF);				/* >> */

	SPAPI A_Err	(*AEGP_GetCompShutterAnglePhase)(
		AEGP_CompH			compH,					/* >> */
		A_Ratio				*angle,					/* << */
		A_Ratio				*phase);				/* << */

	SPAPI A_Err	(*AEGP_GetCompShutterFrameRange)(
		AEGP_CompH			compH,					/* >> */
		const A_Time		*comp_timeP,			/* >> */
		A_Time				*start,					/* << */
		A_Time				*duration);				/* << */

	SPAPI A_Err	(*AEGP_GetCompSuggestedMotionBlurSamples)(
		AEGP_CompH			compH,					/* >> */
		A_long				*samplesPL);			/* << */

	SPAPI A_Err	(*AEGP_SetCompSuggestedMotionBlurSamples)(			/* UNDOABLE */
		AEGP_CompH			compH,					/* >> */
		A_long				samplesL);				/* >> */

	SPAPI A_Err	(*AEGP_GetCompWorkAreaStart)(
		AEGP_CompH			compH,					/* >> */
		A_Time 				*work_area_startPT);	/* << */

	SPAPI A_Err	(*AEGP_GetCompWorkAreaDuration)(
		AEGP_CompH			compH,					/* >> */
		A_Time 				*work_area_durationPT);	/* << */

	SPAPI A_Err	(*AEGP_SetCompWorkAreaStartAndDuration)(			/* UNDOABLE */
		AEGP_CompH			compH,					/* >> */
		const A_Time 		*work_area_startPT,		/* >> */
		const A_Time 		*work_area_durationPT);	/* >> */

	SPAPI A_Err (*AEGP_CreateSolidInComp)(
		const A_char		*nameZ,					/* >> */
		A_long				width,					/* >> */
		A_long				height,					/* >> */
		const AEGP_ColorVal	*color,					/* >> */
		AEGP_CompH			parent_compH,			/* >> */
		const A_Time		*durationPT0,			/* >> */
		AEGP_LayerH			*new_solidPH);			/* << */

	SPAPI A_Err (*AEGP_CreateCameraInComp)(
		const A_char		*nameZ,					/* >> */
		A_FloatPoint		center_point,			/* >> */
		AEGP_CompH			parent_compH,			/* >> */
		AEGP_LayerH			*new_cameraPH);			/* << */

	SPAPI A_Err (*AEGP_CreateLightInComp)(
		const A_char		*nameZ,					/* >> */
		A_FloatPoint		center_point,			/* >> */
		AEGP_CompH			parent_compH,			/* >> */
		AEGP_LayerH			*new_lightPH);			/* << */

	SPAPI A_Err (*AEGP_CreateComp)(
		AEGP_ItemH			parent_folderH0,		/* >> */
		const A_char		*nameZ,					/* >> */
		A_long				widthL,					/* >> */
		A_long				heightL,				/* >> */
		const A_Ratio		*pixel_aspect_ratioPRt,	/* >> */
		const A_Time		*durationPT,			/* >> */
		const A_Ratio		*frameratePRt,			/* >> */
		AEGP_CompH			*new_compPH);			/* << */

	SPAPI A_Err	(*AEGP_GetNewCollectionFromCompSelection)(
		AEGP_PluginID		plugin_id,				/* >> */
		AEGP_CompH			compH,					/* >> */
		AEGP_Collection2H	*collectionPH);			/* << */

	SPAPI A_Err (*AEGP_SetSelection)(
		AEGP_CompH			compH,					/* >> */
		AEGP_Collection2H	collectionH);			/* >> not adopted */

	SPAPI A_Err (*AEGP_GetCompDisplayStartTime)(
		AEGP_CompH			compH,					/* >> */
		A_Time				*start_timePT);			/* << */

	SPAPI A_Err (*AEGP_SetCompDisplayStartTime)(					/*	NOT Undoable! */
		AEGP_CompH			compH,					/* >> */
		const A_Time		*start_timePT);			/* >> */

	SPAPI A_Err (*AEGP_SetCompDuration)(
		AEGP_CompH			compH,					/* >> */
		const A_Time		*durationPT);			/* >> */

	SPAPI A_Err (*AEGP_CreateNullInComp)(
		const A_char		*nameZ,					/* >> */
		AEGP_CompH			parent_compH,			/* >> */
		const A_Time		*durationPT0,			/* >> */
		AEGP_LayerH			*new_null_solidPH);		/* << */

	SPAPI A_Err (*AEGP_SetCompPixelAspectRatio)(
		AEGP_CompH			compH,					/* >> */
		const A_Ratio		*pix_aspectratioPRt);	/* >> */

	SPAPI A_Err (*AEGP_CreateTextLayerInComp)(
		AEGP_CompH			parent_compH,			/* >> */
		AEGP_LayerH			*new_text_layerPH);		/* << */

	SPAPI A_Err (*AEGP_SetCompDimensions)(
		AEGP_CompH			compH,					/* >> */
		A_long				widthL,					/* >> */
		A_long				heightL);				/* >> */

	SPAPI A_Err (*AEGP_DuplicateComp)(
		AEGP_CompH			compH,					/* >> */
		AEGP_CompH			*new_compPH);			/* << */

	SPAPI A_Err	(*AEGP_GetCompFrameDuration)(
		AEGP_CompH			compH,    				/* >> */
		A_Time				*timeP);				/* << */

	SPAPI A_Err (*AEGP_GetMostRecentlyUsedComp)(
		AEGP_CompH			*compPH);				/* << If compPH returns NULL, there's no available comp */

	SPAPI A_Err (*AEGP_CreateVectorLayerInComp)(
		AEGP_CompH			parent_compH,			/* >> */
		AEGP_LayerH			*new_vector_layerPH);	/* << */

	SPAPI A_Err (*AEGP_GetNewCompMarkerStream)(
		AEGP_PluginID		aegp_plugin_id,			/* >> */
		AEGP_CompH			parent_compH,			/* >> */
		AEGP_StreamRefH		*streamPH);				/* << must be disposed by caller */

} AEGP_CompSuite6;


#define kAEGPCompSuiteVersion5		11 /* frozen AE 7.0 */

typedef struct AEGP_CompSuite5 {

	SPAPI A_Err	(*AEGP_GetCompFromItem)(							// error if item isn't AEGP_ItemType_COMP!
		AEGP_ItemH 			itemH,					/* >> */
		AEGP_CompH			*compPH);				/* << */

	SPAPI A_Err	(*AEGP_GetItemFromComp)(
		AEGP_CompH			compH,					/* >> */
		AEGP_ItemH 			*itemPH);				/* << */

	SPAPI A_Err	(*AEGP_GetCompDownsampleFactor)(
		AEGP_CompH				compH,				/* >> */
		AEGP_DownsampleFactor	*dsfP);				/* << */

	SPAPI A_Err	(*AEGP_SetCompDownsampleFactor)(
		AEGP_CompH					compH,			/* <> */
		const AEGP_DownsampleFactor	*dsfP);			/* >> */

	SPAPI A_Err	(*AEGP_GetCompBGColor)(
		AEGP_CompH			compH,					/* >> */
		AEGP_ColorVal		*bg_colorP);			/* << */

	SPAPI A_Err (*AEGP_SetCompBGColor)(
		AEGP_CompH				compH,				/* >> */
		const AEGP_ColorVal		*bg_colorP);		/* >> */

	SPAPI A_Err	(*AEGP_GetCompFlags)(
		AEGP_CompH			compH,					/* >> */
		AEGP_CompFlags		*comp_flagsP);			/* << */

	SPAPI A_Err	(*AEGP_GetCompFramerate)(
		AEGP_CompH			compH,					/* >> */
		A_FpLong			*fpsPF);				/* << */

	SPAPI A_Err (*AEGP_SetCompFrameRate)(
		AEGP_CompH			compH,					/* >> */
		const A_FpLong		*fpsPF);				/* >> */

	SPAPI A_Err	(*AEGP_GetCompShutterAnglePhase)(
		AEGP_CompH			compH,					/* >> */
		A_Ratio				*angle,					/* << */
		A_Ratio				*phase);				/* << */

	SPAPI A_Err	(*AEGP_GetCompShutterFrameRange)(
		AEGP_CompH			compH,					/* >> */
		const A_Time		*comp_timeP,			/* >> */
		A_Time				*start,					/* << */
		A_Time				*duration);				/* << */

	SPAPI A_Err	(*AEGP_GetCompWorkAreaStart)(
		AEGP_CompH			compH,					/* >> */
		A_Time 				*work_area_startPT);	/* << */

	SPAPI A_Err	(*AEGP_GetCompWorkAreaDuration)(
		AEGP_CompH			compH,					/* >> */
		A_Time 				*work_area_durationPT);	/* << */

	SPAPI A_Err	(*AEGP_SetCompWorkAreaStartAndDuration)(			/* UNDOABLE */
		AEGP_CompH			compH,					/* >> */
		A_Time 				*work_area_startPT,		/* >> */
		A_Time 				*work_area_durationPT);	/* >> */

	SPAPI A_Err (*AEGP_CreateSolidInComp)(
		const A_char		*nameZ,					/* >> */
		A_long				width,					/* >> */
		A_long				height,					/* >> */
		const AEGP_ColorVal	*color,					/* >> */
		AEGP_CompH			parent_compH,			/* >> */
		const A_Time		*durationPT0,			/* >> */
		AEGP_LayerH			*new_solidPH);			/* << */

	SPAPI A_Err (*AEGP_CreateCameraInComp)(
		const A_char		*nameZ,					/* >> */
		A_FloatPoint		center_point,			/* >> */
		AEGP_CompH			parent_compH,			/* >> */
		AEGP_LayerH			*new_cameraPH);			/* << */

	SPAPI A_Err (*AEGP_CreateLightInComp)(
		const A_char		*nameZ,					/* >> */
		A_FloatPoint		center_point,			/* >> */
		AEGP_CompH			parent_compH,			/* >> */
		AEGP_LayerH			*new_lightPH);			/* << */

	SPAPI A_Err (*AEGP_CreateComp)(
		AEGP_ItemH			parent_folderH0,		/* >> */
		const A_char		*nameZ,					/* >> */
		A_long				widthL,					/* >> */
		A_long				heightL,				/* >> */
		const A_Ratio		*pixel_aspect_ratioPRt,	/* >> */
		const A_Time		*durationPT,			/* >> */
		const A_Ratio		*frameratePRt,			/* >> */
		AEGP_CompH			*new_compPH);			/* << */

	SPAPI A_Err	(*AEGP_GetNewCollectionFromCompSelection)(
		AEGP_PluginID		plugin_id,				/* >> */
		AEGP_CompH			compH,					/* >> */
		AEGP_Collection2H	*collectionPH);			/* << */

	SPAPI A_Err (*AEGP_SetSelection)(
		AEGP_CompH	compH,							/* >> */
		AEGP_Collection2H collectionH);				/* >> not adopted */

	SPAPI A_Err (*AEGP_GetCompDisplayStartTime)(
		AEGP_CompH			compH,					/* >> */
		A_Time				*start_timePT);			/* << */

	SPAPI A_Err (*AEGP_SetCompDisplayStartTime)(					/*	NOT Undoable! */
		AEGP_CompH			compH,					/* >> */
		const A_Time		*start_timePT);			/* >> */

	SPAPI A_Err (*AEGP_SetCompDuration)(
		AEGP_CompH			compH,					/* >> */
		const A_Time		*durationPT);			/* >> */

	SPAPI A_Err (*AEGP_CreateNullInComp)(
		const A_char		*nameZ,					/* >> */
		AEGP_CompH			parent_compH,			/* >> */
		const A_Time		*durationPT0,			/* >> */
		AEGP_LayerH			*new_null_solidPH);		/* << */

	SPAPI A_Err (*AEGP_SetCompPixelAspectRatio)(
		AEGP_CompH		compH,						/* >> */
		const A_Ratio	*pix_aspectratioPRt);		/* >> */

	SPAPI A_Err (*AEGP_CreateTextLayerInComp)(
		AEGP_CompH			parent_compH,			/* >> */
		AEGP_LayerH			*new_text_layerPH);		/* << */

	SPAPI A_Err (*AEGP_SetCompDimensions)(
		AEGP_CompH		compH,						/* >> */
		A_long			widthL,						/* >> */
		A_long			heightL);					/* >> */

	SPAPI A_Err (*AEGP_DuplicateComp)(
		AEGP_CompH		compH,						/* >> */
		AEGP_CompH		*new_compPH);				/* << */

	SPAPI A_Err	(*AEGP_GetCompFrameDuration)(AEGP_CompH compH,    	/* >> */
		A_Time*		timeP);							/* << */

	SPAPI A_Err (*AEGP_GetMostRecentlyUsedComp)(
		AEGP_CompH		*compPH);					/* << If compPH returns NULL, there's no available comp */
} AEGP_CompSuite5;


#define kAEGPCompSuiteVersion4		9 /* frozen AE 6.5 */

typedef struct AEGP_CompSuite4 {

	SPAPI A_Err	(*AEGP_GetCompFromItem)(							// error if item isn't AEGP_ItemType_COMP!
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_CompH			*compPH);				/* << */

	SPAPI A_Err	(*AEGP_GetItemFromComp)(
						AEGP_CompH			compH,					/* >> */
						AEGP_ItemH 			*itemPH);				/* << */

	SPAPI A_Err	(*AEGP_GetCompDownsampleFactor)(
						AEGP_CompH				compH,				/* >> */
						AEGP_DownsampleFactor	*dsfP);				/* << */

	SPAPI A_Err	(*AEGP_SetCompDownsampleFactor)(
						AEGP_CompH					compH,			/* <> */
						const AEGP_DownsampleFactor	*dsfP);			/* >> */

	SPAPI A_Err	(*AEGP_GetCompBGColor)(
						AEGP_CompH			compH,					/* >> */
						AEGP_ColorVal		*bg_colorP);			/* << */

	SPAPI A_Err	(*AEGP_GetCompFlags)(
						AEGP_CompH			compH,					/* >> */
						AEGP_CompFlags		*comp_flagsP);			/* << */

	SPAPI A_Err	(*AEGP_GetCompFramerate)(
						AEGP_CompH			compH,					/* >> */
						A_FpLong			*fpsPF);				/* << */

	SPAPI A_Err (*AEGP_SetCompFrameRate)(
						AEGP_CompH			compH,					/* >> */
						const A_FpLong		*fpsPF);				/* >> */

	SPAPI A_Err	(*AEGP_GetCompShutterAnglePhase)(
						AEGP_CompH			compH,					/* >> */
						A_Ratio				*angle,					/* << */
						A_Ratio				*phase);				/* << */

	SPAPI A_Err	(*AEGP_GetCompShutterFrameRange)(
						AEGP_CompH			compH,					/* >> */
						const A_Time		*comp_timeP,			/* >> */
						A_Time				*start,					/* << */
						A_Time				*duration);				/* << */

	SPAPI A_Err	(*AEGP_GetCompWorkAreaStart)(
						AEGP_CompH			compH,					/* >> */
						A_Time 				*work_area_startPT);	/* << */

	SPAPI A_Err	(*AEGP_GetCompWorkAreaDuration)(
						AEGP_CompH			compH,					/* >> */
						A_Time 				*work_area_durationPT);	/* << */

	SPAPI A_Err	(*AEGP_SetCompWorkAreaStartAndDuration)(			/* UNDOABLE */
						AEGP_CompH			compH,					/* >> */
						A_Time 				*work_area_startPT,		/* >> */
						A_Time 				*work_area_durationPT);	/* >> */

	SPAPI A_Err (*AEGP_CreateSolidInComp)(
						const A_char		*nameZ,					/* >> */
						A_long				width,					/* >> */
						A_long				height,					/* >> */
						const AEGP_ColorVal	*color,					/* >> */
						AEGP_CompH			parent_compH,			/* >> */
						const A_Time		*durationPT0,			/* >> */
						AEGP_LayerH			*new_solidPH);			/* << */

	SPAPI A_Err (*AEGP_CreateCameraInComp)(
						const A_char		*nameZ,					/* >> */
						A_FloatPoint		center_point,			/* >> */
						AEGP_CompH			parent_compH,			/* >> */
						AEGP_LayerH			*new_cameraPH);			/* << */

	SPAPI A_Err (*AEGP_CreateLightInComp)(
						const A_char		*nameZ,					/* >> */
						A_FloatPoint		center_point,			/* >> */
						AEGP_CompH			parent_compH,			/* >> */
						AEGP_LayerH			*new_lightPH);			/* << */

	SPAPI A_Err (*AEGP_CreateComp)(
						AEGP_ItemH			parent_folderH0,		/* >> */
						const A_char		*nameZ,					/* >> */
						A_long				widthL,					/* >> */
						A_long				heightL,				/* >> */
						const A_Ratio		*pixel_aspect_ratioPRt,	/* >> */
						const A_Time		*durationPT,			/* >> */
						const A_Ratio		*frameratePRt,			/* >> */
						AEGP_CompH			*new_compPH);			/* << */

	SPAPI A_Err	(*AEGP_GetNewCollectionFromCompSelection)(
						AEGP_PluginID		plugin_id,				/* >> */
						AEGP_CompH			compH,					/* >> */
						AEGP_Collection2H	*collectionPH);			/* << */

	SPAPI A_Err (*AEGP_SetSelection)(
						AEGP_CompH	compH,							/* >> */
						AEGP_Collection2H collectionH);				/* >> not adopted */

	SPAPI A_Err (*AEGP_GetCompDisplayStartTime)(
						AEGP_CompH			compH,					/* >> */
						A_Time				*start_timePT);			/* << */

	SPAPI A_Err (*AEGP_SetCompDisplayStartTime)(					/*	NOT Undoable! */
						AEGP_CompH			compH,					/* >> */
						const A_Time		*start_timePT);			/* >> */

	SPAPI A_Err (*AEGP_SetCompDuration)(
						AEGP_CompH			compH,					/* >> */
						const A_Time		*durationPT);			/* >> */

	SPAPI A_Err (*AEGP_CreateNullInComp)(
						const A_char		*nameZ,					/* >> */
						AEGP_CompH			parent_compH,			/* >> */
						const A_Time		*durationPT0,			/* >> */
						AEGP_LayerH			*new_null_solidPH);		/* << */

	SPAPI A_Err (*AEGP_SetCompPixelAspectRatio)(
						AEGP_CompH		compH,						/* >> */
						const A_Ratio	*pix_aspectratioPRt);		/* >> */

	SPAPI A_Err (*AEGP_CreateTextLayerInComp)(
						AEGP_CompH			parent_compH,			/* >> */
						AEGP_LayerH			*new_text_layerPH);		/* << */

	SPAPI A_Err (*AEGP_SetCompDimensions)(
						AEGP_CompH		compH,						/* >> */
						A_long			widthL,						/* >> */
						A_long			heightL);					/* >> */

	SPAPI A_Err (*AEGP_DuplicateComp)(
						AEGP_CompH		compH,						/* >> */
						AEGP_CompH		*new_compPH);				/* << */

	SPAPI A_Err	(*AEGP_GetCompFrameDuration)(AEGP_CompH compH,    // in
		A_Time*		timeP);   // out

} AEGP_CompSuite4;


#define kAEGPCompSuiteVersion3		7 /* frozen AE 6.0 */

typedef struct AEGP_CompSuite3 {

	SPAPI A_Err	(*AEGP_GetCompFromItem)(							// error if item isn't AEGP_ItemType_COMP!
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_CompH			*compPH);				/* << */

	SPAPI A_Err	(*AEGP_GetItemFromComp)(
						AEGP_CompH			compH,					/* >> */
						AEGP_ItemH 			*itemPH);				/* << */

	SPAPI A_Err	(*AEGP_GetCompDownsampleFactor)(
						AEGP_CompH				compH,				/* >> */
						AEGP_DownsampleFactor	*dsfP);				/* << */

	SPAPI A_Err	(*AEGP_SetCompDownsampleFactor)(
						AEGP_CompH					compH,			/* <> */
						const AEGP_DownsampleFactor	*dsfP);			/* >> */

	SPAPI A_Err	(*AEGP_GetCompBGColor)(
						AEGP_CompH			compH,					/* >> */
						AEGP_ColorVal		*bg_colorP);			/* << */

	SPAPI A_Err	(*AEGP_GetCompFlags)(
						AEGP_CompH			compH,					/* >> */
						AEGP_CompFlags		*comp_flagsP);			/* << */

	SPAPI A_Err	(*AEGP_GetCompFramerate)(
						AEGP_CompH			compH,					/* >> */
						A_FpLong			*fpsPF);				/* << */

	SPAPI A_Err (*AEGP_SetCompFrameRate)(
						AEGP_CompH			compH,					/* >> */
						const A_FpLong		*fpsPF);				/* >> */

	SPAPI A_Err	(*AEGP_GetCompShutterAnglePhase)(
						AEGP_CompH			compH,					/* >> */
						A_Ratio				*angle,					/* << */
						A_Ratio				*phase);				/* << */

	SPAPI A_Err	(*AEGP_GetCompShutterFrameRange)(
						AEGP_CompH			compH,					/* >> */
						const A_Time		*comp_timeP,			/* >> */
						A_Time				*start,					/* << */
						A_Time				*duration);				/* << */

	SPAPI A_Err	(*AEGP_GetCompWorkAreaStart)(
						AEGP_CompH			compH,					/* >> */
						A_Time 				*work_area_startPT);	/* << */

	SPAPI A_Err	(*AEGP_GetCompWorkAreaDuration)(
						AEGP_CompH			compH,					/* >> */
						A_Time 				*work_area_durationPT);	/* << */

	SPAPI A_Err	(*AEGP_SetCompWorkAreaStartAndDuration)(			/* UNDOABLE */
						AEGP_CompH			compH,					/* >> */
						A_Time 				*work_area_startPT,		/* >> */
						A_Time 				*work_area_durationPT);	/* >> */

	SPAPI A_Err (*AEGP_CreateSolidInComp)(
						const A_char		*nameZ,					/* >> */
						A_long				width,					/* >> */
						A_long				height,					/* >> */
						const AEGP_ColorVal	*color,					/* >> */
						AEGP_CompH			parent_compH,			/* >> */
						const A_Time		*durationPT0,			/* >> */
						AEGP_LayerH			*new_solidPH);			/* << */

	SPAPI A_Err (*AEGP_CreateCameraInComp)(
						const A_char		*nameZ,					/* >> */
						A_FloatPoint		center_point,			/* >> */
						AEGP_CompH			parent_compH,			/* >> */
						AEGP_LayerH			*new_cameraPH);			/* << */

	SPAPI A_Err (*AEGP_CreateLightInComp)(
						const A_char		*nameZ,					/* >> */
						A_FloatPoint		center_point,			/* >> */
						AEGP_CompH			parent_compH,			/* >> */
						AEGP_LayerH			*new_lightPH);			/* << */

	SPAPI A_Err (*AEGP_CreateComp)(
						AEGP_ItemH			parent_folderH0,		/* >> */
						const A_char		*nameZ,					/* >> */
						A_long				widthL,					/* >> */
						A_long				heightL,				/* >> */
						const A_Ratio		*pixel_aspect_ratioPRt,	/* >> */
						const A_Time		*durationPT,			/* >> */
						const A_Ratio		*frameratePRt,			/* >> */
						AEGP_CompH			*new_compPH);			/* << */

	SPAPI A_Err	(*AEGP_GetNewCollectionFromCompSelection)(
						AEGP_PluginID		plugin_id,				/* >> */
						AEGP_CompH			compH,					/* >> */
						AEGP_CollectionH	*collectionPH);			/* << */

	SPAPI A_Err (*AEGP_SetSelection)(
						AEGP_CompH	compH,							/* >> */
						AEGP_CollectionH collectionH);				/* >> not adopted */

	SPAPI A_Err (*AEGP_GetCompDisplayStartTime)(
						AEGP_CompH			compH,					/* >> */
						A_Time				*start_timePT);			/* << */

	SPAPI A_Err (*AEGP_SetCompDisplayStartTime)(					/*	NOT Undoable! */
						AEGP_CompH			compH,					/* >> */
						const A_Time		*start_timePT);			/* >> */

	SPAPI A_Err (*AEGP_SetCompDuration)(
						AEGP_CompH			compH,					/* >> */
						const A_Time		*durationPT);			/* >> */

	SPAPI A_Err (*AEGP_CreateNullInComp)(
						const A_char		*nameZ,					/* >> */
						AEGP_CompH			parent_compH,			/* >> */
						const A_Time		*durationPT0,			/* >> */
						AEGP_LayerH			*new_null_solidPH);		/* << */

	SPAPI A_Err (*AEGP_SetCompPixelAspectRatio)(
						AEGP_CompH		compH,						/* >> */
						const A_Ratio	*pix_aspectratioPRt);		/* >> */

	SPAPI A_Err (*AEGP_CreateTextLayerInComp)(
						AEGP_CompH			parent_compH,			/* >> */
						AEGP_LayerH			*new_text_layerPH);		/* << */

} AEGP_CompSuite3;


#define kAEGPCompSuiteVersion2		6 /* frozen in AE 5.5 */

typedef struct AEGP_CompSuite2 {

	SPAPI A_Err	(*AEGP_GetCompFromItem)(							// error if item isn't AEGP_ItemType_COMP!
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_CompH			*compPH);				/* << */

	SPAPI A_Err	(*AEGP_GetItemFromComp)(
						AEGP_CompH			compH,					/* >> */
						AEGP_ItemH 			*itemPH);				/* << */

	SPAPI A_Err	(*AEGP_GetCompDownsampleFactor)(
						AEGP_CompH				compH,				/* >> */
						AEGP_DownsampleFactor	*dsfP);				/* << */

	SPAPI A_Err	(*AEGP_SetCompDownsampleFactor)(
						AEGP_CompH					compH,			/* <> */
						const AEGP_DownsampleFactor	*dsfP);			/* >> */

	SPAPI A_Err	(*AEGP_GetCompBGColor)(
						AEGP_CompH			compH,					/* >> */
						AEGP_ColorVal		*bg_colorP);			/* << */

	SPAPI A_Err	(*AEGP_GetCompFlags)(
						AEGP_CompH			compH,					/* >> */
						AEGP_CompFlags		*comp_flagsP);			/* << */

	SPAPI A_Err	(*AEGP_GetCompFramerate)(
						AEGP_CompH			compH,					/* >> */
						A_FpLong			*fpsPF);				/* << */

	SPAPI A_Err	(*AEGP_GetCompShutterAnglePhase)(
						AEGP_CompH			compH,					/* >> */
						A_Ratio				*angle,					/* << */
						A_Ratio				*phase);				/* << */

	SPAPI A_Err	(*AEGP_GetCompShutterFrameRange)(
						AEGP_CompH			compH,					/* >> */
						const A_Time		*comp_timeP,			/* >> */
						A_Time				*start,					/* << */
						A_Time				*duration);				/* << */

	SPAPI A_Err	(*AEGP_GetCompWorkAreaStart)(
						AEGP_CompH			compH,					/* >> */
						A_Time 				*work_area_startPT);	/* << */

	SPAPI A_Err	(*AEGP_GetCompWorkAreaDuration)(
						AEGP_CompH			compH,					/* >> */
						A_Time 				*work_area_durationPT);	/* << */

	SPAPI A_Err	(*AEGP_SetCompWorkAreaStartAndDuration)(			/* UNDOABLE */
						AEGP_CompH			compH,					/* >> */
						A_Time 				*work_area_startPT,		/* >> */
						A_Time 				*work_area_durationPT);	/* >> */

	SPAPI A_Err (*AEGP_CreateSolidInComp)(
						const A_char		*nameZ,					/* >> */
						A_long				width,					/* >> */
						A_long				height,					/* >> */
						const AEGP_ColorVal	*color,					/* >> */
						AEGP_ItemH			parent_compH,			/* >> */
						const A_Time		*durationPT0,			/* >> */
						AEGP_LayerH			*new_solidPH);			/* << */

	SPAPI A_Err (*AEGP_CreateCameraInComp)(
						const A_char		*nameZ,					/* >> */
						A_FloatPoint		center_point,			/* >> */
						AEGP_ItemH			parent_compH,			/* >> */
						AEGP_LayerH			*new_cameraPH);			/* << */

	SPAPI A_Err (*AEGP_CreateLightInComp)(
						const A_char		*nameZ,					/* >> */
						A_FloatPoint		center_point,			/* >> */
						AEGP_ItemH			parent_compH,			/* >> */
						AEGP_LayerH			*new_lightPH);			/* << */

	SPAPI A_Err (*AEGP_CreateComp)(
						AEGP_ItemH			parent_folderH0,		/* >> */
						const A_char		*nameZ,					/* >> */
						A_long				widthL,					/* >> */
						A_long				heightL,				/* >> */
						const A_Ratio		*pixel_aspect_ratioPRt,	/* >> */
						const A_Time		*durationPT,			/* >> */
						const A_Ratio		*frameratePRt,			/* >> */
						AEGP_CompH			*new_compPH);			/* << */

	SPAPI A_Err	(*AEGP_GetNewCollectionFromCompSelection)(
						AEGP_PluginID		plugin_id,				/* >> */
						AEGP_CompH			compH,					/* >> */
						AEGP_CollectionH	*collectionPH);			/* << */

	SPAPI A_Err (*AEGP_SetSelection)(
						AEGP_CompH	compH,							/* >> */
						AEGP_CollectionH collectionH);				/* >> not adopted */

	SPAPI A_Err (*AEGP_SetCompDisplayStartTime)(					/*	NOT Undoable! */
						AEGP_CompH			compH,					/* >> */
						const A_Time		*start_timePT);			/* >> */

	SPAPI A_Err (*AEGP_SetCompDuration)(
						AEGP_CompH			compH,					/* >> */
						const A_Time		*durationPT);			/* >> */


	SPAPI A_Err (*AEGP_CreateNullInComp)(
						const A_char		*nameZ,					/* >> */
						AEGP_CompH			parent_compH,			/* >> */
						const A_Time		*durationPT0,			/* >> */
						AEGP_LayerH			*new_null_solidPH);		/* << */

} AEGP_CompSuite2;


#define kAEGPCompSuiteVersion1		4 /* frozen in AE 5.0 */

typedef struct AEGP_CompSuite1 {

	SPAPI A_Err	(*AEGP_GetCompFromItem)(							// error if item isn't AEGP_ItemType_COMP!
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_CompH			*compPH);				/* << */

	SPAPI A_Err	(*AEGP_GetItemFromComp)(
						AEGP_CompH			compH,					/* >> */
						AEGP_ItemH 			*itemPH);				/* << */

	SPAPI A_Err	(*AEGP_GetCompDownsampleFactor)(
						AEGP_CompH				compH,				/* >> */
						AEGP_DownsampleFactor	*dsfP);				/* << */

	SPAPI A_Err	(*AEGP_GetCompBGColor)(
						AEGP_CompH			compH,					/* >> */
						AEGP_ColorVal		*bg_colorP);			/* << */

	SPAPI A_Err	(*AEGP_GetCompFlags)(
						AEGP_CompH			compH,					/* >> */
						AEGP_CompFlags		*comp_flagsP);			/* << */

	SPAPI A_Err	(*AEGP_GetCompFramerate)(
						AEGP_CompH			compH,					/* >> */
						A_FpLong			*fpsPF);				/* << */

	SPAPI A_Err	(*AEGP_GetCompShutterAnglePhase)(
						AEGP_CompH			compH,					/* >> */
						A_Ratio				*angle,					/* << */
						A_Ratio				*phase);				/* << */

	SPAPI A_Err	(*AEGP_GetCompShutterFrameRange)(
						AEGP_CompH			compH,					/* >> */
						const A_Time		*comp_timeP,			/* >> */
						A_Time				*start,					/* << */
						A_Time				*duration);				/* << */

	SPAPI A_Err	(*AEGP_GetCompWorkAreaStart)(
						AEGP_CompH			compH,					/* >> */
						A_Time 				*work_area_startPT);	/* << */

	SPAPI A_Err	(*AEGP_GetCompWorkAreaDuration)(
						AEGP_CompH			compH,					/* >> */
						A_Time 				*work_area_durationPT);	/* << */

	SPAPI A_Err	(*AEGP_SetCompWorkAreaStartAndDuration)(			/* UNDOABLE */
						AEGP_CompH			compH,					/* >> */
						A_Time 				*work_area_startPT,		/* >> */
						A_Time 				*work_area_durationPT);	/* >> */

	SPAPI A_Err (*AEGP_CreateSolidInComp)(
						const A_char		*nameZ,					/* >> */
						A_long				width,					/* >> */
						A_long				height,					/* >> */
						const AEGP_ColorVal	*color,					/* >> */
						AEGP_ItemH			parent_compH,			/* >> */
						AEGP_LayerH			*new_solidPH);			/* << */

	SPAPI A_Err (*AEGP_CreateComp)(
						AEGP_ItemH			parent_folderH0,		/* >> */
						const A_char		*nameZ,					/* >> */
						A_long				widthL,					/* >> */
						A_long				heightL,				/* >> */
						const A_Ratio		*pixel_aspect_ratioPRt,	/* >> */
						const A_Time		*durationPT,			/* >> */
						const A_Ratio		*frameratePRt,			/* >> */
						AEGP_ItemH			*new_compPH);			/* << */

	SPAPI A_Err	(*AEGP_GetNewCollectionFromCompSelection)(
						AEGP_PluginID		plugin_id,				/* >> */
						AEGP_CompH			compH,					/* >> */
						AEGP_CollectionH	*collectionPH);			/* << */

	SPAPI A_Err (*AEGP_SetSelection)(
						AEGP_CompH	compH,							/* >> */
						AEGP_CollectionH collectionH);				/* >> not adopted */

	SPAPI A_Err (*AEGP_SetCompDisplayStartTime)(					/*	NOT Undoable! */
						AEGP_CompH			compH,					/* >> */
						const A_Time		*start_timePT);			/* >> */

	SPAPI A_Err (*AEGP_SetCompDuration)(
						AEGP_CompH			compH,					/* >> */
						const A_Time		*durationPT);			/* >> */
} AEGP_CompSuite1;



#define kAEGPLayerSuite				"AEGP Layer Suite"

#define kAEGPLayerSuiteVersion8		14	/* frozen AE 12.0 x300 */

typedef struct AEGP_LayerSuite8 {

	SPAPI A_Err	(*AEGP_GetCompNumLayers)(
						AEGP_CompH			compH,					/* >> */
						A_long				*num_layersPL);			/* << */

	SPAPI A_Err	(*AEGP_GetCompLayerByIndex)(
						AEGP_CompH			compH,					/* >> */
						A_long				layer_indexL,			/* >> */
						AEGP_LayerH			*layerPH);				/* << */

	SPAPI A_Err	(*AEGP_GetActiveLayer)(
						AEGP_LayerH			*layerPH);				/* << returns non null only if one layer is selected */

	SPAPI A_Err	(*AEGP_GetLayerIndex)(
						AEGP_LayerH			layerH,					/* >> */
						A_long				*layer_indexPL);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerSourceItem)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_ItemH			*source_itemPH);		/* << */

	SPAPI A_Err (*AEGP_GetLayerSourceItemID)(
						AEGP_LayerH			layerH,					/* >> */
						A_long				*source_item_idPL);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerParentComp)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_CompH			*compPH);				/* << */

	SPAPI A_Err	(*AEGP_GetLayerName)(
						AEGP_PluginID			pluginID,				// in
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_MemHandle		*utf_layer_namePH0,		// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle
						AEGP_MemHandle		*utf_source_namePH0);	// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle

	SPAPI A_Err	(*AEGP_GetLayerQuality)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerQuality	*qualityP);				/* << */

	SPAPI A_Err	(*AEGP_SetLayerQuality)(							/* UNDOABLE */
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerQuality	quality);				/* >> */

	SPAPI A_Err	(*AEGP_GetLayerFlags)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerFlags		*layer_flagsP);			/* << */

	SPAPI A_Err (*AEGP_SetLayerFlag)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerFlags		single_flag,			/* >> */
						A_Boolean			valueB);				/* >> */

	SPAPI A_Err	(*AEGP_IsLayerVideoReallyOn)(						// accounts for solo status of other layers in comp
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			*onPB);					/* << */

	SPAPI A_Err	(*AEGP_IsLayerAudioReallyOn)(						// accounts for solo status of other layers in comp
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			*onPB);					/* << */

	SPAPI A_Err	(*AEGP_GetLayerCurrentTime)(						// not updated while rendering
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						A_Time 				*curr_timePT);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerInPoint)(
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						A_Time 				*in_pointPT);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerDuration)(
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						A_Time 				*durationPT);			/* << */

	SPAPI A_Err	(*AEGP_SetLayerInPointAndDuration)(					/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						const A_Time 		*in_pointPT,			/* >> */
						const A_Time 		*durationPT);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerOffset)(
						AEGP_LayerH 		layerH,					/* >> */
						A_Time 				*offsetPT);				/* << always in comp time */

	SPAPI A_Err	(*AEGP_SetLayerOffset)(								/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						const A_Time 		*offsetPT);				/* >> always in comp time */

	SPAPI A_Err	(*AEGP_GetLayerStretch)(
						AEGP_LayerH 		layerH,					/* >> */
						A_Ratio 			*stretchPRt);			/* << */

	SPAPI A_Err	(*AEGP_SetLayerStretch)(							/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						const A_Ratio 		*stretchPRt);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerTransferMode)(
						AEGP_LayerH 			layerH,				/* >> */
						AEGP_LayerTransferMode	*transfer_modeP);	/* << */

	SPAPI A_Err	(*AEGP_SetLayerTransferMode)(								/* UNDOABLE */
						AEGP_LayerH 					layerH,				/* >> */
						const AEGP_LayerTransferMode	*transfer_modeP);	/* >> */

	SPAPI A_Err	(*AEGP_IsAddLayerValid)(
						AEGP_ItemH 			item_to_addH,			/* >> */
						AEGP_CompH 			into_compH,				/* >> */
						A_Boolean			*validPB);				/* << */

	SPAPI A_Err	(*AEGP_AddLayer)(									/* UNDOABLE */
						AEGP_ItemH 			item_to_addH,			/* >> check AEGP_IsAddLayerValid() before using */
						AEGP_CompH 			into_compH,				/* >> */
						AEGP_LayerH			*added_layerPH0);		/* << */

	SPAPI A_Err	(*AEGP_ReorderLayer)(								/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						A_long 				layer_indexL);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerMaskedBounds)(
						AEGP_LayerH 		layerH,			/* >> */
						AEGP_LTimeMode		time_mode,		/* >> */
						const A_Time	 	*timePT,		/* >> */
						A_FloatRect			*boundsPR);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerObjectType)(
						AEGP_LayerH 		layerH,				/* >> */
						AEGP_ObjectType 	*object_type);		/* << */

	SPAPI A_Err	(*AEGP_IsLayer3D)(
						AEGP_LayerH 		layerH,				/* >> */
						A_Boolean 			*is_3DPB);			/* << */

	SPAPI A_Err	(*AEGP_IsLayer2D)(
						AEGP_LayerH 		layerH,				/* >> */
						A_Boolean 			*is_2DPB);			/* << */

	SPAPI A_Err	(*AEGP_IsVideoActive)(
						AEGP_LayerH 		layerH,				/* >> */
						AEGP_LTimeMode		time_mode,			/* >> */
						const A_Time	 	*timePT,			/* >> */
						A_Boolean			*is_activePB);		/* << */

	SPAPI A_Err	(*AEGP_IsLayerUsedAsTrackMatte)(
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			fill_must_be_activeB,	/* >> */
						A_Boolean			*is_track_mattePB);		/* << */

	SPAPI A_Err	(*AEGP_DoesLayerHaveTrackMatte)(
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			*has_track_mattePB);	/* << */

	SPAPI A_Err	(*AEGP_ConvertCompToLayerTime)(
					AEGP_LayerH		layerH,							/* >> */
					const A_Time	*comp_timePT,					/* >> */
					A_Time			*layer_timePT);					/* << */

	SPAPI A_Err	(*AEGP_ConvertLayerToCompTime)(
					AEGP_LayerH		layerH,							/* >> */
					const A_Time	*layer_timePT,					/* >> */
					A_Time			*comp_timePT) ;					/* << */

	SPAPI A_Err	(*AEGP_GetLayerDancingRandValue)(
					AEGP_LayerH		layerH,							/* >> */
					const A_Time	*comp_timePT,					/* >> */
					A_long			*rand_valuePL);					/* << */

	SPAPI A_Err	(*AEGP_GetLayerID)(
					AEGP_LayerH				layerH,				/* >> */
					AEGP_LayerIDVal			*id_valP);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerToWorldXform)(
				AEGP_LayerH				aegp_layerH,		/* >> */
				const A_Time			*comp_timeP,		/* >> */
				A_Matrix4				*transform);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerToWorldXformFromView)(
				AEGP_LayerH				aegp_layerH,		/* >> */
				const A_Time			*view_timeP,		/* >> */
				const A_Time			*comp_timeP,		/* >> */
				A_Matrix4				*transform);		/* << */

	SPAPI A_Err (*AEGP_SetLayerName)(
				AEGP_LayerH				aegp_layerH,		/* >> */
				const A_UTF16Char		*new_nameZ);				/* >> null terminated UTF16 */

	SPAPI A_Err	(*AEGP_GetLayerParent)(
				const AEGP_LayerH		layerH,				/* >> */
				AEGP_LayerH				*parent_layerPH);	/* << NULL if no parent */

	SPAPI A_Err (*AEGP_SetLayerParent)(
				AEGP_LayerH				layerH,				/* >> */
				const AEGP_LayerH		parent_layerH0);	/* >> */

	SPAPI A_Err (*AEGP_DeleteLayer)(
				AEGP_LayerH				layerH);			/* >>  	UNDOABLE */

	SPAPI A_Err (*AEGP_DuplicateLayer)(
				AEGP_LayerH				orig_layerH,			/* >> */
				AEGP_LayerH				*duplicate_layerPH);	/* << */

	SPAPI A_Err (*AEGP_GetLayerFromLayerID)(
				AEGP_CompH				parent_compH,			/* >> */
				AEGP_LayerIDVal			id,						/* >> */
				AEGP_LayerH				*layerPH);				/* << */

	SPAPI A_Err (*AEGP_GetLayerLabel)(
				AEGP_LayerH				layerH,					/* >> */
				AEGP_LabelID			*labelP);				/* << */

	SPAPI A_Err (*AEGP_SetLayerLabel)(		/* UNDOABLE */
				AEGP_LayerH				layerH,					/* >> */
				AEGP_LabelID			label);					/* >> */

	SPAPI A_Err	(*AEGP_GetLayerSamplingQuality)(
				AEGP_LayerH					layerH,					/* >> */
				AEGP_LayerSamplingQuality	*qualityP);				/* << */

	/* Option is explicitly set on the layer independent of layer quality. 
	If you want to force it on you must also set the layer quality to 
	AEGP_LayerQual_BEST with AEGP_SetLayerQuality. Otherwise it will only be using
	the specified layer sampling quality whenever the layer quality is set to AEGP_LayerQual_BEST*/
	SPAPI A_Err	(*AEGP_SetLayerSamplingQuality)(			/* UNDOABLE */
				AEGP_LayerH					layerH,					/* >> */
				AEGP_LayerSamplingQuality	quality);				/* >> */

} AEGP_LayerSuite8;


#define kAEGPLayerSuiteVersion7		13	/* frozen AE 10.0 build 396 */

typedef struct AEGP_LayerSuite7 {

	SPAPI A_Err	(*AEGP_GetCompNumLayers)(
						AEGP_CompH			compH,					/* >> */
						A_long				*num_layersPL);			/* << */

	SPAPI A_Err	(*AEGP_GetCompLayerByIndex)(
						AEGP_CompH			compH,					/* >> */
						A_long				layer_indexL,			/* >> */
						AEGP_LayerH			*layerPH);				/* << */

	SPAPI A_Err	(*AEGP_GetActiveLayer)(
						AEGP_LayerH			*layerPH);				/* << returns non null only if one layer is selected */

	SPAPI A_Err	(*AEGP_GetLayerIndex)(
						AEGP_LayerH			layerH,					/* >> */
						A_long				*layer_indexPL);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerSourceItem)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_ItemH			*source_itemPH);		/* << */

	SPAPI A_Err (*AEGP_GetLayerSourceItemID)(
						AEGP_LayerH			layerH,					/* >> */
						A_long				*source_item_idPL);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerParentComp)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_CompH			*compPH);				/* << */

	SPAPI A_Err	(*AEGP_GetLayerName)(
						AEGP_PluginID			pluginID,				// in
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_MemHandle		*utf_layer_namePH0,		// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle
						AEGP_MemHandle		*utf_source_namePH0);	// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle

	SPAPI A_Err	(*AEGP_GetLayerQuality)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerQuality	*qualityP);				/* << */

	SPAPI A_Err	(*AEGP_SetLayerQuality)(							/* UNDOABLE */
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerQuality	quality);				/* >> */

	SPAPI A_Err	(*AEGP_GetLayerFlags)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerFlags		*layer_flagsP);			/* << */

	SPAPI A_Err (*AEGP_SetLayerFlag)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerFlags		single_flag,			/* >> */
						A_Boolean			valueB);				/* >> */

	SPAPI A_Err	(*AEGP_IsLayerVideoReallyOn)(						// accounts for solo status of other layers in comp
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			*onPB);					/* << */

	SPAPI A_Err	(*AEGP_IsLayerAudioReallyOn)(						// accounts for solo status of other layers in comp
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			*onPB);					/* << */

	SPAPI A_Err	(*AEGP_GetLayerCurrentTime)(						// not updated while rendering
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						A_Time 				*curr_timePT);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerInPoint)(
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						A_Time 				*in_pointPT);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerDuration)(
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						A_Time 				*durationPT);			/* << */

	SPAPI A_Err	(*AEGP_SetLayerInPointAndDuration)(					/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						const A_Time 		*in_pointPT,			/* >> */
						const A_Time 		*durationPT);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerOffset)(
						AEGP_LayerH 		layerH,					/* >> */
						A_Time 				*offsetPT);				/* << always in comp time */

	SPAPI A_Err	(*AEGP_SetLayerOffset)(								/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						const A_Time 		*offsetPT);				/* >> always in comp time */

	SPAPI A_Err	(*AEGP_GetLayerStretch)(
						AEGP_LayerH 		layerH,					/* >> */
						A_Ratio 			*stretchPRt);			/* << */

	SPAPI A_Err	(*AEGP_SetLayerStretch)(							/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						const A_Ratio 		*stretchPRt);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerTransferMode)(
						AEGP_LayerH 			layerH,				/* >> */
						AEGP_LayerTransferMode	*transfer_modeP);	/* << */

	SPAPI A_Err	(*AEGP_SetLayerTransferMode)(								/* UNDOABLE */
						AEGP_LayerH 					layerH,				/* >> */
						const AEGP_LayerTransferMode	*transfer_modeP);	/* >> */

	SPAPI A_Err	(*AEGP_IsAddLayerValid)(
						AEGP_ItemH 			item_to_addH,			/* >> */
						AEGP_CompH 			into_compH,				/* >> */
						A_Boolean			*validPB);				/* << */

	SPAPI A_Err	(*AEGP_AddLayer)(									/* UNDOABLE */
						AEGP_ItemH 			item_to_addH,			/* >> check AEGP_IsAddLayerValid() before using */
						AEGP_CompH 			into_compH,				/* >> */
						AEGP_LayerH			*added_layerPH0);		/* << */

	SPAPI A_Err	(*AEGP_ReorderLayer)(								/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						A_long 				layer_indexL);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerMaskedBounds)(
						AEGP_LayerH 		layerH,			/* >> */
						AEGP_LTimeMode		time_mode,		/* >> */
						const A_Time	 	*timePT,		/* >> */
						A_FloatRect			*boundsPR);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerObjectType)(
						AEGP_LayerH 		layerH,				/* >> */
						AEGP_ObjectType 	*object_type);		/* << */

	SPAPI A_Err	(*AEGP_IsLayer3D)(
						AEGP_LayerH 		layerH,				/* >> */
						A_Boolean 			*is_3DPB);			/* << */

	SPAPI A_Err	(*AEGP_IsLayer2D)(
						AEGP_LayerH 		layerH,				/* >> */
						A_Boolean 			*is_2DPB);			/* << */

	SPAPI A_Err	(*AEGP_IsVideoActive)(
						AEGP_LayerH 		layerH,				/* >> */
						AEGP_LTimeMode		time_mode,			/* >> */
						const A_Time	 	*timePT,			/* >> */
						A_Boolean			*is_activePB);		/* << */

	SPAPI A_Err	(*AEGP_IsLayerUsedAsTrackMatte)(
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			fill_must_be_activeB,	/* >> */
						A_Boolean			*is_track_mattePB);		/* << */

	SPAPI A_Err	(*AEGP_DoesLayerHaveTrackMatte)(
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			*has_track_mattePB);	/* << */

	SPAPI A_Err	(*AEGP_ConvertCompToLayerTime)(
					AEGP_LayerH		layerH,							/* >> */
					const A_Time	*comp_timePT,					/* >> */
					A_Time			*layer_timePT);					/* << */

	SPAPI A_Err	(*AEGP_ConvertLayerToCompTime)(
					AEGP_LayerH		layerH,							/* >> */
					const A_Time	*layer_timePT,					/* >> */
					A_Time			*comp_timePT) ;					/* << */

	SPAPI A_Err	(*AEGP_GetLayerDancingRandValue)(
					AEGP_LayerH		layerH,							/* >> */
					const A_Time	*comp_timePT,					/* >> */
					A_long			*rand_valuePL);					/* << */

	SPAPI A_Err	(*AEGP_GetLayerID)(
					AEGP_LayerH				layerH,				/* >> */
					AEGP_LayerIDVal			*id_valP);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerToWorldXform)(
				AEGP_LayerH				aegp_layerH,		/* >> */
				const A_Time			*comp_timeP,		/* >> */
				A_Matrix4				*transform);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerToWorldXformFromView)(
				AEGP_LayerH				aegp_layerH,		/* >> */
				const A_Time			*view_timeP,		/* >> */
				const A_Time			*comp_timeP,		/* >> */
				A_Matrix4				*transform);		/* << */

	SPAPI A_Err (*AEGP_SetLayerName)(
				AEGP_LayerH				aegp_layerH,		/* >> */
				const A_UTF16Char		*new_nameZ);				/* >> null terminated UTF16 */

	SPAPI A_Err	(*AEGP_GetLayerParent)(
				const AEGP_LayerH		layerH,				/* >> */
				AEGP_LayerH				*parent_layerPH);	/* << NULL if no parent */

	SPAPI A_Err (*AEGP_SetLayerParent)(
				AEGP_LayerH				layerH,				/* >> */
				const AEGP_LayerH		parent_layerH0);	/* >> */

	SPAPI A_Err (*AEGP_DeleteLayer)(
				AEGP_LayerH				layerH);			/* >>  	UNDOABLE */

	SPAPI A_Err (*AEGP_DuplicateLayer)(
				AEGP_LayerH				orig_layerH,			/* >> */
				AEGP_LayerH				*duplicate_layerPH);	/* << */

	SPAPI A_Err (*AEGP_GetLayerFromLayerID)(
				AEGP_CompH				parent_compH,			/* >> */
				AEGP_LayerIDVal			id,						/* >> */
				AEGP_LayerH				*layerPH);				/* << */

	SPAPI A_Err (*AEGP_GetLayerLabel)(
				AEGP_LayerH				layerH,					/* >> */
				AEGP_LabelID			*labelP);				/* << */

	SPAPI A_Err (*AEGP_SetLayerLabel)(		/* UNDOABLE */
				AEGP_LayerH				layerH,					/* >> */
				AEGP_LabelID			label);					/* >> */

} AEGP_LayerSuite7;


#define kAEGPLayerSuiteVersion6		12	/* frozen AE 9.0 */

typedef struct AEGP_LayerSuite6 {

	SPAPI A_Err	(*AEGP_GetCompNumLayers)(
		AEGP_CompH			compH,					/* >> */
		A_long				*num_layersPL);			/* << */

	SPAPI A_Err	(*AEGP_GetCompLayerByIndex)(
		AEGP_CompH			compH,					/* >> */
		A_long				layer_indexL,			/* >> */
		AEGP_LayerH			*layerPH);				/* << */

	SPAPI A_Err	(*AEGP_GetActiveLayer)(
		AEGP_LayerH			*layerPH);				/* << returns non null only if one layer is selected */

	SPAPI A_Err	(*AEGP_GetLayerIndex)(
		AEGP_LayerH			layerH,					/* >> */
		A_long				*layer_indexPL);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerSourceItem)(
		AEGP_LayerH			layerH,					/* >> */
		AEGP_ItemH			*source_itemPH);		/* << */

	SPAPI A_Err (*AEGP_GetLayerSourceItemID)(
		AEGP_LayerH			layerH,					/* >> */
		A_long				*source_item_idPL);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerParentComp)(
		AEGP_LayerH			layerH,					/* >> */
		AEGP_CompH			*compPH);				/* << */

	SPAPI A_Err	(*AEGP_GetLayerName)(
		AEGP_PluginID			pluginID,				// in
		AEGP_LayerH 		layerH,					/* >> */
		AEGP_MemHandle		*utf_layer_namePH0,		// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle
		AEGP_MemHandle		*utf_source_namePH0);	// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle

	SPAPI A_Err	(*AEGP_GetLayerQuality)(
		AEGP_LayerH			layerH,					/* >> */
		AEGP_LayerQuality	*qualityP);				/* << */

	SPAPI A_Err	(*AEGP_SetLayerQuality)(							/* UNDOABLE */
		AEGP_LayerH			layerH,					/* >> */
		AEGP_LayerQuality	quality);				/* >> */

	SPAPI A_Err	(*AEGP_GetLayerFlags)(
		AEGP_LayerH			layerH,					/* >> */
		AEGP_LayerFlags		*layer_flagsP);			/* << */

	SPAPI A_Err (*AEGP_SetLayerFlag)(
		AEGP_LayerH			layerH,					/* >> */
		AEGP_LayerFlags		single_flag,			/* >> */
		A_Boolean			valueB);				/* >> */

	SPAPI A_Err	(*AEGP_IsLayerVideoReallyOn)(						// accounts for solo status of other layers in comp
		AEGP_LayerH			layerH,					/* >> */
		A_Boolean			*onPB);					/* << */

	SPAPI A_Err	(*AEGP_IsLayerAudioReallyOn)(						// accounts for solo status of other layers in comp
		AEGP_LayerH			layerH,					/* >> */
		A_Boolean			*onPB);					/* << */

	SPAPI A_Err	(*AEGP_GetLayerCurrentTime)(						// not updated while rendering
		AEGP_LayerH 		layerH,					/* >> */
		AEGP_LTimeMode		time_mode,				/* >> */
		A_Time 				*curr_timePT);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerInPoint)(
		AEGP_LayerH 		layerH,					/* >> */
		AEGP_LTimeMode		time_mode,				/* >> */
		A_Time 				*in_pointPT);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerDuration)(
		AEGP_LayerH 		layerH,					/* >> */
		AEGP_LTimeMode		time_mode,				/* >> */
		A_Time 				*durationPT);			/* << */

	SPAPI A_Err	(*AEGP_SetLayerInPointAndDuration)(					/* UNDOABLE */
		AEGP_LayerH 		layerH,					/* >> */
		AEGP_LTimeMode		time_mode,				/* >> */
		const A_Time 		*in_pointPT,			/* >> */
		const A_Time 		*durationPT);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerOffset)(
		AEGP_LayerH 		layerH,					/* >> */
		A_Time 				*offsetPT);				/* << always in comp time */

	SPAPI A_Err	(*AEGP_SetLayerOffset)(								/* UNDOABLE */
		AEGP_LayerH 		layerH,					/* >> */
		const A_Time 		*offsetPT);				/* >> always in comp time */

	SPAPI A_Err	(*AEGP_GetLayerStretch)(
		AEGP_LayerH 		layerH,					/* >> */
		A_Ratio 			*stretchPRt);			/* << */

	SPAPI A_Err	(*AEGP_SetLayerStretch)(							/* UNDOABLE */
		AEGP_LayerH 		layerH,					/* >> */
		const A_Ratio 		*stretchPRt);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerTransferMode)(
		AEGP_LayerH 			layerH,				/* >> */
		AEGP_LayerTransferMode	*transfer_modeP);	/* << */

	SPAPI A_Err	(*AEGP_SetLayerTransferMode)(								/* UNDOABLE */
		AEGP_LayerH 					layerH,				/* >> */
		const AEGP_LayerTransferMode	*transfer_modeP);	/* >> */

	SPAPI A_Err	(*AEGP_IsAddLayerValid)(
		AEGP_ItemH 			item_to_addH,			/* >> */
		AEGP_CompH 			into_compH,				/* >> */
		A_Boolean			*validPB);				/* << */

	SPAPI A_Err	(*AEGP_AddLayer)(									/* UNDOABLE */
		AEGP_ItemH 			item_to_addH,			/* >> check AEGP_IsAddLayerValid() before using */
		AEGP_CompH 			into_compH,				/* >> */
		AEGP_LayerH			*added_layerPH0);		/* << */

	SPAPI A_Err	(*AEGP_ReorderLayer)(								/* UNDOABLE */
		AEGP_LayerH 		layerH,					/* >> */
		A_long 				layer_indexL);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerMaskedBounds)(
		AEGP_LayerH 		layerH,			/* >> */
		AEGP_LTimeMode		time_mode,		/* >> */
		const A_Time	 	*timePT,		/* >> */
		A_FloatRect			*boundsPR);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerObjectType)(
		AEGP_LayerH 		layerH,				/* >> */
		AEGP_ObjectType 	*object_type);		/* << */

	SPAPI A_Err	(*AEGP_IsLayer3D)(
		AEGP_LayerH 		layerH,				/* >> */
		A_Boolean 			*is_3DPB);			/* << */

	SPAPI A_Err	(*AEGP_IsLayer2D)(
		AEGP_LayerH 		layerH,				/* >> */
		A_Boolean 			*is_2DPB);			/* << */

	SPAPI A_Err	(*AEGP_IsVideoActive)(
		AEGP_LayerH 		layerH,				/* >> */
		AEGP_LTimeMode		time_mode,			/* >> */
		const A_Time	 	*timePT,			/* >> */
		A_Boolean			*is_activePB);		/* << */

	SPAPI A_Err	(*AEGP_IsLayerUsedAsTrackMatte)(
		AEGP_LayerH			layerH,					/* >> */
		A_Boolean			fill_must_be_activeB,	/* >> */
		A_Boolean			*is_track_mattePB);		/* << */

	SPAPI A_Err	(*AEGP_DoesLayerHaveTrackMatte)(
		AEGP_LayerH			layerH,					/* >> */
		A_Boolean			*has_track_mattePB);	/* << */

	SPAPI A_Err	(*AEGP_ConvertCompToLayerTime)(
		AEGP_LayerH		layerH,							/* >> */
		const A_Time	*comp_timePT,					/* >> */
		A_Time			*layer_timePT);					/* << */

	SPAPI A_Err	(*AEGP_ConvertLayerToCompTime)(
		AEGP_LayerH		layerH,							/* >> */
		const A_Time	*layer_timePT,					/* >> */
		A_Time			*comp_timePT) ;					/* << */

	SPAPI A_Err	(*AEGP_GetLayerDancingRandValue)(
		AEGP_LayerH		layerH,							/* >> */
		const A_Time	*comp_timePT,					/* >> */
		A_long			*rand_valuePL);					/* << */

	SPAPI A_Err	(*AEGP_GetLayerID)(
		AEGP_LayerH				layerH,				/* >> */
		AEGP_LayerIDVal			*id_valP);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerToWorldXform)(
		AEGP_LayerH				aegp_layerH,		/* >> */
		const A_Time			*comp_timeP,		/* >> */
		A_Matrix4				*transform);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerToWorldXformFromView)(
		AEGP_LayerH				aegp_layerH,		/* >> */
		const A_Time			*view_timeP,		/* >> */
		const A_Time			*comp_timeP,		/* >> */
		A_Matrix4				*transform);		/* << */

	SPAPI A_Err (*AEGP_SetLayerName)(
		AEGP_LayerH				aegp_layerH,		/* >> */
		const A_UTF16Char		*new_nameZ);				/* >> null terminated UTF16 */

	SPAPI A_Err	(*AEGP_GetLayerParent)(
		const AEGP_LayerH		layerH,				/* >> */
		AEGP_LayerH				*parent_layerPH);	/* << NULL if no parent */

	SPAPI A_Err (*AEGP_SetLayerParent)(
		AEGP_LayerH				layerH,				/* >> */
		const AEGP_LayerH		parent_layerH0);	/* >> */

	SPAPI A_Err (*AEGP_DeleteLayer)(
		AEGP_LayerH				layerH);			/* >>  	UNDOABLE */

	SPAPI A_Err (*AEGP_DuplicateLayer)(
		AEGP_LayerH				orig_layerH,			/* >> */
		AEGP_LayerH				*duplicate_layerPH);	/* << */

	SPAPI A_Err (*AEGP_GetLayerFromLayerID)(
		AEGP_CompH				parent_compH,			/* >> */
		AEGP_LayerIDVal			id,						/* >> */
		AEGP_LayerH				*layerPH);				/* << */

} AEGP_LayerSuite6;


#define kAEGPLayerSuiteVersion5		11	/* frozen AE 7.0 */

typedef struct AEGP_LayerSuite5 {

	SPAPI A_Err	(*AEGP_GetCompNumLayers)(
		AEGP_CompH			compH,					/* >> */
		A_long				*num_layersPL);			/* << */

	SPAPI A_Err	(*AEGP_GetCompLayerByIndex)(
		AEGP_CompH			compH,					/* >> */
		A_long				layer_indexL,			/* >> */
		AEGP_LayerH			*layerPH);				/* << */

	SPAPI A_Err	(*AEGP_GetActiveLayer)(
		AEGP_LayerH			*layerPH);				/* << returns non null only if one layer is selected */

	SPAPI A_Err	(*AEGP_GetLayerIndex)(
		AEGP_LayerH			layerH,					/* >> */
		A_long				*layer_indexPL);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerSourceItem)(
		AEGP_LayerH			layerH,					/* >> */
		AEGP_ItemH			*source_itemPH);		/* << */

	SPAPI A_Err (*AEGP_GetLayerSourceItemID)(
		AEGP_LayerH			layerH,					/* >> */
		A_long				*source_item_idPL);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerParentComp)(
		AEGP_LayerH			layerH,					/* >> */
		AEGP_CompH			*compPH);				/* << */

	SPAPI A_Err	(*AEGP_GetLayerName)(
		AEGP_LayerH 		layerH,					/* >> */
		A_char				*layer_nameZ0,			/* << space for A_char[AEGP_MAX_LAYER_NAME_MB_SIZE] */
		A_char				*source_nameZ0);		/* << space for A_char[AEGP_MAX_LAYER_NAME_MB_SIZE] */

	SPAPI A_Err	(*AEGP_GetLayerQuality)(
		AEGP_LayerH			layerH,					/* >> */
		AEGP_LayerQuality	*qualityP);				/* << */

	SPAPI A_Err	(*AEGP_SetLayerQuality)(							/* UNDOABLE */
		AEGP_LayerH			layerH,					/* >> */
		AEGP_LayerQuality	quality);				/* >> */

	SPAPI A_Err	(*AEGP_GetLayerFlags)(
		AEGP_LayerH			layerH,					/* >> */
		AEGP_LayerFlags		*layer_flagsP);			/* << */

	SPAPI A_Err (*AEGP_SetLayerFlag)(
		AEGP_LayerH			layerH,					/* >> */
		AEGP_LayerFlags		single_flag,			/* >> */
		A_Boolean			valueB);				/* >> */

	SPAPI A_Err	(*AEGP_IsLayerVideoReallyOn)(						// accounts for solo status of other layers in comp
		AEGP_LayerH			layerH,					/* >> */
		A_Boolean			*onPB);					/* << */

	SPAPI A_Err	(*AEGP_IsLayerAudioReallyOn)(						// accounts for solo status of other layers in comp
		AEGP_LayerH			layerH,					/* >> */
		A_Boolean			*onPB);					/* << */

	SPAPI A_Err	(*AEGP_GetLayerCurrentTime)(						// not updated while rendering
		AEGP_LayerH 		layerH,					/* >> */
		AEGP_LTimeMode		time_mode,				/* >> */
		A_Time 				*curr_timePT);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerInPoint)(
		AEGP_LayerH 		layerH,					/* >> */
		AEGP_LTimeMode		time_mode,				/* >> */
		A_Time 				*in_pointPT);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerDuration)(
		AEGP_LayerH 		layerH,					/* >> */
		AEGP_LTimeMode		time_mode,				/* >> */
		A_Time 				*durationPT);			/* << */

	SPAPI A_Err	(*AEGP_SetLayerInPointAndDuration)(					/* UNDOABLE */
		AEGP_LayerH 		layerH,					/* >> */
		AEGP_LTimeMode		time_mode,				/* >> */
		const A_Time 		*in_pointPT,			/* >> */
		const A_Time 		*durationPT);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerOffset)(
		AEGP_LayerH 		layerH,					/* >> */
		A_Time 				*offsetPT);				/* << always in comp time */

	SPAPI A_Err	(*AEGP_SetLayerOffset)(								/* UNDOABLE */
		AEGP_LayerH 		layerH,					/* >> */
		const A_Time 		*offsetPT);				/* >> always in comp time */

	SPAPI A_Err	(*AEGP_GetLayerStretch)(
		AEGP_LayerH 		layerH,					/* >> */
		A_Ratio 			*stretchPRt);			/* << */

	SPAPI A_Err	(*AEGP_SetLayerStretch)(							/* UNDOABLE */
		AEGP_LayerH 		layerH,					/* >> */
		const A_Ratio 		*stretchPRt);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerTransferMode)(
		AEGP_LayerH 			layerH,				/* >> */
		AEGP_LayerTransferMode	*transfer_modeP);	/* << */

	SPAPI A_Err	(*AEGP_SetLayerTransferMode)(								/* UNDOABLE */
		AEGP_LayerH 					layerH,				/* >> */
		const AEGP_LayerTransferMode	*transfer_modeP);	/* >> */

	SPAPI A_Err	(*AEGP_IsAddLayerValid)(
		AEGP_ItemH 			item_to_addH,			/* >> */
		AEGP_CompH 			into_compH,				/* >> */
		A_Boolean			*validPB);				/* << */

	SPAPI A_Err	(*AEGP_AddLayer)(									/* UNDOABLE */
		AEGP_ItemH 			item_to_addH,			/* >> check AEGP_IsAddLayerValid() before using */
		AEGP_CompH 			into_compH,				/* >> */
		AEGP_LayerH			*added_layerPH0);		/* << */

	SPAPI A_Err	(*AEGP_ReorderLayer)(								/* UNDOABLE */
		AEGP_LayerH 		layerH,					/* >> */
		A_long 				layer_indexL);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerMaskedBounds)(
		AEGP_LayerH 		layerH,			/* >> */
		AEGP_LTimeMode		time_mode,		/* >> */
		const A_Time	 	*timePT,		/* >> */
		A_FloatRect			*boundsPR);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerObjectType)(
		AEGP_LayerH 		layerH,				/* >> */
		AEGP_ObjectType 	*object_type);		/* << */

	SPAPI A_Err	(*AEGP_IsLayer3D)(
		AEGP_LayerH 		layerH,				/* >> */
		A_Boolean 			*is_3DPB);			/* << */

	SPAPI A_Err	(*AEGP_IsLayer2D)(
		AEGP_LayerH 		layerH,				/* >> */
		A_Boolean 			*is_2DPB);			/* << */

	SPAPI A_Err	(*AEGP_IsVideoActive)(
		AEGP_LayerH 		layerH,				/* >> */
		AEGP_LTimeMode		time_mode,			/* >> */
		const A_Time	 	*timePT,			/* >> */
		A_Boolean			*is_activePB);		/* << */

	SPAPI A_Err	(*AEGP_IsLayerUsedAsTrackMatte)(
		AEGP_LayerH			layerH,					/* >> */
		A_Boolean			fill_must_be_activeB,	/* >> */
		A_Boolean			*is_track_mattePB);		/* << */

	SPAPI A_Err	(*AEGP_DoesLayerHaveTrackMatte)(
		AEGP_LayerH			layerH,					/* >> */
		A_Boolean			*has_track_mattePB);	/* << */

	SPAPI A_Err	(*AEGP_ConvertCompToLayerTime)(
		AEGP_LayerH		layerH,							/* >> */
		const A_Time	*comp_timePT,					/* >> */
		A_Time			*layer_timePT);					/* << */

	SPAPI A_Err	(*AEGP_ConvertLayerToCompTime)(
		AEGP_LayerH		layerH,							/* >> */
		const A_Time	*layer_timePT,					/* >> */
		A_Time			*comp_timePT) ;					/* << */

	SPAPI A_Err	(*AEGP_GetLayerDancingRandValue)(
		AEGP_LayerH		layerH,							/* >> */
		const A_Time	*comp_timePT,					/* >> */
		A_long			*rand_valuePL);					/* << */

	SPAPI A_Err	(*AEGP_GetLayerID)(
		AEGP_LayerH				layerH,				/* >> */
		AEGP_LayerIDVal			*id_valP);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerToWorldXform)(
		AEGP_LayerH				aegp_layerH,		/* >> */
		const A_Time			*comp_timeP,		/* >> */
		A_Matrix4				*transform);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerToWorldXformFromView)(
		AEGP_LayerH				aegp_layerH,		/* >> */
		const A_Time			*view_timeP,		/* >> */
		const A_Time			*comp_timeP,		/* >> */
		A_Matrix4				*transform);		/* << */

	SPAPI A_Err (*AEGP_SetLayerName)(
		AEGP_LayerH				aegp_layerH,		/* >> */
		const A_char			*new_nameZ);		/* >> */

	SPAPI A_Err	(*AEGP_GetLayerParent)(
		const AEGP_LayerH		layerH,				/* >> */
		AEGP_LayerH				*parent_layerPH);	/* << NULL if no parent */

	SPAPI A_Err (*AEGP_SetLayerParent)(
		AEGP_LayerH				layerH,				/* >> */
		const AEGP_LayerH		parent_layerH0);	/* >> */

	SPAPI A_Err (*AEGP_DeleteLayer)(
		AEGP_LayerH				layerH);			/* >>  	UNDOABLE */

	SPAPI A_Err (*AEGP_DuplicateLayer)(
		AEGP_LayerH				orig_layerH,			/* >> */
		AEGP_LayerH				*duplicate_layerPH);	/* << */

	SPAPI A_Err (*AEGP_GetLayerFromLayerID)(
		AEGP_CompH				parent_compH,			/* >> */
		AEGP_LayerIDVal			id,						/* >> */
		AEGP_LayerH				*layerPH);				/* << */

} AEGP_LayerSuite5;



#define kAEGPLayerSuiteVersion4		10	/* frozen AE 6.5 */

typedef struct AEGP_LayerSuite4 {

	SPAPI A_Err	(*AEGP_GetCompNumLayers)(
						AEGP_CompH			compH,					/* >> */
						A_long				*num_layersPL);			/* << */

	SPAPI A_Err	(*AEGP_GetCompLayerByIndex)(
						AEGP_CompH			compH,					/* >> */
						A_long				layer_indexL,			/* >> */
						AEGP_LayerH			*layerPH);				/* << */

	SPAPI A_Err	(*AEGP_GetActiveLayer)(
						AEGP_LayerH			*layerPH);				/* << returns non null only if one layer is selected */

	SPAPI A_Err	(*AEGP_GetLayerIndex)(
						AEGP_LayerH			layerH,					/* >> */
						A_long				*layer_indexPL);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerSourceItem)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_ItemH			*source_itemPH);		/* << */

	SPAPI A_Err (*AEGP_GetLayerSourceItemID)(
						AEGP_LayerH			layerH,					/* >> */
						A_long				*source_item_idPL);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerParentComp)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_CompH			*compPH);				/* << */

	SPAPI A_Err	(*AEGP_GetLayerName)(
						AEGP_LayerH 		layerH,					/* >> */
						A_char				*layer_nameZ0,			/* << space for A_char[AEGP_MAX_LAYER_NAME_SIZE] */
						A_char				*source_nameZ0);		/* << space for A_char[AEGP_MAX_LAYER_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetLayerQuality)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerQuality	*qualityP);				/* << */

	SPAPI A_Err	(*AEGP_SetLayerQuality)(							/* UNDOABLE */
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerQuality	quality);				/* >> */

	SPAPI A_Err	(*AEGP_GetLayerFlags)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerFlags		*layer_flagsP);			/* << */

	SPAPI A_Err (*AEGP_SetLayerFlag)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerFlags		single_flag,			/* >> */
						A_Boolean			valueB);				/* >> */

	SPAPI A_Err	(*AEGP_IsLayerVideoReallyOn)(						// accounts for solo status of other layers in comp
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			*onPB);					/* << */

	SPAPI A_Err	(*AEGP_IsLayerAudioReallyOn)(						// accounts for solo status of other layers in comp
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			*onPB);					/* << */

	SPAPI A_Err	(*AEGP_GetLayerCurrentTime)(						// not updated while rendering
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						A_Time 				*curr_timePT);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerInPoint)(
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						A_Time 				*in_pointPT);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerDuration)(
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						A_Time 				*durationPT);			/* << */

	SPAPI A_Err	(*AEGP_SetLayerInPointAndDuration)(					/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						const A_Time 		*in_pointPT,			/* >> */
						const A_Time 		*durationPT);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerOffset)(
						AEGP_LayerH 		layerH,					/* >> */
						A_Time 				*offsetPT);				/* << always in comp time */

	SPAPI A_Err	(*AEGP_SetLayerOffset)(								/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						const A_Time 		*offsetPT);				/* >> always in comp time */

	SPAPI A_Err	(*AEGP_GetLayerStretch)(
						AEGP_LayerH 		layerH,					/* >> */
						A_Ratio 			*stretchPRt);			/* << */

	SPAPI A_Err	(*AEGP_SetLayerStretch)(							/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						const A_Ratio 		*stretchPRt);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerTransferMode)(
						AEGP_LayerH 			layerH,				/* >> */
						AEGP_LayerTransferMode	*transfer_modeP);	/* << */

	SPAPI A_Err	(*AEGP_SetLayerTransferMode)(								/* UNDOABLE */
						AEGP_LayerH 					layerH,				/* >> */
						const AEGP_LayerTransferMode	*transfer_modeP);	/* >> */

	SPAPI A_Err	(*AEGP_IsAddLayerValid)(
						AEGP_ItemH 			item_to_addH,			/* >> */
						AEGP_CompH 			into_compH,				/* >> */
						A_Boolean			*validPB);				/* << */

	SPAPI A_Err	(*AEGP_AddLayer)(									/* UNDOABLE */
						AEGP_ItemH 			item_to_addH,			/* >> check AEGP_IsAddLayerValid() before using */
						AEGP_CompH 			into_compH,				/* >> */
						AEGP_LayerH			*added_layerPH0);		/* << */

	SPAPI A_Err	(*AEGP_ReorderLayer)(								/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						A_long 				layer_indexL);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerMaskedBounds)(
						AEGP_LayerH 		layerH,			/* >> */
						AEGP_LTimeMode		time_mode,		/* >> */
						const A_Time	 	*timePT,		/* >> */
						A_FloatRect			*boundsPR);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerObjectType)(
						AEGP_LayerH 		layerH,				/* >> */
						AEGP_ObjectType 	*object_type);		/* << */

	SPAPI A_Err	(*AEGP_IsLayer3D)(
						AEGP_LayerH 		layerH,				/* >> */
						A_Boolean 			*is_3DPB);			/* << */

	SPAPI A_Err	(*AEGP_IsLayer2D)(
						AEGP_LayerH 		layerH,				/* >> */
						A_Boolean 			*is_2DPB);			/* << */

	SPAPI A_Err	(*AEGP_IsVideoActive)(
						AEGP_LayerH 		layerH,				/* >> */
						AEGP_LTimeMode		time_mode,			/* >> */
						const A_Time	 	*timePT,			/* >> */
						A_Boolean			*is_activePB);		/* << */

	SPAPI A_Err	(*AEGP_IsLayerUsedAsTrackMatte)(
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			fill_must_be_activeB,	/* >> */
						A_Boolean			*is_track_mattePB);		/* << */

	SPAPI A_Err	(*AEGP_DoesLayerHaveTrackMatte)(
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			*has_track_mattePB);	/* << */

	SPAPI A_Err	(*AEGP_ConvertCompToLayerTime)(
					AEGP_LayerH		layerH,							/* >> */
					const A_Time	*comp_timePT,					/* >> */
					A_Time			*layer_timePT);					/* << */

	SPAPI A_Err	(*AEGP_ConvertLayerToCompTime)(
					AEGP_LayerH		layerH,							/* >> */
					const A_Time	*layer_timePT,					/* >> */
					A_Time			*comp_timePT) ;					/* << */

	SPAPI A_Err	(*AEGP_GetLayerDancingRandValue)(
					AEGP_LayerH		layerH,							/* >> */
					const A_Time	*comp_timePT,					/* >> */
					A_long			*rand_valuePL);					/* << */

	SPAPI A_Err	(*AEGP_GetLayerID)(
					AEGP_LayerH				layerH,				/* >> */
					AEGP_LayerIDVal			*id_valP);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerToWorldXform)(
				AEGP_LayerH				aegp_layerH,		/* >> */
				const A_Time			*comp_timeP,		/* >> */
				A_Matrix4				*transform);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerToWorldXformFromView)(
				AEGP_LayerH				aegp_layerH,		/* >> */
				const A_Time			*view_timeP,		/* >> */
				const A_Time			*comp_timeP,		/* >> */
				A_Matrix4				*transform);		/* << */

	SPAPI A_Err (*AEGP_SetLayerName)(
				AEGP_LayerH				aegp_layerH,		/* >> */
				const A_char			*new_nameZ);		/* >> */

	SPAPI A_Err	(*AEGP_GetLayerParent)(
				const AEGP_LayerH		layerH,				/* >> */
				AEGP_LayerH				*parent_layerPH);	/* << NULL if no parent */

	SPAPI A_Err (*AEGP_SetLayerParent)(
				AEGP_LayerH				layerH,				/* >> */
				const AEGP_LayerH		parent_layerH0);	/* >> */

	SPAPI A_Err (*AEGP_DeleteLayer)(
				AEGP_LayerH				layerH);			/* >>  	UNDOABLE */

	SPAPI A_Err (*AEGP_DuplicateLayer)(
				AEGP_LayerH				orig_layerH,			/* >> */
				AEGP_LayerH				*duplicate_layerPH);	/* << */

} AEGP_LayerSuite4;

#define kAEGPLayerSuiteVersion3		8	/* frozen AE 6.0 */

typedef struct AEGP_LayerSuite3 {

	SPAPI A_Err	(*AEGP_GetCompNumLayers)(
						AEGP_CompH			compH,					/* >> */
						A_long				*num_layersPL);			/* << */

	SPAPI A_Err	(*AEGP_GetCompLayerByIndex)(
						AEGP_CompH			compH,					/* >> */
						A_long				layer_indexL,			/* >> */
						AEGP_LayerH			*layerPH);				/* << */

	SPAPI A_Err	(*AEGP_GetActiveLayer)(
						AEGP_LayerH			*layerPH);				/* << only if one layer is selected */

	SPAPI A_Err	(*AEGP_GetLayerIndex)(
						AEGP_LayerH			layerH,					/* >> */
						A_long				*layer_indexPL);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerSourceItem)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_ItemH			*source_itemPH);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerParentComp)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_CompH			*compPH);				/* << */

	SPAPI A_Err	(*AEGP_GetLayerName)(
						AEGP_LayerH 		layerH,					/* >> */
						A_char				*layer_nameZ0,			/* << space for A_char[AEGP_MAX_LAYER_NAME_SIZE] */
						A_char				*source_nameZ0);		/* << space for A_char[AEGP_MAX_LAYER_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetLayerQuality)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerQuality	*qualityP);				/* << */

	SPAPI A_Err	(*AEGP_SetLayerQuality)(							/* UNDOABLE */
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerQuality	quality);				/* >> */

	SPAPI A_Err	(*AEGP_GetLayerFlags)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerFlags		*layer_flagsP);			/* << */

	SPAPI A_Err (*AEGP_SetLayerFlag)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerFlags		single_flag,			/* >> */
						A_Boolean			valueB);				/* >> */

	SPAPI A_Err	(*AEGP_IsLayerVideoReallyOn)(						// accounts for solo status of other layers in comp
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			*onPB);					/* << */

	SPAPI A_Err	(*AEGP_IsLayerAudioReallyOn)(						// accounts for solo status of other layers in comp
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			*onPB);					/* << */

	SPAPI A_Err	(*AEGP_GetLayerCurrentTime)(						// not updated while rendering
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						A_Time 				*curr_timePT);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerInPoint)(
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						A_Time 				*in_pointPT);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerDuration)(
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						A_Time 				*durationPT);			/* << */

	SPAPI A_Err	(*AEGP_SetLayerInPointAndDuration)(					/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						const A_Time 		*in_pointPT,			/* >> */
						const A_Time 		*durationPT);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerOffset)(
						AEGP_LayerH 		layerH,					/* >> */
						A_Time 				*offsetPT);				/* << always in comp time */

	SPAPI A_Err	(*AEGP_SetLayerOffset)(								/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						const A_Time 		*offsetPT);				/* >> always in comp time */

	SPAPI A_Err	(*AEGP_GetLayerStretch)(
						AEGP_LayerH 		layerH,					/* >> */
						A_Ratio 			*stretchPRt);			/* << */

	SPAPI A_Err	(*AEGP_SetLayerStretch)(							/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						const A_Ratio 		*stretchPRt);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerTransferMode)(
						AEGP_LayerH 			layerH,				/* >> */
						AEGP_LayerTransferMode	*transfer_modeP);	/* << */

	SPAPI A_Err	(*AEGP_SetLayerTransferMode)(								/* UNDOABLE */
						AEGP_LayerH 					layerH,				/* >> */
						const AEGP_LayerTransferMode	*transfer_modeP);	/* >> */

	SPAPI A_Err	(*AEGP_IsAddLayerValid)(
						AEGP_ItemH 			item_to_addH,			/* >> */
						AEGP_CompH 			into_compH,				/* >> */
						A_Boolean			*validPB);				/* << */

	SPAPI A_Err	(*AEGP_AddLayer)(									/* UNDOABLE */
						AEGP_ItemH 			item_to_addH,			/* >> check AEGP_IsAddLayerValid() before using */
						AEGP_CompH 			into_compH,				/* >> */
						AEGP_LayerH			*added_layerPH0);		/* << */

	SPAPI A_Err	(*AEGP_ReorderLayer)(								/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						A_long 				layer_indexL);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerMaskedBounds)(
						AEGP_LayerH 		layerH,			/* >> */
						AEGP_LTimeMode		time_mode,		/* >> */
						const A_Time	 	*timePT,		/* >> */
						A_FloatRect			*boundsPR);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerObjectType)(
						AEGP_LayerH 		layerH,				/* >> */
						AEGP_ObjectType 	*object_type);		/* << */

	SPAPI A_Err	(*AEGP_IsLayer3D)(
						AEGP_LayerH 		layerH,				/* >> */
						A_Boolean 			*is_3DPB);			/* << */

	SPAPI A_Err	(*AEGP_IsLayer2D)(
						AEGP_LayerH 		layerH,				/* >> */
						A_Boolean 			*is_2DPB);			/* << */

	SPAPI A_Err	(*AEGP_IsVideoActive)(
						AEGP_LayerH 		layerH,				/* >> */
						AEGP_LTimeMode		time_mode,			/* >> */
						const A_Time	 	*timePT,			/* >> */
						A_Boolean			*is_activePB);		/* << */

	SPAPI A_Err	(*AEGP_IsLayerUsedAsTrackMatte)(
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			fill_must_be_activeB,	/* >> */
						A_Boolean			*is_track_mattePB);		/* << */

	SPAPI A_Err	(*AEGP_DoesLayerHaveTrackMatte)(
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			*has_track_mattePB);	/* << */

	SPAPI A_Err	(*AEGP_ConvertCompToLayerTime)(
					AEGP_LayerH		layerH,							/* >> */
					const A_Time	*comp_timePT,					/* >> */
					A_Time			*layer_timePT);					/* << */

	SPAPI A_Err	(*AEGP_ConvertLayerToCompTime)(
					AEGP_LayerH		layerH,							/* >> */
					const A_Time	*layer_timePT,					/* >> */
					A_Time			*comp_timePT) ;					/* << */

	SPAPI A_Err	(*AEGP_GetLayerDancingRandValue)(
					AEGP_LayerH		layerH,							/* >> */
					const A_Time	*comp_timePT,					/* >> */
					A_long			*rand_valuePL);					/* << */

	SPAPI A_Err	(*AEGP_GetLayerID)(
					AEGP_LayerH				layerH,				/* >> */
					AEGP_LayerIDVal			*id_valP);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerToWorldXform)(
				AEGP_LayerH				aegp_layerH,		/* >> */
				const A_Time			*comp_timeP,		/* >> */
				A_Matrix4				*tranform);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerToWorldXformFromView)(
				AEGP_LayerH				aegp_layerH,		/* >> */
				const A_Time			*view_timeP,		/* >> */
				const A_Time			*comp_timeP,		/* >> */
				A_Matrix4				*tranform);			/* >> */

	SPAPI A_Err (*AEGP_SetLayerName)(
				AEGP_LayerH				aegp_layerH,		/* >> */
				const A_char			*new_nameZ);		/* >> */

	SPAPI A_Err	(*AEGP_GetLayerParent)(
				const AEGP_LayerH		layerH,				/* >> */
				AEGP_LayerH				*parent_layerPH);	/* << NULL if no parent */

	SPAPI A_Err (*AEGP_SetLayerParent)(
				AEGP_LayerH				layerH,				/* >> */
				const AEGP_LayerH		parent_layerH0);	/* >> */

	SPAPI A_Err (*AEGP_DeleteLayer)(
				AEGP_LayerH				layerH);			/* >>  	UNDOABLE */


} AEGP_LayerSuite3;

/*******************************************************************************/

typedef struct {
	A_char				nameAC		[AEGP_MAX_MARKER_NAME_SIZE];
	A_char				urlAC		[AEGP_MAX_MARKER_URL_SIZE];
	A_char				targetAC	[AEGP_MAX_MARKER_TARGET_SIZE];
	A_char				chapterAC	[AEGP_MAX_MARKER_CHAPTER_SIZE];
} AEGP_MarkerVal;

typedef AEGP_MarkerVal**		AEGP_MarkerValH;

typedef union {
	AEGP_FourDVal			four_d;
	AEGP_ThreeDVal			three_d;
	AEGP_TwoDVal			two_d;
	AEGP_OneDVal			one_d;
	AEGP_ColorVal			color;
	AEGP_ArbBlockVal		arbH;
	AEGP_MarkerValH			markerH;
	AEGP_LayerIDVal			layer_id;
	AEGP_MaskIDVal			mask_id;
	AEGP_MaskOutlineValH	mask;
	AEGP_TextDocumentH		text_documentH;
} AEGP_StreamVal;

/* 	Metrowerks 2.4.6, a.k.a. Codewarrior Pro 7.1, changed PowerPC struct
	alignment. The pragma ensures the same alignment as with 2.4.5 and
	previous since plug-ins are built against this structure. See Codewarrior
	release notes for for details. Bug# WB1-27922.
*/

#if (__MWERKS__ >= 0x2406)
#pragma options align=mac68k4byte
#endif

typedef struct {

	AEGP_StreamRefH 	streamH;
	/* CW 7.1 was adding 4 padding bytes here. See pragma above for comments. */
	AEGP_StreamVal	val;
} AEGP_StreamValue;

#define kAEGPStreamSuite				"AEGP Stream Suite"

#define kAEGPStreamSuiteVersion5        10 /* frozen in AE 15 */
typedef struct AEGP_StreamSuite5 {
    //    the only diff from this vs. last rev is that routines that pass AEGP_StreamValue2, when referring to a marker,
    //    (comp or layer) the struct now contains the NEW markerP type, which is compatible with the new Marker Suite

    SPAPI A_Err (*AEGP_IsStreamLegal)(
                        AEGP_LayerH            layerH,                    /* >> */
                        AEGP_LayerStream    which_stream,            /* >> */
                        A_Boolean*            is_legalP);                /* << */


    SPAPI A_Err (*AEGP_CanVaryOverTime)(
                        AEGP_StreamRefH streamH,                    /* >> */
                        A_Boolean* can_varyPB);                        /* << */

    SPAPI A_Err (*AEGP_GetValidInterpolations)(
                        AEGP_StreamRefH                streamH,                    /* >> */
                        AEGP_KeyInterpolationMask*    valid_interpolationsP);        /* << */

    SPAPI A_Err    (*AEGP_GetNewLayerStream)(
                        AEGP_PluginID        aegp_plugin_id,            /* >> */
                        AEGP_LayerH            layerH,                    /* >> */
                        AEGP_LayerStream    which_stream,            /* >> */
                        AEGP_StreamRefH     *streamPH);                /* << must be disposed by caller! */

    SPAPI A_Err    (*AEGP_GetEffectNumParamStreams)(
                        AEGP_EffectRefH        effect_refH,            /* >> */
                        A_long                *num_paramsPL);            /* << */

    SPAPI A_Err    (*AEGP_GetNewEffectStreamByIndex)(
                        AEGP_PluginID        aegp_plugin_id,            /* >> */
                        AEGP_EffectRefH        effect_refH,            /* >> */
                        PF_ParamIndex        param_index,            /* >> valid in range [0 to AEGP_GetEffectNumParamStreams - 1], where 0 is the effect's input layer */
                        AEGP_StreamRefH     *streamPH);                /* << must be disposed by caller! */

    SPAPI A_Err    (*AEGP_GetNewMaskStream)(
                        AEGP_PluginID        aegp_plugin_id,            /* >> */
                        AEGP_MaskRefH        mask_refH,                /* >> */
                        AEGP_MaskStream        which_stream,            /* >> */
                        AEGP_StreamRefH     *mask_streamPH);        /* << must be disposed by caller! */

    SPAPI A_Err    (*AEGP_DisposeStream)(
                        AEGP_StreamRefH     streamH);                /* >> */

    SPAPI A_Err    (*AEGP_GetStreamName)(
                        AEGP_PluginID            pluginID,                // in
                        AEGP_StreamRefH     streamH,                /* >> */
                        A_Boolean            force_englishB,            /* >> */
                        AEGP_MemHandle        *utf_stream_namePH);        // <<    handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle

    SPAPI A_Err    (*AEGP_GetStreamUnitsText)(
                        AEGP_StreamRefH     streamH,                /* >> */
                        A_Boolean            force_englishB,            /* >> */
                        A_char                *unitsZ);                /* << space for A_char[AEGP_MAX_STREAM_UNITS_SIZE] */

    SPAPI A_Err    (*AEGP_GetStreamProperties)(
                        AEGP_StreamRefH     streamH,                /* >> */
                        AEGP_StreamFlags     *flagsP,                /* << */
                        A_FpLong             *minP0,                    /* << */
                        A_FpLong             *maxP0);                /* << */

    SPAPI A_Err    (*AEGP_IsStreamTimevarying)(                        /* takes expressions into account */
                        AEGP_StreamRefH     streamH,                /* >> */
                        A_Boolean            *is_timevaryingPB);        /* << */

    SPAPI A_Err    (*AEGP_GetStreamType)(
                        AEGP_StreamRefH     streamH,                /* >> */
                        AEGP_StreamType        *stream_typeP);            /* << */

    SPAPI A_Err    (*AEGP_GetNewStreamValue)(
                        AEGP_PluginID        aegp_plugin_id,            /* >> */
                        AEGP_StreamRefH     streamH,                /* >> */
                        AEGP_LTimeMode        time_mode,                /* >> */
                        const A_Time        *timePT,                /* >> */
                        A_Boolean            pre_expressionB,        /* >> sample the stream before evaluating the expression */
                        AEGP_StreamValue2    *valueP);                /* << must be disposed */

    SPAPI A_Err    (*AEGP_DisposeStreamValue)(
                        AEGP_StreamValue2    *valueP);                /* <> */


    SPAPI A_Err    (*AEGP_SetStreamValue)(                                // only legal to call when AEGP_GetStreamNumKFs==0 or NO_DATA
                        AEGP_PluginID        aegp_plugin_id,            /* >> */
                        AEGP_StreamRefH     streamH,                /* >> */
                        AEGP_StreamValue2    *valueP);                /* << */

    // this is only valid on streams with primitive types. It is illegal on
    // AEGP_ArbBlockVal || AEGP_MarkerValP || AEGP_MaskOutlineValH

    SPAPI A_Err    (*AEGP_GetLayerStreamValue)(
                        AEGP_LayerH            layerH,                    /* >> */
                        AEGP_LayerStream    which_stream,            /* >> */
                        AEGP_LTimeMode        time_mode,                /* >> */
                        const A_Time        *timePT,                /* >> */
                        A_Boolean            pre_expressionB,        /* >> sample the stream before evaluating the expression */
                        AEGP_StreamVal2        *stream_valP,            /* << */
                        AEGP_StreamType     *stream_typeP0);        /* << */

    SPAPI A_Err    (*AEGP_GetExpressionState)(                            /* expressions can be disabled automatically by the parser on playback */
                        AEGP_PluginID        aegp_plugin_id,            /* >> */
                        AEGP_StreamRefH     streamH,                /* >> */
                        A_Boolean            *enabledPB);            /* >> */

    SPAPI A_Err    (*AEGP_SetExpressionState)(                            /* expressions can be disabled automatically by the parser on playback */
                        AEGP_PluginID        aegp_plugin_id,            /* >> */
                        AEGP_StreamRefH     streamH,                /* >> */
                        A_Boolean            enabledB);                /* >> */

    SPAPI A_Err(*AEGP_GetExpression)(
                        AEGP_PluginID        aegp_plugin_id,            /* >> */
                        AEGP_StreamRefH     streamH,                /* >> */
                        AEGP_MemHandle        *unicodeHZ);            /* << must be disposed with AEGP_FreeMemHandle */

    SPAPI A_Err(*AEGP_SetExpression)(
                        AEGP_PluginID        aegp_plugin_id,            /* >> */
                        AEGP_StreamRefH     streamH,                /* >> */
                        const A_UTF16Char*    expressionP);            /* >> not adopted */

    SPAPI A_Err (*AEGP_DuplicateStreamRef)(                    // must dispose yourself
                        AEGP_PluginID        aegp_plugin_id,            // in
                        AEGP_StreamRefH        streamH,                // in
                        AEGP_StreamRefH        *dup_streamPH);            // out
} AEGP_StreamSuite5;

#define kAEGPStreamSuiteVersion4		9 /* frozen in AE 9 */
typedef struct AEGP_StreamSuite4 {
	//	the only diff from this vs. last rev is that routines that pass AEGP_StreamValue2, when referring to a marker,
	//	(comp or layer) the struct now contains the NEW markerP type, which is compatible with the new Marker Suite

	SPAPI A_Err(*AEGP_IsStreamLegal)(
		AEGP_LayerH			layerH,					/* >> */
		AEGP_LayerStream	which_stream,			/* >> */
		A_Boolean*			is_legalP);				/* << */


	SPAPI A_Err(*AEGP_CanVaryOverTime)(
		AEGP_StreamRefH streamH,					/* >> */
		A_Boolean* can_varyPB);						/* << */

	SPAPI A_Err(*AEGP_GetValidInterpolations)(
		AEGP_StreamRefH				streamH,					/* >> */
		AEGP_KeyInterpolationMask*	valid_interpolationsP);		/* << */

	SPAPI A_Err(*AEGP_GetNewLayerStream)(
		AEGP_PluginID		aegp_plugin_id,			/* >> */
		AEGP_LayerH			layerH,					/* >> */
		AEGP_LayerStream	which_stream,			/* >> */
		AEGP_StreamRefH 	*streamPH);				/* << must be disposed by caller! */

	SPAPI A_Err(*AEGP_GetEffectNumParamStreams)(
		AEGP_EffectRefH		effect_refH,			/* >> */
		A_long				*num_paramsPL);			/* << */

	SPAPI A_Err(*AEGP_GetNewEffectStreamByIndex)(
		AEGP_PluginID		aegp_plugin_id,			/* >> */
		AEGP_EffectRefH		effect_refH,			/* >> */
		PF_ParamIndex		param_index,			/* >> valid in range [0 to AEGP_GetEffectNumParamStreams - 1], where 0 is the effect's input layer */
		AEGP_StreamRefH 	*streamPH);				/* << must be disposed by caller! */

	SPAPI A_Err(*AEGP_GetNewMaskStream)(
		AEGP_PluginID		aegp_plugin_id,			/* >> */
		AEGP_MaskRefH		mask_refH,				/* >> */
		AEGP_MaskStream		which_stream,			/* >> */
		AEGP_StreamRefH 	*mask_streamPH);		/* << must be disposed by caller! */

	SPAPI A_Err(*AEGP_DisposeStream)(
		AEGP_StreamRefH 	streamH);				/* >> */

	SPAPI A_Err(*AEGP_GetStreamName)(
		AEGP_PluginID			pluginID,				// in
		AEGP_StreamRefH 	streamH,				/* >> */
		A_Boolean			force_englishB,			/* >> */
		AEGP_MemHandle		*utf_stream_namePH);		// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle

	SPAPI A_Err(*AEGP_GetStreamUnitsText)(
		AEGP_StreamRefH 	streamH,				/* >> */
		A_Boolean			force_englishB,			/* >> */
		A_char				*unitsZ);				/* << space for A_char[AEGP_MAX_STREAM_UNITS_SIZE] */

	SPAPI A_Err(*AEGP_GetStreamProperties)(
		AEGP_StreamRefH 	streamH,				/* >> */
		AEGP_StreamFlags 	*flagsP,				/* << */
		A_FpLong 			*minP0,					/* << */
		A_FpLong 			*maxP0);				/* << */

	SPAPI A_Err(*AEGP_IsStreamTimevarying)(						/* takes expressions into account */
		AEGP_StreamRefH 	streamH,				/* >> */
		A_Boolean			*is_timevaryingPB);		/* << */

	SPAPI A_Err(*AEGP_GetStreamType)(
		AEGP_StreamRefH 	streamH,				/* >> */
		AEGP_StreamType		*stream_typeP);			/* << */

	SPAPI A_Err(*AEGP_GetNewStreamValue)(
		AEGP_PluginID		aegp_plugin_id,			/* >> */
		AEGP_StreamRefH 	streamH,				/* >> */
		AEGP_LTimeMode		time_mode,				/* >> */
		const A_Time		*timePT,				/* >> */
		A_Boolean			pre_expressionB,		/* >> sample the stream before evaluating the expression */
		AEGP_StreamValue2	*valueP);				/* << must be disposed */

	SPAPI A_Err(*AEGP_DisposeStreamValue)(
		AEGP_StreamValue2	*valueP);				/* <> */


	SPAPI A_Err(*AEGP_SetStreamValue)(								// only legal to call when AEGP_GetStreamNumKFs==0 or NO_DATA
		AEGP_PluginID		aegp_plugin_id,			/* >> */
		AEGP_StreamRefH 	streamH,				/* >> */
		AEGP_StreamValue2	*valueP);				/* << */

	// this is only valid on streams with primitive types. It is illegal on
	// AEGP_ArbBlockVal || AEGP_MarkerValP || AEGP_MaskOutlineValH

	SPAPI A_Err(*AEGP_GetLayerStreamValue)(
		AEGP_LayerH			layerH,					/* >> */
		AEGP_LayerStream	which_stream,			/* >> */
		AEGP_LTimeMode		time_mode,				/* >> */
		const A_Time		*timePT,				/* >> */
		A_Boolean			pre_expressionB,		/* >> sample the stream before evaluating the expression */
		AEGP_StreamVal2		*stream_valP,			/* << */
		AEGP_StreamType 	*stream_typeP0);		/* << */

	SPAPI A_Err(*AEGP_GetExpressionState)(							/* expressions can be disabled automatically by the parser on playback */
		AEGP_PluginID		aegp_plugin_id,			/* >> */
		AEGP_StreamRefH 	streamH,				/* >> */
		A_Boolean			*enabledPB);			/* >> */

	SPAPI A_Err(*AEGP_SetExpressionState)(							/* expressions can be disabled automatically by the parser on playback */
		AEGP_PluginID		aegp_plugin_id,			/* >> */
		AEGP_StreamRefH 	streamH,				/* >> */
		A_Boolean			enabledB);				/* >> */

	SPAPI A_Err(*AEGP_GetExpression)(
		AEGP_PluginID		aegp_plugin_id,			/* >> */
		AEGP_StreamRefH 	streamH,				/* >> */
		AEGP_MemHandle		*expressionHZ);			/* << must be disposed with AEGP_FreeMemHandle */

	SPAPI A_Err(*AEGP_SetExpression)(
		AEGP_PluginID		aegp_plugin_id,			/* >> */
		AEGP_StreamRefH 	streamH,				/* >> */
		const A_char*			expressionP);			/* >> not adopted */

	SPAPI A_Err(*AEGP_DuplicateStreamRef)(					// must dispose yourself
		AEGP_PluginID		aegp_plugin_id,			// in
		AEGP_StreamRefH		streamH,				// in
		AEGP_StreamRefH		*dup_streamPH);			// out
} AEGP_StreamSuite4;



#define kAEGPStreamSuiteVersion3		8 /* frozen in AE 8 */
typedef struct AEGP_StreamSuite3 {
	//	the only diff from this vs. last rev is that routines that pass AEGP_StreamValue2, when referring to a marker,
	//	(comp or layer) the struct now contains the NEW markerP type, which is compatible with the new Marker Suite

	SPAPI A_Err (*AEGP_IsStreamLegal)(
		AEGP_LayerH			layerH,					/* >> */
		AEGP_LayerStream	which_stream,			/* >> */
		A_Boolean*			is_legalP);				/* << */


	SPAPI A_Err (*AEGP_CanVaryOverTime)(
		AEGP_StreamRefH streamH,					/* >> */
		A_Boolean* can_varyPB);						/* << */

	SPAPI A_Err (*AEGP_GetValidInterpolations)(
		AEGP_StreamRefH				streamH,					/* >> */
		AEGP_KeyInterpolationMask*	valid_interpolationsP);		/* << */

	SPAPI A_Err	(*AEGP_GetNewLayerStream)(
		AEGP_PluginID		aegp_plugin_id,			/* >> */
		AEGP_LayerH			layerH,					/* >> */
		AEGP_LayerStream	which_stream,			/* >> */
		AEGP_StreamRefH 	*streamPH);				/* << must be disposed by caller! */

	SPAPI A_Err	(*AEGP_GetEffectNumParamStreams)(
		AEGP_EffectRefH		effect_refH,			/* >> */
		A_long				*num_paramsPL);			/* << */

	SPAPI A_Err	(*AEGP_GetNewEffectStreamByIndex)(
		AEGP_PluginID		aegp_plugin_id,			/* >> */
		AEGP_EffectRefH		effect_refH,			/* >> */
		PF_ParamIndex		param_index,			/* >> valid in range [0 to AEGP_GetEffectNumParamStreams - 1], where 0 is the effect's input layer */
		AEGP_StreamRefH 	*streamPH);				/* << must be disposed by caller! */

	SPAPI A_Err	(*AEGP_GetNewMaskStream)(
		AEGP_PluginID		aegp_plugin_id,			/* >> */
		AEGP_MaskRefH		mask_refH,				/* >> */
		AEGP_MaskStream		which_stream,			/* >> */
		AEGP_StreamRefH 	*mask_streamPH);		/* << must be disposed by caller! */

	SPAPI A_Err	(*AEGP_DisposeStream)(
		AEGP_StreamRefH 	streamH);				/* >> */

	SPAPI A_Err	(*AEGP_GetStreamName)(
		AEGP_StreamRefH 	streamH,				/* >> */
		A_Boolean			force_englishB,			/* >> */
		A_char				*nameZ);				/* << space for A_char[AEGP_MAX_STREAM_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetStreamUnitsText)(
		AEGP_StreamRefH 	streamH,				/* >> */
		A_Boolean			force_englishB,			/* >> */
		A_char				*unitsZ);				/* << space for A_char[AEGP_MAX_STREAM_UNITS_SIZE] */

	SPAPI A_Err	(*AEGP_GetStreamProperties)(
		AEGP_StreamRefH 	streamH,				/* >> */
		AEGP_StreamFlags 	*flagsP,				/* << */
		A_FpLong 			*minP0,					/* << */
		A_FpLong 			*maxP0);				/* << */

	SPAPI A_Err	(*AEGP_IsStreamTimevarying)(						/* takes expressions into account */
		AEGP_StreamRefH 	streamH,				/* >> */
		A_Boolean			*is_timevaryingPB);		/* << */

	SPAPI A_Err	(*AEGP_GetStreamType)(
		AEGP_StreamRefH 	streamH,				/* >> */
		AEGP_StreamType		*stream_typeP);			/* << */

	SPAPI A_Err	(*AEGP_GetNewStreamValue)(
		AEGP_PluginID		aegp_plugin_id,			/* >> */
		AEGP_StreamRefH 	streamH,				/* >> */
		AEGP_LTimeMode		time_mode,				/* >> */
		const A_Time		*timePT,				/* >> */
		A_Boolean			pre_expressionB,		/* >> sample the stream before evaluating the expression */
		AEGP_StreamValue2	*valueP);				/* << must be disposed */

	SPAPI A_Err	(*AEGP_DisposeStreamValue)(
		AEGP_StreamValue2	*valueP);				/* <> */


	SPAPI A_Err	(*AEGP_SetStreamValue)(								// only legal to call when AEGP_GetStreamNumKFs==0 or NO_DATA
		AEGP_PluginID		aegp_plugin_id,			/* >> */
		AEGP_StreamRefH 	streamH,				/* >> */
		AEGP_StreamValue2	*valueP);				/* << */

	// this is only valid on streams with primitive types. It is illegal on
	// AEGP_ArbBlockVal || AEGP_MarkerValP || AEGP_MaskOutlineValH

	SPAPI A_Err	(*AEGP_GetLayerStreamValue)(
		AEGP_LayerH			layerH,					/* >> */
		AEGP_LayerStream	which_stream,			/* >> */
		AEGP_LTimeMode		time_mode,				/* >> */
		const A_Time		*timePT,				/* >> */
		A_Boolean			pre_expressionB,		/* >> sample the stream before evaluating the expression */
		AEGP_StreamVal2		*stream_valP,			/* << */
		AEGP_StreamType 	*stream_typeP0);		/* << */

	SPAPI A_Err	(*AEGP_GetExpressionState)(							/* expressions can be disabled automatically by the parser on playback */
		AEGP_PluginID		aegp_plugin_id,			/* >> */
		AEGP_StreamRefH 	streamH,				/* >> */
		A_Boolean			*enabledPB);			/* >> */

	SPAPI A_Err	(*AEGP_SetExpressionState)(							/* expressions can be disabled automatically by the parser on playback */
		AEGP_PluginID		aegp_plugin_id,			/* >> */
		AEGP_StreamRefH 	streamH,				/* >> */
		A_Boolean			enabledB);				/* >> */

	SPAPI A_Err	(*AEGP_GetExpression)(
		AEGP_PluginID		aegp_plugin_id,			/* >> */
		AEGP_StreamRefH 	streamH,				/* >> */
		AEGP_MemHandle		*expressionHZ);			/* << must be disposed with AEGP_FreeMemHandle */

	SPAPI A_Err	(*AEGP_SetExpression)(
		AEGP_PluginID		aegp_plugin_id,			/* >> */
		AEGP_StreamRefH 	streamH,				/* >> */
		const A_char*			expressionP);			/* >> not adopted */

	SPAPI A_Err (*AEGP_DuplicateStreamRef)(					// must dispose yourself
		AEGP_PluginID		aegp_plugin_id,			// in
		AEGP_StreamRefH		streamH,				// in
		AEGP_StreamRefH		*dup_streamPH);			// out
} AEGP_StreamSuite3;


#define kAEGPStreamSuiteVersion2		7 /* frozen in AE 6.5 */

typedef struct AEGP_StreamSuite2 {

	SPAPI A_Err (*AEGP_IsStreamLegal)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerStream	which_stream,			/* >> */
						A_Boolean*			is_legalP);				/* << */


	SPAPI A_Err (*AEGP_CanVaryOverTime)(
						AEGP_StreamRefH streamH,					/* >> */
						A_Boolean* can_varyPB);						/* << */

	SPAPI A_Err (*AEGP_GetValidInterpolations)(
						AEGP_StreamRefH				streamH,					/* >> */
						AEGP_KeyInterpolationMask*	valid_interpolationsP);		/* << */

	SPAPI A_Err	(*AEGP_GetNewLayerStream)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerStream	which_stream,			/* >> */
						AEGP_StreamRefH 	*streamPH);				/* << must be disposed by caller! */

	SPAPI A_Err	(*AEGP_GetEffectNumParamStreams)(
						AEGP_EffectRefH		effect_refH,			/* >> */
						A_long				*num_paramsPL);			/* << */

	SPAPI A_Err	(*AEGP_GetNewEffectStreamByIndex)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_EffectRefH		effect_refH,			/* >> */
						PF_ParamIndex		param_index,			/* >> valid in range [0 to AEGP_GetEffectNumParamStreams - 1], where 0 is the effect's input layer */
						AEGP_StreamRefH 	*streamPH);				/* << must be disposed by caller! */

	SPAPI A_Err	(*AEGP_GetNewMaskStream)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_MaskRefH		mask_refH,				/* >> */
						AEGP_MaskStream		which_stream,			/* >> */
						AEGP_StreamRefH 	*mask_streamPH);		/* << must be disposed by caller! */

	SPAPI A_Err	(*AEGP_DisposeStream)(
						AEGP_StreamRefH 	streamH);				/* >> */

	SPAPI A_Err	(*AEGP_GetStreamName)(
						AEGP_StreamRefH 	streamH,				/* >> */
						A_Boolean			force_englishB,			/* >> */
						A_char				*nameZ);				/* << space for A_char[AEGP_MAX_STREAM_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetStreamUnitsText)(
						AEGP_StreamRefH 	streamH,				/* >> */
						A_Boolean			force_englishB,			/* >> */
						A_char				*unitsZ);				/* << space for A_char[AEGP_MAX_STREAM_UNITS_SIZE] */

	SPAPI A_Err	(*AEGP_GetStreamProperties)(
						AEGP_StreamRefH 	streamH,				/* >> */
						AEGP_StreamFlags 	*flagsP,				/* << */
						A_FpLong 			*minP0,					/* << */
						A_FpLong 			*maxP0);				/* << */

	SPAPI A_Err	(*AEGP_IsStreamTimevarying)(						/* takes expressions into account */
						AEGP_StreamRefH 	streamH,				/* >> */
						A_Boolean			*is_timevaryingPB);		/* << */

	SPAPI A_Err	(*AEGP_GetStreamType)(
						AEGP_StreamRefH 	streamH,				/* >> */
						AEGP_StreamType		*stream_typeP);			/* << */

	SPAPI A_Err	(*AEGP_GetNewStreamValue)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_StreamRefH 	streamH,				/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						const A_Time		*timePT,				/* >> */
						A_Boolean			pre_expressionB,		/* >> sample the stream before evaluating the expression */
						AEGP_StreamValue	*valueP);				/* << must be disposed */

	SPAPI A_Err	(*AEGP_DisposeStreamValue)(
						AEGP_StreamValue	*valueP);				/* <> */


	SPAPI A_Err	(*AEGP_SetStreamValue)(								// only legal to call when AEGP_GetStreamNumKFs==0 or NO_DATA
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_StreamRefH 	streamH,				/* >> */
						AEGP_StreamValue	*valueP);				/* << */

	// this is only valid on streams with primitive types. It is illegal on
	// AEGP_ArbBlockVal || AEGP_MarkerValP || AEGP_MaskOutlineValH

	SPAPI A_Err	(*AEGP_GetLayerStreamValue)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerStream	which_stream,			/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						const A_Time		*timePT,				/* >> */
						A_Boolean			pre_expressionB,		/* >> sample the stream before evaluating the expression */
						AEGP_StreamVal	*stream_valP,			/* << */
						AEGP_StreamType 	*stream_typeP0);		/* << */

	SPAPI A_Err	(*AEGP_GetExpressionState)(							/* expressions can be disabled automatically by the parser on playback */
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_StreamRefH 	streamH,				/* >> */
						A_Boolean			*enabledPB);			/* >> */

	SPAPI A_Err	(*AEGP_SetExpressionState)(							/* expressions can be disabled automatically by the parser on playback */
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_StreamRefH 	streamH,				/* >> */
						A_Boolean			enabledB);				/* >> */

	SPAPI A_Err	(*AEGP_GetExpression)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_StreamRefH 	streamH,				/* >> */
						AEGP_MemHandle		*expressionHZ);			/* << must be disposed with AEGP_FreeMemHandle */

	SPAPI A_Err	(*AEGP_SetExpression)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_StreamRefH 	streamH,				/* >> */
						const A_char*			expressionP);			/* >> not adopted */

	SPAPI A_Err (*AEGP_DuplicateStreamRef)(					// must dispose yourself
						AEGP_PluginID		aegp_plugin_id,			// in
						AEGP_StreamRefH		streamH,				// in
						AEGP_StreamRefH		*dup_streamPH);			// out
} AEGP_StreamSuite2;

#define kAEGPStreamSuite				"AEGP Stream Suite"
#define kAEGPStreamSuiteVersion1		4 /* frozen in AE 5.0 */

typedef struct AEGP_StreamSuite1 {

	SPAPI A_Err (*AEGP_IsStreamLegal)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerStream	which_stream,			/* >> */
						A_Boolean*			is_legalP);				/* << */


	SPAPI A_Err (*AEGP_CanVaryOverTime)(
						AEGP_StreamRefH streamH,					/* >> */
						A_Boolean* can_varyPB);						/* << */


	SPAPI A_Err	(*AEGP_GetNewLayerStream)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerStream	which_stream,			/* >> */
						AEGP_StreamRefH 	*streamPH);				/* << must be disposed by caller! */

	SPAPI A_Err	(*AEGP_GetEffectNumParamStreams)(
						AEGP_EffectRefH		effect_refH,			/* >> */
						A_long				*num_paramsPL);			/* << */

	SPAPI A_Err	(*AEGP_GetNewEffectStreamByIndex)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_EffectRefH		effect_refH,			/* >> */
						PF_ParamIndex		param_index,			/* >> valid in range [0 to AEGP_GetEffectNumParamStreams - 1],  where 0 is the effect's input layer */
						AEGP_StreamRefH 	*streamPH);				/* << must be disposed by caller! */

	SPAPI A_Err	(*AEGP_GetNewMaskStream)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_MaskRefH		mask_refH,				/* >> */
						AEGP_MaskStream		which_stream,			/* >> */
						AEGP_StreamRefH 	*mask_streamPH);		/* << must be disposed by caller! */

	SPAPI A_Err	(*AEGP_DisposeStream)(
						AEGP_StreamRefH 	streamH);				/* >> */

	SPAPI A_Err	(*AEGP_GetStreamName)(
						AEGP_StreamRefH 	streamH,				/* >> */
						A_Boolean			force_englishB,			/* >> */
						A_char				*nameZ);				/* << space for A_char[AEGP_MAX_STREAM_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetStreamUnitsText)(
						AEGP_StreamRefH 	streamH,				/* >> */
						A_Boolean			force_englishB,			/* >> */
						A_char				*unitsZ);				/* << space for A_char[AEGP_MAX_STREAM_UNITS_SIZE] */

	SPAPI A_Err	(*AEGP_GetStreamProperties)(
						AEGP_StreamRefH 	streamH,				/* >> */
						AEGP_StreamFlags 	*flagsP,				/* << */
						A_FpLong 			*minP0,					/* << */
						A_FpLong 			*maxP0);				/* << */

	SPAPI A_Err	(*AEGP_IsStreamTimevarying)(						/* takes expressions into account */
						AEGP_StreamRefH 	streamH,				/* >> */
						A_Boolean			*is_timevaryingPB);		/* << */

	SPAPI A_Err	(*AEGP_GetStreamType)(
						AEGP_StreamRefH 	streamH,				/* >> */
						AEGP_StreamType		*stream_typeP);			/* << */

	SPAPI A_Err	(*AEGP_GetNewStreamValue)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_StreamRefH 	streamH,				/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						const A_Time		*timePT,				/* >> */
						A_Boolean			pre_expressionB,		/* >> sample the stream before evaluating the expression */
						AEGP_StreamValue	*valueP);				/* << must be disposed */

	SPAPI A_Err	(*AEGP_DisposeStreamValue)(
						AEGP_StreamValue	*valueP);				/* <> */


	SPAPI A_Err	(*AEGP_SetStreamValue)(								// only legal to call when AEGP_GetStreamNumKFs==0 or NO_DATA
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_StreamRefH 	streamH,				/* >> */
						AEGP_StreamValue	*valueP);				/* << */

	// this is only valid on streams with primitive types. It is illegal on
	// AEGP_ArbBlockVal || AEGP_MarkerValH || AEGP_MaskOutlineValH

	SPAPI A_Err	(*AEGP_GetLayerStreamValue)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerStream	which_stream,			/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						const A_Time		*timePT,				/* >> */
						A_Boolean			pre_expressionB,		/* >> sample the stream before evaluating the expression */
						AEGP_StreamVal	*stream_valP,			/* << */
						AEGP_StreamType 	*stream_typeP0);		/* << */

	SPAPI A_Err	(*AEGP_GetExpressionState)(							/* expressions can be disabled automatically by the parser on playback */
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_StreamRefH 	streamH,				/* >> */
						A_Boolean			*enabledPB);			/* >> */

	SPAPI A_Err	(*AEGP_SetExpressionState)(							/* expressions can be disabled automatically by the parser on playback */
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_StreamRefH 	streamH,				/* >> */
						A_Boolean			enabledB);				/* >> */

	SPAPI A_Err	(*AEGP_GetExpression)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_StreamRefH 	streamH,				/* >> */
						AEGP_MemHandle		*expressionHZ);			/* << must be disposed with AEGP_FreeMemHandle */

	SPAPI A_Err	(*AEGP_SetExpression)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_StreamRefH 	streamH,				/* >> */
						const A_char*			expressionP);			/* >> not adopted */


} AEGP_StreamSuite1;


#define kAEGPLayerSuiteVersion1		5		/* frozen in AE 5.0 */

typedef struct AEGP_LayerSuite1 {

	SPAPI A_Err	(*AEGP_GetCompNumLayers)(
						AEGP_CompH			compH,					/* >> */
						A_long				*num_layersPL);			/* << */

	SPAPI A_Err	(*AEGP_GetCompLayerByIndex)(
						AEGP_CompH			compH,					/* >> */
						A_long				layer_indexL,			/* >> */
						AEGP_LayerH			*layerPH);				/* << */

	SPAPI A_Err	(*AEGP_GetActiveLayer)(
						AEGP_LayerH			*layerPH);				/* << only if one layer is selected */

	SPAPI A_Err	(*AEGP_GetLayerIndex)(
						AEGP_LayerH			layerH,					/* >> */
						A_long				*layer_indexPL);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerSourceItem)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_ItemH			*source_itemPH);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerParentComp)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_CompH			*compPH);				/* << */

	SPAPI A_Err	(*AEGP_GetLayerName)(
						AEGP_LayerH 		layerH,					/* >> */
						A_char				*layer_nameZ0,			/* << space for A_char[AEGP_MAX_LAYER_NAME_SIZE] */
						A_char				*source_nameZ0);		/* << space for A_char[AEGP_MAX_LAYER_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetLayerQuality)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerQuality	*qualityP);				/* << */

	SPAPI A_Err	(*AEGP_SetLayerQuality)(							/* UNDOABLE */
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerQuality	quality);				/* >> */

	SPAPI A_Err	(*AEGP_GetLayerFlags)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerFlags		*layer_flagsP);			/* << */

	SPAPI A_Err (*AEGP_SetLayerFlag)(
						AEGP_LayerH			layerH,					// >>
						AEGP_LayerFlags		single_flag,			// >>
						A_Boolean			valueB);				// >>

	SPAPI A_Err	(*AEGP_IsLayerVideoReallyOn)(						// accounts for solo status of other layers in comp
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			*onPB);					/* << */

	SPAPI A_Err	(*AEGP_IsLayerAudioReallyOn)(						// accounts for solo status of other layers in comp
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			*onPB);					/* << */

	SPAPI A_Err	(*AEGP_GetLayerCurrentTime)(						// not updated while rendering
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						A_Time 				*curr_timePT);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerInPoint)(
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						A_Time 				*in_pointPT);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerDuration)(
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						A_Time 				*durationPT);			/* << */

	SPAPI A_Err	(*AEGP_SetLayerInPointAndDuration)(					/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						const A_Time 				*in_pointPT,	/* >> */
						const A_Time 				*durationPT);	/* >> */

	SPAPI A_Err	(*AEGP_GetLayerOffset)(
						AEGP_LayerH 		layerH,					/* >> */
						A_Time 				*offsetPT);				/* << always in comp time */

	SPAPI A_Err	(*AEGP_SetLayerOffset)(								/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						const A_Time 				*offsetPT);		/* >> always in comp time */

	SPAPI A_Err	(*AEGP_GetLayerStretch)(
						AEGP_LayerH 		layerH,					/* >> */
						A_Ratio 			*stretchPRt);			/* << */

	SPAPI A_Err	(*AEGP_SetLayerStretch)(							/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						const A_Ratio 			*stretchPRt);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerTransferMode)(
						AEGP_LayerH 			layerH,				/* >> */
						AEGP_LayerTransferMode	*transfer_modeP);	/* << */

	SPAPI A_Err	(*AEGP_SetLayerTransferMode)(						/* UNDOABLE */
						AEGP_LayerH 			layerH,				/* >> */
						const AEGP_LayerTransferMode	*transfer_modeP);	/* >> */

	SPAPI A_Err	(*AEGP_IsAddLayerValid)(
						AEGP_ItemH 			item_to_addH,			/* >> */
						AEGP_CompH 			into_compH,				/* >> */
						A_Boolean			*validPB);				/* << */

	SPAPI A_Err	(*AEGP_AddLayer)(									/* UNDOABLE */
						AEGP_ItemH 			item_to_addH,			/* >> check AEGP_IsAddLayerValid() before using */
						AEGP_CompH 			into_compH,				/* >> */
						AEGP_LayerH			*added_layerPH0);		/* << */

	SPAPI A_Err	(*AEGP_ReorderLayer)(								/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						A_long 				layer_indexL);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerMaskedBounds)(
						AEGP_LayerH 		layerH,			/* >> */
						AEGP_LTimeMode		time_mode,		/* >> */
						const A_Time	 	*timePT,		/* >> */
						A_FloatRect			*boundsPR);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerObjectType)(
						AEGP_LayerH 		layerH,				/* >> */
						AEGP_ObjectType 	*object_type);		/* << */

	SPAPI A_Err	(*AEGP_IsLayer3D)(
						AEGP_LayerH 		layerH,				/* >> */
						A_Boolean 			*is_3DPB);			/* << */

	SPAPI A_Err	(*AEGP_IsLayer2D)(
						AEGP_LayerH 		layerH,				/* >> */
						A_Boolean 			*is_2DPB);			/* << */

	SPAPI A_Err	(*AEGP_IsVideoActive)(
						AEGP_LayerH 		layerH,				/* >> */
						AEGP_LTimeMode		time_mode,			/* >> */
						const A_Time	 	*timePT,			/* >> */
						A_Boolean			*is_activePB);		/* << */

	SPAPI A_Err	(*AEGP_IsLayerUsedAsTrackMatte)(
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			fill_must_be_activeB,	/* >> */
						A_Boolean			*is_track_mattePB);		/* << */

	SPAPI A_Err	(*AEGP_DoesLayerHaveTrackMatte)(
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			*has_track_mattePB);	/* << */

	SPAPI A_Err	(*AEGP_ConvertCompToLayerTime)(
					AEGP_LayerH		layerH,							/* >> */
					const A_Time	*comp_timeP,					/* >> */
					A_Time			*layer_timeP); 					/* << */

	SPAPI A_Err	(*AEGP_GetLayerDancingRandValue)(
					AEGP_LayerH		layerH,							/* >> */
					const A_Time	*comp_timePT,					/* >> */
					A_long			*rand_valuePL);					/* << */

	SPAPI A_Err	(*AEGP_GetLayerID)(
						AEGP_LayerH				layerH,				/* >> */
						AEGP_LayerIDVal				*id_valP);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerToWorldXform)(
				AEGP_LayerH				aegp_layerH,		/* >> */
				const A_Time			*comp_timeP,		/* >> */
				A_Matrix4				*tranform);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerToWorldXformFromView)(
				AEGP_LayerH				aegp_layerH,		/* >> */
				const A_Time			*view_timeP,		/* >> */
				const A_Time			*comp_timeP,		/* >> */
				A_Matrix4				*tranform);			/* >> */

	SPAPI A_Err (*AEGP_SetLayerName)(
				AEGP_LayerH				aegp_layerH,		/* >> */
				const A_char			*new_nameZ);		/* >> */

} AEGP_LayerSuite1;

#define kAEGPLayerSuiteVersion2		7	/* frozen in AE 5.5 */

typedef struct AEGP_LayerSuite2 {

	SPAPI A_Err	(*AEGP_GetCompNumLayers)(
						AEGP_CompH			compH,					/* >> */
						A_long				*num_layersPL);			/* << */

	SPAPI A_Err	(*AEGP_GetCompLayerByIndex)(
						AEGP_CompH			compH,					/* >> */
						A_long				layer_indexL,			/* >> */
						AEGP_LayerH			*layerPH);				/* << */

	SPAPI A_Err	(*AEGP_GetActiveLayer)(
						AEGP_LayerH			*layerPH);				/* << only if one layer is selected */

	SPAPI A_Err	(*AEGP_GetLayerIndex)(
						AEGP_LayerH			layerH,					/* >> */
						A_long				*layer_indexPL);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerSourceItem)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_ItemH			*source_itemPH);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerParentComp)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_CompH			*compPH);				/* << */

	SPAPI A_Err	(*AEGP_GetLayerName)(
						AEGP_LayerH 		layerH,					/* >> */
						A_char				*layer_nameZ0,			/* << space for A_char[AEGP_MAX_LAYER_NAME_SIZE] */
						A_char				*source_nameZ0);		/* << space for A_char[AEGP_MAX_LAYER_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetLayerQuality)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerQuality	*qualityP);				/* << */

	SPAPI A_Err	(*AEGP_SetLayerQuality)(							/* UNDOABLE */
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerQuality	quality);				/* >> */

	SPAPI A_Err	(*AEGP_GetLayerFlags)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerFlags		*layer_flagsP);			/* << */

	SPAPI A_Err (*AEGP_SetLayerFlag)(
						AEGP_LayerH			layerH,					/* >> */
						AEGP_LayerFlags		single_flag,			/* >> */
						A_Boolean			valueB);				/* >> */

	SPAPI A_Err	(*AEGP_IsLayerVideoReallyOn)(						// accounts for solo status of other layers in comp
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			*onPB);					/* << */

	SPAPI A_Err	(*AEGP_IsLayerAudioReallyOn)(						// accounts for solo status of other layers in comp
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			*onPB);					/* << */

	SPAPI A_Err	(*AEGP_GetLayerCurrentTime)(						// not updated while rendering
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						A_Time 				*curr_timePT);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerInPoint)(
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						A_Time 				*in_pointPT);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerDuration)(
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						A_Time 				*durationPT);			/* << */

	SPAPI A_Err	(*AEGP_SetLayerInPointAndDuration)(					/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						AEGP_LTimeMode		time_mode,				/* >> */
						const A_Time 		*in_pointPT,			/* >> */
						const A_Time 		*durationPT);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerOffset)(
						AEGP_LayerH 		layerH,					/* >> */
						A_Time 				*offsetPT);				/* << always in comp time */

	SPAPI A_Err	(*AEGP_SetLayerOffset)(								/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						const A_Time 		*offsetPT);				/* >> always in comp time */

	SPAPI A_Err	(*AEGP_GetLayerStretch)(
						AEGP_LayerH 		layerH,					/* >> */
						A_Ratio 			*stretchPRt);			/* << */

	SPAPI A_Err	(*AEGP_SetLayerStretch)(							/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						const A_Ratio 		*stretchPRt);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerTransferMode)(
						AEGP_LayerH 			layerH,				/* >> */
						AEGP_LayerTransferMode	*transfer_modeP);	/* << */

	SPAPI A_Err	(*AEGP_SetLayerTransferMode)(								/* UNDOABLE */
						AEGP_LayerH 					layerH,				/* >> */
						const AEGP_LayerTransferMode	*transfer_modeP);	/* >> */

	SPAPI A_Err	(*AEGP_IsAddLayerValid)(
						AEGP_ItemH 			item_to_addH,			/* >> */
						AEGP_CompH 			into_compH,				/* >> */
						A_Boolean			*validPB);				/* << */

	SPAPI A_Err	(*AEGP_AddLayer)(									/* UNDOABLE */
						AEGP_ItemH 			item_to_addH,			/* >> check AEGP_IsAddLayerValid() before using */
						AEGP_CompH 			into_compH,				/* >> */
						AEGP_LayerH			*added_layerPH0);		/* << */

	SPAPI A_Err	(*AEGP_ReorderLayer)(								/* UNDOABLE */
						AEGP_LayerH 		layerH,					/* >> */
						A_long 				layer_indexL);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerMaskedBounds)(
						AEGP_LayerH 		layerH,			/* >> */
						AEGP_LTimeMode		time_mode,		/* >> */
						const A_Time	 	*timePT,		/* >> */
						A_FloatRect			*boundsPR);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerObjectType)(
						AEGP_LayerH 		layerH,				/* >> */
						AEGP_ObjectType 	*object_type);		/* << */

	SPAPI A_Err	(*AEGP_IsLayer3D)(
						AEGP_LayerH 		layerH,				/* >> */
						A_Boolean 			*is_3DPB);			/* << */

	SPAPI A_Err	(*AEGP_IsLayer2D)(
						AEGP_LayerH 		layerH,				/* >> */
						A_Boolean 			*is_2DPB);			/* << */

	SPAPI A_Err	(*AEGP_IsVideoActive)(
						AEGP_LayerH 		layerH,				/* >> */
						AEGP_LTimeMode		time_mode,			/* >> */
						const A_Time	 	*timePT,			/* >> */
						A_Boolean			*is_activePB);		/* << */

	SPAPI A_Err	(*AEGP_IsLayerUsedAsTrackMatte)(
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			fill_must_be_activeB,	/* >> */
						A_Boolean			*is_track_mattePB);		/* << */

	SPAPI A_Err	(*AEGP_DoesLayerHaveTrackMatte)(
						AEGP_LayerH			layerH,					/* >> */
						A_Boolean			*has_track_mattePB);	/* << */

	SPAPI A_Err	(*AEGP_ConvertCompToLayerTime)(
					AEGP_LayerH		layerH,							/* >> */
					const A_Time	*comp_timePT,					/* >> */
					A_Time			*layer_timePT);					/* << */

	SPAPI A_Err	(*AEGP_ConvertLayerToCompTime)(
					AEGP_LayerH		layerH,							/* >> */
					const A_Time	*layer_timePT,					/* >> */
					A_Time			*comp_timePT) ;					/* << */

	SPAPI A_Err	(*AEGP_GetLayerDancingRandValue)(
					AEGP_LayerH		layerH,							/* >> */
					const A_Time	*comp_timePT,					/* >> */
					A_long			*rand_valuePL);					/* << */

	SPAPI A_Err	(*AEGP_GetLayerID)(
						AEGP_LayerH				layerH,				/* >> */
						AEGP_LayerIDVal			*id_valP);			/* << */

	SPAPI A_Err	(*AEGP_GetLayerToWorldXform)(
				AEGP_LayerH				aegp_layerH,		/* >> */
				const A_Time			*comp_timeP,		/* >> */
				A_Matrix4				*tranform);			/* >> */

	SPAPI A_Err	(*AEGP_GetLayerToWorldXformFromView)(
				AEGP_LayerH				aegp_layerH,		/* >> */
				const A_Time			*view_timeP,		/* >> */
				const A_Time			*comp_timeP,		/* >> */
				A_Matrix4				*tranform);			/* >> */

	SPAPI A_Err (*AEGP_SetLayerName)(
				AEGP_LayerH				aegp_layerH,		/* >> */
				const A_char			*new_nameZ);		/* >> */

	SPAPI A_Err	(*AEGP_GetLayerParent)(
				const AEGP_LayerH		layerH,				/* >> */
				AEGP_LayerH				*parent_layerPH);	/* << NULL if no parent */

	SPAPI A_Err (*AEGP_SetLayerParent)(
				AEGP_LayerH				layerH,				/* >> */
				const AEGP_LayerH		parent_layerH);		/* >> */


} AEGP_LayerSuite2;




#define kAEGPEffectSuite				"AEGP Effect Suite"
#define kAEGPEffectSuiteVersion1		1 /* frozen in AE 5.5 */

typedef struct AEGP_EffectSuite1 {

	SPAPI A_Err	(*AEGP_GetLayerNumEffects)(
						AEGP_LayerH			layerH,					/* >> */
						A_long				*num_effectsPL);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerEffectByIndex)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_LayerH			layerH,					/* >> */
						AEGP_EffectIndex	layer_effect_indexL,	/* >> */
						AEGP_EffectRefH		*effectPH);				/* <<  MUST dispose with DisposeEffect*/

	SPAPI A_Err (*AEGP_GetInstalledKeyFromLayerEffect)(
						AEGP_EffectRefH		effect_refH,					/* >> */
						AEGP_InstalledEffectKey	*installed_effect_keyP);	/* << */

	SPAPI A_Err (*AEGP_GetEffectParamUnionByIndex)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_EffectRefH		effect_refH,			/* >> */
						PF_ParamIndex		param_index,			/* >> valid in range [0 to AEGP_GetEffectNumParamStreams - 1], where 0 is the effect's input layer */
						PF_ParamType		*param_typeP,			/* << */
						PF_ParamDefUnion	*uP0);					/* << DO NOT USE THE VALUE FROM THIS PARAMDEF! */

	SPAPI A_Err (*AEGP_GetEffectFlags)(
						AEGP_EffectRefH		effect_refH,			/* >> */
						AEGP_EffectFlags	*effect_flagsP);		/* << */

	SPAPI A_Err (*AEGP_SetEffectFlags)(
						AEGP_EffectRefH		effect_refH,			/* >> */
						AEGP_EffectFlags	effect_flags_set_mask,	/* >> */
						AEGP_EffectFlags	effect_flags);			/* >> */

	SPAPI A_Err	(*AEGP_ReorderEffect)(								/* UNDOABLE */
						AEGP_EffectRefH 	effect_refH,			/* >> */
						A_long 				effect_indexL);			/* >> */

	SPAPI A_Err (*AEGP_EffectCallGeneric)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_EffectRefH		effect_refH,			/* >> */
						const A_Time		*timePT,				/* >> Use the timebase of the layer to which effect is applied. */
						void				*effect_extraPV);		/* <> */

	SPAPI A_Err (*AEGP_DisposeEffect)(
						AEGP_EffectRefH	effect_refH );				/* >> */

	SPAPI A_Err (*AEGP_ApplyEffect)(
						AEGP_PluginID		aegp_plugin_id,				/* >> */
						AEGP_LayerH			layerH,						/* >> */
						AEGP_InstalledEffectKey	installed_effect_key,	/* >> */
						AEGP_EffectRefH		*effect_refPH);				/* <<  MUST BE DISPOSED with AEGP_DisposeEffect */

	SPAPI A_Err	(*AEGP_DeleteLayerEffect)(
						AEGP_EffectRefH 	effect_refH);				/* >>  undoable */

	SPAPI A_Err (*AEGP_GetNumInstalledEffects)(
						A_long 				*num_installed_effectsPL);	/* << */

	// pass in AEGP_InstalledEffectKey_NONE for installed_effect_key to get first effect key

	SPAPI A_Err (*AEGP_GetNextInstalledEffect)(
									AEGP_InstalledEffectKey	installed_effect_key,	/* >> */
									AEGP_InstalledEffectKey	*next_effectPH);		/* << */

	SPAPI A_Err	(*AEGP_GetEffectName)(
						AEGP_InstalledEffectKey		installed_effect_key,	/* >> */
						A_char						*nameZ);				/* << space for A_char[AEGP_MAX_EFFECT_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetEffectMatchName)(
						AEGP_InstalledEffectKey		installed_effect_key,	/* >> */
						A_char						*match_nameZ);			/* << space for A_char[AEGP_MAX_EFFECT_MATCH_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetEffectCategory)(
						AEGP_InstalledEffectKey		installed_effect_key,	/* >> */
						A_char						*categoryZ);			/* << space for A_char[AEGP_MAX_EFFECT_CATEGORY_NAME_SIZE] */


} AEGP_EffectSuite1;




#define kAEGPEffectSuiteVersion2		2 /* frozen in AE 6.5 */

typedef struct AEGP_EffectSuite2 {

	SPAPI A_Err	(*AEGP_GetLayerNumEffects)(
						AEGP_LayerH			layerH,					/* >> */
						A_long				*num_effectsPL);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerEffectByIndex)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_LayerH			layerH,					/* >> */
						AEGP_EffectIndex	layer_effect_indexL,	/* >> */
						AEGP_EffectRefH		*effectPH);				/* <<  MUST dispose with DisposeEffect*/

	SPAPI A_Err (*AEGP_GetInstalledKeyFromLayerEffect)(
						AEGP_EffectRefH		effect_refH,					/* >> */
						AEGP_InstalledEffectKey	*installed_effect_keyP);	/* << */

	SPAPI A_Err (*AEGP_GetEffectParamUnionByIndex)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_EffectRefH		effect_refH,			/* >> */
						PF_ParamIndex		param_index,			/* >> valid in range [0 to AEGP_GetEffectNumParamStreams - 1], where 0 is the effect's input layer */
						PF_ParamType		*param_typeP,			/* << */
						PF_ParamDefUnion	*uP0);					/* << DO NOT USE THE VALUE FROM THIS PARAMDEF! */

	SPAPI A_Err (*AEGP_GetEffectFlags)(
						AEGP_EffectRefH		effect_refH,			/* >> */
						AEGP_EffectFlags	*effect_flagsP);		/* << */

	SPAPI A_Err (*AEGP_SetEffectFlags)(
						AEGP_EffectRefH		effect_refH,			/* >> */
						AEGP_EffectFlags	effect_flags_set_mask,	/* >> */
						AEGP_EffectFlags	effect_flags);			/* >> */

	SPAPI A_Err	(*AEGP_ReorderEffect)(								/* UNDOABLE */
						AEGP_EffectRefH 	effect_refH,			/* >> */
						A_long 				effect_indexL);			/* >> */

	SPAPI A_Err (*AEGP_EffectCallGeneric)(
						AEGP_PluginID		aegp_plugin_id,			/* >> */
						AEGP_EffectRefH		effect_refH,			/* >> */
						const A_Time		*timePT,				/* >> Use the timebase of the layer to which effect is applied. */
						void				*effect_extraPV);		/* <> */

	SPAPI A_Err (*AEGP_DisposeEffect)(
						AEGP_EffectRefH	effect_refH );				/* >> */

	SPAPI A_Err (*AEGP_ApplyEffect)(
						AEGP_PluginID		aegp_plugin_id,				/* >> */
						AEGP_LayerH			layerH,						/* >> */
						AEGP_InstalledEffectKey	installed_effect_key,	/* >> */
						AEGP_EffectRefH		*effect_refPH);				/* <<  MUST BE DISPOSED with AEGP_DisposeEffect */

	SPAPI A_Err	(*AEGP_DeleteLayerEffect)(
						AEGP_EffectRefH 	effect_refH);				/* >>  undoable */

	SPAPI A_Err (*AEGP_GetNumInstalledEffects)(
						A_long 				*num_installed_effectsPL);	/* << */

	// pass in AEGP_InstalledEffectKey_NONE for installed_effect_key to get first effect key

	SPAPI A_Err (*AEGP_GetNextInstalledEffect)(
									AEGP_InstalledEffectKey	installed_effect_key,	/* >> */
									AEGP_InstalledEffectKey	*next_effectPH);		/* << */

	SPAPI A_Err	(*AEGP_GetEffectName)(
						AEGP_InstalledEffectKey		installed_effect_key,	/* >> */
						A_char						*nameZ);				/* << space for A_char[AEGP_MAX_EFFECT_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetEffectMatchName)(
						AEGP_InstalledEffectKey		installed_effect_key,	/* >> */
						A_char						*match_nameZ);			/* << space for A_char[AEGP_MAX_EFFECT_MATCH_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetEffectCategory)(
						AEGP_InstalledEffectKey		installed_effect_key,	/* >> */
						A_char						*categoryZ);			/* << space for A_char[AEGP_MAX_EFFECT_CATEGORY_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_DuplicateEffect)(
						AEGP_EffectRefH		original_effect_refH,			/* >> */
						AEGP_EffectRefH		*duplicate_effect_refPH);		/* << */

} AEGP_EffectSuite2;


#define kAEGPEffectSuiteVersion3		3 /* frozen in AE 7.0 */

typedef struct AEGP_EffectSuite3 {

	SPAPI A_Err	(*AEGP_GetLayerNumEffects)(
		AEGP_LayerH			layerH,					/* >> */
		A_long				*num_effectsPL);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerEffectByIndex)(
		AEGP_PluginID		aegp_plugin_id,			/* >> */
		AEGP_LayerH			layerH,					/* >> */
		AEGP_EffectIndex	layer_effect_indexL,	/* >> */
		AEGP_EffectRefH		*effectPH);				/* <<  MUST dispose with DisposeEffect*/

	SPAPI A_Err (*AEGP_GetInstalledKeyFromLayerEffect)(
		AEGP_EffectRefH		effect_refH,					/* >> */
		AEGP_InstalledEffectKey	*installed_effect_keyP);	/* << */

	SPAPI A_Err (*AEGP_GetEffectParamUnionByIndex)(
		AEGP_PluginID		aegp_plugin_id,			/* >> */
		AEGP_EffectRefH		effect_refH,			/* >> */
		PF_ParamIndex		param_index,			/* >> valid in range [0 to AEGP_GetEffectNumParamStreams - 1], where 0 is the effect's input layer */
		PF_ParamType		*param_typeP,			/* << */
		PF_ParamDefUnion	*uP0);					/* << DO NOT USE THE VALUE FROM THIS PARAMDEF! */

	SPAPI A_Err (*AEGP_GetEffectFlags)(
		AEGP_EffectRefH		effect_refH,			/* >> */
		AEGP_EffectFlags	*effect_flagsP);		/* << */

	SPAPI A_Err (*AEGP_SetEffectFlags)(
		AEGP_EffectRefH		effect_refH,			/* >> */
		AEGP_EffectFlags	effect_flags_set_mask,	/* >> */
		AEGP_EffectFlags	effect_flags);			/* >> */

	SPAPI A_Err	(*AEGP_ReorderEffect)(								/* UNDOABLE */
		AEGP_EffectRefH 	effect_refH,			/* >> */
		A_long 				effect_indexL);			/* >> */

	/** new command parameter addded. To get old behaviour pass in PF_Cmd_COMPLETELY_GENERAL for effect_command **/
	SPAPI A_Err (*AEGP_EffectCallGeneric)(
		AEGP_PluginID		aegp_plugin_id,			/* >> */
		AEGP_EffectRefH		effect_refH,			/* >> */
		const A_Time		*timePT,				/* >> Use the timebase of the layer to which effect is applied. */
		PF_Cmd				effect_cmd,				/* >> new parameter from version 2 */
		void				*effect_extraPV);		/* <> */

	SPAPI A_Err (*AEGP_DisposeEffect)(
		AEGP_EffectRefH	effect_refH );				/* >> */

	SPAPI A_Err (*AEGP_ApplyEffect)(
		AEGP_PluginID		aegp_plugin_id,				/* >> */
		AEGP_LayerH			layerH,						/* >> */
		AEGP_InstalledEffectKey	installed_effect_key,	/* >> */
		AEGP_EffectRefH		*effect_refPH);				/* <<  MUST BE DISPOSED with AEGP_DisposeEffect */

	SPAPI A_Err	(*AEGP_DeleteLayerEffect)(
		AEGP_EffectRefH 	effect_refH);				/* >>  undoable */

	SPAPI A_Err (*AEGP_GetNumInstalledEffects)(
		A_long 				*num_installed_effectsPL);	/* << */

	// pass in AEGP_InstalledEffectKey_NONE for installed_effect_key to get first effect key

	SPAPI A_Err (*AEGP_GetNextInstalledEffect)(
		AEGP_InstalledEffectKey	installed_effect_key,	/* >> */
		AEGP_InstalledEffectKey	*next_effectPH);		/* << */

	SPAPI A_Err	(*AEGP_GetEffectName)(
		AEGP_InstalledEffectKey		installed_effect_key,	/* >> */
		A_char						*nameZ);				/* << space for A_char[AEGP_MAX_EFFECT_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetEffectMatchName)(
		AEGP_InstalledEffectKey		installed_effect_key,	/* >> */
		A_char						*match_nameZ);			/* << space for A_char[AEGP_MAX_EFFECT_MATCH_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetEffectCategory)(
		AEGP_InstalledEffectKey		installed_effect_key,	/* >> */
		A_char						*categoryZ);			/* << space for A_char[AEGP_MAX_EFFECT_CATEGORY_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_DuplicateEffect)(
		AEGP_EffectRefH		original_effect_refH,			/* >> */
		AEGP_EffectRefH		*duplicate_effect_refPH);		/* << */
} AEGP_EffectSuite3;

#define kAEGPLightSuite				"AEGP Light Suite"
#define kAEGPLightSuiteVersion1		1 /* frozen in AE 5.0 */



typedef struct AEGP_LightSuite1 {

	SPAPI A_Err	(*AEGP_GetLightType)(
						AEGP_LayerH				light_layerH,		/* >> */
						AEGP_LightType			*light_typeP);		/* << */


} AEGP_LightSuite1;



#define kAEGPMaskSuite					"AEGP Layer Mask Suite"
#define kAEGPMaskSuiteVersion5			6 /* frozen AE 10 */

typedef struct AEGP_MaskSuite5 {

	SPAPI A_Err	(*AEGP_GetLayerNumMasks)(
						AEGP_LayerH				aegp_layerH,		/* >> */
						A_long					*num_masksPL);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerMaskByIndex)(
						AEGP_LayerH				aegp_layerH,		/* >> */
						AEGP_MaskIndex			mask_indexL,		/* >> */
						AEGP_MaskRefH			*maskPH);			/* << must be disposed by calling AEGP_DisposeMask() */

	SPAPI A_Err	(*AEGP_DisposeMask)(
						AEGP_MaskRefH			mask_refH);			/* >> */

	SPAPI A_Err	(*AEGP_GetMaskInvert)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						A_Boolean				*invertPB);			/* << */

	SPAPI A_Err (*AEGP_SetMaskInvert)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						A_Boolean				invertB);			/* << */

	SPAPI A_Err	(*AEGP_GetMaskMode)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						PF_MaskMode				*modeP);			/* << */

	SPAPI A_Err (*AEGP_SetMaskMode)(
						AEGP_MaskRefH			maskH,				/* >> */
						PF_MaskMode				mode);				/* >> */

	SPAPI A_Err (*AEGP_GetMaskMotionBlurState)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						AEGP_MaskMBlur			*blur_stateP);		/* << */

	SPAPI A_Err (*AEGP_SetMaskMotionBlurState)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						AEGP_MaskMBlur			blur_state);		/* >> */

	// AEGP_GetMaskName/SetMaskName are obsoleted. Use AEGP_GetNewDynamicStreamForMask
	// and the name functions there

	SPAPI A_Err	(*AEGP_GetMaskID)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						AEGP_MaskIDVal			*id_valP);			/* << */

	SPAPI A_Err (*AEGP_CreateNewMask)(								/* UNDOABLE */
						AEGP_LayerH				layerH,				/* >> */
						AEGP_MaskRefH			*mask_refPH,		/* << */
						A_long					*mask_indexPL0);	/* << */

	SPAPI A_Err (*AEGP_DeleteMaskFromLayer)(						/* UNDOABLE */
						AEGP_MaskRefH			mask_refH);			/* >> still need to Dispose MaskRefH */

	SPAPI A_Err (*AEGP_GetMaskColor)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						AEGP_ColorVal			*colorP);			/* << */

	SPAPI A_Err (*AEGP_SetMaskColor)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						const AEGP_ColorVal		*colorP);			/* >> */

	SPAPI A_Err	(*AEGP_GetMaskLockState)(
						AEGP_MaskRefH			mask_refH,			/* <> */
						A_Boolean				*is_lockedPB);		/* >> */

	SPAPI A_Err	(*AEGP_SetMaskLockState)(
						AEGP_MaskRefH			mask_refH,			/* <> */
						A_Boolean				lockB);				/* >> */

	SPAPI A_Err (*AEGP_GetMaskIsRotoBezier)(
						AEGP_MaskRefH			mask_refH,			/* <> */
						A_Boolean				*is_roto_bezierPB);	/* << */

	SPAPI A_Err (*AEGP_SetMaskIsRotoBezier)(
						AEGP_MaskRefH			mask_refH,			/* <> */
						A_Boolean				is_roto_bezierB);	/* >> */

	SPAPI A_Err (*AEGP_DuplicateMask)(
						AEGP_MaskRefH			orig_mask_refH,			/* >> */
						AEGP_MaskRefH			*duplicate_mask_refPH);	/* << */

} AEGP_MaskSuite5;

#define kAEGPMaskSuiteVersion4			5 /* frozen AE 6.5 */

typedef struct AEGP_MaskSuite4 {

	SPAPI A_Err	(*AEGP_GetLayerNumMasks)(
		AEGP_LayerH				aegp_layerH,		/* >> */
		A_long					*num_masksPL);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerMaskByIndex)(
		AEGP_LayerH				aegp_layerH,		/* >> */
		AEGP_MaskIndex			mask_indexL,		/* >> */
		AEGP_MaskRefH			*maskPH);			/* << must be disposed by calling AEGP_DisposeMask() */

	SPAPI A_Err	(*AEGP_DisposeMask)(
		AEGP_MaskRefH			mask_refH);			/* >> */

	SPAPI A_Err	(*AEGP_GetMaskInvert)(
		AEGP_MaskRefH			mask_refH,			/* >> */
		A_Boolean				*invertPB);			/* << */

	SPAPI A_Err (*AEGP_SetMaskInvert)(
		AEGP_MaskRefH			mask_refH,			/* >> */
		A_Boolean				invertB);			/* << */

	SPAPI A_Err	(*AEGP_GetMaskMode)(
		AEGP_MaskRefH			mask_refH,			/* >> */
		PF_MaskMode				*modeP);			/* << */

	SPAPI A_Err (*AEGP_SetMaskMode)(
		AEGP_MaskRefH			maskH,				/* >> */
		PF_MaskMode				mode);				/* >> */

	SPAPI A_Err (*AEGP_GetMaskMotionBlurState)(
		AEGP_MaskRefH			mask_refH,			/* >> */
		AEGP_MaskMBlur			*blur_stateP);		/* << */

	SPAPI A_Err (*AEGP_SetMaskMotionBlurState)(
		AEGP_MaskRefH			mask_refH,			/* >> */
		AEGP_MaskMBlur			blur_state);		/* >> */

	SPAPI A_Err	(*AEGP_GetMaskName)(
		AEGP_MaskRefH			mask_refH,			/* >> */
		A_char					*nameZ);			/* << space for A_char[AEGP_MAX_MASK_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_SetMaskName)(
		AEGP_MaskRefH			mask_refH,			/* >> */
		A_char					*nameZ);			/* >> space for A_char[AEGP_MAX_MASK_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetMaskID)(
		AEGP_MaskRefH			mask_refH,			/* >> */
		AEGP_MaskIDVal			*id_valP);			/* << */

	SPAPI A_Err (*AEGP_CreateNewMask)(								/* UNDOABLE */
		AEGP_LayerH				layerH,				/* >> */
		AEGP_MaskRefH			*mask_refPH,		/* << */
		A_long					*mask_indexPL0);	/* << */

	SPAPI A_Err (*AEGP_DeleteMaskFromLayer)(						/* UNDOABLE */
		AEGP_MaskRefH			mask_refH);			/* >> still need to Dispose MaskRefH */

	SPAPI A_Err (*AEGP_GetMaskColor)(
		AEGP_MaskRefH			mask_refH,			/* >> */
		AEGP_ColorVal			*colorP);			/* << */

	SPAPI A_Err (*AEGP_SetMaskColor)(
		AEGP_MaskRefH			mask_refH,			/* >> */
		const AEGP_ColorVal		*colorP);			/* >> */

	SPAPI A_Err	(*AEGP_GetMaskLockState)(
		AEGP_MaskRefH			mask_refH,			/* <> */
		A_Boolean				*is_lockedPB);		/* >> */

	SPAPI A_Err	(*AEGP_SetMaskLockState)(
		AEGP_MaskRefH			mask_refH,			/* <> */
		A_Boolean				lockB);				/* >> */

	SPAPI A_Err (*AEGP_GetMaskIsRotoBezier)(
		AEGP_MaskRefH			mask_refH,			/* <> */
		A_Boolean				*is_roto_bezierPB);	/* << */

	SPAPI A_Err (*AEGP_SetMaskIsRotoBezier)(
		AEGP_MaskRefH			mask_refH,			/* <> */
		A_Boolean				is_roto_bezierB);	/* >> */

	SPAPI A_Err (*AEGP_DuplicateMask)(
		AEGP_MaskRefH			orig_mask_refH,			/* >> */
		AEGP_MaskRefH			*duplicate_mask_refPH);	/* << */

} AEGP_MaskSuite4;

#define kAEGPMaskSuiteVersion3			4 /* frozen AE 6.0 */

typedef struct AEGP_MaskSuite3 {

	SPAPI A_Err	(*AEGP_GetLayerNumMasks)(
						AEGP_LayerH				aegp_layerH,		/* >> */
						A_long					*num_masksPL);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerMaskByIndex)(
						AEGP_LayerH				aegp_layerH,		/* >> */
						AEGP_MaskIndex			mask_indexL,		/* >> */
						AEGP_MaskRefH			*maskPH);			/* << must be disposed by calling AEGP_DisposeMask() */

	SPAPI A_Err	(*AEGP_DisposeMask)(
						AEGP_MaskRefH			mask_refH);			/* >> */

	SPAPI A_Err	(*AEGP_GetMaskInvert)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						A_Boolean				*invertPB);			/* << */

	SPAPI A_Err (*AEGP_SetMaskInvert)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						A_Boolean				invertB);			/* << */

	SPAPI A_Err	(*AEGP_GetMaskMode)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						PF_MaskMode				*modeP);			/* << */

	SPAPI A_Err (*AEGP_SetMaskMode)(
						AEGP_MaskRefH			maskH,				/* >> */
						PF_MaskMode				mode);				/* >> */

	SPAPI A_Err (*AEGP_GetMaskMotionBlurState)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						AEGP_MaskMBlur			*blur_stateP);		/* << */

	SPAPI A_Err (*AEGP_SetMaskMotionBlurState)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						AEGP_MaskMBlur			blur_state);		/* >> */

	SPAPI A_Err	(*AEGP_GetMaskName)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						A_char					*nameZ);			/* << space for A_char[AEGP_MAX_MASK_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_SetMaskName)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						A_char					*nameZ);			/* >> space for A_char[AEGP_MAX_MASK_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetMaskID)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						AEGP_MaskIDVal			*id_valP);			/* << */

	SPAPI A_Err (*AEGP_CreateNewMask)(								/* UNDOABLE */
						AEGP_LayerH				layerH,				/* >> */
						AEGP_MaskRefH			*mask_refPH,		/* << */
						A_long					*mask_indexPL0);	/* << */

	SPAPI A_Err (*AEGP_DeleteMaskFromLayer)(						/* UNDOABLE */
						AEGP_MaskRefH			mask_refH);			/* >> still need to Dispose MaskRefH */

	SPAPI A_Err (*AEGP_GetMaskColor)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						AEGP_ColorVal			*colorP);			/* << */

	SPAPI A_Err (*AEGP_SetMaskColor)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						const AEGP_ColorVal		*colorP);			/* >> */

	SPAPI A_Err	(*AEGP_GetMaskLockState)(
						AEGP_MaskRefH			mask_refH,			/* <> */
						A_Boolean				*is_lockedPB);		/* >> */

	SPAPI A_Err	(*AEGP_SetMaskLockState)(
						AEGP_MaskRefH			mask_refH,			/* <> */
						A_Boolean				lockB);				/* >> */

	SPAPI A_Err (*AEGP_GetMaskIsRotoBezier)(
						AEGP_MaskRefH			mask_refH,			/* <> */
						A_Boolean				*is_roto_bezierPB);	/* << */

	SPAPI A_Err (*AEGP_SetMaskIsRotoBezier)(
						AEGP_MaskRefH			mask_refH,			/* <> */
						A_Boolean				is_roto_bezierB);	/* >> */

} AEGP_MaskSuite3;

#define kAEGPMaskSuiteVersion1			2 /* frozen in AE 5.0 */

typedef struct AEGP_MaskSuite1 {

	SPAPI A_Err	(*AEGP_GetLayerNumMasks)(
						AEGP_LayerH				aegp_layerH,		/* >> */
						A_long					*num_masksPL);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerMaskByIndex)(
						AEGP_LayerH				aegp_layerH,		/* >> */
						AEGP_MaskIndex			mask_indexL,		/* >> */
						AEGP_MaskRefH			*maskPH);			/* << must be disposed by calling AEGP_DisposeMask() */

	SPAPI A_Err	(*AEGP_DisposeMask)(
						AEGP_MaskRefH			mask_refH);				/* >> */

	SPAPI A_Err	(*AEGP_GetMaskInvert)(
						AEGP_MaskRefH			mask_refH,				/* >> */
						A_Boolean				*invertPB);			/* << */

	SPAPI A_Err	(*AEGP_GetMaskMode)(
						AEGP_MaskRefH			mask_refH,				/* >> */
						PF_MaskMode				*modeP);			/* << */

	SPAPI A_Err	(*AEGP_GetMaskName)(
						AEGP_MaskRefH			mask_refH,				/* >> */
						A_char					*nameZ);			/* << space for A_char[AEGP_MAX_MASK_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetMaskID)(
						AEGP_MaskRefH			mask_refH,				/* >> */
						AEGP_MaskIDVal			*id_valP);			/* << */

	SPAPI A_Err (*AEGP_CreateNewMask)(			//undoable
						AEGP_LayerH				layerH,			/* >> */
						AEGP_MaskRefH			*mask_refPH,	/* << */
						A_long					*mask_indexPL0);/* << */

	SPAPI A_Err (*AEGP_DeleteMaskFromLayer)(	//undoable
						AEGP_MaskRefH			mask_refH);		/* >> still need to Dispose MaskRefH */

} AEGP_MaskSuite1;

#define kAEGPMaskSuiteVersion2			3 /* frozen in AE 5.5 */

typedef struct AEGP_MaskSuite2 {

	SPAPI A_Err	(*AEGP_GetLayerNumMasks)(
						AEGP_LayerH				aegp_layerH,		/* >> */
						A_long					*num_masksPL);		/* << */

	SPAPI A_Err	(*AEGP_GetLayerMaskByIndex)(
						AEGP_LayerH				aegp_layerH,		/* >> */
						AEGP_MaskIndex			mask_indexL,		/* >> */
						AEGP_MaskRefH			*maskPH);			/* << must be disposed by calling AEGP_DisposeMask() */

	SPAPI A_Err	(*AEGP_DisposeMask)(
						AEGP_MaskRefH			mask_refH);			/* >> */

	SPAPI A_Err	(*AEGP_GetMaskInvert)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						A_Boolean				*invertPB);			/* << */

	SPAPI A_Err (*AEGP_SetMaskInvert)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						A_Boolean				invertB);			/* << */

	SPAPI A_Err	(*AEGP_GetMaskMode)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						PF_MaskMode				*modeP);			/* << */

	SPAPI A_Err (*AEGP_SetMaskMode)(
						AEGP_MaskRefH			maskH,				/* >> */
						PF_MaskMode				mode);				/* >> */

	SPAPI A_Err (*AEGP_GetMaskMotionBlurState)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						AEGP_MaskMBlur			*blur_stateP);		/* << */

	SPAPI A_Err (*AEGP_SetMaskMotionBlurState)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						AEGP_MaskMBlur			blur_state);		/* >> */

	SPAPI A_Err	(*AEGP_GetMaskName)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						A_char					*nameZ);			/* << space for A_char[AEGP_MAX_MASK_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetMaskID)(
						AEGP_MaskRefH			mask_refH,			/* >> */
						AEGP_MaskIDVal			*id_valP);			/* << */

	SPAPI A_Err (*AEGP_CreateNewMask)(								//undoable
						AEGP_LayerH				layerH,				/* >> */
						AEGP_MaskRefH			*mask_refPH,		/* << */
						A_long					*mask_indexPL0);	/* << */

	SPAPI A_Err (*AEGP_DeleteMaskFromLayer)(						//undoable
						AEGP_MaskRefH			mask_refH);			/* >> still need to Dispose MaskRefH */

} AEGP_MaskSuite2;
/**
 ** Camera Suite
 **
 **/
#define kAEGPCameraSuite				"AEGP Camera Suite"
#define kAEGPCameraSuiteVersion1		1 /* frozen in AE 5.0 */



typedef struct AEGP_CameraSuite1 {

		SPAPI A_Err	(*AEGP_GetCamera)(
						PR_RenderContextH 		render_contextH,   	/* >> */
						const A_Time			*comp_timeP,		/* >> */
						AEGP_LayerH				*camera_layerPH);	/* << */

		SPAPI A_Err	(*AEGP_GetCameraType)(
						AEGP_LayerH				camera_layerH,		/* >> */
						AEGP_CameraType			*camera_typeP);		/* << */


		SPAPI A_Err (*AEGP_GetDefaultCameraDistanceToImagePlane)(
					AEGP_CompH				compH,					/* >> */
					A_FpLong				*dist_to_planePF);		/* << */

} AEGP_CameraSuite1;


#define kAEGPItemSuite				"AEGP Item Suite"

#define kAEGPItemSuiteVersion8		13	/* frozen in AE 9.0 */

typedef struct AEGP_ItemSuite8 {

	SPAPI A_Err	(*AEGP_GetFirstProjItem)(
						AEGP_ProjectH		projectH,				/* >> */
						AEGP_ItemH			*itemPH);					/* << */

	SPAPI A_Err	(*AEGP_GetNextProjItem)(
						AEGP_ProjectH		projectH,				/* >> */
						AEGP_ItemH			itemH,					/* >> */
						AEGP_ItemH			*next_itemPH);			/* << NULL after last item */

	SPAPI A_Err	(*AEGP_GetActiveItem)(
						AEGP_ItemH			*itemPH);				/* << NULL if none is active */

	SPAPI A_Err	(*AEGP_IsItemSelected)(
						AEGP_ItemH			itemH,					/* >> */
						A_Boolean			*selectedPB);			/* << */

	SPAPI A_Err	(*AEGP_SelectItem)(
						AEGP_ItemH			itemH,					/* >> */
						A_Boolean			selectB,				/* >>	allows to select or deselect the item */
						A_Boolean			deselect_othersB);		/* >> */

	SPAPI A_Err	(*AEGP_GetItemType)(
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_ItemType		*item_typeP);			/* << */

	SPAPI A_Err	(*AEGP_GetTypeName)(
						AEGP_ItemType		item_type,				/* << */
						A_char 				*nameZ);				/* << space for A_char[AEGP_MAX_TYPE_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetItemName)(
						AEGP_PluginID			pluginID,				// in
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_MemHandle		*unicode_namePH);	// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle

	SPAPI A_Err	(*AEGP_SetItemName)(								/* UNDOABLE */
						AEGP_ItemH 			itemH,					/* >> */
						const A_UTF16Char	*nameZ);				/* >> null terminated UTF16 */

	SPAPI A_Err	(*AEGP_GetItemID)(
						AEGP_ItemH 			itemH,					/* >> */
						A_long				*item_idPL);			/* << */

	SPAPI A_Err	(*AEGP_GetItemFlags)(
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_ItemFlags		*item_flagsP);			/* << */

	SPAPI A_Err	(*AEGP_SetItemUseProxy)(							/* UNDOABLE */
						AEGP_ItemH 			itemH,					/* >> error if has_proxy is FALSE! */
						A_Boolean			use_proxyB);			/* >> */

	SPAPI A_Err	(*AEGP_GetItemParentFolder)(
						AEGP_ItemH			itemH,					/* >> */
						AEGP_ItemH			*parent_folder_itemPH);	/* << */

	SPAPI A_Err	(*AEGP_SetItemParentFolder)(
						AEGP_ItemH			itemH,					/* <> */
						AEGP_ItemH			parent_folder_itemH);	/* >> */

	SPAPI A_Err	(*AEGP_GetItemDuration)(							/* Returns the result in the item's native timespace:	*/
						AEGP_ItemH 			itemH,					/* >>		Comp			-> comp time,				*/
						A_Time 				*durationPT);			/* <<		Footage			-> footage time,			*/
																	/*			Folder			-> 0 (no duration)			*/

	SPAPI A_Err	(*AEGP_GetItemCurrentTime)(							/* Returns the result in the item's native timespace (not updated while rendering)*/
						AEGP_ItemH 			itemH,					/* >>	*/
						A_Time 				*curr_timePT);			/* <<	*/

	SPAPI A_Err	(*AEGP_GetItemDimensions)(
						AEGP_ItemH 			itemH,					/* >> */
						A_long	 			*widthPL,				/* << */
						A_long				*heightPL);				/* << */

	SPAPI A_Err	(*AEGP_GetItemPixelAspectRatio)(
						AEGP_ItemH 			itemH,					/* >> */
						A_Ratio 			*pix_aspect_ratioPRt);	/* << */

	SPAPI A_Err	(*AEGP_DeleteItem)(									/* UNDOABLE */
						AEGP_ItemH 			itemH);					/* >> removes item from all comps */

	SPAPI A_Err (*AEGP_CreateNewFolder)(
						const A_UTF16Char	*nameZ,				/* >> null terminated UTF16 */
						AEGP_ItemH			parent_folderH0,		/* >> */
						AEGP_ItemH			*new_folderPH);			/* << allocated and owned by AE */

	SPAPI A_Err (*AEGP_SetItemCurrentTime)(							/* UNDOABLE. Use the item's native timespace */
						AEGP_ItemH 			itemH,					/* >> */
						const A_Time		*new_timePT);			/* >> */

	SPAPI A_Err (*AEGP_GetItemCommentLength)(
						AEGP_ItemH			itemH, 					/* >> */
						A_u_long			*buf_sizePLu);			/* << */

	SPAPI A_Err	(*AEGP_GetItemComment)(
						AEGP_ItemH			itemH,					/* >> */
						A_u_long			buf_sizeLu,				/* >> */
						A_char				*commentZ);				/* << */

	SPAPI A_Err (*AEGP_SetItemComment)(
						AEGP_ItemH			itemH, 					/* >> UNDOABLE */
						const A_char			*commentZ);				/* >> */

	SPAPI A_Err (*AEGP_GetItemLabel)(
						AEGP_ItemH			itemH, 					/* >> */
						AEGP_LabelID		*labelP);				/* << */

	SPAPI A_Err (*AEGP_SetItemLabel)(
						AEGP_ItemH			itemH, 					/* >> UNDOABLE */
						AEGP_LabelID		label);					/* >> */

	SPAPI A_Err (*AEGP_GetItemMRUView)(
						AEGP_ItemH			itemH,					// >>
						AEGP_ItemViewP		*mru_viewP);			// <<

} AEGP_ItemSuite8;

#define kAEGPItemSuiteVersion7		11	/* frozen in AE 8.0 */

typedef struct AEGP_ItemSuite7 {

	SPAPI A_Err	(*AEGP_GetFirstProjItem)(
		AEGP_ProjectH		projectH,				/* >> */
		AEGP_ItemH			*itemPH);					/* << */

	SPAPI A_Err	(*AEGP_GetNextProjItem)(
		AEGP_ProjectH		projectH,				/* >> */
		AEGP_ItemH			itemH,					/* >> */
		AEGP_ItemH			*next_itemPH);			/* << NULL after last item */

	SPAPI A_Err	(*AEGP_GetActiveItem)(
		AEGP_ItemH			*itemPH);				/* << NULL if none is active */

	SPAPI A_Err	(*AEGP_IsItemSelected)(
		AEGP_ItemH			itemH,					/* >> */
		A_Boolean			*selectedPB);			/* << */

	SPAPI A_Err	(*AEGP_SelectItem)(
		AEGP_ItemH			itemH,					/* >> */
		A_Boolean			selectB,				/* >>	allows to select or deselect the item */
		A_Boolean			deselect_othersB);		/* >> */

	SPAPI A_Err	(*AEGP_GetItemType)(
		AEGP_ItemH 			itemH,					/* >> */
		AEGP_ItemType		*item_typeP);			/* << */

	SPAPI A_Err	(*AEGP_GetTypeName)(
		AEGP_ItemType		item_type,				/* << */
		A_char 				*nameZ);				/* << space for A_char[AEGP_MAX_TYPE_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetItemName)(
		AEGP_ItemH 			itemH,					/* >> */
		A_char				*nameZ);				/* << space for A_char[AEGP_MAX_ITEM_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_SetItemName)(								/* UNDOABLE */
		AEGP_ItemH 			itemH,					/* >> */
		const A_char		*nameZ);				/* >> up to  A_char[AEGP_MAX_ITEM_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetItemID)(
		AEGP_ItemH 			itemH,					/* >> */
		A_long				*item_idPL);			/* << */

	SPAPI A_Err	(*AEGP_GetItemFlags)(
		AEGP_ItemH 			itemH,					/* >> */
		AEGP_ItemFlags		*item_flagsP);			/* << */

	SPAPI A_Err	(*AEGP_SetItemUseProxy)(							/* UNDOABLE */
		AEGP_ItemH 			itemH,					/* >> error if has_proxy is FALSE! */
		A_Boolean			use_proxyB);			/* >> */

	SPAPI A_Err	(*AEGP_GetItemParentFolder)(
		AEGP_ItemH			itemH,					/* >> */
		AEGP_ItemH			*parent_folder_itemPH);	/* << */

	SPAPI A_Err	(*AEGP_SetItemParentFolder)(
		AEGP_ItemH			itemH,					/* <> */
		AEGP_ItemH			parent_folder_itemH);	/* >> */

	SPAPI A_Err	(*AEGP_GetItemDuration)(							/* Returns the result in the item's native timespace:	*/
		AEGP_ItemH 			itemH,					/* >>		Comp			-> comp time,				*/
		A_Time 				*durationPT);			/* <<		Footage			-> footage time,			*/
	/*			Folder			-> 0 (no duration)			*/

	SPAPI A_Err	(*AEGP_GetItemCurrentTime)(							/* Returns the result in the item's native timespace (not updated while rendering)*/
		AEGP_ItemH 			itemH,					/* >>	*/
		A_Time 				*curr_timePT);			/* <<	*/

	SPAPI A_Err	(*AEGP_GetItemDimensions)(
		AEGP_ItemH 			itemH,					/* >> */
		A_long	 			*widthPL,				/* << */
		A_long				*heightPL);				/* << */

	SPAPI A_Err	(*AEGP_GetItemPixelAspectRatio)(
		AEGP_ItemH 			itemH,					/* >> */
		A_Ratio 			*pix_aspect_ratioPRt);	/* << */

	SPAPI A_Err	(*AEGP_DeleteItem)(									/* UNDOABLE */
		AEGP_ItemH 			itemH);					/* >> removes item from all comps */

	SPAPI A_Err (*AEGP_CreateNewFolder)(
		const A_char		*nameZ,					/* >> */
		AEGP_ItemH			parent_folderH0,		/* >> */
		AEGP_ItemH			*new_folderPH);			/* << allocated and owned by AE */

	SPAPI A_Err (*AEGP_SetItemCurrentTime)(							/* UNDOABLE. Use the item's native timespace */
		AEGP_ItemH 			itemH,					/* >> */
		const A_Time		*new_timePT);			/* >> */

	SPAPI A_Err (*AEGP_GetItemCommentLength)(
		AEGP_ItemH			itemH, 					/* >> */
		A_u_long			*buf_sizePLu);			/* << */

	SPAPI A_Err	(*AEGP_GetItemComment)(
		AEGP_ItemH			itemH,					/* >> */
		A_u_long			buf_sizeLu,				/* >> */
		A_char				*commentZ);				/* << */

	SPAPI A_Err (*AEGP_SetItemComment)(
		AEGP_ItemH			itemH, 					/* >> UNDOABLE */
		const A_char			*commentZ);				/* >> */

	SPAPI A_Err (*AEGP_GetItemLabel)(
		AEGP_ItemH			itemH, 					/* >> */
		AEGP_LabelID		*labelP);				/* << */

	SPAPI A_Err (*AEGP_SetItemLabel)(
		AEGP_ItemH			itemH, 					/* >> UNDOABLE */
		AEGP_LabelID		label);					/* >> */

	SPAPI A_Err (*AEGP_GetItemMRUView)(
		AEGP_ItemH			itemH,					// >>
		AEGP_ItemViewP		*mru_viewP);			// <<

} AEGP_ItemSuite7;


#define kAEGPItemSuiteVersion6		10	/* frozen in AE 7.0 */

typedef struct AEGP_ItemSuite6 {

	SPAPI A_Err	(*AEGP_GetFirstProjItem)(
						AEGP_ProjectH		projectH,				/* >> */
						AEGP_ItemH			*itemPH);					/* << */

	SPAPI A_Err	(*AEGP_GetNextProjItem)(
						AEGP_ProjectH		projectH,				/* >> */
						AEGP_ItemH			itemH,					/* >> */
						AEGP_ItemH			*next_itemPH);			/* << NULL after last item */

	SPAPI A_Err	(*AEGP_GetActiveItem)(
						AEGP_ItemH			*itemPH);				/* << NULL if none is active */

	SPAPI A_Err	(*AEGP_IsItemSelected)(
						AEGP_ItemH			itemH,					/* >> */
						A_Boolean			*selectedPB);			/* << */

	SPAPI A_Err	(*AEGP_SelectItem)(
						AEGP_ItemH			itemH,					/* >> */
						A_Boolean			selectB,				/* >>	allows to select or deselect the item */
						A_Boolean			deselect_othersB);		/* >> */

	SPAPI A_Err	(*AEGP_GetItemType)(
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_ItemType		*item_typeP);			/* << */

	SPAPI A_Err	(*AEGP_GetTypeName)(
						AEGP_ItemType		item_type,				/* << */
						A_char 				*nameZ);				/* << space for A_char[AEGP_MAX_TYPE_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetItemName)(
						AEGP_ItemH 			itemH,					/* >> */
						A_char				*nameZ);				/* << space for A_char[AEGP_MAX_ITEM_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_SetItemName)(								/* UNDOABLE */
						AEGP_ItemH 			itemH,					/* >> */
						const A_char		*nameZ);				/* >> up to  A_char[AEGP_MAX_ITEM_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetItemID)(
						AEGP_ItemH 			itemH,					/* >> */
						A_long				*item_idPL);			/* << */

	SPAPI A_Err	(*AEGP_GetItemFlags)(
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_ItemFlags		*item_flagsP);			/* << */

	SPAPI A_Err	(*AEGP_SetItemUseProxy)(							/* UNDOABLE */
						AEGP_ItemH 			itemH,					/* >> error if has_proxy is FALSE! */
						A_Boolean			use_proxyB);			/* >> */

	SPAPI A_Err	(*AEGP_GetItemParentFolder)(
						AEGP_ItemH			itemH,					/* >> */
						AEGP_ItemH			*parent_folder_itemPH);	/* << */

	SPAPI A_Err	(*AEGP_SetItemParentFolder)(
						AEGP_ItemH			itemH,					/* <> */
						AEGP_ItemH			parent_folder_itemH);	/* >> */

	SPAPI A_Err	(*AEGP_GetItemDuration)(							/* Returns the result in the item's native timespace:	*/
						AEGP_ItemH 			itemH,					/* >>		Comp			-> comp time,				*/
						A_Time 				*durationPT);			/* <<		Footage			-> footage time,			*/
																	/*			Folder			-> 0 (no duration)			*/

	SPAPI A_Err	(*AEGP_GetItemCurrentTime)(							/* Returns the result in the item's native timespace (not updated while rendering)*/
						AEGP_ItemH 			itemH,					/* >>	*/
						A_Time 				*curr_timePT);			/* <<	*/

	SPAPI A_Err	(*AEGP_GetItemDimensions)(
						AEGP_ItemH 			itemH,					/* >> */
						A_long	 			*widthPL,				/* << */
						A_long				*heightPL);				/* << */

	SPAPI A_Err	(*AEGP_GetItemPixelAspectRatio)(
						AEGP_ItemH 			itemH,					/* >> */
						A_Ratio 			*pix_aspect_ratioPRt);	/* << */

	SPAPI A_Err	(*AEGP_DeleteItem)(									/* UNDOABLE */
						AEGP_ItemH 			itemH);					/* >> removes item from all comps */

	SPAPI A_Err (*AEGP_CreateNewFolder)(
						const A_char		*nameZ,					/* >> */
						AEGP_ItemH			parent_folderH0,		/* >> */
						AEGP_ItemH			*new_folderPH);			/* << allocated and owned by AE */

	SPAPI A_Err (*AEGP_SetItemCurrentTime)(							/* UNDOABLE. Use the item's native timespace */
						AEGP_ItemH 			itemH,					/* >> */
						const A_Time		*new_timePT);			/* >> */

	SPAPI A_Err (*AEGP_GetItemCommentLength)(
						AEGP_ItemH			itemH, 					/* >> */
						A_u_long			*buf_sizePLu);			/* << */

	SPAPI A_Err	(*AEGP_GetItemComment)(
						AEGP_ItemH			itemH,					/* >> */
						A_u_long			buf_sizeLu,				/* >> */
						A_char				*commentZ);				/* << */

	SPAPI A_Err (*AEGP_SetItemComment)(
						AEGP_ItemH			itemH, 					/* >> UNDOABLE */
						const A_char			*commentZ);				/* >> */

	SPAPI A_Err (*AEGP_GetItemLabel)(
						AEGP_ItemH			itemH, 					/* >> */
						AEGP_LabelID		*labelP);				/* << */

	SPAPI A_Err (*AEGP_SetItemLabel)(
						AEGP_ItemH			itemH, 					/* >> UNDOABLE */
						AEGP_LabelID		label);					/* >> */

} AEGP_ItemSuite6;


#define kAEGPItemSuiteVersion5		7	/* frozen in AE 6.5 */

typedef struct AEGP_ItemSuite5 {

	SPAPI A_Err	(*AEGP_GetNextItem)(
						AEGP_ItemH			itemH,					/* >> */
						AEGP_ItemH			*next_itemPH);			/* << NULL after last item */

	SPAPI A_Err	(*AEGP_GetActiveItem)(
						AEGP_ItemH			*itemPH);				/* << NULL if none is active */

	SPAPI A_Err	(*AEGP_IsItemSelected)(
						AEGP_ItemH			itemH,					/* >> */
						A_Boolean			*selectedPB);			/* << */

	SPAPI A_Err	(*AEGP_SelectItem)(
						AEGP_ItemH			itemH,					/* >> */
						A_Boolean			selectB,				/* >>	allows to select or deselect the item */
						A_Boolean			deselect_othersB);		/* >> */

	SPAPI A_Err	(*AEGP_GetItemType)(
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_ItemType		*item_typeP);			/* << */

	SPAPI A_Err	(*AEGP_GetTypeName)(
						AEGP_ItemType		item_type,				/* << */
						A_char 				*nameZ);				/* << space for A_char[AEGP_MAX_TYPE_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetItemName)(
						AEGP_ItemH 			itemH,					/* >> */
						A_char				*nameZ);				/* << space for A_char[AEGP_MAX_ITEM_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetItemID)(
						AEGP_ItemH 			itemH,					/* >> */
						A_long				*item_idPL);			/* << */

	SPAPI A_Err	(*AEGP_GetItemFlags)(
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_ItemFlags		*item_flagsP);			/* << */

	SPAPI A_Err	(*AEGP_SetItemUseProxy)(							/* UNDOABLE */
						AEGP_ItemH 			itemH,					/* >> error if has_proxy is FALSE! */
						A_Boolean			use_proxyB);			/* >> */

	SPAPI A_Err	(*AEGP_GetItemParentFolder)(
						AEGP_ItemH			itemH,					/* >> */
						AEGP_ItemH			*parent_folder_itemPH);	/* << */

	SPAPI A_Err	(*AEGP_SetItemParentFolder)(
						AEGP_ItemH			itemH,					/* <> */
						AEGP_ItemH			parent_folder_itemH);	/* >> */

	SPAPI A_Err	(*AEGP_GetItemDuration)(							/* Returns the result in the item's native timespace:	*/
						AEGP_ItemH 			itemH,					/* >>		Comp			-> comp time,				*/
						A_Time 				*durationPT);			/* <<		Footage			-> footage time,			*/
																	/*			Folder			-> 0 (no duration)			*/

	SPAPI A_Err	(*AEGP_GetItemCurrentTime)(							/* Returns the result in the item's native timespace (not updated while rendering)*/
						AEGP_ItemH 			itemH,					/* >>	*/
						A_Time 				*curr_timePT);			/* <<	*/

	SPAPI A_Err	(*AEGP_GetItemDimensions)(
						AEGP_ItemH 			itemH,					/* >> */
						A_long	 			*widthPL,				/* << */
						A_long				*heightPL);				/* << */

	SPAPI A_Err	(*AEGP_GetItemPixelAspectRatio)(
						AEGP_ItemH 			itemH,					/* >> */
						A_Ratio 			*pix_aspect_ratioPRt);	/* << */

	SPAPI A_Err	(*AEGP_DeleteItem)(									/* UNDOABLE */
						AEGP_ItemH 			itemH);					/* >> removes item from all comps */

	SPAPI A_Err (*AEGP_CreateNewFolder)(
						const A_char		*nameZ,					/* >> */
						AEGP_ItemH			parent_folderH0,		/* >> */
						AEGP_ItemH			*new_folderPH);			/* << allocated and owned by AE */

	SPAPI A_Err (*AEGP_SetItemCurrentTime)(							/* UNDOABLE. Use the item's native timespace */
						AEGP_ItemH 			itemH,					/* >> */
						const A_Time		*new_timePT);			/* >> */

	SPAPI A_Err (*AEGP_GetItemCommentLength)(
						AEGP_ItemH			itemH, 					/* >> */
						A_u_long			*buf_sizePLu);			/* << */

	SPAPI A_Err	(*AEGP_GetItemComment)(
						AEGP_ItemH			itemH,					/* >> */
						A_u_long			buf_sizeLu,				/* >> */
						char				*commentZ);				/* << */

	SPAPI A_Err (*AEGP_SetItemComment)(
						AEGP_ItemH			itemH, 					/* >> UNDOABLE */
						const char			*commentZ);				/* >> */

} AEGP_ItemSuite5;


#define kAEGPItemSuiteVersion4		6	/* frozen in AE 6.0 */

typedef struct AEGP_ItemSuite4 {

	SPAPI A_Err	(*AEGP_GetNextItem)(
						AEGP_ItemH			itemH,					/* >> */
						AEGP_ItemH			*next_itemPH);			/* << NULL after last item */

	SPAPI A_Err	(*AEGP_GetActiveItem)(
						AEGP_ItemH			*itemPH);				/* << NULL if none is active */

	SPAPI A_Err	(*AEGP_IsItemSelected)(
						AEGP_ItemH			itemH,					/* >> */
						A_Boolean			*selectedPB);			/* << */

	SPAPI A_Err	(*AEGP_SelectItem)(
						AEGP_ItemH			itemH,					/* >> */
						A_Boolean			selectB,				/* >>	allows to select or deselect the item */
						A_Boolean			deselect_othersB);		/* >> */

	SPAPI A_Err	(*AEGP_GetItemType)(
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_ItemType		*item_typeP);			/* << */

	SPAPI A_Err	(*AEGP_GetTypeName)(
						AEGP_ItemType		item_type,				/* << */
						A_char 				*nameZ);				/* << space for A_char[AEGP_MAX_TYPE_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetItemName)(
						AEGP_ItemH 			itemH,					/* >> */
						A_char				*nameZ);				/* << space for A_char[AEGP_MAX_ITEM_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetItemID)(
						AEGP_ItemH 			itemH,					/* >> */
						A_long				*item_idPL);			/* << */

	SPAPI A_Err	(*AEGP_GetItemFlags)(
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_ItemFlags		*item_flagsP);			/* << */

	SPAPI A_Err	(*AEGP_SetItemUseProxy)(							/* UNDOABLE */
						AEGP_ItemH 			itemH,					/* >> error if has_proxy is FALSE! */
						A_Boolean			use_proxyB);			/* >> */

	SPAPI A_Err	(*AEGP_GetItemParentFolder)(
						AEGP_ItemH			itemH,					/* >> */
						AEGP_ItemH			*parent_folder_itemPH);	/* << */

	SPAPI A_Err	(*AEGP_GetItemDuration)(							/* Returns the result in the item's native timespace:	*/
						AEGP_ItemH 			itemH,					/* >>		Comp			-> comp time,				*/
						A_Time 				*durationPT);			/* <<		Footage			-> footage time,			*/
																	/*			Folder			-> 0 (no duration)			*/

	SPAPI A_Err	(*AEGP_GetItemCurrentTime)(							/* Returns the result in the item's native timespace (not updated while rendering)*/
						AEGP_ItemH 			itemH,					/* >>	*/
						A_Time 				*curr_timePT);			/* <<	*/

	SPAPI A_Err	(*AEGP_GetItemDimensions)(
						AEGP_ItemH 			itemH,					/* >> */
						A_long	 			*widthPL,				/* << */
						A_long				*heightPL);				/* << */

	SPAPI A_Err	(*AEGP_GetItemPixelAspectRatio)(
						AEGP_ItemH 			itemH,					/* >> */
						A_Ratio 			*pix_aspect_ratioPRt);	/* << */

	SPAPI A_Err	(*AEGP_DeleteItem)(									/* UNDOABLE */
						AEGP_ItemH 			itemH);					/* >> removes item from all comps */

	SPAPI A_Err (*AEGP_CreateNewFolder)(
						const A_char		*nameZ,					/* >> */
						AEGP_ItemH			parent_folderH0,		/* >> */
						AEGP_ItemH			*new_folderPH);			/* << allocated and owned by AE */

	SPAPI A_Err (*AEGP_SetItemCurrentTime)(							/* UNDOABLE. Use the item's native timespace */
						AEGP_ItemH 			itemH,					/* >> */
						const A_Time		*new_timePT);			/* >> */

	SPAPI A_Err (*AEGP_GetItemCommentLength)(
						AEGP_ItemH			itemH, 					/* >> */
						A_u_long			*buf_sizePLu);			/* << */

	SPAPI A_Err	(*AEGP_GetItemComment)(
						AEGP_ItemH			itemH,					/* >> */
						A_u_long			buf_sizeLu,				/* >> */
						char				*commentZ);				/* << */

	SPAPI A_Err (*AEGP_SetItemComment)(
						AEGP_ItemH			itemH, 					/* >> UNDOABLE */
						const char			*commentZ);				/* >> */

} AEGP_ItemSuite4;


#define kAEGPItemSuite				"AEGP Item Suite"
#define kAEGPItemSuiteVersion3		5	/* frozen in 5.5.1 */

typedef struct AEGP_ItemSuite3 {

	SPAPI A_Err	(*AEGP_GetNextItem)(
						AEGP_ItemH			itemH,					/* >> */
						AEGP_ItemH			*next_itemPH);			/* << NULL after last item */

	SPAPI A_Err	(*AEGP_GetActiveItem)(
						AEGP_ItemH			*itemPH);				/* << could be NULL if none is active */

	SPAPI A_Err	(*AEGP_IsItemSelected)(
						AEGP_ItemH			itemH,					/* >> */
						A_Boolean			*selectedPB);			/* << */

	SPAPI A_Err	(*AEGP_SelectItem)(
						AEGP_ItemH			itemH,					/* >> */
						A_Boolean			selectB,				/* >>	allows to select or deselect the item */
						A_Boolean			deselect_othersB);		/* >> */

	SPAPI A_Err	(*AEGP_GetItemType)(
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_ItemType		*item_typeP);			/* << */

	SPAPI A_Err	(*AEGP_GetTypeName)(
						AEGP_ItemType		item_type,				/* << */
						A_char 				*nameZ);				/* << space for A_char[AEGP_MAX_TYPE_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetItemName)(
						AEGP_ItemH 			itemH,					/* >> */
						A_char				*nameZ);				/* << space for A_char[AEGP_MAX_ITEM_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetItemID)(
						AEGP_ItemH 			itemH,					/* >> */
						A_long				*item_idPL);			/* << */

	SPAPI A_Err	(*AEGP_GetItemFlags)(
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_ItemFlags		*item_flagsP);			/* << */

	SPAPI A_Err	(*AEGP_SetItemUseProxy)(							/* UNDOABLE */
						AEGP_ItemH 			itemH,					/* >> error if has_proxy is FALSE! */
						A_Boolean			use_proxyB);			/* >> */

	SPAPI A_Err	(*AEGP_GetItemParentFolder)(
						AEGP_ItemH			itemH,						/* >> */
						AEGP_ItemH			*parent_folder_itemPH);		/* << */

	SPAPI A_Err	(*AEGP_GetItemDuration)(							/* Returns the result in the item's native timespace:	*/
						AEGP_ItemH 			itemH,					/* >>		Comp			-> comp time,				*/
						A_Time 				*durationPT);			/* <<		Footage			-> footage time,			*/
																	/*			Solid/Folder	-> 0 (no duration)			*/

	SPAPI A_Err	(*AEGP_GetItemCurrentTime)(							/* Returns the result in the item's native timespace (not updated while rendering)*/
						AEGP_ItemH 			itemH,					/* >>	*/
						A_Time 				*curr_timePT);			/* <<	*/

	SPAPI A_Err	(*AEGP_GetItemDimensions)(
						AEGP_ItemH 			itemH,					/* >> */
						A_long	 			*widthPL,				/* << */
						A_long				*heightPL);				/* << */

	SPAPI A_Err	(*AEGP_GetItemPixelAspectRatio)(
						AEGP_ItemH 			itemH,					/* >> */
						A_Ratio 			*pix_aspect_ratioPRt);	/* << */

	SPAPI A_Err	(*AEGP_DeleteItem)(									/* UNDOABLE */
						AEGP_ItemH 			itemH);					/* >> removes item from all comps */

	SPAPI A_Err	(*AEGP_GetItemSolidColor)(							/* error if item isn't AEGP_ItemType_SOLID! */
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_ColorVal		*colorP);				/* << */

	SPAPI A_Err	(*AEGP_SetSolidColor)(								/* error if item isn't AEGP_ItemType_SOLID! */
						AEGP_ItemH			itemH,					/* <> */
						AEGP_ColorVal		color);					/* >> */

	SPAPI A_Err (*AEGP_SetSolidDimensions)(							/* error if item isn't AEGP_ItemType_SOLID! */
						AEGP_ItemH			itemH,					/* <> */
						A_short				widthS,					/* >> */
						A_short				heightS);				/* >> */

	SPAPI A_Err (*AEGP_CreateNewFolder)(
						const A_char		*nameZ,					/* >> */
						AEGP_ItemH			parent_folderH0,		/* >> */
						AEGP_ItemH			*new_folderPH);			/* << */  /* allocated and owned by project (AE) */

	SPAPI A_Err (*AEGP_SetItemCurrentTime)(							/* Undoable. Use the item's native timespace */
						AEGP_ItemH 			itemH,					/* >> */
						const A_Time		*new_timePT);			/* >> */


} AEGP_ItemSuite3;

/**************************************************************************************************/
#define kAEGPKeyframeSuite				"AEGP Keyframe Suite"
#define kAEGPKeyframeSuiteVersion4		4 	/* frozen in 8 */

typedef struct AEGP_KeyframeSuite4 {
	//	the only diff from this vs. last rev is that routines that pass AEGP_StreamValue2, when referring to a marker,
	//	(comp or layer) the struct now contains the NEW markerP type, which is compatible with the new Marker Suite

	// returns AEGP_NumKF_NO_DATA if it's a AEGP_StreamType_NO_DATA, and you can't retrieve any values
	// returns zero if no keyframes (but might have an expression, so not necessarily constant)
	SPAPI A_Err(*AEGP_GetStreamNumKFs)(
		AEGP_StreamRefH 		streamH,				/* >> */
		A_long* num_kfsPL);			/* << */


	SPAPI A_Err(*AEGP_GetKeyframeTime)(
		AEGP_StreamRefH			streamH,				/* >> */
		AEGP_KeyframeIndex		key_index,				/* >> */
		AEGP_LTimeMode			time_mode,				/* >> */
		A_Time* timePT);				/* << */

// leaves stream unchanged if a keyframe already exists at specified time
	SPAPI A_Err(*AEGP_InsertKeyframe)(									/* UNDOABLE */
		AEGP_StreamRefH			streamH,				/* <> */
		AEGP_LTimeMode			time_mode,				/* >> */
		const A_Time* timePT,				/* >> */
		AEGP_KeyframeIndex* key_indexP);			/* << */

	SPAPI A_Err(*AEGP_DeleteKeyframe)(									/* UNDOABLE */
		AEGP_StreamRefH			streamH,				/* <> */
		AEGP_KeyframeIndex		key_index);				/* >> */

	SPAPI A_Err(*AEGP_GetNewKeyframeValue)(							// dispose using AEGP_DisposeStreamValue()
		AEGP_PluginID			aegp_plugin_id,			/* >> */
		AEGP_StreamRefH			streamH,				/* >> */
		AEGP_KeyframeIndex		key_index,				/* >> */
		AEGP_StreamValue2* valueP);				/* << */

	SPAPI A_Err(*AEGP_SetKeyframeValue)(								/* UNDOABLE */
		AEGP_StreamRefH			streamH,				/* >> */
		AEGP_KeyframeIndex		key_index,				/* >> */
		const AEGP_StreamValue2* valueP);				/* >>  not adopted */

	SPAPI A_Err(*AEGP_GetStreamValueDimensionality)(
		AEGP_StreamRefH			streamH,				/* >> */
		A_short* value_dimPS);			/* << */

	SPAPI A_Err(*AEGP_GetStreamTemporalDimensionality)(
		AEGP_StreamRefH			streamH,				/* >> */
		A_short* temporal_dimPS);		/* << */

	SPAPI A_Err(*AEGP_GetNewKeyframeSpatialTangents)(					// dispose using AEGP_DisposeStreamValue()
		AEGP_PluginID			aegp_plugin_id,			/* >> */
		AEGP_StreamRefH			streamH,				/* >> */
		AEGP_KeyframeIndex		key_index,				/* >> */
		AEGP_StreamValue2* in_tanP0,				/* << */
		AEGP_StreamValue2* out_tanP0);			/* << */

	SPAPI A_Err(*AEGP_SetKeyframeSpatialTangents)(						/* UNDOABLE */
		AEGP_StreamRefH			streamH,				/* >> */
		AEGP_KeyframeIndex		key_index,				/* >> */
		const AEGP_StreamValue2* in_tanP0,				/* >>  not adopted */
		const AEGP_StreamValue2* out_tanP0);			/* >>  not adopted */

	SPAPI A_Err(*AEGP_GetKeyframeTemporalEase)(
		AEGP_StreamRefH			streamH,				/* >> */
		AEGP_KeyframeIndex		key_index,				/* >> */
		A_long					dimensionL,				/* >> ranges from 0..TemporalDimensionality-1 */
		AEGP_KeyframeEase* in_easeP0,				/* << */
		AEGP_KeyframeEase* out_easeP0);			/* << */

	SPAPI A_Err(*AEGP_SetKeyframeTemporalEase)(						/* UNDOABLE */
		AEGP_StreamRefH			streamH,				/* >> */
		AEGP_KeyframeIndex		key_index,				/* >> */
		A_long					dimensionL,				/* >> ranges from 0..TemporalDimensionality-1 */
		const AEGP_KeyframeEase* in_easeP0,				/* >> not adopted */
		const AEGP_KeyframeEase* out_easeP0);			/* >> not adopted */

	SPAPI A_Err(*AEGP_GetKeyframeFlags)(
		AEGP_StreamRefH			streamH,				/* >> */
		AEGP_KeyframeIndex		key_index,				/* >> */
		AEGP_KeyframeFlags* flagsP);				/* << */

	SPAPI A_Err(*AEGP_SetKeyframeFlag)(								/* UNDOABLE */
		AEGP_StreamRefH			streamH,				/* >> */
		AEGP_KeyframeIndex		key_index,				/* >> */
		AEGP_KeyframeFlags		flag,					/* >> set one flag at a time */
		A_Boolean				true_falseB);			/* >> */

	SPAPI A_Err(*AEGP_GetKeyframeInterpolation)(
		AEGP_StreamRefH					streamH,		/* >> */
		AEGP_KeyframeIndex				key_index,		/* >> */
		AEGP_KeyframeInterpolationType* in_interpP0,	/* << */
		AEGP_KeyframeInterpolationType* out_interpP0);	/* << */

	SPAPI A_Err(*AEGP_SetKeyframeInterpolation)(						/* UNDOABLE */
		AEGP_StreamRefH					streamH,		/* >> */
		AEGP_KeyframeIndex				key_index,		/* >> */
		AEGP_KeyframeInterpolationType	in_interp,		/* >> */
		AEGP_KeyframeInterpolationType	out_interp);	/* >> */

	SPAPI A_Err(*AEGP_StartAddKeyframes)(
		AEGP_StreamRefH			streamH,
		AEGP_AddKeyframesInfoH* akPH);			/* << */


	SPAPI A_Err(*AEGP_AddKeyframes)(
		AEGP_AddKeyframesInfoH	akH,			/* <> */
		AEGP_LTimeMode          time_mode,		/* >> */
		const A_Time* timePT,		/* >> */
		A_long* key_indexPL);	/* >> */

	SPAPI A_Err(*AEGP_SetAddKeyframe)(
		AEGP_AddKeyframesInfoH	akH,			/* <> */
		A_long					key_indexL,		/* >> */
		const AEGP_StreamValue2* valueP);		/* >> */

	SPAPI A_Err(*AEGP_EndAddKeyframes)(						/* UNDOABLE */
		A_Boolean				addB,
		AEGP_AddKeyframesInfoH	akH);			/* >> */

} AEGP_KeyframeSuite4;

#define kAEGPKeyframeSuiteVersion3		3 	/* frozen in 6.5 */

typedef struct AEGP_KeyframeSuite3 {

	// returns AEGP_NumKF_NO_DATA if it's a AEGP_StreamType_NO_DATA, and you can't retrieve any values
	// returns zero if no keyframes (but might have an expression, so not necessarily constant)


	SPAPI A_Err	(*AEGP_GetStreamNumKFs)(
						AEGP_StreamRefH 		streamH,				/* >> */
						A_long					*num_kfsPL);			/* << */


	SPAPI A_Err (*AEGP_GetKeyframeTime)(
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						AEGP_LTimeMode			time_mode,				/* >> */
						A_Time					*timePT);				/* << */

	// leaves stream unchanged if a keyframe already exists at specified time
	SPAPI A_Err (*AEGP_InsertKeyframe)(									/* UNDOABLE */
						AEGP_StreamRefH			streamH,				/* <> */
						AEGP_LTimeMode			time_mode,				/* >> */
						const A_Time			*timePT,				/* >> */
						AEGP_KeyframeIndex		*key_indexP);			/* << */

	SPAPI A_Err (*AEGP_DeleteKeyframe)(									/* UNDOABLE */
						AEGP_StreamRefH			streamH,				/* <> */
						AEGP_KeyframeIndex		key_index);				/* >> */

	SPAPI A_Err (*AEGP_GetNewKeyframeValue)(							// dispose using AEGP_DisposeStreamValue()
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						AEGP_StreamValue		*valueP);				/* << */

	SPAPI A_Err (*AEGP_SetKeyframeValue)(								/* UNDOABLE */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						const AEGP_StreamValue	*valueP);				/* >>  not adopted */

	SPAPI A_Err (*AEGP_GetStreamValueDimensionality)(
						AEGP_StreamRefH			streamH,				/* >> */
						A_short					*value_dimPS);			/* << */

	SPAPI A_Err (*AEGP_GetStreamTemporalDimensionality)(
						AEGP_StreamRefH			streamH,				/* >> */
						A_short					*temporal_dimPS);		/* << */

	SPAPI A_Err (*AEGP_GetNewKeyframeSpatialTangents)(					// dispose using AEGP_DisposeStreamValue()
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						AEGP_StreamValue		*in_tanP0,				/* << */
						AEGP_StreamValue		*out_tanP0);			/* << */

	// In AEGP_KeyframeSuite2 and prior versions, the values returned from
	// this function were wrong when called on an effect point control stream or
	// anchor point. They were not multiplied by the layer size. Now they are.
	SPAPI A_Err (*AEGP_SetKeyframeSpatialTangents)(						/* UNDOABLE */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						const AEGP_StreamValue	*in_tanP0,				/* >>  not adopted */
						const AEGP_StreamValue	*out_tanP0);			/* >>  not adopted */

	SPAPI A_Err (*AEGP_GetKeyframeTemporalEase)(
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						A_long					dimensionL,				/* >> ranges from 0..TemporalDimensionality-1 */
						AEGP_KeyframeEase		*in_easeP0,				/* << */
						AEGP_KeyframeEase		*out_easeP0);			/* << */

	SPAPI A_Err (*AEGP_SetKeyframeTemporalEase)(						/* UNDOABLE */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						A_long					dimensionL,				/* >> ranges from 0..TemporalDimensionality-1 */
						const AEGP_KeyframeEase	*in_easeP0,				/* >> not adopted */
						const AEGP_KeyframeEase	*out_easeP0);			/* >> not adopted */

	SPAPI A_Err (*AEGP_GetKeyframeFlags)(
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						AEGP_KeyframeFlags		*flagsP);				/* << */

	SPAPI A_Err (*AEGP_SetKeyframeFlag)(								/* UNDOABLE */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						AEGP_KeyframeFlags		flag,					/* >> set one flag at a time */
						A_Boolean				true_falseB);			/* >> */

	SPAPI A_Err (*AEGP_GetKeyframeInterpolation)(
						AEGP_StreamRefH					streamH,		/* >> */
						AEGP_KeyframeIndex				key_index,		/* >> */
						AEGP_KeyframeInterpolationType	*in_interpP0,	/* << */
						AEGP_KeyframeInterpolationType	*out_interpP0);	/* << */

	SPAPI A_Err (*AEGP_SetKeyframeInterpolation)(						/* UNDOABLE */
						AEGP_StreamRefH					streamH,		/* >> */
						AEGP_KeyframeIndex				key_index,		/* >> */
						AEGP_KeyframeInterpolationType	in_interp,		/* >> */
						AEGP_KeyframeInterpolationType	out_interp);	/* >> */

	SPAPI A_Err (*AEGP_StartAddKeyframes)(
						AEGP_StreamRefH			streamH,
						AEGP_AddKeyframesInfoH	*akPH);			/* << */


	SPAPI A_Err (*AEGP_AddKeyframes)(
						AEGP_AddKeyframesInfoH	akH,			/* <> */
						AEGP_LTimeMode          time_mode,		/* >> */
						const A_Time            *timePT,		/* >> */
						A_long					*key_indexPL);	/* >> */

	SPAPI A_Err (*AEGP_SetAddKeyframe)(
						AEGP_AddKeyframesInfoH	akH,			/* <> */
						A_long					key_indexL,		/* >> */
						const AEGP_StreamValue	*valueP);		/* >> */

	SPAPI A_Err (*AEGP_EndAddKeyframes)(						/* UNDOABLE */
						A_Boolean				addB,
						AEGP_AddKeyframesInfoH	akH);			/* >> */

} AEGP_KeyframeSuite3;

#define kAEGPKeyframeSuiteVersion2		2 	/* frozen in 5.5 */

typedef struct AEGP_KeyframeSuite2 {

	// returns AEGP_NumKF_NO_DATA if it's a AEGP_StreamType_NO_DATA, and you can't retrieve any values
	// returns zero if no keyframes (but might have an expression, so not necessarily constant)


	SPAPI A_Err	(*AEGP_GetStreamNumKFs)(
						AEGP_StreamRefH 		streamH,				/* >> */
						A_long					*num_kfsPL);			/* << */


	SPAPI A_Err (*AEGP_GetKeyframeTime)(
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						AEGP_LTimeMode			time_mode,				/* >> */
						A_Time					*timePT);				/* << */

	// leaves stream unchanged if a keyframe already exists at specified time
	SPAPI A_Err (*AEGP_InsertKeyframe)(									/* UNDOABLE */
						AEGP_StreamRefH			streamH,				/* <> */
						AEGP_LTimeMode			time_mode,				/* >> */
						const A_Time			*timePT,				/* >> */
						AEGP_KeyframeIndex		*key_indexP);			/* << */

	SPAPI A_Err (*AEGP_DeleteKeyframe)(									/* UNDOABLE */
						AEGP_StreamRefH			streamH,				/* <> */
						AEGP_KeyframeIndex		key_index);				/* >> */

	SPAPI A_Err (*AEGP_GetNewKeyframeValue)(							// dispose using AEGP_DisposeStreamValue()
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						AEGP_StreamValue		*valueP);				/* << */

	SPAPI A_Err (*AEGP_SetKeyframeValue)(								/* UNDOABLE */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						const AEGP_StreamValue	*valueP);				/* >>  not adopted */

	SPAPI A_Err (*AEGP_GetStreamValueDimensionality)(
						AEGP_StreamRefH			streamH,				/* >> */
						A_short					*value_dimPS);			/* << */

	SPAPI A_Err (*AEGP_GetStreamTemporalDimensionality)(
						AEGP_StreamRefH			streamH,				/* >> */
						A_short					*temporal_dimPS);		/* << */

	SPAPI A_Err (*AEGP_GetNewKeyframeSpatialTangents)(					// dispose using AEGP_DisposeStreamValue()
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						AEGP_StreamValue		*in_tanP0,				/* << */
						AEGP_StreamValue		*out_tanP0);			/* << */

	SPAPI A_Err (*AEGP_SetKeyframeSpatialTangents)(						/* UNDOABLE */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						const AEGP_StreamValue	*in_tanP0,				/* >>  not adopted */
						const AEGP_StreamValue	*out_tanP0);			/* >>  not adopted */

	SPAPI A_Err (*AEGP_GetKeyframeTemporalEase)(
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						A_long					dimensionL,				/* >> ranges from 0..TemporalDimensionality-1 */
						AEGP_KeyframeEase		*in_easeP0,				/* << */
						AEGP_KeyframeEase		*out_easeP0);			/* << */

	SPAPI A_Err (*AEGP_SetKeyframeTemporalEase)(						/* UNDOABLE */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						A_long					dimensionL,				/* >> ranges from 0..TemporalDimensionality-1 */
						const AEGP_KeyframeEase	*in_easeP0,				/* >> not adopted */
						const AEGP_KeyframeEase	*out_easeP0);			/* >> not adopted */

	SPAPI A_Err (*AEGP_GetKeyframeFlags)(
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						AEGP_KeyframeFlags		*flagsP);				/* << */

	SPAPI A_Err (*AEGP_SetKeyframeFlag)(								/* UNDOABLE */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						AEGP_KeyframeFlags		flag,					/* >> set one flag at a time */
						A_Boolean				true_falseB);			/* >> */

	SPAPI A_Err (*AEGP_GetKeyframeInterpolation)(
						AEGP_StreamRefH					streamH,		/* >> */
						AEGP_KeyframeIndex				key_index,		/* >> */
						AEGP_KeyframeInterpolationType	*in_interpP0,	/* << */
						AEGP_KeyframeInterpolationType	*out_interpP0);	/* << */

	SPAPI A_Err (*AEGP_SetKeyframeInterpolation)(						/* UNDOABLE */
						AEGP_StreamRefH					streamH,		/* >> */
						AEGP_KeyframeIndex				key_index,		/* >> */
						AEGP_KeyframeInterpolationType	in_interp,		/* >> */
						AEGP_KeyframeInterpolationType	out_interp);	/* >> */

	SPAPI A_Err (*AEGP_StartAddKeyframes)(
						AEGP_StreamRefH			streamH,
						AEGP_AddKeyframesInfoH	*akPH);			/* << */


	SPAPI A_Err (*AEGP_AddKeyframes)(
						AEGP_AddKeyframesInfoH	akH,			/* <> */
						AEGP_LTimeMode          time_mode,		/* >> */
						const A_Time            *timePT,		/* >> */
						A_long					*key_indexPL);	/* >> */

	SPAPI A_Err (*AEGP_SetAddKeyframe)(
						AEGP_AddKeyframesInfoH	akH,			/* <> */
						A_long					key_indexL,		/* >> */
						const AEGP_StreamValue	*valueP);		/* >> */

	SPAPI A_Err (*AEGP_EndAddKeyframes)(						/* UNDOABLE */
						A_Boolean				addB,
						AEGP_AddKeyframesInfoH	akH);			/* >> */

} AEGP_KeyframeSuite2;

#define kAEGPKeyframeSuiteVersion1		1 /* frozen in AE 5.0 */

typedef struct AEGP_KeyframeSuite1 {

	// returns AEGP_NumKF_NO_DATA if it's a AEGP_StreamType_NO_DATA, and you can't retrieve any values
	// returns zero if no keyframes (but might have an expression, so not necessarily constant)


	SPAPI A_Err	(*AEGP_GetStreamNumKFs)(
						AEGP_StreamRefH 			streamH,				/* >> */
						A_long					*num_kfsPL);			/* << */


	SPAPI A_Err (*AEGP_GetKeyframeTime)(
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						AEGP_LTimeMode			time_mode,				/* >> */
						A_Time					*timePT);				/* << */

	// leaves stream unchanged if a keyframe already exists at specified time
	SPAPI A_Err (*AEGP_InsertKeyframe)(									/* UNDOABLE */
						AEGP_StreamRefH			streamH,				/* <> */
						AEGP_LTimeMode			time_mode,				/* >> */
						const A_Time			*timePT,				/* >> */
						AEGP_KeyframeIndex		*key_indexP);			/* << */

	SPAPI A_Err (*AEGP_DeleteKeyframe)(									/* UNDOABLE */
						AEGP_StreamRefH			streamH,				/* <> */
						AEGP_KeyframeIndex		key_index);				/* >> */

	SPAPI A_Err (*AEGP_GetNewKeyframeValue)(							// dispose using AEGP_DisposeStreamValue()
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						AEGP_StreamValue		*valueP);				/* << */

	SPAPI A_Err (*AEGP_SetKeyframeValue)(								/* UNDOABLE */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						const AEGP_StreamValue	*valueP);				/* >> */	// not adopted

	SPAPI A_Err (*AEGP_GetStreamValueDimensionality)(
						AEGP_StreamRefH			streamH,				/* >> */
						short					*value_dimPS);			/* << */

	SPAPI A_Err (*AEGP_GetStreamTemporalDimensionality)(
						AEGP_StreamRefH			streamH,				/* >> */
						short					*temporal_dimPS);		/* << */

	SPAPI A_Err (*AEGP_GetNewKeyframeSpatialTangents)(					// dispose using AEGP_DisposeStreamValue()
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						AEGP_StreamValue		*in_tanP0,				/* << */
						AEGP_StreamValue		*out_tanP0);			/* << */

	SPAPI A_Err (*AEGP_SetKeyframeSpatialTangents)(						/* UNDOABLE */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						const AEGP_StreamValue	*in_tanP0,				/* >> */	// not adopted
						const AEGP_StreamValue	*out_tanP0);			/* >> */	// not adopted

	SPAPI A_Err (*AEGP_GetKeyframeTemporalEase)(
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						A_long					dimensionL,				/* >> */	// ranges from 0..TemporalDimensionality-1
						AEGP_KeyframeEase		*in_easeP0,				/* << */
						AEGP_KeyframeEase		*out_easeP0);			/* << */

	SPAPI A_Err (*AEGP_SetKeyframeTemporalEase)(						/* UNDOABLE */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						A_long					dimensionL,				/* >> */	// ranges from 0..TemporalDimensionality-1
						const AEGP_KeyframeEase	*in_easeP0,				/* >> */	// not adopted
						const AEGP_KeyframeEase	*out_easeP0);			/* >> */	// not adopted

	SPAPI A_Err (*AEGP_GetKeyframeFlags)(
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						AEGP_KeyframeFlags		*flagsP);				/* << */

	SPAPI A_Err (*AEGP_SetKeyframeFlag)(								/* UNDOABLE */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_KeyframeIndex		key_index,				/* >> */
						AEGP_KeyframeFlags		flag,					/* >> */	// set one at a time
						A_Boolean				true_falseB);			/* >> */

	SPAPI A_Err (*AEGP_GetKeyframeInterpolation)(
						AEGP_StreamRefH					streamH,		/* >> */
						AEGP_KeyframeIndex				key_index,		/* >> */
						AEGP_KeyframeInterpolationType	*in_interpP0,	/* << */
						AEGP_KeyframeInterpolationType	*out_interpP0);	/* << */

	SPAPI A_Err (*AEGP_SetKeyframeInterpolation)(						/* UNDOABLE */
						AEGP_StreamRefH					streamH,		/* >> */
						AEGP_KeyframeIndex				key_index,		/* >> */
						AEGP_KeyframeInterpolationType	in_interp,		/* >> */
						AEGP_KeyframeInterpolationType	out_interp);	/* >> */

} AEGP_KeyframeSuite1;

/* frozen AE 5.5 */
#define kAEGPItemSuiteVersion2		4

typedef struct AEGP_ItemSuite2 {

	SPAPI A_Err	(*AEGP_GetNextItem)(
						AEGP_ItemH			itemH,					/* >> */
						AEGP_ItemH			*next_itemPH);			/* << NULL after last item */

	SPAPI A_Err	(*AEGP_GetActiveItem)(
						AEGP_ItemH			*itemPH);				/* << could be NULL if none is active */

	SPAPI A_Err	(*AEGP_IsItemSelected)(
						AEGP_ItemH			itemH,					/* >> */
						A_Boolean			*selectedPB);			/* << */

	SPAPI A_Err	(*AEGP_SelectItem)(
						AEGP_ItemH			itemH,					/* >> */
						A_Boolean			selectB,				/* >>	allows to select or deselect the item */
						A_Boolean			deselect_othersB);		/* >> */

	SPAPI A_Err	(*AEGP_GetItemType)(
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_ItemType		*item_typeP);			/* << */

	SPAPI A_Err	(*AEGP_GetTypeName)(
						AEGP_ItemType		item_type,				/* << */
						A_char 				*nameZ);				/* << space for A_char[AEGP_MAX_TYPE_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetItemName)(
						AEGP_ItemH 			itemH,					/* >> */
						A_char				*nameZ);				/* << space for A_char[AEGP_MAX_ITEM_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetItemID)(
						AEGP_ItemH 			itemH,					/* >> */
						A_long				*item_idPL);			/* << */

	SPAPI A_Err	(*AEGP_GetItemFlags)(
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_ItemFlags		*item_flagsP);			/* << */

	SPAPI A_Err	(*AEGP_SetItemUseProxy)(							/* UNDOABLE */
						AEGP_ItemH 			itemH,					/* >> error if has_proxy is FALSE! */
						A_Boolean			use_proxyB);			/* >> */

	SPAPI A_Err	(*AEGP_GetItemParentFolder)(
						AEGP_ItemH			itemH,						/* >> */
						AEGP_ItemH			*parent_folder_itemPH);		/* << */

	SPAPI A_Err	(*AEGP_GetItemDuration)(							/* Returns the result in the item's native timespace:	*/
						AEGP_ItemH 			itemH,					/* >>		Comp			-> comp time,				*/
						A_Time 				*durationPT);			/* <<		Footage			-> footage time,			*/
																	/*			Solid/Folder	-> 0 (no duration)			*/

	SPAPI A_Err	(*AEGP_GetItemCurrentTime)(							/* Returns the result in the item's native timespace (not updated while rendering)*/
						AEGP_ItemH 			itemH,					/* >>	*/
						A_Time 				*curr_timePT);			/* <<	*/

	SPAPI A_Err	(*AEGP_GetItemDimensions)(
						AEGP_ItemH 			itemH,					/* >> */
						A_long	 			*widthPL,				/* << */
						A_long				*heightPL);				/* << */

	SPAPI A_Err	(*AEGP_GetItemPixelAspectRatio)(
						AEGP_ItemH 			itemH,					/* >> */
						A_Ratio 			*pix_aspect_ratioPRt);	/* << */

	SPAPI A_Err	(*AEGP_DeleteItem)(									/* UNDOABLE */
						AEGP_ItemH 			itemH);					/* >> removes item from all comps */

	SPAPI A_Err	(*AEGP_GetItemSolidColor)(							/* error if item isn't AEGP_ItemType_SOLID! */
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_ColorVal		*colorP);				/* << */

	SPAPI A_Err	(*AEGP_SetSolidColor)(								/* error if item isn't AEGP_ItemType_SOLID! */
						AEGP_ItemH			itemH,					/* <> */
						AEGP_ColorVal		color);					/* >> */

	SPAPI A_Err (*AEGP_SetSolidDimensions)(							/* error if item isn't AEGP_ItemType_SOLID! */
						AEGP_ItemH			itemH,					/* <> */
						A_short				widthS,					/* >> */
						A_short				heightS);				/* >> */

	SPAPI A_Err (*AEGP_CreateNewFolder)(
						const A_char		*nameZ,					/* >> */
						AEGP_ItemH			parent_folderH0,		/* >> */
						AEGP_ItemH			*new_folderPH);			/* << */  /* allocated and owned by project (AE) */

	SPAPI A_Err (*AEGP_SetItemCurrentTime)(							/* Undoable. Use the item's native timespace */
						AEGP_ItemH 			itemH,					/* >> */
						const A_Time		*new_timePT);			/* >> */


	//  work on Comps and Footage items.
	SPAPI A_Err (*AEGP_RenderNewItemSoundData)( // AEGP_SoundDataH must be disposed.
					AEGP_ItemH	itemH,								// >>
					const A_Time			*start_timePT,			// >>
					const A_Time			*durationPT,			// >>
					const AEGP_SoundDataFormat* sound_formatP,		// >>
					AEGP_SoundDataH			*new_sound_dataPH);		// << can return NULL if no audio

} AEGP_ItemSuite2;


#define kAEGPItemSuiteVersion1		3 /* frozen in AE 5.0 */

typedef struct AEGP_ItemSuite1 {

	SPAPI A_Err	(*AEGP_GetNextItem)(
						AEGP_ItemH			itemH,					/* >> */
						AEGP_ItemH			*next_itemPH);			/* << NULL after last item */

	SPAPI A_Err	(*AEGP_GetActiveItem)(
						AEGP_ItemH			*itemPH);				/* << could be NULL if none is active */

	SPAPI A_Err	(*AEGP_IsItemSelected)(
						AEGP_ItemH			itemH,					/* >> */
						A_Boolean			*selectedPB);			/* << */

	SPAPI A_Err	(*AEGP_SelectItem)(
						AEGP_ItemH			itemH,					/* >> */
						A_Boolean			selectB,				/* >>	allows to select or deselect the item */
						A_Boolean			deselect_othersB);		/* >> */

	SPAPI A_Err	(*AEGP_GetItemType)(
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_ItemType		*item_typeP);			/* << */

	SPAPI A_Err	(*AEGP_GetTypeName)(
						AEGP_ItemType		item_type,				/* << */
						A_char 				*nameZ);				/* << space for A_char[AEGP_MAX_TYPE_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetItemName)(
						AEGP_ItemH 			itemH,					/* >> */
						A_char				*nameZ);				/* << space for A_char[AEGP_MAX_ITEM_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetItemID)(
						AEGP_ItemH 			itemH,					/* >> */
						A_long				*item_idPL);			/* << */

	SPAPI A_Err	(*AEGP_GetItemFlags)(
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_ItemFlags		*item_flagsP);			/* << */

	SPAPI A_Err	(*AEGP_SetItemUseProxy)(							/* UNDOABLE */
						AEGP_ItemH 			itemH,					/* >> error if has_proxy is FALSE! */
						A_Boolean			use_proxyB);			/* >> */

	SPAPI A_Err	(*AEGP_GetItemParentFolder)(
						AEGP_ItemH			itemH,						/* >> */
						AEGP_ItemH			*parent_folder_itemPH);		/* << */

	SPAPI A_Err	(*AEGP_GetItemDuration)(							/* Returns the result in the item's native timespace:	*/
						AEGP_ItemH 			itemH,					/* >>		Comp			-> comp time,				*/
						A_Time 				*durationPT);			/* <<		Footage			-> footage time,			*/
																	/*			Solid/Folder	-> 0 (no duration)			*/

	SPAPI A_Err	(*AEGP_GetItemCurrentTime)(							/* Returns the result in the item's native timespace (not updated while rendering)*/
						AEGP_ItemH 			itemH,					/* >>	*/
						A_Time 				*curr_timePT);			/* <<	*/

	SPAPI A_Err	(*AEGP_GetItemDimensions)(
						AEGP_ItemH 			itemH,					/* >> */
						A_long	 			*widthPL,				/* << */
						A_long				*heightPL);				/* << */

	SPAPI A_Err	(*AEGP_GetItemPixelAspectRatio)(
						AEGP_ItemH 			itemH,					/* >> */
						A_Ratio 			*pix_aspect_ratioPRt);	/* << */

	SPAPI A_Err	(*AEGP_DeleteItem)(									/* UNDOABLE */
						AEGP_ItemH 			itemH);					/* >> removes item from all comps */

	SPAPI A_Err	(*AEGP_GetItemSolidColor)(							/* error if item isn't AEGP_ItemType_SOLID! */
						AEGP_ItemH 			itemH,					/* >> */
						AEGP_ColorVal		*colorP);				/* << */

	SPAPI A_Err (*AEGP_CreateNewFolder)(
						const A_char		*nameZ,					/* >> */
						AEGP_ItemH			parent_folderH0,		/* >> */
						AEGP_ItemH			*new_folderPH);			/* << */  /* allocated and owned by project (AE) */

	SPAPI A_Err (*AEGP_SetItemCurrentTime)(							/* Undoable. Use the item's native timespace */
						AEGP_ItemH 			itemH,					/* >> */
						const A_Time		*new_timePT);			/* >> */


	//  work on Comps and Footage items.
	SPAPI A_Err (*AEGP_RenderNewItemSoundData)( // AEGP_SoundDataH must be disposed.
					AEGP_ItemH	itemH,								// >>
					const A_Time			*start_timePT,			// >>
					const A_Time			*durationPT,			// >>
					const AEGP_SoundDataFormat* sound_formatP,		// >>
					AEGP_SoundDataH			*new_sound_dataPH);		// << can return NULL if no audio

} AEGP_ItemSuite1;

/*********************************************************/

#define kAEGPUtilitySuiteVersion5		11 /* frozen in AE 8.0 */

typedef struct AEGP_UtilitySuite5 {

	SPAPI A_Err	(*AEGP_ReportInfo)(										/* displays dialog with name of plugin followed by info string */
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						const A_char			*info_stringZ);			/* >> */


	SPAPI A_Err	(*AEGP_GetDriverPluginInitFuncVersion)(
						A_short					*major_versionPS,		/* << */
						A_short					*minor_versionPS);		/* << */

	SPAPI A_Err	(*AEGP_GetDriverImplementationVersion)(
						A_short					*major_versionPS,		/* << */
						A_short					*minor_versionPS);		/* << */

	SPAPI A_Err	(*AEGP_StartQuietErrors)(
						AEGP_ErrReportState		*err_stateP);			/* << */

	SPAPI A_Err	(*AEGP_EndQuietErrors)(
						A_Boolean				report_quieted_errorsB,	/* >> currently reports last quieted error */
						AEGP_ErrReportState		*err_stateP);			/* >> */

	SPAPI A_Err (*AEGP_GetLastErrorMessage)(
						A_long					buffer_size,			/* >> size of character buffer */
						A_char					*error_string,					/* << */
						A_Err					*error_num);				/* << */

	SPAPI A_Err	(*AEGP_StartUndoGroup)(									/* MUST be balanced with call to AEGP_EndUndoGroup() */
						const A_char			*undo_nameZ);			/* >> */

	SPAPI A_Err	(*AEGP_EndUndoGroup)(void);

	SPAPI A_Err (*AEGP_RegisterWithAEGP)(
						AEGP_GlobalRefcon 		global_refcon,			/* >> global refcon passed in command handlers */
						const A_char			*plugin_nameZ,			/* >> name of this plugin. AEGP_MAX_PLUGIN_NAME_SIZE */
						AEGP_PluginID			*plugin_id);			/* << id for plugin to use in other AEGP calls */

	SPAPI A_Err (*AEGP_GetMainHWND)(
						void					*main_hwnd);			/* << */

	SPAPI A_Err (*AEGP_ShowHideAllFloaters)(
						A_Boolean				include_tool_palB);		/* >> */

	SPAPI A_Err (*AEGP_PaintPalGetForeColor)(
						AEGP_ColorVal			*fore_colorP);			/* << */

	SPAPI A_Err (*AEGP_PaintPalGetBackColor)(
						AEGP_ColorVal			*back_colorP);			/* << */

	SPAPI A_Err (*AEGP_PaintPalSetForeColor)(
						const AEGP_ColorVal		*fore_colorP);			/* >> */

	SPAPI A_Err (*AEGP_PaintPalSetBackColor)(
						const AEGP_ColorVal		*back_colorP);			/* >> */

	SPAPI A_Err (*AEGP_CharPalGetFillColor)(
						A_Boolean				*is_fill_color_definedPB,	/*  << */
                        AEGP_ColorVal			*fill_colorP); 				/* << only valid if is_fill_color_definedPB == TRUE */

	SPAPI A_Err (*AEGP_CharPalGetStrokeColor)(
						A_Boolean				*is_stroke_color_definedPB, /*  << */
                        AEGP_ColorVal			*stroke_colorP); 			/* << only valid if is_stroke_color_definedPB == TRUE */

	SPAPI A_Err (*AEGP_CharPalSetFillColor)(
						const AEGP_ColorVal		*fill_colorP);				/* >> */

	SPAPI A_Err (*AEGP_CharPalSetStrokeColor)(
						const AEGP_ColorVal		*stroke_colorP);			/* >> */

	SPAPI A_Err (*AEGP_CharPalIsFillColorUIFrontmost)(						/* Otherwise, StrokeColor is frontmost */
						A_Boolean				*is_fill_color_selectedPB);	/* << */

	SPAPI A_Err (*AEGP_ConvertFpLongToHSFRatio)(
						A_FpLong				numberF,					/* >> */
						A_Ratio					*ratioPR);					/* << */

	SPAPI A_Err (*AEGP_ConvertHSFRatioToFpLong)(
						A_Ratio					ratioR,						/* << */
						A_FpLong				*numberPF);					/* >> */

	// this routine is safe to call from the non-main
	// thread. It is asynchronous and will return before the idle handler is called.
	// The Suite routines to get this pointer are not
	// thread safe, therefore you need to save it off
	// in the main thread for use by the child thread.
	SPAPI A_Err (*AEGP_CauseIdleRoutinesToBeCalled)(void);


	// Determine if after effects is running in a mode where there is no
	// user interface, and attempting to interact with the user (via a modal dialog)
	// will hang the application.
	// This will not change during a run. Use it to optimize your plugin at startup
	// to not create a user interface and make AE launch faster, and not break
	// when running multiple instances of a service.
	SPAPI	A_Err  (*AEGP_GetSuppressInteractiveUI)(A_Boolean* ui_is_suppressedPB); // out

	// this call writes text to the console if one is available.  One is guaranteed to be available
	// if ui_is_suppressedB == true.
	// In general use the call AEGP_ReportInfo() as it will write to the console in
	// non-interactive modes, and use a dialog in interactive modes.
	SPAPI	A_Err  (*AEGP_WriteToOSConsole)(const A_char* textZ);				// in

	// this writes an entry into the debug log, or to the command line if launched
	// with the -debug flag.
	SPAPI	A_Err  (*AEGP_WriteToDebugLog)(const A_char* subsystemZ,	// in
								const A_char* event_typeZ,				// in
								const A_char * infoZ);					// in


	SPAPI	A_Err  (*AEGP_IsScriptingAvailable)(A_Boolean* outAvailablePB);

	// Execute a script.
	// The script text can either be in UTF-8, or the current
	// application encoding.
	// The result is the result string if OK. It is optional.
	// The error is the error string if an error occurred. It is optional.
	// the result and error are in the encoding specified by platform_encodingB
	SPAPI	A_Err  (*AEGP_ExecuteScript)(AEGP_PluginID			inPlugin_id,
										const A_char* inScriptZ,		// in
										const A_Boolean platform_encodingB,	// in
										AEGP_MemHandle* outResultPH0,
										AEGP_MemHandle* outErrorStringPH0);

	SPAPI A_Err (*AEGP_HostIsActivated)(A_Boolean	*is_activatedPB);

	SPAPI A_Err (*AEGP_GetPluginPlatformRef)(AEGP_PluginID	plug_id, void** plat_refPPV); // on the Mac, it is a CFBundleRef to your mach-o plugin or NULL for a CFM plug-in; on Windows it is set to NULL for now

	SPAPI A_Err (*AEGP_UpdateFontList)(void); // Rescan the system font list.  This will return quickly if the font list hasn't changed.

} AEGP_UtilitySuite5;



#define kAEGPUtilitySuiteVersion4		10 /* frozen in AE 7.0 */

typedef struct AEGP_UtilitySuite4 {

	SPAPI A_Err	(*AEGP_ReportInfo)(										/* displays dialog with name of plugin followed by info string */
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						const A_char			*info_stringZ);			/* >> */


	SPAPI A_Err	(*AEGP_GetDriverPluginInitFuncVersion)(
						A_short					*major_versionPS,		/* << */
						A_short					*minor_versionPS);		/* << */

	SPAPI A_Err	(*AEGP_GetDriverImplementationVersion)(
						A_short					*major_versionPS,		/* << */
						A_short					*minor_versionPS);		/* << */

	SPAPI A_Err	(*AEGP_StartQuietErrors)(
						AEGP_ErrReportState		*err_stateP);			/* << */

	SPAPI A_Err	(*AEGP_EndQuietErrors)(
						A_Boolean				report_quieted_errorsB,	/* >> currently reports last quieted error */
						AEGP_ErrReportState		*err_stateP);			/* >> */

	SPAPI A_Err (*AEGP_GetLastErrorMessage)(
						A_long					buffer_size,			/* >> size of character buffer */
						A_char					*error_string,					/* << */
						A_Err					*error_num);				/* << */

	SPAPI A_Err	(*AEGP_StartUndoGroup)(									/* MUST be balanced with call to AEGP_EndUndoGroup() */
						const A_char			*undo_nameZ);			/* >> */

	SPAPI A_Err	(*AEGP_EndUndoGroup)(void);

	SPAPI A_Err (*AEGP_RegisterWithAEGP)(
						AEGP_GlobalRefcon 		global_refcon,			/* >> global refcon passed in command handlers */
						const A_char			*plugin_nameZ,			/* >> name of this plugin. AEGP_MAX_PLUGIN_NAME_SIZE */
						AEGP_PluginID			*plugin_id);			/* << id for plugin to use in other AEGP calls */

	SPAPI A_Err (*AEGP_GetMainHWND)(
						void					*main_hwnd);			/* << */

	SPAPI A_Err (*AEGP_ShowHideAllFloaters)(
						A_Boolean				include_tool_palB);		/* >> */

	SPAPI A_Err (*AEGP_PaintPalGetForeColor)(
						AEGP_ColorVal			*fore_colorP);			/* << */

	SPAPI A_Err (*AEGP_PaintPalGetBackColor)(
						AEGP_ColorVal			*back_colorP);			/* << */

	SPAPI A_Err (*AEGP_PaintPalSetForeColor)(
						const AEGP_ColorVal		*fore_colorP);			/* >> */

	SPAPI A_Err (*AEGP_PaintPalSetBackColor)(
						const AEGP_ColorVal		*back_colorP);			/* >> */

	SPAPI A_Err (*AEGP_CharPalGetFillColor)(
						A_Boolean				*is_fill_color_definedPB,	/*  << */
                        AEGP_ColorVal			*fill_colorP); 				/* << only valid if is_fill_color_definedPB == TRUE */

	SPAPI A_Err (*AEGP_CharPalGetStrokeColor)(
						A_Boolean				*is_stroke_color_definedPB, /*  << */
                        AEGP_ColorVal			*stroke_colorP); 			/* << only valid if is_stroke_color_definedPB == TRUE */

	SPAPI A_Err (*AEGP_CharPalSetFillColor)(
						const AEGP_ColorVal		*fill_colorP);				/* >> */

	SPAPI A_Err (*AEGP_CharPalSetStrokeColor)(
						const AEGP_ColorVal		*stroke_colorP);			/* >> */

	SPAPI A_Err (*AEGP_CharPalIsFillColorUIFrontmost)(						/* Otherwise, StrokeColor is frontmost */
						A_Boolean				*is_fill_color_selectedPB);	/* << */

	SPAPI A_Err (*AEGP_ConvertFpLongToHSFRatio)(
						A_FpLong				numberF,					/* >> */
						A_Ratio					*ratioPR);					/* << */

	SPAPI A_Err (*AEGP_ConvertHSFRatioToFpLong)(
						A_Ratio					ratioR,						/* << */
						A_FpLong				*numberPF);					/* >> */

	// this routine is safe to call from the non-main
	// thread. It is asynchronous and will return before the idle handler is called.
	// The Suite routines to get this pointer are not
	// thread safe, therefore you need to save it off
	// in the main thread for use by the child thread.
	SPAPI A_Err (*AEGP_CauseIdleRoutinesToBeCalled)(void);


	// Determine if after effects is running in a mode where there is no
	// user interface, and attempting to interact with the user (via a modal dialog)
	// will hang the application.
	// This will not change during a run. Use it to optimize your plugin at startup
	// to not create a user interface and make AE launch faster, and not break
	// when running multiple instances of a service.
	SPAPI	A_Err  (*AEGP_GetSuppressInteractiveUI)(A_Boolean* ui_is_suppressedPB); // out

	// this call writes text to the console if one is available.  One is guaranteed to be available
	// if ui_is_suppressedB == true.
	// In general use the call AEGP_ReportInfo() as it will write to the console in
	// non-interactive modes, and use a dialog in interactive modes.
	SPAPI	A_Err  (*AEGP_WriteToOSConsole)(const A_char* textZ);				// in

	// this writes an entry into the debug log, or to the command line if launched
	// with the -debug flag.
	SPAPI	A_Err  (*AEGP_WriteToDebugLog)(const A_char* subsystemZ,	// in
								const A_char* event_typeZ,				// in
								const A_char * infoZ);					// in


	SPAPI	A_Err  (*AEGP_IsScriptingAvailable)(A_Boolean* outAvailablePB);

	// Execute a script.
	// The script text can either be in UTF-8, or the current
	// application encoding.
	// The result is the result string if OK. It is optional.
	// The error is the error string if an error occurred. It is optional.
	// the result and error are in the encoding specified by platform_encodingB
	SPAPI	A_Err  (*AEGP_ExecuteScript)(AEGP_PluginID			inPlugin_id,
										const A_char* inScriptZ,		// in
										const A_Boolean platform_encodingB,	// in
										AEGP_MemHandle* outResultPH0,
										AEGP_MemHandle* outErrorStringPH0);

	SPAPI A_Err (*AEGP_HostIsActivated)(A_Boolean	*is_activatedPB);

	SPAPI A_Err (*AEGP_GetPluginPlatformRef)(AEGP_PluginID	plug_id, void** plat_refPPV); // on the Mac, it is a CFBundleRef to your mach-o plugin or NULL for a CFM plug-in; on Windows it is set to NULL for now

} AEGP_UtilitySuite4;



#define kAEGPUtilitySuiteVersion3		7 /* frozen in AE 6.5 */

typedef struct AEGP_UtilitySuite3 {

	SPAPI A_Err	(*AEGP_ReportInfo)(										/* displays dialog with name of plugin followed by info string */
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						const A_char			*info_stringZ);			/* >> */


	SPAPI A_Err	(*AEGP_GetDriverPluginInitFuncVersion)(
						A_short					*major_versionPS,		/* << */
						A_short					*minor_versionPS);		/* << */

	SPAPI A_Err	(*AEGP_GetDriverImplementationVersion)(
						A_short					*major_versionPS,		/* << */
						A_short					*minor_versionPS);		/* << */

	SPAPI A_Err	(*AEGP_StartQuietErrors)(
						AEGP_ErrReportState		*err_stateP);			/* << */

	SPAPI A_Err	(*AEGP_EndQuietErrors)(
						A_Boolean				report_quieted_errorsB,	/* >> currently reports last quieted error */
						AEGP_ErrReportState		*err_stateP);			/* >> */

	SPAPI A_Err	(*AEGP_StartUndoGroup)(									/* MUST be balanced with call to AEGP_EndUndoGroup() */
						const A_char			*undo_nameZ);			/* >> */

	SPAPI A_Err	(*AEGP_EndUndoGroup)(void);

	SPAPI A_Err (*AEGP_RegisterWithAEGP)(
						AEGP_GlobalRefcon 		global_refcon,			/* >> global refcon passed in command handlers */
						const A_char			*plugin_nameZ,			/* >> name of this plugin. AEGP_MAX_PLUGIN_NAME_SIZE */
						AEGP_PluginID			*plugin_id);			/* << id for plugin to use in other AEGP calls */

	SPAPI A_Err (*AEGP_GetMainHWND)(
						void					*main_hwnd);			/* << */

	SPAPI A_Err (*AEGP_ShowHideAllFloaters)(
						A_Boolean				include_tool_palB);		/* >> */

	SPAPI A_Err (*AEGP_PaintPalGetForeColor)(
						AEGP_ColorVal			*fore_colorP);			/* << */

	SPAPI A_Err (*AEGP_PaintPalGetBackColor)(
						AEGP_ColorVal			*back_colorP);			/* << */

	SPAPI A_Err (*AEGP_PaintPalSetForeColor)(
						const AEGP_ColorVal		*fore_colorP);			/* >> */

	SPAPI A_Err (*AEGP_PaintPalSetBackColor)(
						const AEGP_ColorVal		*back_colorP);			/* >> */

	SPAPI A_Err (*AEGP_CharPalGetFillColor)(
						A_Boolean				*is_fill_color_definedPB,	/*  << */
                        AEGP_ColorVal			*fill_colorP); 				/* << only valid if is_fill_color_definedPB == TRUE */

	SPAPI A_Err (*AEGP_CharPalGetStrokeColor)(
						A_Boolean				*is_stroke_color_definedPB, /*  << */
                        AEGP_ColorVal			*stroke_colorP); 			/* << only valid if is_stroke_color_definedPB == TRUE */

	SPAPI A_Err (*AEGP_CharPalSetFillColor)(
						const AEGP_ColorVal		*fill_colorP);				/* >> */

	SPAPI A_Err (*AEGP_CharPalSetStrokeColor)(
						const AEGP_ColorVal		*stroke_colorP);			/* >> */

	SPAPI A_Err (*AEGP_CharPalIsFillColorUIFrontmost)(						/* Otherwise, StrokeColor is frontmost */
						A_Boolean				*is_fill_color_selectedPB);	/* << */

	SPAPI A_Err (*AEGP_ConvertFpLongToHSFRatio)(
						A_FpLong				numberF,					/* >> */
						A_Ratio					*ratioPR);					/* << */

	SPAPI A_Err (*AEGP_ConvertHSFRatioToFpLong)(
						A_Ratio					ratioR,						/* << */
						A_FpLong				*numberPF);					/* >> */

	// this routine is safe to call from the non-main
	// thread. It is asynchronous and will return before the idle handler is called.
	// The Suite routines to get this pointer are not
	// thread safe, therefore you need to save it off
	// in the main thread for use by the child thread.
	SPAPI A_Err (*AEGP_CauseIdleRoutinesToBeCalled)(void);


	// Determine if after effects is running in a mode where there is no
	// user interface, and attempting to interact with the user (via a modal dialog)
	// will hang the application.
	// This will not change during a run. Use it to optimize your plugin at startup
	// to not create a user interface and make AE launch faster, and not break
	// when running multiple instances of a service.
	SPAPI	A_Err  (*AEGP_GetSuppressInteractiveUI)(A_Boolean* ui_is_suppressedPB); // out

	// this call writes text to the console if one is available.  One is guaranteed to be available
	// if ui_is_suppressedB == true.
	// In general use the call AEGP_ReportInfo() as it will write to the console in
	// non-interactive modes, and use a dialog in interactive modes.
	SPAPI	A_Err  (*AEGP_WriteToOSConsole)(const A_char* textZ);				// in

	// this writes an entry into the debug log, or to the command line if launched
	// with the -debug flag.
	SPAPI	A_Err  (*AEGP_WriteToDebugLog)(const A_char* subsystemZ,	// in
								const A_char* event_typeZ,				// in
								const A_char * infoZ);					// in
} AEGP_UtilitySuite3;

#define kAEGPUtilitySuiteVersion2		5 /* frozen in AE 6.0 */

typedef struct AEGP_UtilitySuite2 {

	SPAPI A_Err	(*AEGP_ReportInfo)(										/* displays dialog with name of plugin followed by info string */
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						const A_char			*info_stringZ);			/* >> */


	SPAPI A_Err	(*AEGP_GetDriverPluginInitFuncVersion)(
						A_short					*major_versionPS,		/* << */
						A_short					*minor_versionPS);		/* << */

	SPAPI A_Err	(*AEGP_GetDriverImplementationVersion)(
						A_short					*major_versionPS,		/* << */
						A_short					*minor_versionPS);		/* << */

	SPAPI A_Err	(*AEGP_StartQuietErrors)(
						AEGP_ErrReportState		*err_stateP);			/* << */

	SPAPI A_Err	(*AEGP_EndQuietErrors)(
						A_Boolean				report_quieted_errorsB,	/* >> currently reports last quieted error */
						AEGP_ErrReportState		*err_stateP);			/* >> */

	SPAPI A_Err	(*AEGP_StartUndoGroup)(									/* MUST be balanced with call to AEGP_EndUndoGroup() */
						const A_char			*undo_nameZ);			/* >> */

	SPAPI A_Err	(*AEGP_EndUndoGroup)(void);

	SPAPI A_Err (*AEGP_RegisterWithAEGP)(
						AEGP_GlobalRefcon 		global_refcon,			/* >> global refcon passed in command handlers */
						const A_char			*plugin_nameZ,			/* >> name of this plugin. AEGP_MAX_PLUGIN_NAME_SIZE */
						AEGP_PluginID			*plugin_id);			/* << id for plugin to use in other AEGP calls */

	SPAPI A_Err (*AEGP_GetMainHWND)(
						void					*main_hwnd);			/* << */

	SPAPI A_Err (*AEGP_ShowHideAllFloaters)(
						A_Boolean				include_tool_palB);		/* >> */

	SPAPI A_Err (*AEGP_PaintPalGetForeColor)(
						AEGP_ColorVal			*fore_colorP);			/* << */

	SPAPI A_Err (*AEGP_PaintPalGetBackColor)(
						AEGP_ColorVal			*back_colorP);			/* << */

	SPAPI A_Err (*AEGP_PaintPalSetForeColor)(
						const AEGP_ColorVal		*fore_colorP);			/* >> */

	SPAPI A_Err (*AEGP_PaintPalSetBackColor)(
						const AEGP_ColorVal		*back_colorP);			/* >> */

	SPAPI A_Err (*AEGP_CharPalGetFillColor)(
						A_Boolean				*is_fill_color_definedPB,	/*  << */
                        AEGP_ColorVal			*fill_colorP); 				/* << only valid if is_fill_color_definedPB == TRUE */

	SPAPI A_Err (*AEGP_CharPalGetStrokeColor)(
						A_Boolean				*is_stroke_color_definedPB, /*  << */
                        AEGP_ColorVal			*stroke_colorP); 			/* << only valid if is_stroke_color_definedPB == TRUE */

	SPAPI A_Err (*AEGP_CharPalSetFillColor)(
						const AEGP_ColorVal		*fill_colorP);				/* >> */

	SPAPI A_Err (*AEGP_CharPalSetStrokeColor)(
						const AEGP_ColorVal		*stroke_colorP);			/* >> */

	SPAPI A_Err (*AEGP_CharPalIsFillColorUIFrontmost)(						/* Otherwise, StrokeColor is frontmost */
						A_Boolean				*is_fill_color_selectedPB);	/* << */

} AEGP_UtilitySuite2;

#define kAEGPUtilitySuiteVersion1		3 /* frozen in AE 5.0 */

typedef struct AEGP_UtilitySuite1 {

	SPAPI A_Err	(*AEGP_ReportInfo)(										/* displays dialog with name of plugin followed by info string */
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						const A_char			*info_stringZ);			/* >> */


	SPAPI A_Err	(*AEGP_GetDriverPluginInitFuncVersion)(
						A_short					*major_versionPS,		/* << */
						A_short					*minor_versionPS);		/* << */

	SPAPI A_Err	(*AEGP_GetDriverImplementationVersion)(
						A_short					*major_versionPS,		/* << */
						A_short					*minor_versionPS);		/* << */

	SPAPI A_Err	(*AEGP_StartQuietErrors)(
						AEGP_ErrReportState		*err_stateP);			/* << */

	SPAPI A_Err	(*AEGP_EndQuietErrors)(
						A_Boolean				report_quieted_errorsB,	/* >> currently reports last quieted error */
						AEGP_ErrReportState		*err_stateP);			/* >> */

	SPAPI A_Err	(*AEGP_StartUndoGroup)(									/* MUST be balanced with call to AEGP_EndUndoGroup() */
						const A_char			*undo_nameZ);			/* >> */

	SPAPI A_Err	(*AEGP_EndUndoGroup)(void);

	SPAPI A_Err (*AEGP_RegisterWithAEGP)(
						AEGP_GlobalRefcon 		global_refcon,			/* >> global refcon passed in command handlers */
						const A_char			*plugin_nameZ,			/* >> name of this plugin. AEGP_MAX_PLUGIN_NAME_SIZE */
						AEGP_PluginID			*plugin_id);			/* << id for plugin to use in other AEGP calls */

	SPAPI A_Err (*AEGP_GetMainHWND)(
						void					*main_hwnd);			/* << */

} AEGP_UtilitySuite1;




#define kAEGPQueryXformSuiteVersion1		1 /* frozen in AE 5.0 */



typedef struct AEGP_QueryXformSuite1 {

	SPAPI A_Err	(*AEGP_QueryXformGetSrcType)(
					PR_QueryContextH		query_contextH,		/* <> */
					AEGP_QueryXformType		*src_type);			/* << */

	SPAPI A_Err	(*AEGP_QueryXformGetDstType)(
					PR_QueryContextH		query_contextH,		/* <> */
					AEGP_QueryXformType		*dst_type);			/* << */

	SPAPI A_Err	(*AEGP_QueryXformGetLayer)(
						PR_QueryContextH	query_contextH,		/* <> */
						AEGP_LayerH			*layerPH);			/* << */

	SPAPI A_Err	(*AEGP_QueryXformGetComp)(
						PR_QueryContextH	query_contextH,		/* <> */
						AEGP_CompH			*compPH);			/* << */

	SPAPI A_Err	(*AEGP_QueryXformGetTransformTime)(
						PR_QueryContextH	query_contextH,		/* <> */
						A_Time				*time);				/* << */

	SPAPI A_Err	(*AEGP_QueryXformGetViewTime)(
						PR_QueryContextH	query_contextH,		/* <> */
						A_Time				*time);				/* << */

	SPAPI A_Err	(*AEGP_QueryXformGetCamera)(
						PR_QueryContextH	query_contextH,		/* <> */
						AEGP_LayerH			*camera_layerPH);	/* << */

	SPAPI A_Err	(*AEGP_QueryXformGetXform)(
						PR_QueryContextH	query_contextH,		/* <> */
						A_Matrix4			*xform);			/* << */

	SPAPI A_Err	(*AEGP_QueryXformSetXform)(
						PR_QueryContextH	query_contextH,		/* <> */
						A_Matrix4			*xform);			/* >> */

}AEGP_QueryXformSuite1;




#define	kAEGPRenderSuiteVersion1			1 /* frozen in AE 5.5.1 */


typedef struct {
	SPAPI A_Err (*AEGP_RenderAndCheckoutFrame)(
					AEGP_RenderOptionsH				optionsH,					/* >> */
					AEGP_RenderSuiteCheckForCancel	cancel_functionP0,			/* >> optional*/
					AEGP_CancelRefcon				cancel_function_refconP0, 	/* >> optional */
					AEGP_FrameReceiptH				*receiptPH);				/* << check in using AEGP_CheckinFrame to release memory */

	SPAPI A_Err (*AEGP_CheckinFrame)(
					AEGP_FrameReceiptH		receiptH);							/* >> */

	/*	This returns a read only world that is not-owned by the plugin.
		Call CheckinFrame to release the world when you are done reading from it.
	*/

	SPAPI A_Err (*AEGP_GetReceiptWorld)(
					AEGP_FrameReceiptH		receiptH,							/* >> */
					AEGP_WorldH				*worldPH);							/* << */

	SPAPI A_Err (*AEGP_GetRenderedRegion)(
					AEGP_FrameReceiptH		receiptH,							/* >> */
					A_LRect					*rendered_regionP);					/* << */

	SPAPI A_Err (*AEGP_IsRenderedFrameSufficient)(
						AEGP_RenderOptionsH rendered_optionsH,					/* >> */
						AEGP_RenderOptionsH proposed_optionsH,					/* >> */
						A_Boolean			*rendered_is_sufficientPB);			/* << */

	SPAPI A_Err (*AEGP_RenderNewItemSoundData)( 								/* Works on Compositions and Footage items. */
					AEGP_ItemH						itemH,						/* >> */
					const A_Time					*start_timePT,				/* >> */
					const A_Time					*durationPT,				/* >> */
					const AEGP_SoundDataFormat		*sound_formatP,				/* >> */
					AEGP_RenderSuiteCheckForCancel	cancel_functionP0,			/* >> optional*/
					AEGP_CancelRefcon				cancel_function_refconP0, 	/* >> optional */
					AEGP_SoundDataH					*new_sound_dataPH);			/* << AEGP_SoundDataH must be disposed. Returns NULL if no audio */

} AEGP_RenderSuite1;


#define	kAEGPRenderSuiteVersion2			2 /* frozen in 6.5 */


typedef A_Err (*AEGP_RenderSuiteCheckForCancelv1)(
					void 		*refcon,
					A_Boolean 	*cancelPB);

typedef struct {
	SPAPI A_Err (*AEGP_RenderAndCheckoutFrame)(
					AEGP_RenderOptionsH				optionsH,					/* >> */
					AEGP_RenderSuiteCheckForCancelv1	cancel_functionP0,			/* >> optional*/
					AEGP_CancelRefcon				cancel_function_refconP0, 	/* >> optional */
					AEGP_FrameReceiptH				*receiptPH);				/* << check in using AEGP_CheckinFrame to release memory */

	SPAPI A_Err (*AEGP_CheckinFrame)(
					AEGP_FrameReceiptH		receiptH);							/* >> */

	/*	This returns a read only world that is not-owned by the plugin.
		Call CheckinFrame to release the world when you are done reading from it.
	*/

	SPAPI A_Err (*AEGP_GetReceiptWorld)(
					AEGP_FrameReceiptH		receiptH,							/* >> */
					AEGP_WorldH				*worldPH);							/* << */

	SPAPI A_Err (*AEGP_GetRenderedRegion)(
					AEGP_FrameReceiptH		receiptH,							/* >> */
					A_LRect					*rendered_regionP);					/* << */

	SPAPI A_Err (*AEGP_IsRenderedFrameSufficient)(
						AEGP_RenderOptionsH rendered_optionsH,					/* >> */
						AEGP_RenderOptionsH proposed_optionsH,					/* >> */
						A_Boolean			*rendered_is_sufficientPB);			/* << */

	SPAPI A_Err (*AEGP_RenderNewItemSoundData)( 								/* Works on Compositions and Footage items. */
					AEGP_ItemH						itemH,						/* >> */
					const A_Time					*start_timePT,				/* >> */
					const A_Time					*durationPT,				/* >> */
					const AEGP_SoundDataFormat		*sound_formatP,				/* >> */
					AEGP_RenderSuiteCheckForCancel	cancel_functionP0,			/* >> optional*/
					AEGP_CancelRefcon				cancel_function_refconP0, 	/* >> optional */
					AEGP_SoundDataH					*new_sound_dataPH);			/* << AEGP_SoundDataH must be disposed. Returns NULL if no audio */


	// returns the current timestamp of the project.this is increased any time something is touched in the project
	// that affects rendering
	SPAPI A_Err (*AEGP_GetCurrentTimestamp)(
							AEGP_TimeStamp * time_stampP); // out

	// Lets you know if the video of the item has changed since the input time stamp.
	// Is not affected by audio.
	SPAPI A_Err (*AEGP_HasItemChangedSinceTimestamp)(AEGP_ItemH itemH,					// in
													const A_Time * start_timeP,			// in
													const A_Time* durationP,			//in
													const AEGP_TimeStamp * time_stampP, //in
													A_Boolean * item_has_changedPB);	//out

	// checks whether this frame would be worth rendering externally and
	// checking in to the cache. a speculative renderer should check this twice:
	// (1) before sending the frame out to render
	// (2) when it is complete, before calling AEGP_NewPlatformWorld and checking in.
	// (don't forget to call AEGP_HasItemChangedSinceTimestamp also!)
	SPAPI A_Err (*AEGP_IsItemWorthwhileToRender)(	AEGP_RenderOptionsH roH,					// in
												const AEGP_TimeStamp* time_stampP,		// in
												A_Boolean *worthwhile_to_renderPB);	// out

	// ticks_to_render is the approximate amount of time needed to render the frame
	// on this machine. it is 60Hz.
	SPAPI A_Err (*AEGP_CheckinRenderedFrame)( AEGP_RenderOptionsH roH,					// in
												const AEGP_TimeStamp* time_stampP,		// in
												A_u_long ticks_to_renderL,				// in
												AEGP_PlatformWorldH	imageH);			// in (adopted)
} AEGP_RenderSuite2;


#define	kAEGPRenderSuiteVersion3			3 /* frozen in 11.0 */

typedef struct {
	SPAPI A_Err (*AEGP_RenderAndCheckoutFrame)(
					AEGP_RenderOptionsH				optionsH,					/* >> */
					AEGP_RenderSuiteCheckForCancel	cancel_functionP0,			/* >> optional*/
					AEGP_CancelRefcon				cancel_function_refconP0, 	/* >> optional */
					AEGP_FrameReceiptH				*receiptPH);				/* << check in using AEGP_CheckinFrame to release memory */

	SPAPI A_Err (*AEGP_CheckinFrame)(
					AEGP_FrameReceiptH		receiptH);							/* >> */

	/*	This returns a read only world that is not-owned by the plugin.
		Call CheckinFrame to release the world when you are done reading from it.
	*/

	SPAPI A_Err (*AEGP_GetReceiptWorld)(
					AEGP_FrameReceiptH		receiptH,							/* >> */
					AEGP_WorldH				*worldPH);							/* << */

	SPAPI A_Err (*AEGP_GetRenderedRegion)(
					AEGP_FrameReceiptH		receiptH,							/* >> */
					A_LRect					*rendered_regionP);					/* << */

	SPAPI A_Err (*AEGP_IsRenderedFrameSufficient)(
						AEGP_RenderOptionsH rendered_optionsH,					/* >> */
						AEGP_RenderOptionsH proposed_optionsH,					/* >> */
						A_Boolean			*rendered_is_sufficientPB);			/* << */

	SPAPI A_Err (*AEGP_RenderNewItemSoundData)( 								/* Works on Compositions and Footage items. */
					AEGP_ItemH						itemH,						/* >> */
					const A_Time					*start_timePT,				/* >> */
					const A_Time					*durationPT,				/* >> */
					const AEGP_SoundDataFormat		*sound_formatP,				/* >> */
					AEGP_RenderSuiteCheckForCancel	cancel_functionP0,			/* >> optional*/
					AEGP_CancelRefcon				cancel_function_refconP0, 	/* >> optional */
					AEGP_SoundDataH					*new_sound_dataPH);			/* << AEGP_SoundDataH must be disposed. Returns NULL if no audio */


	// returns the current timestamp of the project.this is increased any time something is touched in the project
	// that affects rendering
	SPAPI A_Err (*AEGP_GetCurrentTimestamp)(
							AEGP_TimeStamp * time_stampP); // out

	// Lets you know if the video of the item has changed since the input time stamp.
	// Is not affected by audio.
	SPAPI A_Err (*AEGP_HasItemChangedSinceTimestamp)(AEGP_ItemH itemH,					// in
													const A_Time * start_timeP,			// in
													const A_Time* durationP,			//in
													const AEGP_TimeStamp * time_stampP, //in
													A_Boolean * item_has_changedPB);	//out

	// checks whether this frame would be worth rendering externally and
	// checking in to the cache. a speculative renderer should check this twice:
	// (1) before sending the frame out to render
	// (2) when it is complete, before calling AEGP_NewPlatformWorld and checking in.
	// (don't forget to call AEGP_HasItemChangedSinceTimestamp also!)
	SPAPI A_Err (*AEGP_IsItemWorthwhileToRender)(	AEGP_RenderOptionsH roH,					// in
												const AEGP_TimeStamp* time_stampP,		// in
												A_Boolean *worthwhile_to_renderPB);	// out

	// ticks_to_render is the approximate amount of time needed to render the frame
	// on this machine. it is 60Hz.
	SPAPI A_Err (*AEGP_CheckinRenderedFrame)( AEGP_RenderOptionsH roH,					// in
												const AEGP_TimeStamp* time_stampP,		// in
												A_u_long ticks_to_renderL,				// in
												AEGP_PlatformWorldH	imageH);			// in (adopted)
												
	SPAPI A_Err (*AEGP_GetReceiptGuid) (AEGP_FrameReceiptH receiptH, 	// in
											AEGP_MemHandle *guidMH);	// out, must be disposed
} AEGP_RenderSuite3;


#define	kAEGPRenderSuiteVersion4			5 /* frozen in 13.0 */

typedef struct {
	SPAPI A_Err (*AEGP_RenderAndCheckoutFrame)(
					AEGP_RenderOptionsH				optionsH,					/* >> */
					AEGP_RenderSuiteCheckForCancel	cancel_functionP0,			/* >> optional*/
					AEGP_CancelRefcon				cancel_function_refconP0, 	/* >> optional */
					AEGP_FrameReceiptH				*receiptPH);				/* << check in using AEGP_CheckinFrame to release memory */

	SPAPI A_Err (*AEGP_RenderAndCheckoutLayerFrame)(
					AEGP_LayerRenderOptionsH			optionsH,					/* >> */
					A_Boolean							render_plain_layer_frameB,	/* >> true to render layer frame, false to render effect input frame */
					AEGP_RenderSuiteCheckForCancel		cancel_functionP0,			/* >> optional*/
					AEGP_CancelRefcon					cancel_function_refconP0,	/* >> optional */
					AEGP_FrameReceiptH					*receiptPH);				/* << check in using AEGP_CheckinFrame to release memory */

	SPAPI A_Err (*AEGP_CheckinFrame)(
					AEGP_FrameReceiptH		receiptH);							/* >> */

	/*	This returns a read only world that is not-owned by the plugin.
		Call CheckinFrame to release the world when you are done reading from it.
	*/

	SPAPI A_Err (*AEGP_GetReceiptWorld)(
					AEGP_FrameReceiptH		receiptH,							/* >> */
					AEGP_WorldH				*worldPH);							/* << */

	SPAPI A_Err (*AEGP_GetRenderedRegion)(
					AEGP_FrameReceiptH		receiptH,							/* >> */
					A_LRect					*rendered_regionP);					/* << */

	SPAPI A_Err (*AEGP_IsRenderedFrameSufficient)(
						AEGP_RenderOptionsH rendered_optionsH,					/* >> */
						AEGP_RenderOptionsH proposed_optionsH,					/* >> */
						A_Boolean			*rendered_is_sufficientPB);			/* << */

	SPAPI A_Err (*AEGP_RenderNewItemSoundData)( 								/* Works on Compositions and Footage items. */
					AEGP_ItemH						itemH,						/* >> */
					const A_Time					*start_timePT,				/* >> */
					const A_Time					*durationPT,				/* >> */
					const AEGP_SoundDataFormat		*sound_formatP,				/* >> */
					AEGP_RenderSuiteCheckForCancel	cancel_functionP0,			/* >> optional*/
					AEGP_CancelRefcon				cancel_function_refconP0, 	/* >> optional */
					AEGP_SoundDataH					*new_sound_dataPH);			/* << AEGP_SoundDataH must be disposed. Returns NULL if no audio */


	// returns the current timestamp of the project.this is increased any time something is touched in the project
	// that affects rendering
	SPAPI A_Err (*AEGP_GetCurrentTimestamp)(
							AEGP_TimeStamp * time_stampP); // out

	// Lets you know if the video of the item has changed since the input time stamp.
	// Is not affected by audio.
	SPAPI A_Err (*AEGP_HasItemChangedSinceTimestamp)(AEGP_ItemH itemH,					// in
													const A_Time * start_timeP,			// in
													const A_Time* durationP,			//in
													const AEGP_TimeStamp * time_stampP, //in
													A_Boolean * item_has_changedPB);	//out

	// checks whether this frame would be worth rendering externally and
	// checking in to the cache. a speculative renderer should check this twice:
	// (1) before sending the frame out to render
	// (2) when it is complete, before calling AEGP_NewPlatformWorld and checking in.
	// (don't forget to call AEGP_HasItemChangedSinceTimestamp also!)
	SPAPI A_Err (*AEGP_IsItemWorthwhileToRender)(	AEGP_RenderOptionsH roH,					// in
												const AEGP_TimeStamp* time_stampP,		// in
												A_Boolean *worthwhile_to_renderPB);	// out

	// ticks_to_render is the approximate amount of time needed to render the frame
	// on this machine. it is 60Hz.
	SPAPI A_Err (*AEGP_CheckinRenderedFrame)( AEGP_RenderOptionsH roH,					// in
												const AEGP_TimeStamp* time_stampP,		// in
												A_u_long ticks_to_renderL,				// in
												AEGP_PlatformWorldH	imageH);			// in (adopted)
												
	SPAPI A_Err (*AEGP_GetReceiptGuid) (AEGP_FrameReceiptH receiptH, 	// in
											AEGP_MemHandle *guidMH);	// out, must be disposed
} AEGP_RenderSuite4;



#define	kAEGPWorldSuiteVersion2			2 /* frozen in AE 6.5 */

typedef struct {
	SPAPI A_Err (*AEGP_New)(
		AEGP_PluginID	plugin_id,			/* >> */
		AEGP_WorldType	type,				/* >> */
		A_long			widthL,				/* >> */
		A_long			heightL,			/* >> */
		AEGP_WorldH		*worldPH);			/* << */

	SPAPI A_Err (*AEGP_Dispose)(
		AEGP_WorldH		worldH);			/* >> */

	SPAPI A_Err (*AEGP_GetType)(
		AEGP_WorldH		worldH,				/* >> */
		AEGP_WorldType	*typeP);			/* << */

	SPAPI A_Err (*AEGP_GetSize)(
		AEGP_WorldH		worldH,				/* >> */
		A_long			*widthPL,			/* << */
		A_long			*heightPL);			/* << */

	SPAPI A_Err (*AEGP_GetRowBytes)(
		AEGP_WorldH		worldH,				/* >> */
		A_u_long			*row_bytesPL);	/* << */

	SPAPI A_Err (*AEGP_GetBaseAddr8)(
		AEGP_WorldH		worldH,				/* >> error if the worldH is not AEGP_WorldType_8 */
		PF_Pixel8		**base_addrP);		/* << */

	SPAPI A_Err (*AEGP_GetBaseAddr16)(
		AEGP_WorldH		worldH,				/* >> error if the worldH is not AEGP_WorldType_16 */
		PF_Pixel16		**base_addrP);		/* << */

	SPAPI A_Err (*AEGP_FillOutPFEffectWorld)(				/*	Provided so you can use some of the PF routines with an AEGPWorld. Pass NULL as the ProgPtr to the PF routines.*/
		AEGP_WorldH		worldH,				/* >> */
		PF_EffectWorld	*pf_worldP);		/* << */

	SPAPI A_Err (*AEGP_FastBlur)(
		A_FpLong		radiusF,			/* >> */
		PF_ModeFlags	mode,				/* >> */
		PF_Quality		quality,			/* >> */
		AEGP_WorldH		worldH);			/* <>  only for user allocated worlds; not for checked-out frames which are read only */

	SPAPI A_Err (*AEGP_NewPlatformWorld)(
		AEGP_PluginID	plugin_id,			/* >> */
		AEGP_WorldType	type,				/* >> */
		A_long			widthL,				/* >> */
		A_long			heightL,			/* >> */
		AEGP_PlatformWorldH		*worldPH);			/* << */

	SPAPI A_Err (*AEGP_DisposePlatformWorld)(
		AEGP_PlatformWorldH		worldH);			/* >> */

	SPAPI A_Err (*AEGP_NewReferenceFromPlatformWorld)(
		AEGP_PluginID	plugin_id,			/* >> */
		AEGP_PlatformWorldH platform_worldH, // >>
		AEGP_WorldH		*worldPH);			/* << */


} AEGP_WorldSuite2;


#define	kAEGPWorldSuite					"AEGP World Suite"
#define	kAEGPWorldSuiteVersion1			1 /* frozen AE 6.0 */

typedef struct {
	SPAPI A_Err (*AEGP_New)(
		AEGP_PluginID	plugin_id,			/* >> */
		AEGP_WorldType	type,				/* >> */
		A_long			widthL,				/* >> */
		A_long			heightL,			/* >> */
		AEGP_WorldH		*worldPH);			/* << */

	SPAPI A_Err (*AEGP_Dispose)(
		AEGP_WorldH		worldH);			/* >> */

	SPAPI A_Err (*AEGP_GetType)(
		AEGP_WorldH		worldH,				/* >> */
		AEGP_WorldType	*typeP);			/* << */

	SPAPI A_Err (*AEGP_GetSize)(
		AEGP_WorldH		worldH,				/* >> */
		A_long			*widthPL,			/* << */
		A_long			*heightPL);			/* << */

	SPAPI A_Err (*AEGP_GetRowBytes)(
		AEGP_WorldH		worldH,				/* >> */
		A_u_long			*row_bytesPL);	/* << */

	SPAPI A_Err (*AEGP_GetBaseAddr8)(
		AEGP_WorldH		worldH,				/* >> error if the worldH is not AEGP_WorldType_8 */
		PF_Pixel8		**base_addrP);		/* << */

	SPAPI A_Err (*AEGP_GetBaseAddr16)(
		AEGP_WorldH		worldH,				/* >> error if the worldH is not AEGP_WorldType_16 */
		PF_Pixel16		**base_addrP);		/* << */

	SPAPI A_Err (*AEGP_FillOutPFEffectWorld)(				/*	Provided so you can use some of the PF routines with an AEGPWorld. Pass NULL as the ProgPtr to the PF routines.*/
		AEGP_WorldH		worldH,				/* >> */
		PF_EffectWorld	*pf_worldP);		/* << */

	SPAPI A_Err (*AEGP_FastBlur)(
		A_FpLong		radiusF,			/* >> */
		PF_ModeFlags	mode,				/* >> */
		PF_Quality		quality,			/* >> */
		AEGP_WorldH		worldH);			/* <>  only for user allocated worlds; not for checked-out frames which are read only */
} AEGP_WorldSuite1;


typedef struct {
	AEGP_CollectionItemType	type;
	union {
		AEGP_LayerCollectionItem		layer;
		AEGP_MaskCollectionItem			mask;
		AEGP_EffectCollectionItem		effect;
		AEGP_StreamCollectionItem		stream;
		AEGP_MaskVertexCollectionItem	mask_vertex;
		AEGP_KeyframeCollectionItem		keyframe;
	} u;
} AEGP_CollectionItem;


#define	kAEGPCollectionSuiteVersion1			1 /* frozen in AE 5.0 */

typedef struct {
	SPAPI A_Err (*AEGP_NewCollection)(									/* dispose with dispose collection */
		AEGP_PluginID	plugin_id,						/* >> */
		AEGP_CollectionH *collectionPH);				/* << */

	SPAPI A_Err (*AEGP_DisposeCollection)(
		AEGP_CollectionH collectionH);					/* >> */

	SPAPI A_Err	(*AEGP_GetCollectionNumItems)(							/* constant time */
		AEGP_CollectionH	collectionH,				/* >> */
		A_u_long		*num_itemsPL);					/* << */

	SPAPI A_Err	(*AEGP_GetCollectionItemByIndex)(						/* constant time */
		AEGP_CollectionH	collectionH,				/* >> */
		A_u_long			indexL,						/* >> */
		AEGP_CollectionItem	*collection_itemP);			/* << */

	SPAPI A_Err (*AEGP_CollectionPushBack)(								/* constant time */
		AEGP_CollectionH			collectionH,		/* <> */
		const AEGP_CollectionItem	*collection_itemP);	/* >> */

	SPAPI A_Err (*AEGP_CollectionErase)(								/* O(n) */
		AEGP_CollectionH	collectionH,				/* <> */
		A_u_long			index_firstL,				/* >> */
		A_u_long			index_lastL);				/* >> */

} AEGP_CollectionSuite1;

#define kAEGPDynamicStreamSuiteVersion1		1	/* frozen in AE 6.0 */

typedef struct AEGP_DynamicStreamSuite1 {

	SPAPI A_Err	(*AEGP_GetNewStreamRefForLayer)(						// used to start recursive walk of layer,
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						AEGP_LayerH				layerH,					/* >> */
						AEGP_StreamRefH 		*streamPH);				/* << must be disposed by caller! */

	SPAPI A_Err (*AEGP_GetStreamDepth)(									// layer is depth 0
						AEGP_StreamRefH			streamH,				/* >> */
						A_long					*depthPL);				/* << */


	SPAPI A_Err	(*AEGP_GetStreamGroupingType)(
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_StreamGroupingType	*group_typeP);			/* << */

	SPAPI A_Err	(*AEGP_GetNumStreamsInGroup)(	// error on leaf
						AEGP_StreamRefH			streamH,				/* >> */
						A_long					*num_streamsPL);		/* << */


	SPAPI A_Err	(*AEGP_GetDynamicStreamFlags)(
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_DynStreamFlags		*stream_flagsP);		/* << */

	SPAPI A_Err	(*AEGP_SetDynamicStreamFlag)(							/* UNDOABLE */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_DynStreamFlags		one_flag,				/* >> */
						A_Boolean				setB);					/* >> */


	SPAPI A_Err	(*AEGP_GetNewStreamRefByIndex)(		// legal for namedgroup, indexedgroup, not leaf
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						AEGP_StreamRefH			parent_groupH,			/* >> */
						A_long					indexL,					/* >> */
						AEGP_StreamRefH 		*streamPH);				/* << must be disposed by caller! */

	SPAPI A_Err	(*AEGP_GetNewStreamRefByMatchname)(	// legal for namedgroup
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						AEGP_StreamRefH			parent_groupH,			/* >> */
						const A_char			*match_nameZ,			/* >> */
						AEGP_StreamRefH 		*streamPH);				/* << must be disposed by caller! */

	SPAPI A_Err	(*AEGP_DeleteStream)(		/* UNDOABLE, only valid for children of AEGP_StreamGroupingType_INDEXED_GROUP */
						AEGP_StreamRefH			streamH);			/* >> */ // must still dispose the streamref later

	SPAPI A_Err	(*AEGP_ReorderStream)(		/* UNDOABLE, only valid for children of AEGP_StreamGroupingType_INDEXED_GROUP */
						AEGP_StreamRefH			streamH,			/* <> updated to refer to newly ordered stream */
						A_long 					new_indexL);		/* >> */

	SPAPI A_Err (*AEGP_DuplicateStream)(	/* UNDOABLE, only valid for children of AEGP_StreamGroupingType_INDEXED_GROUP */
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						AEGP_StreamRefH			streamH,				/* >> */
						A_long					*new_indexPL0);			/* << */

	/* GetStreamName is in main kAEGPStreamSuite, and works on dynamic streams including groups */

	SPAPI A_Err	(*AEGP_SetStreamName)(		/* UNDOABLE, only valid for children of AEGP_StreamGroupingType_INDEXED_GROUP */
						AEGP_StreamRefH			streamH,				/* >> */
						const A_char			*nameZ);				/* >> */

	SPAPI A_Err (*AEGP_CanAddStream)(
						AEGP_StreamRefH			group_streamH,			/* >> */
						const A_char			*match_nameZ,			/* >> */
						A_Boolean				*can_addPB);			/* << */

	SPAPI A_Err (*AEGP_AddStream)(				/* UNDOABLE, only valid for AEGP_StreamGroupingType_INDEXED_GROUP */
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						AEGP_StreamRefH			indexed_group_streamH,	/* >> */
						const A_char			*match_nameZ,
						AEGP_StreamRefH			*streamPH0);			/* << must be disposed by caller! */

	SPAPI A_Err (*AEGP_GetMatchName)(
						AEGP_StreamRefH			streamH,				/* >> */
						A_char					*nameZ);				/* << use A_char[AEGP_MAX_STREAM_MATCH_NAME_SIZE] for buffer */

	SPAPI A_Err (*AEGP_GetNewParentStreamRef)(
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_StreamRefH			*parent_streamPH);		/* << must be disposed by caller! */

	SPAPI A_Err (*AEGP_GetStreamIsModified)(	// i.e. changed from defaults, like the UU key
						AEGP_StreamRefH			streamH,				/* >> */
						A_Boolean				*modifiedPB);			/* << */

} AEGP_DynamicStreamSuite1;

#define kAEGPDynamicStreamSuiteVersion2		2	/* frozen in AE 6.5 */

typedef struct AEGP_DynamicStreamSuite2 {

	SPAPI A_Err	(*AEGP_GetNewStreamRefForLayer)(						// used to start recursive walk of layer,
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						AEGP_LayerH				layerH,					/* >> */
						AEGP_StreamRefH 		*streamPH);				/* << must be disposed by caller! */

	SPAPI A_Err (*AEGP_GetStreamDepth)(									// layer is depth 0
						AEGP_StreamRefH			streamH,				/* >> */
						A_long					*depthPL);				/* << */


	SPAPI A_Err	(*AEGP_GetStreamGroupingType)(
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_StreamGroupingType	*group_typeP);			/* << */

	SPAPI A_Err	(*AEGP_GetNumStreamsInGroup)(	// error on leaf
						AEGP_StreamRefH			streamH,				/* >> */
						A_long					*num_streamsPL);		/* << */


	SPAPI A_Err	(*AEGP_GetDynamicStreamFlags)(
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_DynStreamFlags		*stream_flagsP);		/* << */

	SPAPI A_Err	(*AEGP_SetDynamicStreamFlag)(
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_DynStreamFlags		one_flag,				/* >> */
						A_Boolean				undoableB,				/* true if you want this to be an undoable change */
																		/* if false, the only legal flag is AEGP_DynStreamFlag_HIDDEN */
						A_Boolean				setB);					/* >> */


	SPAPI A_Err	(*AEGP_GetNewStreamRefByIndex)(		// legal for namedgroup, indexedgroup, not leaf
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						AEGP_StreamRefH			parent_groupH,			/* >> */
						A_long					indexL,					/* >> */
						AEGP_StreamRefH 		*streamPH);				/* << must be disposed by caller! */

	SPAPI A_Err	(*AEGP_GetNewStreamRefByMatchname)(	// legal for namedgroup
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						AEGP_StreamRefH			parent_groupH,			/* >> */
						const A_char			*match_nameZ,			/* >> */
						AEGP_StreamRefH 		*streamPH);				/* << must be disposed by caller! */

	SPAPI A_Err	(*AEGP_DeleteStream)(		/* UNDOABLE, only valid for children of AEGP_StreamGroupingType_INDEXED_GROUP */
						AEGP_StreamRefH			streamH);			/* >> */ // must still dispose the streamref later

	SPAPI A_Err	(*AEGP_ReorderStream)(		/* UNDOABLE, only valid for children of AEGP_StreamGroupingType_INDEXED_GROUP */
						AEGP_StreamRefH			streamH,			/* <> updated to refer to newly ordered stream */
						A_long 					new_indexL);		/* >> */

	SPAPI A_Err (*AEGP_DuplicateStream)(	/* UNDOABLE, only valid for children of AEGP_StreamGroupingType_INDEXED_GROUP */
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						AEGP_StreamRefH			streamH,				/* >> */
						A_long					*new_indexPL0);			/* << */

	/* GetStreamName is in main kAEGPStreamSuite, and works on dynamic streams including groups */

	SPAPI A_Err	(*AEGP_SetStreamName)(		/* UNDOABLE, only valid for children of AEGP_StreamGroupingType_INDEXED_GROUP */
						AEGP_StreamRefH			streamH,				/* >> */
						const A_char			*nameZ);				/* >> */

	SPAPI A_Err (*AEGP_CanAddStream)(
						AEGP_StreamRefH			group_streamH,			/* >> */
						const A_char			*match_nameZ,			/* >> */
						A_Boolean				*can_addPB);			/* << */

	SPAPI A_Err (*AEGP_AddStream)(				/* UNDOABLE, only valid for AEGP_StreamGroupingType_INDEXED_GROUP */
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						AEGP_StreamRefH			indexed_group_streamH,	/* >> */
						const A_char			*match_nameZ,
						AEGP_StreamRefH			*streamPH0);			/* << must be disposed by caller! */

	SPAPI A_Err (*AEGP_GetMatchName)(
						AEGP_StreamRefH			streamH,				/* >> */
						A_char					*nameZ);				/* << use A_char[AEGP_MAX_STREAM_MATCH_NAME_SIZE] for buffer */

	SPAPI A_Err (*AEGP_GetNewParentStreamRef)(
						AEGP_PluginID			aegp_plugin_id,			/* >> */
						AEGP_StreamRefH			streamH,				/* >> */
						AEGP_StreamRefH			*parent_streamPH);		/* << must be disposed by caller! */

	SPAPI A_Err (*AEGP_GetStreamIsModified)(	// i.e. changed from defaults, like the UU key
						AEGP_StreamRefH			streamH,				/* >> */
						A_Boolean				*modifiedPB);			/* << */

} AEGP_DynamicStreamSuite2;

#define kAEGPDynamicStreamSuiteVersion3		3	/* frozen in AE 7.0 */

typedef struct AEGP_DynamicStreamSuite3 {

	SPAPI A_Err	(*AEGP_GetNewStreamRefForLayer)(						// used to start recursive walk of layer,
		AEGP_PluginID			aegp_plugin_id,			/* >> */
		AEGP_LayerH				layerH,					/* >> */
		AEGP_StreamRefH 		*streamPH);				/* << must be disposed by caller! */

	SPAPI A_Err (*AEGP_GetStreamDepth)(									// layer is depth 0
		AEGP_StreamRefH			streamH,				/* >> */
		A_long					*depthPL);				/* << */


	SPAPI A_Err	(*AEGP_GetStreamGroupingType)(
		AEGP_StreamRefH			streamH,				/* >> */
		AEGP_StreamGroupingType	*group_typeP);			/* << */

	SPAPI A_Err	(*AEGP_GetNumStreamsInGroup)(	// error on leaf
		AEGP_StreamRefH			streamH,				/* >> */
		A_long					*num_streamsPL);		/* << */


	SPAPI A_Err	(*AEGP_GetDynamicStreamFlags)(
		AEGP_StreamRefH			streamH,				/* >> */
		AEGP_DynStreamFlags		*stream_flagsP);		/* << */

	SPAPI A_Err	(*AEGP_SetDynamicStreamFlag)(
		AEGP_StreamRefH			streamH,				/* >> */
		AEGP_DynStreamFlags		one_flag,				/* >> */
		A_Boolean				undoableB,				/* true if you want this to be an undoable change */
		/* if false, the only legal flag is AEGP_DynStreamFlag_HIDDEN */
		A_Boolean				setB);					/* >> */


	SPAPI A_Err	(*AEGP_GetNewStreamRefByIndex)(		// legal for namedgroup, indexedgroup, not leaf
		AEGP_PluginID			aegp_plugin_id,			/* >> */
		AEGP_StreamRefH			parent_groupH,			/* >> */
		A_long					indexL,					/* >> */
		AEGP_StreamRefH 		*streamPH);				/* << must be disposed by caller! */

	SPAPI A_Err	(*AEGP_GetNewStreamRefByMatchname)(	// legal for namedgroup
		AEGP_PluginID			aegp_plugin_id,			/* >> */
		AEGP_StreamRefH			parent_groupH,			/* >> */
		const A_char			*match_nameZ,			/* >> */
		AEGP_StreamRefH 		*streamPH);				/* << must be disposed by caller! */

	SPAPI A_Err	(*AEGP_DeleteStream)(		/* UNDOABLE, only valid for children of AEGP_StreamGroupingType_INDEXED_GROUP */
		AEGP_StreamRefH			streamH);			/* >> */ // must still dispose the streamref later

	SPAPI A_Err	(*AEGP_ReorderStream)(		/* UNDOABLE, only valid for children of AEGP_StreamGroupingType_INDEXED_GROUP */
		AEGP_StreamRefH			streamH,			/* <> updated to refer to newly ordered stream */
		A_long 					new_indexL);		/* >> */

	SPAPI A_Err (*AEGP_DuplicateStream)(	/* UNDOABLE, only valid for children of AEGP_StreamGroupingType_INDEXED_GROUP */
		AEGP_PluginID			aegp_plugin_id,			/* >> */
		AEGP_StreamRefH			streamH,				/* >> */
		A_long					*new_indexPL0);			/* << */

	/* GetStreamName is in main kAEGPStreamSuite, and works on dynamic streams including groups */

	SPAPI A_Err	(*AEGP_SetStreamName)(		/* UNDOABLE, only valid for children of AEGP_StreamGroupingType_INDEXED_GROUP */
		AEGP_StreamRefH			streamH,				/* >> */
		const A_char			*nameZ);				/* >> */

	SPAPI A_Err (*AEGP_CanAddStream)(
		AEGP_StreamRefH			group_streamH,			/* >> */
		const A_char			*match_nameZ,			/* >> */
		A_Boolean				*can_addPB);			/* << */

	SPAPI A_Err (*AEGP_AddStream)(				/* UNDOABLE, only valid for AEGP_StreamGroupingType_INDEXED_GROUP */
		AEGP_PluginID			aegp_plugin_id,			/* >> */
		AEGP_StreamRefH			indexed_group_streamH,	/* >> */
		const A_char			*match_nameZ,
		AEGP_StreamRefH			*streamPH0);			/* << must be disposed by caller! */

	SPAPI A_Err (*AEGP_GetMatchName)(
		AEGP_StreamRefH			streamH,				/* >> */
		A_char					*nameZ);				/* << use A_char[AEGP_MAX_STREAM_MATCH_NAME_SIZE] for buffer */

	SPAPI A_Err (*AEGP_GetNewParentStreamRef)(
		AEGP_PluginID			aegp_plugin_id,			/* >> */
		AEGP_StreamRefH			streamH,				/* >> */
		AEGP_StreamRefH			*parent_streamPH);		/* << must be disposed by caller! */

	SPAPI A_Err (*AEGP_GetStreamIsModified)(	// i.e. changed from defaults, like the UU key
		AEGP_StreamRefH			streamH,				/* >> */
		A_Boolean				*modifiedPB);			/* << */

	SPAPI A_Err (*AEGP_GetStreamIndexInParent)(	// only valid for children of AEGP_StreamGroupingType_INDEXED_GROUP
		AEGP_StreamRefH			streamH,				/* >> */
		A_long 					*indexPL);				/* << */



} AEGP_DynamicStreamSuite3;


#define	kAEGPRenderOptionsSuite					"AEGP Render Options Suite"
#define	kAEGPRenderOptionsSuiteVersion3			3 /* frozen in AE 7.01 */

typedef struct {
	// fills out
	// Time to 0
	// Time step to the frame duration
	// field render to none
	// depth is best resolution of item
	SPAPI A_Err (*AEGP_NewFromItem)(
					AEGP_PluginID		plugin_id,			/* >> */
					AEGP_ItemH			itemH,				/* >> */
					AEGP_RenderOptionsH	*optionsPH);		/* << */

	SPAPI A_Err (*AEGP_Duplicate)(
					AEGP_PluginID		plugin_id,			/* >> */
					AEGP_RenderOptionsH	optionsH,			/* >> */
					AEGP_RenderOptionsH	*copyPH);			/* << */

	SPAPI A_Err (*AEGP_Dispose)(
					AEGP_RenderOptionsH	optionsH);			/* >> */

	SPAPI A_Err (*AEGP_SetTime)(							/* the render time */
					AEGP_RenderOptionsH	optionsH,			/* <> */
					A_Time				time);				/* >> */

	SPAPI A_Err (*AEGP_GetTime)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					A_Time				*timeP);			/* << */

	SPAPI A_Err (*AEGP_SetTimeStep)(						/* duration of the frame; important for motion blur. */
					AEGP_RenderOptionsH	optionsH,			/* <> */
					A_Time				time_step);			/* >> */

	SPAPI A_Err (*AEGP_GetTimeStep)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					A_Time				*timePT);			/* << */

	SPAPI A_Err (*AEGP_SetFieldRender)(						/* How fields are to be handled. */
					AEGP_RenderOptionsH	optionsH,			/* <> */
					PF_Field			field_render);		/* >> */

	SPAPI A_Err (*AEGP_GetFieldRender)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					PF_Field			*field_renderP);	/* << */


	SPAPI A_Err (*AEGP_SetWorldType)(
					AEGP_RenderOptionsH	optionsH,			/* <> */
					AEGP_WorldType		type);				/* >> */

	SPAPI A_Err (*AEGP_GetWorldType)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					AEGP_WorldType		*typeP);			/* << */


	// 1 == 100%
	// 2 == 50%
	// ...
	SPAPI A_Err (*AEGP_SetDownsampleFactor)(
					AEGP_RenderOptionsH	optionsH,			/* <> */
					A_short		x,							/* >> */
					A_short		y);							/* >> */

	SPAPI A_Err (*AEGP_GetDownsampleFactor)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					A_short				*xP,				/* >> */
					A_short				*yP);				/* << */

	SPAPI A_Err	(*AEGP_SetRegionOfInterest)(
					AEGP_RenderOptionsH	optionsH,			/* <> */
					const A_LRect		*roiP);				/* >>  {0,0,0,0} for all*/

	SPAPI A_Err (*AEGP_GetRegionOfInterest)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					A_LRect				*roiP);				/* << */

	SPAPI A_Err	(*AEGP_SetMatteMode)(
					AEGP_RenderOptionsH	optionsH,			/* <> */
					AEGP_MatteMode		mode);				/* >> */

	SPAPI A_Err (*AEGP_GetMatteMode)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					AEGP_MatteMode		*modeP);			/* << */

	SPAPI A_Err	(*AEGP_SetChannelOrder)(
					AEGP_RenderOptionsH optionsH,			/* <> */
					AEGP_ChannelOrder	channel_order);		/* >> */

	SPAPI A_Err (*AEGP_GetChannelOrder)(
					AEGP_RenderOptionsH optionsH,			/* >> */
					AEGP_ChannelOrder	*channelP);			/* << */

	SPAPI A_Err (*AEGP_GetRenderGuideLayers)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					A_Boolean			*will_renderPB);	/* << */

	SPAPI A_Err (*AEGP_SetRenderGuideLayers)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					A_Boolean			render_themB);		/* >> */

} AEGP_RenderOptionsSuite3;


#define	kAEGPRenderOptionsSuite					"AEGP Render Options Suite"
#define	kAEGPRenderOptionsSuiteVersion2			2 /* frozen in AE 7.0 */

typedef struct {
	// fills out
	// Time to 0
	// Time step to the frame duration
	// field render to none
	// depth is best resolution of item
	SPAPI A_Err (*AEGP_NewFromItem)(
					AEGP_PluginID		plugin_id,			/* >> */
					AEGP_ItemH			itemH,				/* >> */
					AEGP_RenderOptionsH	*optionsPH);		/* << */

	SPAPI A_Err (*AEGP_Duplicate)(
					AEGP_PluginID		plugin_id,			/* >> */
					AEGP_RenderOptionsH	optionsH,			/* >> */
					AEGP_RenderOptionsH	*copyPH);			/* << */

	SPAPI A_Err (*AEGP_Dispose)(
					AEGP_RenderOptionsH	optionsH);			/* >> */

	SPAPI A_Err (*AEGP_SetTime)(							/* the render time */
					AEGP_RenderOptionsH	optionsH,			/* <> */
					A_Time				time);				/* >> */

	SPAPI A_Err (*AEGP_GetTime)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					A_Time				*timeP);			/* << */

	SPAPI A_Err (*AEGP_SetTimeStep)(						/* duration of the frame; important for motion blur. */
					AEGP_RenderOptionsH	optionsH,			/* <> */
					A_Time				time_step);			/* >> */

	SPAPI A_Err (*AEGP_GetTimeStep)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					A_Time				*timePT);			/* << */

	SPAPI A_Err (*AEGP_SetFieldRender)(						/* How fields are to be handled. */
					AEGP_RenderOptionsH	optionsH,			/* <> */
					PF_Field			field_render);		/* >> */

	SPAPI A_Err (*AEGP_GetFieldRender)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					PF_Field			*field_renderP);	/* << */


	SPAPI A_Err (*AEGP_SetWorldType)(
					AEGP_RenderOptionsH	optionsH,			/* <> */
					AEGP_WorldType		type);				/* >> */

	SPAPI A_Err (*AEGP_GetWorldType)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					AEGP_WorldType		*typeP);			/* << */


	// 1 == 100%
	// 2 == 50%
	// ...
	SPAPI A_Err (*AEGP_SetDownsampleFactor)(
					AEGP_RenderOptionsH	optionsH,			/* <> */
					A_short		x,							/* >> */
					A_short		y);							/* >> */

	SPAPI A_Err (*AEGP_GetDownsampleFactor)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					A_short				*xP,				/* >> */
					A_short				*yP);				/* << */

	SPAPI A_Err	(*AEGP_SetRegionOfInterest)(
					AEGP_RenderOptionsH	optionsH,			/* <> */
					const A_LRect		*roiP);				/* >>  {0,0,0,0} for all*/

	SPAPI A_Err (*AEGP_GetRegionOfInterest)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					A_LRect				*roiP);				/* << */

	SPAPI A_Err	(*AEGP_SetMatteMode)(
					AEGP_RenderOptionsH	optionsH,			/* <> */
					AEGP_MatteMode		mode);				/* >> */

	SPAPI A_Err (*AEGP_GetMatteMode)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					AEGP_MatteMode		*modeP);			/* << */

	SPAPI A_Err	(*AEGP_SetChannelOrder)(
					AEGP_RenderOptionsH optionsH,			/* <> */
					AEGP_ChannelOrder	channel_order);		/* >> */

	SPAPI A_Err (*AEGP_GetChannelOrder)(
					AEGP_RenderOptionsH optionsH,			/* >> */
					AEGP_ChannelOrder	*channelP);			/* << */
} AEGP_RenderOptionsSuite2;


#define	kAEGPRenderOptionsSuite					"AEGP Render Options Suite"
#define	kAEGPRenderOptionsSuiteVersion1			1 /* frozen in AE 5.5.1 */

typedef struct {
	// fills out
	// Time to 0
	// Time step to the frame duration
	// field render to none
	// depth is best resolution of item
	SPAPI A_Err (*AEGP_NewFromItem)(
					AEGP_PluginID		plugin_id,			/* >> */
					AEGP_ItemH			itemH,				/* >> */
					AEGP_RenderOptionsH	*optionsPH);		/* << */

	SPAPI A_Err (*AEGP_Duplicate)(
					AEGP_PluginID		plugin_id,			/* >> */
					AEGP_RenderOptionsH	optionsH,			/* >> */
					AEGP_RenderOptionsH	*copyPH);			/* << */

	SPAPI A_Err (*AEGP_Dispose)(
					AEGP_RenderOptionsH	optionsH);			/* >> */

	SPAPI A_Err (*AEGP_SetTime)(							/* the render time */
					AEGP_RenderOptionsH	optionsH,			/* <> */
					A_Time				time);				/* >> */

	SPAPI A_Err (*AEGP_GetTime)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					A_Time				*timeP);			/* << */

	SPAPI A_Err (*AEGP_SetTimeStep)(						/* duration of the frame; important for motion blur. */
					AEGP_RenderOptionsH	optionsH,			/* <> */
					A_Time				time_step);			/* >> */

	SPAPI A_Err (*AEGP_GetTimeStep)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					A_Time				*timePT);			/* << */

	SPAPI A_Err (*AEGP_SetFieldRender)(						/* How fields are to be handled. */
					AEGP_RenderOptionsH	optionsH,			/* <> */
					PF_Field			field_render);		/* >> */

	SPAPI A_Err (*AEGP_GetFieldRender)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					PF_Field			*field_renderP);	/* << */


	SPAPI A_Err (*AEGP_SetWorldType)(
					AEGP_RenderOptionsH	optionsH,			/* <> */
					AEGP_WorldType		type);				/* >> */

	SPAPI A_Err (*AEGP_GetWorldType)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					AEGP_WorldType		*typeP);			/* << */


	// 1 == 100%
	// 2 == 50%
	// ...
	SPAPI A_Err (*AEGP_SetDownsampleFactor)(
					AEGP_RenderOptionsH	optionsH,			/* <> */
					A_short		x,							/* >> */
					A_short		y);							/* >> */

	SPAPI A_Err (*AEGP_GetDownsampleFactor)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					A_short				*xP,				/* >> */
					A_short				*yP);				/* << */

	SPAPI A_Err	(*AEGP_SetRegionOfInterest)(
					AEGP_RenderOptionsH	optionsH,			/* <> */
					const A_LRect		*roiP);				/* >>  {0,0,0,0} for all*/

	SPAPI A_Err (*AEGP_GetRegionOfInterest)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					A_LRect				*roiP);				/* << */

	SPAPI A_Err	(*AEGP_SetMatteMode)(
					AEGP_RenderOptionsH	optionsH,			/* <> */
					AEGP_MatteMode		mode);				/* >> */

	SPAPI A_Err (*AEGP_GetMatteMode)(
					AEGP_RenderOptionsH	optionsH,			/* >> */
					AEGP_MatteMode		*modeP);			/* << */

} AEGP_RenderOptionsSuite1;




#define	kAEGPLayerRenderOptionsSuite					"AEGP Layer Render Options Suite"
#define	kAEGPLayerRenderOptionsSuiteVersion1			1 /* frozen in 13.0 */

typedef struct {
	// optionsPH must be disposed by calling code
	//
	// fills out
	// Time to the layer's current time
	// Time step to layer's frame duration
	// ROI to the layer's nominal bounds
	// EffectsToRender to "all"
	SPAPI A_Err (*AEGP_NewFromLayer)(
					AEGP_PluginID				plugin_id,		/* >> */
					AEGP_LayerH					layerH,			/* >> */
					AEGP_LayerRenderOptionsH	*optionsPH);	/* << */

	// optionsPH must be disposed by calling code
	// like AEGP_NewFromLayer, but sets EffectsToRender to be the index fof effectH
	SPAPI A_Err (*AEGP_NewFromUpstreamOfEffect)(
					AEGP_PluginID				plugin_id,		/* >> */
					AEGP_EffectRefH				effectH,		/* >> */
					AEGP_LayerRenderOptionsH	*optionsPH);	/* << */

	// copyPH must be disposed by calling code
	SPAPI A_Err (*AEGP_Duplicate)(
					AEGP_PluginID				plugin_id,		/* >> */
					AEGP_LayerRenderOptionsH	optionsH,		/* >> */
					AEGP_LayerRenderOptionsH	*copyPH);		/* << */

	SPAPI A_Err (*AEGP_Dispose)(
					AEGP_LayerRenderOptionsH	optionsH);		/* >> */

	SPAPI A_Err (*AEGP_SetTime)(								/* the render time */
					AEGP_LayerRenderOptionsH	optionsH,		/* <> */
					A_Time						time);			/* >> */

	SPAPI A_Err (*AEGP_GetTime)(
					AEGP_LayerRenderOptionsH	optionsH,		/* >> */
					A_Time				*timeP);				/* << */

	SPAPI A_Err (*AEGP_SetTimeStep)(							/* duration of the frame; important for motion blur. */
					AEGP_LayerRenderOptionsH	optionsH,		/* <> */
					A_Time						time_step);		/* >> */

	SPAPI A_Err (*AEGP_GetTimeStep)(
					AEGP_LayerRenderOptionsH	optionsH,		/* >> */
					A_Time						*timePT);		/* << */

	SPAPI A_Err (*AEGP_SetWorldType)(
					AEGP_LayerRenderOptionsH	optionsH,		/* <> */
					AEGP_WorldType				type);			/* >> */

	SPAPI A_Err (*AEGP_GetWorldType)(
					AEGP_LayerRenderOptionsH	optionsH,		/* >> */
					AEGP_WorldType				*typeP);		/* << */

	// 1 == 100%
	// 2 == 50%
	// ...
	SPAPI A_Err (*AEGP_SetDownsampleFactor)(
					AEGP_LayerRenderOptionsH	optionsH,		/* <> */
					A_short						x,				/* >> */
					A_short						y);				/* >> */

	SPAPI A_Err (*AEGP_GetDownsampleFactor)(
					AEGP_LayerRenderOptionsH	optionsH,		/* >> */
					A_short						*xP,			/* >> */
					A_short						*yP);			/* << */

	SPAPI A_Err	(*AEGP_SetMatteMode)(
					AEGP_LayerRenderOptionsH	optionsH,		/* <> */
					AEGP_MatteMode				mode);			/* >> */

	SPAPI A_Err (*AEGP_GetMatteMode)(
					AEGP_LayerRenderOptionsH	optionsH,		/* >> */
					AEGP_MatteMode				*modeP);		/* << */
} AEGP_LayerRenderOptionsSuite1;




#define kAEGPColorSettingsSuiteVersion1	1	// frozen in AE 7.0

typedef struct AEGP_ColorSettingsSuite1 {

	 SPAPI A_Err (*AEGP_GetBlendingTables)(
		PR_RenderContextH 		render_contextH,
		PF_EffectBlendingTables *blending_tables);

} AEGP_ColorSettingsSuite1;

#define kAEGPColorSettingsSuiteVersion2	3	// frozen in AE 8.0

typedef struct AEGP_ColorSettingsSuite2 {

	 SPAPI	A_Err (*AEGP_GetBlendingTables)(
		PR_RenderContextH 		render_contextH,
		PF_EffectBlendingTables *blending_tables);

	SPAPI	A_Err (*AEGP_DoesViewHaveColorSpaceXform)(
		AEGP_ItemViewP	viewP,			// >>
		A_Boolean		*has_xformPB);	// <<

	SPAPI	A_Err (*AEGP_XformWorkingToViewColorSpace)(
		AEGP_ItemViewP	viewP,		// >>
		AEGP_WorldH		srcH,		// in
		AEGP_WorldH		dstH);		// out; must be the same size (can be the same as source)

	SPAPI	A_Err (*AEGP_GetNewWorkingSpaceColorProfile)(
		AEGP_PluginID		aegp_plugin_id,					// >>
		AEGP_CompH			compH,							// >>
		AEGP_ColorProfileP	*color_profilePP);				// << caller must dispose with AEGP_DisposeColorProfile

	SPAPI	A_Err (*AEGP_GetNewColorProfileFromICCProfile)(
		AEGP_PluginID		aegp_plugin_id,		// >>
		A_long				icc_sizeL,			// >>	icc profile size
		const	void		*icc_dataPV,		// >>	icc profile
		AEGP_ColorProfileP	*color_profilePP);	// <<	builds AEGP_ColorProfile from icc profile; caller must dispose with AEGP_DisposeColorProfile

	SPAPI	A_Err (*AEGP_GetNewICCProfileFromColorProfile)(
		AEGP_PluginID			aegp_plugin_id,		// >>
		AEGP_ConstColorProfileP	color_profileP,		// >>
		AEGP_MemHandle			*icc_profilePH);	// <<	extract icc profile from AEGP_ColorProfile; caller must dispose with AEGP_FreeMemHandle

	SPAPI	A_Err (*AEGP_GetNewColorProfileDescription)(
		AEGP_PluginID			aegp_plugin_id,		// >>
		AEGP_ConstColorProfileP	color_profileP,		// >>
		AEGP_MemHandle			*unicode_descPH);	// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle

	SPAPI	A_Err (*AEGP_DisposeColorProfile)(
		AEGP_ColorProfileP	color_profileP);	// >>

	SPAPI	A_Err (*AEGP_GetColorProfileApproximateGamma)(
		AEGP_ConstColorProfileP	color_profileP,		// >>
		A_FpShort				*approx_gammaP);	// <<

	SPAPI	A_Err (*AEGP_IsRGBColorProfile)(
		AEGP_ConstColorProfileP	color_profileP,		// <<
		A_Boolean				*is_rgbPB);			// >>


} AEGP_ColorSettingsSuite2;

#define kAEGPColorSettingsSuiteVersion3	4	// frozen in AE 16.1; adding an API to set working color space

typedef struct AEGP_ColorSettingsSuite3 {

	 SPAPI	A_Err (*AEGP_GetBlendingTables)(
		PR_RenderContextH 		render_contextH,
		PF_EffectBlendingTables *blending_tables);
		
	SPAPI	A_Err (*AEGP_DoesViewHaveColorSpaceXform)(
		AEGP_ItemViewP	viewP,			// >>
		A_Boolean		*has_xformPB);	// <<
		
	SPAPI	A_Err (*AEGP_XformWorkingToViewColorSpace)(
		AEGP_ItemViewP	viewP,		// >>
		AEGP_WorldH		srcH,		// in
		AEGP_WorldH		dstH);		// out; must be the same size (can be the same as source)
		
	SPAPI	A_Err (*AEGP_GetNewWorkingSpaceColorProfile)(
		AEGP_PluginID		aegp_plugin_id,					// >>
		AEGP_CompH			compH,							// >>
		AEGP_ColorProfileP	*color_profilePP);				// << caller must dispose with AEGP_DisposeColorProfile
		
	SPAPI	A_Err (*AEGP_GetNewColorProfileFromICCProfile)(
		AEGP_PluginID		aegp_plugin_id,		// >>
		A_long				icc_sizeL,			// >>	icc profile size
		const	void		*icc_dataPV,		// >>	icc profile
		AEGP_ColorProfileP	*color_profilePP);	// <<	builds AEGP_ColorProfile from icc profile; caller must dispose with AEGP_DisposeColorProfile
		
	SPAPI	A_Err (*AEGP_GetNewICCProfileFromColorProfile)(
		AEGP_PluginID			aegp_plugin_id,		// >>
		AEGP_ConstColorProfileP	color_profileP,		// >>
		AEGP_MemHandle			*icc_profilePH);	// <<	extract icc profile from AEGP_ColorProfile; caller must dispose with AEGP_FreeMemHandle
		
	SPAPI	A_Err (*AEGP_GetNewColorProfileDescription)(
		AEGP_PluginID			aegp_plugin_id,		// >>
		AEGP_ConstColorProfileP	color_profileP,		// >>
		AEGP_MemHandle			*unicode_descPH);	// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle
		
	SPAPI	A_Err (*AEGP_DisposeColorProfile)(
		AEGP_ColorProfileP	color_profileP);	// >>
		
	SPAPI	A_Err (*AEGP_GetColorProfileApproximateGamma)(
		AEGP_ConstColorProfileP	color_profileP,		// >>
		A_FpShort				*approx_gammaP);	// <<
		
	SPAPI	A_Err (*AEGP_IsRGBColorProfile)(
		AEGP_ConstColorProfileP	color_profileP,		// <<
		A_Boolean				*is_rgbPB);			// >>
	
	SPAPI	A_Err (*AEGP_SetWorkingColorSpace)(
		AEGP_PluginID			aegp_plugin_id,
		AEGP_CompH				compH,				// >>
		AEGP_ConstColorProfileP	color_profileP);	// >>
} AEGP_ColorSettingsSuite3;

#define kAEGPColorSettingsSuiteVersion4	5	// frozen in AE 22.6; get OCIO Color information
typedef struct AEGP_ColorSettingsSuite4 {

	 SPAPI	A_Err (*AEGP_GetBlendingTables)(
		PR_RenderContextH 		render_contextH,
		PF_EffectBlendingTables *blending_tables);
		
	SPAPI	A_Err (*AEGP_DoesViewHaveColorSpaceXform)(
		AEGP_ItemViewP	viewP,			// >>
		A_Boolean		*has_xformPB);	// <<
		
	SPAPI	A_Err (*AEGP_XformWorkingToViewColorSpace)(
		AEGP_ItemViewP	viewP,		// >>
		AEGP_WorldH		srcH,		// in
		AEGP_WorldH		dstH);		// out; must be the same size (can be the same as source)
		
	SPAPI	A_Err (*AEGP_GetNewWorkingSpaceColorProfile)(
		AEGP_PluginID		aegp_plugin_id,					// >>
		AEGP_CompH			compH,							// >>
		AEGP_ColorProfileP	*color_profilePP);				// << caller must dispose with AEGP_DisposeColorProfile
		
	SPAPI	A_Err (*AEGP_GetNewColorProfileFromICCProfile)(
		AEGP_PluginID		aegp_plugin_id,		// >>
		A_long				icc_sizeL,			// >>	icc profile size
		const	void		*icc_dataPV,		// >>	icc profile
		AEGP_ColorProfileP	*color_profilePP);	// <<	builds AEGP_ColorProfile from icc profile; caller must dispose with AEGP_DisposeColorProfile
		
	SPAPI	A_Err (*AEGP_GetNewICCProfileFromColorProfile)(
		AEGP_PluginID			aegp_plugin_id,		// >>
		AEGP_ConstColorProfileP	color_profileP,		// >>
		AEGP_MemHandle			*icc_profilePH);	// <<	extract icc profile from AEGP_ColorProfile; caller must dispose with AEGP_FreeMemHandle
		
	SPAPI	A_Err (*AEGP_GetNewColorProfileDescription)(
		AEGP_PluginID			aegp_plugin_id,		// >>
		AEGP_ConstColorProfileP	color_profileP,		// >>
		AEGP_MemHandle			*unicode_descPH);	// <<	handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle
		
	SPAPI	A_Err (*AEGP_DisposeColorProfile)(
		AEGP_ColorProfileP	color_profileP);	// >>
		
	SPAPI	A_Err (*AEGP_GetColorProfileApproximateGamma)(
		AEGP_ConstColorProfileP	color_profileP,		// >>
		A_FpShort				*approx_gammaP);	// <<
		
	SPAPI	A_Err (*AEGP_IsRGBColorProfile)(
		AEGP_ConstColorProfileP	color_profileP,		// <<
		A_Boolean				*is_rgbPB);			// >>
	
	SPAPI	A_Err (*AEGP_SetWorkingColorSpace)(
		AEGP_PluginID			aegp_plugin_id,
		AEGP_CompH				compH,				// >>
		AEGP_ConstColorProfileP	color_profileP);	// >>
		
	SPAPI	A_Err (*AEGP_IsOCIOColorManagementUsed)(
		AEGP_PluginID			aegp_plugin_id,					// >>
		A_Boolean				*is_OCIOColorManagementUsedPB);	// <<

	SPAPI	A_Err (*AEGP_GetOCIOConfigurationFile)(
		AEGP_PluginID			aegp_plugin_id,		// >>
		AEGP_MemHandle			*config_filePH);	// <<
} AEGP_ColorSettingsSuite4;

#define kAEGPMarkerSuiteVersion1		1 /* frozen in AE 8.0 */

typedef struct AEGP_MarkerSuite1 {

	SPAPI A_Err	(*AEGP_NewMarker)(
		AEGP_MarkerValP			*markerPP);

	SPAPI A_Err	(*AEGP_DisposeMarker)(
		AEGP_MarkerValP			markerP);

	SPAPI A_Err	(*AEGP_DuplicateMarker)(
		AEGP_MarkerValP			markerP, 			// >>
		AEGP_MarkerValP			*new_markerP);		// <<

	SPAPI A_Err	(*AEGP_SetMarkerFlag)(
		AEGP_MarkerValP			markerP,			// >>
		AEGP_MarkerFlagType		flagType,			// >>
		A_Boolean				valueB);			// >>

	SPAPI A_Err	(*AEGP_GetMarkerFlag)(
		AEGP_ConstMarkerValP	markerP,			// >>
		AEGP_MarkerFlagType		flagType,			// >>
		A_Boolean				*valueBP);			// <<

	SPAPI A_Err	(*AEGP_GetMarkerString)(
		AEGP_PluginID			aegp_plugin_id,		/* >> */
		AEGP_ConstMarkerValP	markerP,			// >>
		AEGP_MarkerStringType	strType,			// >>
		AEGP_MemHandle			*unicodePH);		/* << handle of A_u_short, UTF16, NULL terminated, must be disposed with AEGP_FreeMemHandle */

	SPAPI A_Err	(*AEGP_SetMarkerString)(
		AEGP_MarkerValP			markerP,			// <<>>
		AEGP_MarkerStringType	strType,			// >>
		const A_u_short			*unicodeP,			// >>
		A_long					lengthL);			// >> number of characters

	SPAPI A_Err	(*AEGP_CountCuePointParams)(
		AEGP_ConstMarkerValP	markerP,			// >>
		A_long					*paramsLP);			// <<

	SPAPI A_Err	(*AEGP_GetIndCuePointParam)(
		AEGP_PluginID			aegp_plugin_id,		// >>
		AEGP_ConstMarkerValP	markerP,			// >>
		A_long					param_indexL,		// >> must be between 0 and count - 1. else error
		AEGP_MemHandle			*unicodeKeyPH,		// << handle of A_u_short, UTF16, NULL terminated, must be disposed with AEGP_FreeMemHandle
		AEGP_MemHandle			*unicodeValuePH);	// << handle of A_u_short, UTF16, NULL terminated, must be disposed with AEGP_FreeMemHandle

	SPAPI A_Err	(*AEGP_SetIndCuePointParam)(
		AEGP_MarkerValP			markerP,			// >>
		A_long					param_indexL,		// must be between 0 and count - 1. else error
		const A_u_short			*unicodeKeyP,		// >> UTF16
		A_long					key_lengthL,		// >> number of characters
		const A_u_short			*unicodeValueP,		// >> UTF16
		A_long					value_lengthL);		// >> number of characters

	//	this call is followed by AEGP_SetIndCuePointParam() to actually set the data
	//	the ONLY thing this function does is reserve the space for the param, at the provided index
	SPAPI A_Err	(*AEGP_InsertCuePointParam)(
		AEGP_MarkerValP			markerP,			// >>
		A_long					param_indexL);		// must be between 0 and count. else error

	SPAPI A_Err	(*AEGP_DeleteIndCuePointParam)(
		AEGP_MarkerValP			markerP,			// >>
		A_long					param_indexL);		// must be between 0 and count - 1. else error

} AEGP_MarkerSuite1;

#define kAEGPMarkerSuiteVersion2		2 /* frozen in AE 9.0 */

typedef struct AEGP_MarkerSuite2 {

	SPAPI A_Err	(*AEGP_NewMarker)(
						AEGP_MarkerValP			*markerPP);

	SPAPI A_Err	(*AEGP_DisposeMarker)(
						AEGP_MarkerValP			markerP);

	SPAPI A_Err	(*AEGP_DuplicateMarker)(
						AEGP_MarkerValP			markerP, 			// >>
						AEGP_MarkerValP			*new_markerP);		// <<

	SPAPI A_Err	(*AEGP_SetMarkerFlag)(
						AEGP_MarkerValP			markerP,			// >>
						AEGP_MarkerFlagType		flagType,			// >>
						A_Boolean				valueB);			// >>

	SPAPI A_Err	(*AEGP_GetMarkerFlag)(
						AEGP_ConstMarkerValP	markerP,			// >>
						AEGP_MarkerFlagType		flagType,			// >>
							A_Boolean				*valueBP);			// <<

	SPAPI A_Err	(*AEGP_GetMarkerString)(
						AEGP_PluginID			aegp_plugin_id,		/* >> */
						AEGP_ConstMarkerValP	markerP,			// >>
						AEGP_MarkerStringType	strType,			// >>
						AEGP_MemHandle			*unicodePH);		/* << handle of A_u_short, UTF16, NULL terminated, must be disposed with AEGP_FreeMemHandle */

	SPAPI A_Err	(*AEGP_SetMarkerString)(
						AEGP_MarkerValP			markerP,			// <<>>
						AEGP_MarkerStringType	strType,			// >>
						const A_u_short			*unicodeP,			// >>
						A_long					lengthL);			// >> number of characters

	SPAPI A_Err	(*AEGP_CountCuePointParams)(
						AEGP_ConstMarkerValP	markerP,			// >>
						A_long					*paramsLP);			// <<

	SPAPI A_Err	(*AEGP_GetIndCuePointParam)(
						AEGP_PluginID			aegp_plugin_id,		// >>
						AEGP_ConstMarkerValP	markerP,			// >>
						A_long					param_indexL,		// >> must be between 0 and count - 1. else error
						AEGP_MemHandle			*unicodeKeyPH,		// << handle of A_u_short, UTF16, NULL terminated, must be disposed with AEGP_FreeMemHandle
						AEGP_MemHandle			*unicodeValuePH);	// << handle of A_u_short, UTF16, NULL terminated, must be disposed with AEGP_FreeMemHandle

	SPAPI A_Err	(*AEGP_SetIndCuePointParam)(
						AEGP_MarkerValP			markerP,			// >>
						A_long					param_indexL,		// must be between 0 and count - 1. else error
						const A_u_short			*unicodeKeyP,		// >> UTF16
						A_long					key_lengthL,		// >> number of characters
						const A_u_short			*unicodeValueP,		// >> UTF16
						A_long					value_lengthL);		// >> number of characters

	//	this call is followed by AEGP_SetIndCuePointParam() to actually set the data
	//	the ONLY thing this function does is reserve the space for the param, at the provided index
	SPAPI A_Err	(*AEGP_InsertCuePointParam)(
						AEGP_MarkerValP			markerP,			// >>
						A_long					param_indexL);		// must be between 0 and count. else error

	SPAPI A_Err	(*AEGP_DeleteIndCuePointParam)(
						AEGP_MarkerValP			markerP,			// >>
						A_long					param_indexL);		// must be between 0 and count - 1. else error

	SPAPI A_Err	(*AEGP_SetMarkerDuration)(
						AEGP_MarkerValP			markerP,			// >>
						const A_Time			*durationPT);		// >>


	SPAPI A_Err	(*AEGP_GetMarkerDuration)(
						AEGP_ConstMarkerValP	markerP,			// >>
						A_Time					*durationPT);		// <<


} AEGP_MarkerSuite2;

#define kAEGPProjSuiteVersion5		8	/* frozen in AE 10.0 */

typedef struct AEGP_ProjSuite5 {

	SPAPI A_Err	(*AEGP_GetNumProjects)(									/* will always (in 5.0) return 1 if project is open */
		A_long				*num_projPL);				/* << */

	SPAPI A_Err	(*AEGP_GetProjectByIndex)(
		A_long				proj_indexL,				/* >> */
		AEGP_ProjectH		*projPH);					/* << */

	SPAPI A_Err	(*AEGP_GetProjectName)(
		AEGP_ProjectH		projH,						/* >> */
		A_char 				*nameZ);					/* << space for A_char[AEGP_MAX_PROJ_NAME_SIZE] */

	SPAPI A_Err	(*AEGP_GetProjectPath)(
		AEGP_ProjectH		projH,						/* >> */
		AEGP_MemHandle		*unicode_pathPH);			// << empty string if no file. handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle

	SPAPI A_Err	(*AEGP_GetProjectRootFolder)(
		AEGP_ProjectH		projH,						/* >> */
		AEGP_ItemH			*root_folderPH);			/* << */

	SPAPI A_Err (*AEGP_SaveProjectToPath)(
		AEGP_ProjectH		projH,						/* >> */
		const A_UTF16Char	*pathZ);					// >> null terminated unicode path with platform separators

	SPAPI A_Err (*AEGP_GetProjectTimeDisplay)(
		AEGP_ProjectH		projH,						/* >> */
		AEGP_TimeDisplay2	*time_displayP);			/* << */

	SPAPI A_Err (*AEGP_SetProjectTimeDisplay)(							/* UNDOABLE */
		AEGP_ProjectH			projH,					/* <> */
		const AEGP_TimeDisplay2	*time_displayP);		/* >> */

	SPAPI A_Err (*AEGP_ProjectIsDirty)(
		AEGP_ProjectH		projH,						/* >> */
		A_Boolean			*is_dirtyPB);				/* << */

	SPAPI A_Err (*AEGP_SaveProjectAs)(
		AEGP_ProjectH		projH,						/* >> */
		const A_UTF16Char	*pathZ);					// >> null terminated unicode path with platform separators

	SPAPI A_Err (*AEGP_NewProject)(
		AEGP_ProjectH	*new_projectPH);				/* << WARNING: Will close any open projects! */

	// WARNING: Will close any open projects!
	SPAPI A_Err (*AEGP_OpenProjectFromPath)(
		const A_UTF16Char	*pathZ,						// >> null terminated unicode path with platform separators
		AEGP_ProjectH		*projectPH);				/* << */

	SPAPI A_Err	(*AEGP_GetProjectBitDepth)(
		AEGP_ProjectH		projectH,					/* >> */
		AEGP_ProjBitDepth	*bit_depthP);				/* << */

	SPAPI A_Err	(*AEGP_SetProjectBitDepth)(								/* UNDOABLE */
		AEGP_ProjectH		projectH,					/* >> */
		AEGP_ProjBitDepth	bit_depth);					/* >> */

} AEGP_ProjSuite5;

#define	kAEGPPersistentDataSuiteVersion3	3 /* frozen in AE 10.0 */

typedef struct {
	// get a handle of the application blob,
	// modifying this will modify the application
	SPAPI A_Err (*AEGP_GetApplicationBlob)(
		AEGP_PersistentBlobH	*blobPH);			/* >> */

	// section and value key management
	SPAPI A_Err (*AEGP_GetNumSections)(
		AEGP_PersistentBlobH	blobH,				/* >> */
		A_long					*num_sectionPL);	/* << */

	SPAPI A_Err (*AEGP_GetSectionKeyByIndex)(
		AEGP_PersistentBlobH	blobH,				/* >> */
		A_long					section_index,		/* >> */
		A_long					max_section_size,	/* >> */
		A_char					*section_keyZ);		/* << */

	SPAPI A_Err	(*AEGP_DoesKeyExist)(
		AEGP_PersistentBlobH	blobH,				/* >> */
		const A_char			*section_keyZ,		/* >> */
		const A_char			*value_keyZ,		/* >> */
		A_Boolean				*existsPB);			/* << */

	SPAPI A_Err (*AEGP_GetNumKeys)(
		AEGP_PersistentBlobH	blobH,				/* >> */
		const A_char			*section_keyZ,		/* >> */
		A_long					*num_keysPL);		/* << */

	SPAPI A_Err (*AEGP_GetValueKeyByIndex)(
		AEGP_PersistentBlobH	blobH,				/* >> */
		const A_char			*section_keyZ,		/* >> */
		A_long					key_index,			/* >> */
		A_long					max_key_size,		/* >> */
		A_char					*value_keyZ);		/* << */

	// data access and manipulation

	// For the entry points below, if a given key is not found,
	//	the default value is both written to the blobH and
	//	returned as the value; if no default is provided, a blank value will be written
	//	and returned

	SPAPI A_Err (*AEGP_GetDataHandle)(
		AEGP_PluginID			plugin_id,
		AEGP_PersistentBlobH	blobH,			/* >> */
		const A_char			*section_keyZ,	/* >> */
		const A_char			*value_keyZ,	/* >> */
		AEGP_MemHandle			defaultH0,		/* >> never adopted, NULL means no default data */
		AEGP_MemHandle			*valuePH);		/* << newly allocated, owned by caller, NULL if would be zero sized handle */

	SPAPI A_Err (*AEGP_GetData)(
		AEGP_PersistentBlobH	blobH,			/* >> */
		const A_char			*section_keyZ,	/* >> */
		const A_char			*value_keyZ,	/* >> */
		A_u_long				data_sizeLu,	/* >> bufPV & default must be this big, if pref isn't then the default will be used */
		const void				*defaultPV0,	/* >> NULL means all zeros for default */
		void					*bufPV);		/* << */

	SPAPI A_Err (*AEGP_GetString)(
		AEGP_PersistentBlobH	blobH,					/* >> */
		const A_char			*section_keyZ,			/* >> */
		const A_char			*value_keyZ,			/* >> */
		const A_char			*defaultZ0,				/* >> NULL means '\0' is the default */
		A_u_long				buf_sizeLu,				/* >> size of buffer. Behavior dependent on actual_buf_sizeLu0 */
		A_char					*bufZ,					/* << will be "" if buf_size is too small */
		A_u_long				*actual_buf_sizeLu0);	/* << actual size needed to store the buffer (includes terminating NULL). Pass NULL for error reporting if size mismatch.*/

	SPAPI A_Err (*AEGP_GetLong)(
		AEGP_PersistentBlobH	blobH,			/* >> */
		const A_char			*section_keyZ,	/* >> */
		const A_char			*value_keyZ,	/* >> */
		A_long					defaultL,		/* >> */
		A_long					*valuePL);		/* << */

	SPAPI A_Err	(*AEGP_GetFpLong)(
		AEGP_PersistentBlobH	blobH,			/* >> */
		const A_char			*section_keyZ,	/* >> */
		const A_char			*value_keyZ,	/* >> */
		A_FpLong				defaultF,		/* >> */
		A_FpLong				*valuePF);		/* << */

	// setters
	SPAPI A_Err	(*AEGP_SetDataHandle)(
		AEGP_PersistentBlobH	blobH,			/* >> */
		const A_char			*section_keyZ,	/* >> */
		const A_char			*value_keyZ,	/* >> */
		const AEGP_MemHandle	valueH);		/* >> not adopted */

	SPAPI A_Err	(*AEGP_SetData)(
		AEGP_PersistentBlobH	blobH,			/* >> */
		const A_char			*section_keyZ,	/* >> */
		const A_char			*value_keyZ,	/* >> */
		A_u_long				data_sizeLu,	/* >> */
		const void				*dataPV);		/* >> */

	SPAPI A_Err	(*AEGP_SetString)(
		AEGP_PersistentBlobH	blobH,			/* >> */
		const A_char			*section_keyZ,	/* >> */
		const A_char			*value_keyZ,	/* >> */
		const A_char			*strZ);			/* >> */

	SPAPI A_Err	(*AEGP_SetLong)(
		AEGP_PersistentBlobH	blobH,			/* >> */
		const A_char			*section_keyZ,	/* >> */
		const A_char			*value_keyZ,	/* >> */
		A_long					valueL);		/* >> */


	SPAPI A_Err	(*AEGP_SetFpLong)(
		AEGP_PersistentBlobH	blobH,			/* >> */
		const A_char			*section_keyZ,	/* >> */
		const A_char			*value_keyZ,	/* >> */
		A_FpLong				valueF);		/* >> */

	SPAPI A_Err	(*AEGP_DeleteEntry)(							/* no error if entry not found */
		AEGP_PersistentBlobH	blobH,			/* >> */
		const A_char			*section_keyZ,	/* >> */
		const A_char			*value_keyZ);	/* >> */

	SPAPI A_Err	(*AEGP_GetPrefsDirectory)(
		AEGP_MemHandle			*unicode_pathPH);		// << empty string if no file. handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle

} AEGP_PersistentDataSuite3;

#define kAEGPIterateSuite				"AEGP Iterate Suite"
#define kAEGPIterateSuiteVersion1		1 /* frozen in AE 5.0 */

typedef struct AEGP_IterateSuite1 {

	SPAPI A_Err(*AEGP_GetNumThreads)(
		A_long* num_threadsPL);


	SPAPI A_Err(*AEGP_IterateGeneric)(
		A_long			iterationsL,						/* >> */		// can be PF_Iterations_ONCE_PER_PROCESSOR
		void* refconPV,							/* >> */
		A_Err(*fn_func)(void* refconPV,		/* >> */
			A_long 	thread_indexL,	/* >> */
			A_long 	i,				/* >> */
			A_long 	iterationsL));	/* >> */

} AEGP_IterateSuite1;

#define kAEGPIOInSuite			"AEGP IO In Suite"
#define kAEGPIOInSuiteVersion4	5 /* frozen in AE 10 */

typedef struct AEGP_IOInSuite4 {
	
	SPAPI A_Err	(*AEGP_GetInSpecOptionsHandle)(
											   AEIO_InSpecH	inH,					/* >> */
											   void			**optionsPPV);			/* << */
	
	SPAPI A_Err	(*AEGP_SetInSpecOptionsHandle)(
											   AEIO_InSpecH	inH,					/* >> */
											   void			*optionsPV,				/* >> */
											   void			**old_optionsPPV);		/* << */
	
	SPAPI A_Err	(*AEGP_GetInSpecFilePath)(
										  AEIO_InSpecH	inH,					/* >> */
										  AEGP_MemHandle	*unicode_pathPH);		// << handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle
	
	SPAPI A_Err	(*AEGP_GetInSpecNativeFPS)(
										   AEIO_InSpecH	inH,					/* >> */
										   A_Fixed			*native_fpsP);			/* << */
	
	SPAPI A_Err	(*AEGP_SetInSpecNativeFPS)(
										   AEIO_InSpecH	inH,					/* >> */
										   A_Fixed			native_fps);			/* >> */
	
	SPAPI A_Err	(*AEGP_GetInSpecDepth)(
									   AEIO_InSpecH	inH,					/* >> */
									   A_short			*depthPS);				/* << */
	
	SPAPI A_Err	(*AEGP_SetInSpecDepth)(
									   AEIO_InSpecH	inH,					/* >> */
									   A_short			depthS);				/* >> */
	
	SPAPI A_Err	(*AEGP_GetInSpecSize)(
									  AEIO_InSpecH	inH,					/* >> */
									  AEIO_FileSize	*sizePL);				/* << */
	
	SPAPI A_Err	(*AEGP_SetInSpecSize)(
									  AEIO_InSpecH	inH,					/* >> */
									  AEIO_FileSize	sizeL);					/* >> */
	
	SPAPI A_Err	(*AEGP_GetInSpecInterlaceLabel)(
												AEIO_InSpecH		inH,				/* >> */
												FIEL_Label	 		*interlaceP);		/* << */
	
	SPAPI A_Err	(*AEGP_SetInSpecInterlaceLabel)(
												AEIO_InSpecH		inH,				/* >> */
												const FIEL_Label	*interlaceP);		/* << */
	
	SPAPI A_Err	(*AEGP_GetInSpecAlphaLabel)(
											AEIO_InSpecH			inH,			/* >> */
											AEIO_AlphaLabel			*alphaP);		/* << */
	
	SPAPI A_Err	(*AEGP_SetInSpecAlphaLabel)(
											AEIO_InSpecH			inH,			/* >> */
											const AEIO_AlphaLabel	*alphaP);		/* << */
	
	SPAPI A_Err	(*AEGP_GetInSpecDuration)(
										  AEIO_InSpecH	inH,					/* >> */
										  A_Time			*durationP);			/* << */
	
	SPAPI A_Err	(*AEGP_SetInSpecDuration)(
										  AEIO_InSpecH	inH,					/* >> */
										  const A_Time	*durationP);			/* >> */
	
	SPAPI A_Err	(*AEGP_GetInSpecDimensions)(
											AEIO_InSpecH	inH,					/* >> */
											A_long			*widthPL0,				/* << */
											A_long			*heightPL0);
	
	SPAPI A_Err	(*AEGP_SetInSpecDimensions)(
											AEIO_InSpecH	inH,					/* >> */
											A_long			widthL,					/* >> */
											A_long			heightL);				/* >> */
	
	SPAPI A_Err	(*AEGP_InSpecGetRationalDimensions)(
													AEIO_InSpecH				inH,		/* >> */
													const AEIO_RationalScale	*rs0,		/* << */
													A_long						*width0,	/* << */
													A_long						*height0,	/* << */
													A_Rect						*r0);		/* << */
	
	SPAPI A_Err	(*AEGP_GetInSpecHSF)(
									 AEIO_InSpecH	inH,					/* >> */
									 A_Ratio			*hsfP);					/* << */
	
	SPAPI A_Err	(*AEGP_SetInSpecHSF)(
									 AEIO_InSpecH	inH,					/* >> */
									 const A_Ratio	*hsfP);					/* >> */
	
	SPAPI A_Err	(*AEGP_GetInSpecSoundRate)(
										   AEIO_InSpecH	inH,					/* >> */
										   A_FpLong		*ratePF);				/* << */
	
	SPAPI A_Err	(*AEGP_SetInSpecSoundRate)(
										   AEIO_InSpecH	inH,					/* >> */
										   A_FpLong		rateF);					/* >> */
	
	SPAPI A_Err	(*AEGP_GetInSpecSoundEncoding)(
											   AEIO_InSpecH		inH,				/* >> */
											   AEIO_SndEncoding	*encodingP);		/* << */
	
	SPAPI A_Err	(*AEGP_SetInSpecSoundEncoding)(
											   AEIO_InSpecH		inH,				/* >> */
											   AEIO_SndEncoding	encoding);			/* >> */
	
	SPAPI A_Err	(*AEGP_GetInSpecSoundSampleSize)(
												 AEIO_InSpecH		inH,				/* >> */
												 AEIO_SndSampleSize	*bytes_per_sampleP);/* << */
	
	SPAPI A_Err	(*AEGP_SetInSpecSoundSampleSize)(
												 AEIO_InSpecH		inH,				/* >> */
												 AEIO_SndSampleSize	bytes_per_sample);	/* >> */
	
	SPAPI A_Err	(*AEGP_GetInSpecSoundChannels)(
											   AEIO_InSpecH		inH,				/* >> */
											   AEIO_SndChannels	*num_channelsP);	/* << */
	
	SPAPI A_Err	(*AEGP_SetInSpecSoundChannels)(
											   AEIO_InSpecH		inH,				/* >> */
											   AEIO_SndChannels	num_channels);		/* >> */
	
	SPAPI A_Err	(*AEGP_AddAuxExtMap)(
									 const A_char		*extension,			/* >> */
									 A_long				file_type,			/* >> */
									 A_long				creator);			/* >> */
	
	// In case of RGB data, if there is an embedded icc profile, build AEGP_ColorProfile out of this icc profile using AEGP_GetNewColorProfileFromICCProfile and pass it to
	// AEGP_SetInSpecEmbeddedColorProfile, with profile description set to NULL.
	//
	// In case of non-RGB data, if there is an embedded non-RGB icc profile or you know the color space the data is in, pass its description as a null-terminated unicode string
	// to AEGP_SetInSpecEmbeddedColorProfile, with color profile set to NULL. Doing this disables color management UI that allows user to affect
	// profile choice in the application UI.
	//
	// If you are unpacking non-RGB data directly into working space (to get working space use AEGP_GetNewWorkingSpaceColorProfile), you are done.
	//
	// If you are unpacking non-RGB data into specific RGB color space, you must pass the profile describing this space to AEGP_SetInSpecAssignedColorProfile.
	// Otherwise, your RGB data will be incorrectly interpreted as being in working space.
	//
	// Either color profile or profile description should be NULL in AEGP_SetInSpecEmbeddedColorProfile. You cannot use both.
	SPAPI A_Err (*AEGP_SetInSpecEmbeddedColorProfile)(
													  AEIO_InSpecH			inH,				// <<
													  AEGP_ConstColorProfileP	color_profileP0,	// <<
													  const	A_UTF16Char		*profile_descP0);	// <<	pointer to a null-terminated unicode string
	
	// Assign valid RGB profile to the footage
	SPAPI A_Err (*AEGP_SetInSpecAssignedColorProfile)(
													  AEIO_InSpecH			inH,				// <<
													  AEGP_ConstColorProfileP	color_profileP);	// <<
	
} AEGP_IOInSuite4;

#define kAEGPIOOutSuiteVersion4	7 /* frozen in AE 10.0 */

typedef struct AEGP_IOOutSuite4 {
	SPAPI A_Err	(*AEGP_GetOutSpecOptionsHandle)(
						AEIO_OutSpecH	outH,					/* >> */
						void			**optionsPPV);			/* << */

	SPAPI A_Err	(*AEGP_SetOutSpecOptionsHandle)(
						AEIO_OutSpecH	outH,					/* >> */
						void			*optionsPV,				/* >> */
						void			**old_optionsPPVO);		/* <> */

	SPAPI A_Err	(*AEGP_GetOutSpecFilePath)(
						AEIO_OutSpecH	outH,					/* >> */
						AEGP_MemHandle	*unicode_pathPH,		// << handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle 
						A_Boolean		*file_reservedPB);		/* << If the file is reserved, do not create the file.
																	  Otherwise, multi-machine rendering can fail. 
																	  If true, an empty file has already been created. */

	SPAPI A_Err	(*AEGP_GetOutSpecFPS)(
						AEIO_OutSpecH	outH,					/* >> */
						A_Fixed			*native_fpsP);			/* << */

	SPAPI A_Err	(*AEGP_SetOutSpecNativeFPS)(
						AEIO_OutSpecH	outH,					/* >> */
						A_Fixed			native_fpsP);			/* >> */

	SPAPI A_Err	(*AEGP_GetOutSpecDepth)(
						AEIO_OutSpecH	outH,					/* >> */
						A_short			*depthPS);				/* << */

	SPAPI A_Err	(*AEGP_SetOutSpecDepth)(
						AEIO_OutSpecH	outH,					/* >> */
						A_short			depthPS);				/* >> */

	SPAPI A_Err	(*AEGP_GetOutSpecInterlaceLabel)(
						AEIO_OutSpecH		outH,				/* >> */
						FIEL_Label			*interlaceP);		/* << */

	SPAPI A_Err	(*AEGP_SetOutSpecInterlaceLabel)(
						AEIO_OutSpecH		outH,				/* >> */
						const FIEL_Label	*interlaceP);		/* >> */

	SPAPI A_Err	(*AEGP_GetOutSpecAlphaLabel)(
						AEIO_OutSpecH		outH,				/* >> */
						AEIO_AlphaLabel		*alphaP);			/* << */

	SPAPI A_Err	(*AEGP_SetOutSpecAlphaLabel)(
						AEIO_OutSpecH			outH,			/* >> */
						const AEIO_AlphaLabel	*alphaP);		/* >> */

	SPAPI A_Err	(*AEGP_GetOutSpecDuration)(
						AEIO_OutSpecH	outH,					/* >> */
						A_Time			*durationP);			/* << */

	SPAPI A_Err	(*AEGP_SetOutSpecDuration)(
						AEIO_OutSpecH	outH,					/* >> */
						const A_Time	*durationP);			/* >> */

	SPAPI A_Err	(*AEGP_GetOutSpecDimensions)(
						AEIO_OutSpecH	outH,					/* >> */
						A_long			*widthPL,				/* << */
						A_long			*heightPL);				/* << */

	SPAPI A_Err	(*AEGP_GetOutSpecHSF)(
						AEIO_OutSpecH	outH,					/* >> */
						A_Ratio			*hsfP);					/* << */

	SPAPI A_Err	(*AEGP_SetOutSpecHSF)(
						AEIO_OutSpecH	outH,					/* >> */
						const A_Ratio	*hsfP);					/* >> */

	SPAPI A_Err	(*AEGP_GetOutSpecSoundRate)(
						AEIO_OutSpecH	outH,					/* >> */
						A_FpLong		*ratePF);				/* << */

	SPAPI A_Err	(*AEGP_SetOutSpecSoundRate)(
						AEIO_OutSpecH	outH,					/* >> */
						A_FpLong		rateF);					/* >> */

	SPAPI A_Err	(*AEGP_GetOutSpecSoundEncoding)(
						AEIO_OutSpecH		outH,				/* >> */
						AEIO_SndEncoding	*encodingP);		/* << */

	SPAPI A_Err	(*AEGP_SetOutSpecSoundEncoding)(
						AEIO_OutSpecH		outH,				/* >> */
						AEIO_SndEncoding	encoding);			/* >> */

	SPAPI A_Err	(*AEGP_GetOutSpecSoundSampleSize)(
						AEIO_OutSpecH		outH,				/* >> */
						AEIO_SndSampleSize	*bytes_per_sampleP);/* << */

	SPAPI A_Err	(*AEGP_SetOutSpecSoundSampleSize)(
						AEIO_OutSpecH		outH,				/* >> */
						AEIO_SndSampleSize	bytes_per_sample);	/* >> */

	SPAPI A_Err	(*AEGP_GetOutSpecSoundChannels)(
						AEIO_OutSpecH		outH,				/* >> */
						AEIO_SndChannels	*num_channelsP);	/* << */

	SPAPI A_Err	(*AEGP_SetOutSpecSoundChannels)(
						AEIO_OutSpecH		outH,				/* >> */
						AEIO_SndChannels	num_channels);		/* >> */

	SPAPI A_Err	(*AEGP_GetOutSpecIsStill)(
						AEIO_OutSpecH		outH,				/* >> */
						A_Boolean			*is_stillPB);		/* << */

	SPAPI A_Err	(*AEGP_GetOutSpecPosterTime)(
						AEIO_OutSpecH		outH,				/* >> */
						A_Time				*poster_timeP);		/* << */

	SPAPI A_Err	(*AEGP_GetOutSpecStartFrame)(
						AEIO_OutSpecH		outH,				/* >> */
						A_long				*start_frameP);		/* << */

	SPAPI A_Err	(*AEGP_GetOutSpecPullDown)(
						AEIO_OutSpecH		outH,				/* >> */
						AEIO_Pulldown		*pulldownP);		/* << */

	SPAPI A_Err	(*AEGP_GetOutSpecIsMissing)(
						AEIO_OutSpecH		outH,				/* >> */
						A_Boolean			*missingPB);		/* << */
	
	// see if you need to embed outspec's color profile as an icc profile
	SPAPI A_Err (*AEGP_GetOutSpecShouldEmbedICCProfile)(
						AEIO_OutSpecH		outH,				// >>
						A_Boolean			*embedPB);			// <<
	
	// query outspec's color profile					
	SPAPI A_Err (*AEGP_GetNewOutSpecColorProfile)(
						AEGP_PluginID		aegp_plugin_id,		// >>
						AEIO_OutSpecH		outH,				// >>
						AEGP_ColorProfileP	*color_profilePP);	// <<	output color space; caller must dispose with AEGP_DisposeColorProfile

	// Fails if rq_itemP is not found.
	// This API would also fail if the outH is not a confirmed outH and is a copy.
	// e.g. if the Output Module settings dialog is Open.
	SPAPI A_Err	(*AEGP_GetOutSpecOutputModule)(
						AEIO_OutSpecH		outH,				/* >> */
						AEGP_RQItemRefH		*rq_itemP,			/* << */
						AEGP_OutputModuleRefH *om_refP);		/* << */

	
} AEGP_IOOutSuite4;

#define	kAEGPFIMSuiteVersion3	3 /* frozen in AE 10.0 */
typedef struct {
	SPAPI A_Err (*AEGP_RegisterImportFlavor)(
				const A_char 				*nameZ,		// format name you'd like to appear
													// in AE's Import Dialog Format pop-up
													// menu.
													// Limited to AE_FIM_MAX_IMPORT_FLAVOR_NAME_LEN.
													// Everything after that will be truncated.
				AE_FIM_ImportFlavorRef	*imp_refP);	// On return it is set to a valid opaque ref.
													// If error occured, it will be returned to
													// the caller and ref will be set to a special
													// value - AE_FIM_ImportFlavorRef_NONE.
													
	SPAPI A_Err (*AEGP_RegisterImportFlavorFileTypes)(
				AE_FIM_ImportFlavorRef	imp_ref,		// Received from AEGP_RegisterImportFlavor
				A_long					num_filekindsL,	// number of supported file types for this format
				const	AEIO_FileKind	*kindsAP,		// Array of supported file types for this format
				A_long					num_fileextsL,	// number of supported file exts for this format
				const	AEIO_FileKind	*extsAP);		// Array of supported file exts for this format
				
				
	SPAPI A_Err (*AEGP_RegisterImportFlavorImportCallbacks)(
				AE_FIM_ImportFlavorRef	imp_ref,			// Received from AEGP_RegisterImportFlavor
				AE_FIM_ImportFlags		single_flag,		// You can register callbacks only per single flag
															// this also registers the flag with the import flavor		
				const	AE_FIM_ImportCallbacks	*imp_cbsP);	// Callbacks your format installs per each flag
				
	// optionally call once from AE_FIM_ImportFileCB.  This is used by the application when re-importing
	// from the render queue and replacing an existing item.
	SPAPI A_Err (*AEGP_SetImportedItem)(
			AE_FIM_ImportOptions		imp_options,		/* <> */
			AEGP_ItemH					imported_itemH);	/* >> */
				
} AEGP_FIMSuite3;


#include <AE_GeneralPlugPost.h>

```

---

<h2>Begin File: AE_GeneralPlugPanels.h</h2>

```cpp
#ifndef _AEGP_PANELS_H_
#define _AEGP_PANELS_H_

#include "AE_GeneralPlug.h"

#if defined(__GNUC__) && defined(__MACH__)
	#if defined(__LP64__)
		#include <Cocoa/Cocoa.h>
		typedef NSView *AEGP_PlatformViewRef;
	#else
		typedef HIViewRef AEGP_PlatformViewRef;
	#endif
#endif

#if defined(WIN32)
	#include <windows.h>
	typedef HWND AEGP_PlatformViewRef;
#endif

typedef struct _AEGP_CreatePanelRefcon			*AEGP_CreatePanelRefcon;
typedef struct _AEGP_PanelRefcon			*AEGP_PanelRefcon;

#ifndef AEGP_INTERNAL
	// opaque for everyone else
	typedef struct _AEGP_PanelH						*AEGP_PanelH;
#endif



#include <AE_GeneralPlugPre.h>


enum {AEGP_FlyoutMenuCmdID_NONE = 0};
typedef A_long AEGP_FlyoutMenuCmdID;


enum {
	AEGP_FlyoutMenuMarkType_NORMAL,
	AEGP_FlyoutMenuMarkType_CHECKED,
	AEGP_FlyoutMenuMarkType_RADIO_BULLET,
	AEGP_FlyoutMenuMarkType_SEPARATOR
};
typedef A_long AEGP_FlyoutMenuMarkType;

typedef A_long AEGP_FlyoutMenuIndent;


typedef struct 
{
	AEGP_FlyoutMenuIndent	indent;
	AEGP_FlyoutMenuMarkType	type;
	A_Boolean				enabledB;
	AEGP_FlyoutMenuCmdID	cmdID;		// limited to MAX(A_long) - 201;
	const A_u_char*			utf8NameZ;
}AEGP_FlyoutMenuItem;

/*
flyout menu's are a simple declarative structure

AEGP_FlyoutMenuItem	myMenu[] = { 
	{1, AEGP_FlyoutMenuMarkType_NORMAL,		FALSE,	AEGP_FlyoutMenuCmdID_NONE, "Hi!"  },
	{1, AEGP_FlyoutMenuMarkType_SEPARATOR,	TRUE,	AEGP_FlyoutMenuCmdID_NONE, NULL  },
	{1, AEGP_FlyoutMenuMarkType_NORMAL,		TRUE,	AEGP_FlyoutMenuCmdID_NONE, "Set BG Color"  },
		{2, AEGP_FlyoutMenuMarkType_NORMAL,		TRUE,	PT_MenuCmd_RED,				"Red"  },
		{2, AEGP_FlyoutMenuMarkType_NORMAL,		TRUE,	PT_MenuCmd_GREEN,			"Green"  },
		{2, AEGP_FlyoutMenuMarkType_NORMAL,		TRUE,	PT_MenuCmd_BLUE,			"Blue"  },
	{1, AEGP_FlyoutMenuMarkType_NORMAL,		TRUE,	PT_MenuCmd_STANDARD,		"Normal Fill Color"  },
	{1, AEGP_FlyoutMenuMarkType_NORMAL,		TRUE,	AEGP_FlyoutMenuCmdID_NONE,	"Set Title"  },
		{2, AEGP_FlyoutMenuMarkType_NORMAL,		TRUE,	PT_MenuCmd_TITLE_LONGER,	"Longer"  },
		{2, AEGP_FlyoutMenuMarkType_NORMAL,		TRUE,	PT_MenuCmd_TITLE_SHORTER,	"Shorter"  }
};


*/

typedef struct {
	// no more than 5 snap sizes. Our algo can't really cope and it confuses
	// the user.
	A_Err	(*GetSnapSizes)(AEGP_PanelRefcon refcon, A_LPoint*	snapSizes, A_long * numSizesP);


	A_Err	(*PopulateFlyout)(AEGP_PanelRefcon refcon, AEGP_FlyoutMenuItem* itemsP, A_long * in_out_numItemsP);
	A_Err	(*DoFlyoutCommand)(AEGP_PanelRefcon refcon, AEGP_FlyoutMenuCmdID commandID);
} AEGP_PanelFunctions1;

typedef A_Err		(*AEGP_CreatePanelHook)(							
									 AEGP_GlobalRefcon		plugin_refconP,			
									 AEGP_CreatePanelRefcon		refconP,
									 AEGP_PlatformViewRef container,
									 AEGP_PanelH		panelH,
									 AEGP_PanelFunctions1* outFunctionTable,
									 AEGP_PanelRefcon*		outRefcon);			
#define	kAEGPPanelSuite			"AEGP Workspace Panel Suite"
#define	kAEGPPanelSuiteVersion1	1 /* frozen in AE 8.0 */

typedef struct {
	SPAPI A_Err	(*AEGP_RegisterCreatePanelHook)(
		AEGP_PluginID			in_plugin_id,				
		const A_u_char*				in_utf8_match_nameZ, // do not localize
		AEGP_CreatePanelHook	in_update_menu_hook_func,	
		AEGP_CreatePanelRefcon	in_refconP,
		A_Boolean				in_paint_backgroundB);				


	SPAPI A_Err	(*AEGP_UnRegisterCreatePanelHook)(			
		const A_u_char*				in_utf8_match_nameZ);	// do not localize match name

	SPAPI A_Err (*AEGP_SetTitle)(
		AEGP_PanelH in_panelH,
		const A_u_char*		in_utf8_nameZ		// use this to localize the user visible name of the panel
		);

	/** Does the standard 'Window' menu operation
	If tab is not in workspace, it creates it.
	Otherwise, if the tab is not the front most tab in it's frame, it is made frontmost
	Else, if it is visible and frontmost, it is closed.
	*/
	SPAPI A_Err (*AEGP_ToggleVisibility)(
		const A_u_char*				in_utf8_match_nameZ
		);

	SPAPI A_Err (*AEGP_IsShown)(
		const A_u_char*	in_utf8_match_nameZ, 
		A_Boolean*	out_tab_is_shownB,
		A_Boolean*	out_panel_is_frontmostB
		);

} AEGP_PanelSuite1;


#include <AE_GeneralPlugPost.h>


#endif
```

---

<h2>Begin File: AE_GeneralPlugPost.h</h2>

```cpp

#ifdef __cplusplus
}		// end extern "C"
#endif



#include <adobesdk/config/PostConfig.h>



#ifndef _AE_GENERAL_PLUG_PRE___
	#error "AE_GeneralPlugPost.h not balanced"
#else
	#undef _AE_GENERAL_PLUG_PRE___
#endif
```

---

<h2>Begin File: AE_GeneralPlugPre.h</h2>

```cpp

/* This file should be included after all headers, but before the definition of any suites
or data structures.
*/
#include <adobesdk/config/PreConfig.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _AE_GENERAL_PLUG_PRE___
#error "AE_GeneralPlugPre.h not balanced"
#endif

#define _AE_GENERAL_PLUG_PRE___
```

---

<h2>Begin File: AE_HashSuite.h</h2>

```cpp
/********************************************************************
* ADOBE CONFIDENTIAL
* __________________
*
*  Copyright 2020 Adobe Inc.
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe and its suppliers, if any. The intellectual
* and technical concepts contained herein are proprietary to Adobe
* and its suppliers and are protected by all applicable intellectual
* property laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe.
********************************************************************/

#ifndef _H_AE_HashSuite
	#define _H_AE_HashSuite

#ifdef AEGP_INTERNAL
	#include <AE_GeneralPlug_Private.h>
#endif

#include <AE_ComputeCacheSuite.h>

#ifdef __cplusplus
	extern "C" {
#endif

#define kAEGPHashSuite				"AEGP Hash Suite"
#define kAEGPHashSuiteVersion1		1	/* frozen in AE 17.5.1 */

typedef struct {

	SPAPI A_Err (*AEGP_CreateHashFromPtr)(
							const A_u_longlong		buf_sizeLu,		/* >> size of the buffer */
							const void				*bufPV,			/* >> the buffer pointer */
							AEGP_GUID				*hashP);		/* << result */

	SPAPI A_Err	(*AEGP_HashMixInPtr)(
							const A_u_longlong		buf_sizeLu,		/* >> size of the buffer */
							const void				*bufPV,			/* >> the buffer pointer */
							AEGP_GUID				*hashP);		/* <> guid to be mixed in */

} AEGP_HashSuite1;

#ifdef __cplusplus
	}		// end extern "C"
#endif

#endif

```

---

<h2>Begin File: AE_Hook.h</h2>

```cpp
/*******************************************************************/
/*                                                                 */
/*                      ADOBE CONFIDENTIAL                         */
/*                   _ _ _ _ _ _ _ _ _ _ _ _ _                     */
/*                                                                 */
/* Copyright 2007 Adobe Systems Incorporated                       */
/* All Rights Reserved.                                            */
/*                                                                 */
/* NOTICE:  All information contained herein is, and remains the   */
/* property of Adobe Systems Incorporated and its suppliers, if    */
/* any.  The intellectual and technical concepts contained         */
/* herein are proprietary to Adobe Systems Incorporated and its    */
/* suppliers and may be covered by U.S. and Foreign Patents,       */
/* patents in process, and are protected by trade secret or        */
/* copyright law.  Dissemination of this information or            */
/* reproduction of this material is strictly forbidden unless      */
/* prior written permission is obtained from Adobe Systems         */
/* Incorporated.                                                   */
/*                                                                 */
/*******************************************************************/

#ifndef _H_HOOK_AE
#define _H_HOOK_AE


#include <AE_Effect.h>			// for PF_Version, other types


#ifdef __cplusplus
	extern "C" {
#endif


#define AE_HOOK_PLUGIN_TYPE		'AEgp'

#define AE_HOOK_MAJOR_VERSION		3
#define AE_HOOK_MINOR_VERSION		0

enum {
	AE_PixFormat_NONE = -1,		// sentinel -- meaningless
	AE_PixFormat_ARGB = 0,
	AE_PixFormat_BGRA
};

typedef A_long AE_PixFormat;

enum {
	AE_BlitOutFlag_NONE = 0,
	AE_BlitOutFlag_ASYNCHRONOUS = 1L << 0
};

enum {
	AE_BlitInFlag_NONE = 0,
	AE_BlitInFlag_RENDERING = 1L << 0
};

typedef A_long AE_BlitInFlags;
typedef A_long AE_BlitOutFlags;

// AE now supports 8bpp, 16bpp and 32bpc
// depthL, chan_bytesL, and plane_bytesL
// can now change.
typedef struct {
	A_long			widthL;
	A_long			heightL;
	A_long			depthL;			// 32, 64, or 128
	AE_PixFormat	pix_format;		// always AE_PixFormat_ARGB on Mac, BGRA on Windows (for now)

	A_long			row_bytesL;
	A_long			chan_bytesL;	// 4, 8, or 16
	A_long			plane_bytesL;	// 1, 2, or 4 (for float)

	void			*pixelsPV;

} AE_PixBuffer;



typedef struct {
	A_long		frame_widthL;			// original size of image regardless of region of interest
	A_long		frame_heightL;

	A_long		origin_xL;				// where the pix buffer is placed in frame coords
	A_long		origin_yL;		

	A_long		view_rect_leftL;		// what the user is actually seeing in the window
	A_long		view_rect_topL;
	A_long		view_rect_rightL;
	A_long		view_rect_bottomL;


} AE_ViewCoordinates;



typedef struct _AE_BlitReceipt			*AE_BlitReceipt;		// opaque

typedef struct _AE_CursorInfo			*AE_CursorInfo;			// opaque until I can decide what this means



typedef void		(*AE_DeathHook)(	void *hook_refconPV);						/* >> */	

typedef void		(*AE_VersionHook)(	void *hook_refconPV,						/* >> */	
										A_u_long *versionPV);					/* << */


typedef struct		FILE_Spec			**AE_FileSpecH;


typedef void		(*AE_BlitCompleteFunc)(	AE_BlitReceipt			receipt,
											PF_Err					err);		// non zero if error during asynch operation


typedef PF_Err		(*AE_BlitHook)(		void						*hook_refconPV,	/* >> */
										const AE_PixBuffer			*pix_bufP0,		/* >> 	if NULL, display a blank frame */
										const AE_ViewCoordinates	*viewP,			/* >> */
										AE_BlitReceipt				receipt,		/* >> */
										AE_BlitCompleteFunc			complete_func0,	/* >> */
										AE_BlitInFlags				in_flags,		/* >> */
										AE_BlitOutFlags				*out_flags);	/* << */



typedef void		(*AE_CursorHook)(	void						*hook_refconPV,	/* >> */	
										const AE_CursorInfo			*cursorP);		/* >> */

typedef struct {
	// must match NIM_Hooks
	
	void				*hook_refconPV;
	void				*reservedAPV[8];
	AE_DeathHook		death_hook_func;
	AE_VersionHook		version_hook_func;
	struct SPBasicSuite	*pica_basicP;
	AE_BlitHook			blit_hook_func;
	AE_CursorHook		cursor_hook_func;

} AE_Hooks;



typedef PF_Err (*AE_HookPluginEntryFunc)(	A_long major_version,			/* >> */		
											A_long minor_version,			/* >> */		
											AE_FileSpecH file_specH,	/* >> */		
											AE_FileSpecH res_specH,		/* >> */		
											AE_Hooks *hooksP);			/* << */

#ifdef __cplusplus
	}
#endif


#endif


```

---

<h2>Begin File: AE_IO.h</h2>

```cpp
/*******************************************************************/
/*                                                                 */
/*                      ADOBE CONFIDENTIAL                         */
/*                   _ _ _ _ _ _ _ _ _ _ _ _ _                     */
/*                                                                 */
/* Copyright 2007 Adobe Systems Incorporated                       */
/* All Rights Reserved.                                            */
/*                                                                 */
/* NOTICE:  All information contained herein is, and remains the   */
/* property of Adobe Systems Incorporated and its suppliers, if    */
/* any.  The intellectual and technical concepts contained         */
/* herein are proprietary to Adobe Systems Incorporated and its    */
/* suppliers and may be covered by U.S. and Foreign Patents,       */
/* patents in process, and are protected by trade secret or        */
/* copyright law.  Dissemination of this information or            */
/* reproduction of this material is strictly forbidden unless      */
/* prior written permission is obtained from Adobe Systems         */
/* Incorporated.                                                   */
/*                                                                 */
/*******************************************************************/

#ifndef _AEIO_Public_H
#define _AEIO_Public_H

#include <A.h>
#include <AE_IO_FileExt.h>
#include <SPBasic.h>
#include <AE_Effect.h>
#include <FIEL_Public.h>

#include <adobesdk/config/PreConfig.h>


///////////////////////////////////////////////////
////////////////// PUBLIC ////////////////////////
//////////////////////////////////////////////////

#define AEIO_MAX_MODULE_NAME_LEN		31
#define AEIO_MAX_TYPES					16
#define AEIO_MAX_SEQ_NAME_LEN			31
#define AEIO_MAX_MESSAGE_LEN			127
#define AEIO_MAX_AUX_EXT				16

#define AEIO_ANY_CREATOR				-1

#ifdef __cplusplus
	extern "C" {
#endif

#ifndef AEGP_INTERNAL 
		typedef const struct _AEGP_MarkerVal			*AEGP_ConstMarkerValP;
#else
#ifndef _H_AE_GENERALPLUG_PRIVATE_H
#error include general plug private header before including AEIO
#endif
#endif



/**
 ** in data is passed to every function block function
 **/

typedef void (*AEIO_MessageFunc) (A_Err err_number, const A_char *msgA);

typedef struct AEIO_InData {
	AEIO_MessageFunc			msg_func;
	const struct SPBasicSuite	*pica_basicP;
	A_long						aegp_plug_id;
	void						*aegp_refconPV;
} AEIO_BasicData;

enum {
	AEIO_Err_UNSUPPORTED_CALLBACK = (((39)<<8)+1), 
	AEIO_Err_UNIMPLEMENTED,
	AEIO_Err_UNSUPPORTED_FILETYPE,
	AEIO_Err_INAPPROPRIATE_ACTION,
	AEIO_Err_BAD_BMWORLD,
	AEIO_Err_INCONSISTENT_PARAMETERS,
	AEIO_Err_INVALID_TIME,
	AEIO_Err_USE_DFLT_CALLBACK,
	AEIO_Err_USER_CANCEL,
	AEIO_Err_DISK_FULL,
	AEIO_Err_INITIALIZE_FAILED,
	AEIO_Err_BAD_FILENAME,
	AEIO_Err_PARSING,
	AEIO_Err_NOT_SEQUENCE,
	AEIO_Err_USE_DFLT_GETSIZES_FREESPACE
};

typedef struct _Up_OpaqueMem			**AEIO_Handle;

enum {
	AEIO_DFlags_NONE		=		0,
	AEIO_DFlags_DID_DEINT	= 		(1L<<1),	// I already did deinterlacing
	AEIO_DFlags_DID_ALPHA_CONV =	(1L<<2)	// I already did alpha conversion to what you wanted.
};
typedef A_long AEIO_DrawingFlags;

/* 	NOTE: AEIO_DFlags_NO_SCALE and AEIO_DFlags_DID_TIME_FILTER,
	previously included in the above, were never honored (so
	we removed them). -bbb 8/14/02
*/

enum {
	AEIO_Qual_LOW,
	AEIO_Qual_HIGH
};
typedef A_short	AEIO_Quality;

enum {
	AEIO_TimeDir_FORWARD 			= 0x0000,
	AEIO_TimeDir_BACKWARD 			= 0x0001,
	AEIO_TimeDir_INCLUDE_BASE_TIME 	= 0x1000
};
typedef A_short	AEIO_TimeDir;

enum {
	AEIO_IdleFlag_NONE 			= 0,
	AEIO_IdleFlag_PURGED_MEM	= 1L << 0,
	AEIO_IdleFlag_ADD_YOUR_OWN 	= 1L << 1
};
typedef A_long AEIO_IdleFlags;

enum {
	AEIO_SndQuality_APPROX = -1,		// This quality is used to draw the audio waveform.  -jja
	AEIO_SndQuality_LO = 0,
	AEIO_SndQuality_HI
};

typedef A_long AEIO_SndQuality;

enum {
	AEIO_E_UNSIGNED_PCM = 1,
	AEIO_E_SIGNED_PCM = 2,
	AEIO_E_SIGNED_FLOAT = 3
};
typedef A_short	AEIO_SndEncoding;

enum {
	AEIO_SS_1 = 1,
	AEIO_SS_2 = 2,
	AEIO_SS_4 = 4
};
typedef A_short	AEIO_SndSampleSize;

enum {
	AEIO_SndChannels_MONO = 1,
	AEIO_SndChannels_STEREO = 2
};
typedef A_short	AEIO_SndChannels;

enum {
	AEIO_Marker_URL_FLIP,
	AEIO_Marker_CHAPTER,
	AEIO_Marker_HOTSPOT,
	AEIO_Marker_NONE
};
typedef A_u_char AEIO_MarkerType;

enum {
	AEIO_Field_FRAME = 0,
	AEIO_Field_UPPER,
	AEIO_Field_LOWER
};
typedef A_long AEIO_Field;


typedef struct {
	const A_char		*chapterZ0;
	const A_char		*commentZ0;
	const A_char		*urlZ0;
	const A_char		*url_frame_targetZ0; // optionally used if urlZ0 != NULL
} AEIO_Marker;


enum {
	AEIO_FrameBlend_NONE = 0,
	AEIO_FrameBlend_LOW = 1,
	AEIO_FrameBlend_HIGH = 2
};
typedef A_char AEIO_FrameBlend;


enum {
	AEIO_LFlag_ALFA = 0x1,
	AEIO_LFlag_FIELDS = 0x2,
	AEIO_LFlag_SIGNATURE = 0x4
};
typedef A_long AEIO_LabelFlags;

enum {
	AEIO_InputDepth_1		= 1,
	AEIO_InputDepth_2  		= 2,
	AEIO_InputDepth_4  		= 4,
	AEIO_InputDepth_8  		= 8, 
	AEIO_InputDepth_16 		= 16,
	AEIO_InputDepth_24 		= 24, 
	AEIO_InputDepth_30		= 30,
	AEIO_InputDepth_32 		= 32, 
	AEIO_InputDepth_GRAY_2 	= 34,
	AEIO_InputDepth_GRAY_4 	= 36,
	AEIO_InputDepth_GRAY_8 	= 40,
	AEIO_InputDepth_48	 	= 48,
	AEIO_InputDepth_64	 	= 64,
	AEIO_InputDepth_96		= 96,		// RGB float
	AEIO_InputDepth_128		= 128,		// ARGB float
	AEIO_InputDepth_GRAY_16	= -16,		
	AEIO_InputDepth_GRAY_32	= -32
};

typedef A_long AEIO_InputDepth;

enum {
	AEIO_SupportedDepthFlags_NONE 			= 0,		
	AEIO_SupportedDepthFlags_DEPTH_1  		= 1L << 1,	// Enable 1 bit images. Put an interface on it, if you like
	AEIO_SupportedDepthFlags_DEPTH_2  		= 1L << 2,	// Enable 2 bit images. etc.
	AEIO_SupportedDepthFlags_DEPTH_4  		= 1L << 3,
	AEIO_SupportedDepthFlags_DEPTH_8  		= 1L << 4,
	AEIO_SupportedDepthFlags_DEPTH_16 		= 1L << 5,
	AEIO_SupportedDepthFlags_DEPTH_24 		= 1L << 6,
	AEIO_SupportedDepthFlags_DEPTH_32 		= 1L << 7,	// Enable  32-bit images (with alpha channels)
	AEIO_SupportedDepthFlags_DEPTH_GRAY_2 	= 1L << 8,	// greyscale 
	AEIO_SupportedDepthFlags_DEPTH_GRAY_4 	= 1L << 9,
	AEIO_SupportedDepthFlags_DEPTH_GRAY_8 	= 1L << 10,
	AEIO_SupportedDepthFlags_DEPTH_48		= 1L << 11,
	AEIO_SupportedDepthFlags_DEPTH_64		= 1L << 12,
	AEIO_SupportedDepthFlags_DEPTH_GRAY_16 	= 1L << 13,
	AEIO_SupportedDepthFlags_DEPTH_96		= 1L << 14,
	AEIO_SupportedDepthFlags_DEPTH_128		= 1L << 15,
	AEIO_SupportedDepthFlags_LAST	 		= 1L << 16
};

typedef A_long AEIO_SupportedDepthFlags;

enum {
	AEIO_Phase_NO_PULLDOWN = 0,
	AEIO_Phase_WSSWW = 1,
	AEIO_Phase_SSWWW,
	AEIO_Phase_SWWWS,
	AEIO_Phase_WWWSS,
	AEIO_Phase_WWSSW
};
typedef A_long AEIO_Pulldown;

typedef	A_long	AEIO_FileType;
typedef	A_long	AEIO_Creator;

typedef struct {
	AEIO_FileType type;
	AEIO_Creator creator;
} PFILE_FileKind;


typedef union {
	PFILE_FileKind		mac;
	AEIO_FileExt		ext;
	A_long				scrap;
} AEIO_FileKind;


typedef struct {
	A_char				name[AEIO_MAX_SEQ_NAME_LEN+1];			// usually the filename
	A_char				type[AEIO_MAX_SEQ_NAME_LEN+1];			// e.g. "PICT Sequence" "QT Movie"
	A_char				sub_type[AEIO_MAX_MESSAGE_LEN+1];
} AEIO_Verbiage;


#ifdef __cplusplus
	}
#endif


/////////////////////////////////////////////////////////
////////////////// redefined in PRIVATE /////////////////
////////////////////////////////////////////////////////

#ifdef A_INTERNAL
	#include <AE_IO_Private.h>
#else  
	#ifdef __cplusplus
		extern "C" {
	#endif

	typedef struct AEIO_SeqSpec		**AEIO_InSpecH;
	typedef struct AEIO_OutSpec		**AEIO_OutSpecH;

	typedef A_long	AEIO_ModuleSignature;				// please register your module signature with adobe
														// mailto:bbb@adobe.com?subject=AEIO_Signature

	typedef struct {
		A_Ratio	x;
		A_Ratio	y;
	} AEIO_RationalScale;


	#define AEIO_AlphaLabel_VERSION	0x0101

	enum {
		AEIO_AlphaPremul 		= 0x1,		// otherwise straight
		AEIO_AlphaInverted		= 0x2		//  255 = transparent
	};

	typedef A_u_long	AEIO_AlphaFlags;

	enum {
		AEIO_Alpha_STRAIGHT,
		AEIO_Alpha_PREMUL,
		AEIO_Alpha_IGNORE,
		AEIO_Alpha_NONE
	};

	typedef A_u_char	AEIO_AlphaType;

            
    #pragma pack( push, CoSAalign, 2 )

	typedef struct {
			A_short				version;
			AEIO_AlphaFlags		flags;
			A_u_char			red;		// color that was matted (if premul)
			A_u_char			green;
			A_u_char			blue;
			AEIO_AlphaType		alpha;	
		} AEIO_AlphaLabel;
#if defined(A_INTERNAL) && defined(__cplusplus)
	AE_STRUCT_SIZE_ASSERT(AEIO_AlphaLabel, 10);
#endif

    #pragma pack( pop, CoSAalign)


	typedef A_Err (*AEIO_AbortProc)(void *refcon);
	typedef A_Err (*AEIO_ProgressProc)(void *refcon, A_long count, A_long total);


	typedef struct {
		void				*refcon;
		AEIO_AbortProc		abort0;
		AEIO_ProgressProc	progress0;
	} AEIO_InterruptFuncs;


	//	All coordinates are in the scaled coordinate system.
	typedef struct {
		AEIO_Quality		qual;
		AEIO_AlphaLabel		alpha_label;
		AEIO_Field			field_request;
		AEIO_RationalScale	rs;
		A_Time				tr;
		A_Time				duration;
		AEIO_FrameBlend		time_filter;
		// CW adds 1 pad byte here
		A_LRect				required_region0;		// empty rect means entire
		// CW adds 2 pad bytes here
		AEIO_InterruptFuncs	inter;
	} AEIO_DrawFramePB;
	
	enum {
		AEIO_RenderMarkerFlag_NONE = 0x00000000,
		AEIO_RenderMarkerFlag_COMP = 0x00000001 // if 1 means comp marker; 0 means Layer marker
	};
	typedef A_long	AEIO_RenderMarkerFlag;

	#ifdef __cplusplus
	}
	#endif
#endif // A_INTERNAL

#ifdef __cplusplus
	extern "C" {
#endif


#define	AEIO_FileType_DIR		-2L
#define	AEIO_FileType_NONE		-1L
#define	AEIO_FileType_ANY		0L
#define AEIO_FileType_GENERIC	1L


////////////////////////////////////////////////////////////////////
///////////////////////// PUBLIC ///////////////////////////////////
////////////////////////////////////////////////////////////////////


enum {
	AEIO_MFlag_NONE						= 0,
	AEIO_MFlag_INPUT					= (1L<<0),	// input module
	AEIO_MFlag_OUTPUT					= (1L<<1),	// output module (can be both)
	AEIO_MFlag_FILE						= (1L<<2),	// direct correspondence to file in file system
	AEIO_MFlag_STILL					= (1L<<3),	// still image support (not VIDEO)
	AEIO_MFlag_VIDEO					= (1L<<4),	// multiple image support (not STILL)
	AEIO_MFlag_AUDIO					= (1L<<5),	// audio support
	AEIO_MFlag_NO_TIME					= (1L<<6),	// time-independent frame-store? always true if STILL; PICS example of non-STILL one
	AEIO_MFlag_INTERACTIVE_GET			= (1L<<7),	// user interaction for new seq, required if !FILE & INPUT
	AEIO_MFlag_INTERACTIVE_PUT			= (1L<<8),	// user interaction for new out, required if !FILE & OUTPUT
	AEIO_MFlag_CANT_CLIP				= (1L<<9),	// DrawFrame can't accept worlds smaller than requested dimensions
	AEIO_MFlag_MUST_INTERACT_PUT		= (1L<<10),	// dialog box can't be avoided, even if optionsH available
	AEIO_MFlag_CANT_SOUND_INTERLEAVE	= (1L<<11),	// all frames must be added, then sound
	AEIO_MFlag_CAN_ADD_FRAMES_NON_LINEAR= (1L<<12),	// AddFrame can handle non-sequential times
	AEIO_MFlag_HOST_DEPTH_DIALOG		= (1L<<13),	// expects host to bring up a dialog with depth
	AEIO_MFlag_HOST_FRAME_START_DIALOG	= (1L<<14),	// expects host to bring up dialog with starting frame #
	AEIO_MFlag_RESERVED1				= (1L<<15),	
	AEIO_MFlag_NO_OPTIONS				= (1L<<16),	// set this bit if the module does not accept output options
	AEIO_MFlag_RESERVED2				= (1L<<17),
	
	AEIO_MFlag_RESERVED3				= (1L<<18),	
	AEIO_MFlag_NO_PIXELS				= (1L<<19),	// this file format doesn't store real pixels, only geometry (or whatever)
	AEIO_MFlag_SEQUENCE_OPTIONS_OK		= (1L<<20),	// this module should take the options of its parent sequence when a folder is selected
	AEIO_MFlag_INPUT_OPTIONS			= (1L<<21),	// this module has user options associated with an input sequence. NOTE: options must be flat.
	AEIO_MFlag_HSF_AWARE			  	= (1L<<22),	// this module set the hsf for incoming sequences -> don't guess what it is!
	AEIO_MFlag_HAS_LAYERS				= (1L<<23),	// this module supports multiple layers in a single document
	AEIO_MFlag_SCRAP					= (1L<<24),	// module has a memory parsing (clipboard) component
	AEIO_MFlag_NO_UI					= (1L<<25),	// don't show any UI for this module
	AEIO_MFlag_SEQ_OPTIONS_DLG			= (1L<<26),	// module has sequence options
	AEIO_MFlag_HAS_AUX_DATA				= (1L<<27),	// has depth, or normals, or anything that is on a per pixel basis besides color
	AEIO_MFlag_HAS_META_DATA			= (1L<<28),	// supports user definable metadata
	AEIO_MFlag_CAN_DO_MARKERS			= (1L<<29),	// supports markers (e.g. URL flips, chapters)
	AEIO_MFlag_CAN_DRAW_DEEP			= (1L<<30),	// module can draw into 64 bpp BM_Worlds
	AEIO_MFlag_RESERVED4				= (1L<<31)	
};
typedef A_u_long AEIO_ModuleFlags;

enum {
	AEIO_MFlag2_NONE = 0,
	AEIO_MFlag2_AUDIO_OPTIONS					= (1L<<0),		// has audio options
	AEIO_MFlag2_RESERVED1						= (1L<<1),
	AEIO_MFlag2_SEND_ADDMARKER_BEFORE_ADDFRAME	= (1L<<2),		// otherwise it is sent just after; use with AEIO_MFlag_CAN_DO_MARKERS
	AEIO_MFlag2_CAN_DO_MARKERS_2				= (1L<<3),		// supports combined markers (e.g. URL flips, chapters, comments)
	AEIO_MFlag2_CAN_DRAW_FLOAT					= (1L<<4),
	AEIO_MFlag2_RESERVED2						= (1L<<5),
	AEIO_MFlag2_CAN_DO_AUDIO_32					= (1L<<6),		// supports 32 bit audio output.
	AEIO_MFlag2_RESERVED3						= (1L<<7),
	AEIO_MFlag2_SUPPORTS_ICC_PROFILES			= (1L<<8),
	AEIO_MFlag2_CAN_DO_MARKERS_3				= (1L<<9),		// supports cue points
	AEIO_MFlag2_SEND_ADDMARKER_BEFORE_STARTADDING = (1L<<10),
	AEIO_MFlag2_RESERVED4					  = (1L<<11),			
	AEIO_MFlag2_USES_QUICKTIME				  = (1L<<12),			// Module uses quicktime for decompression or compression
	AEIO_MFlag2_RESERVED5					  = (1L<<13),
	AEIO_MFlag2_RESERVED6					  = (1L<<14),
	AEIO_MFlag2_RESERVED7					  = (1L<<15),
	AEIO_MFlag2_RESERVED8					  = (1L<<16),
	AEIO_MFlag2_RESERVED9					  = (1L<<17),
	AEIO_MFlag2_RESERVED10					  = (1L<<18)
};
typedef A_u_long AEIO_ModuleFlags2;

typedef struct {
	A_char extension[4]; // includes '.'
	A_long type;		 // mac type
	A_long creator;		 // mac creator
} AEIO_AuxExt;

typedef struct {	
	AEIO_ModuleSignature	sig;							// please register number this with adobe
	A_char					name[AEIO_MAX_MODULE_NAME_LEN+1];
	AEIO_ModuleFlags		flags;
	AEIO_ModuleFlags2		flags2;
	A_long					max_width;
	A_long					max_height;
	A_short					num_filetypes;					// # of filetype/creator pairs supported
	A_short					num_extensions;					// # of .XXX extensions supported
	A_short					num_clips;						// # of clipboard types supported
	A_short					pad;
	PFILE_FileKind			create_kind;					// type/creator for newly created files
	AEIO_FileExt			create_ext;						// extension for new created DOS files
	AEIO_FileKind			read_kinds[AEIO_MAX_TYPES];		// mac types first, then DOS, then clipboard
	A_short					num_aux_extensionsS;
	// CW adds 2 pad bytes here
	AEIO_AuxExt				aux_ext[AEIO_MAX_AUX_EXT];
} AEIO_ModuleInfo;

typedef struct AEIO_OptionsCBInfo {
	AEIO_SupportedDepthFlags 	o_flags;
	AEIO_OutSpecH		out_specH;
} AEIO_OptionsCBInfo;

typedef struct {
		AEIO_Quality		qual;
		// CW adds 2 pad bytes here
		AEIO_RationalScale	rs;
		A_Time				tr;
		A_Time				duration;
		A_LRect				required_region;		// empty rect means entire
		AEIO_InterruptFuncs	inter;
} AEIO_DrawSparseFramePB;


/***********************   plugin entry points  *****************************
 ** the main routine of each plugin fills in these function pointers
 ** AE will call them as appropriate
 ****************************************************************************/

typedef struct _AEIO_FunctionBlock4 { // revved to 4 in AE 10.  Frozen in AE10.

	A_Err	(*AEIO_InitInSpecFromFile)(
		AEIO_BasicData		*basic_dataP,
		const A_UTF16Char	*file_pathZ,		// Null terminated UTF16 string with platform separators
		AEIO_InSpecH		inH);

	A_Err	(*AEIO_InitInSpecInteractive)(
		AEIO_BasicData	*basic_dataP,
		AEIO_InSpecH	inH);

	A_Err	(*AEIO_DisposeInSpec)(
		AEIO_BasicData	*basic_dataP,
		AEIO_InSpecH	inH);

	A_Err	(*AEIO_FlattenOptions)(
		AEIO_BasicData	*basic_dataP,
		AEIO_InSpecH	inH,
		AEIO_Handle		*flat_optionsPH);		

	A_Err	(*AEIO_InflateOptions)(
		AEIO_BasicData	*basic_dataP,
		AEIO_InSpecH	inH,
		AEIO_Handle		flat_optionsH);		

	A_Err	(*AEIO_SynchInSpec)(
		AEIO_BasicData	*basic_dataP,
		AEIO_InSpecH	inH, 
		A_Boolean		*changed0);

	A_Err	(*AEIO_GetActiveExtent)(
		AEIO_BasicData		*basic_dataP,
		AEIO_InSpecH		inH,				/* >> */
		const	A_Time		*tr,				/* >> */
		A_LRect				*extent);			/* << */

	A_Err	(*AEIO_GetInSpecInfo)(
		AEIO_BasicData		*basic_dataP,
		AEIO_InSpecH		inH, 
		AEIO_Verbiage		*verbiageP);

	//	All coordinates are in the scaled coordinate system.
	A_Err	(*AEIO_DrawSparseFrame)(
		AEIO_BasicData					*basic_dataP,
		AEIO_InSpecH					inH,
		const AEIO_DrawSparseFramePB	*sparse_framePPB, 
		PF_EffectWorld					*worldP,
		AEIO_DrawingFlags				*draw_flagsP);

	A_Err	(*AEIO_GetDimensions)(
		AEIO_BasicData	*basic_dataP,
		AEIO_InSpecH			 inH, 
		const AEIO_RationalScale *rs0,
		A_long					 *width0, 
		A_long					 *height0);

	A_Err	(*AEIO_GetDuration)(
		AEIO_BasicData		*basic_dataP,
		AEIO_InSpecH		inH, 
		A_Time				*tr);

	A_Err	(*AEIO_GetTime)(
		AEIO_BasicData		*basic_dataP,
		AEIO_InSpecH		inH, 
		A_Time				*tr);

	A_Err	(*AEIO_GetSound)(
		AEIO_BasicData				*basic_dataP,	
		AEIO_InSpecH				inH,
		AEIO_SndQuality				quality,
		const AEIO_InterruptFuncs 	*interrupt_funcsP0,	
		const A_Time				*startPT,	
		const A_Time				*durPT,	
		A_u_long					start_sampLu,
		A_u_long					num_samplesLu,
		void						*dataPV);

	A_Err	(*AEIO_InqNextFrameTime)(
		AEIO_BasicData			*basic_dataP,
		AEIO_InSpecH			inH, 
		const A_Time			*base_time_tr,
		AEIO_TimeDir			time_dir, 
		A_Boolean				*found0,
		A_Time					*key_time_tr0);

	A_Err	(*AEIO_InitOutputSpec)(
		AEIO_BasicData		*basic_dataP,
		AEIO_OutSpecH		outH, 
		A_Boolean			*user_interacted);

	A_Err	(*AEIO_GetFlatOutputOptions)(
		AEIO_BasicData		*basic_dataP,
		AEIO_OutSpecH		outH, 
		AEIO_Handle			*optionsH);

	A_Err	(*AEIO_DisposeOutputOptions)(
		AEIO_BasicData		*basic_dataP,
		void				*optionsPV);

	A_Err	(*AEIO_UserOptionsDialog)(
		AEIO_BasicData			*basic_dataP,
		AEIO_OutSpecH			outH, 
		const PF_EffectWorld	*sample0,
		A_Boolean				*user_interacted0);

	A_Err	(*AEIO_GetOutputInfo)(
		AEIO_BasicData		*basic_dataP,
		AEIO_OutSpecH		outH,
		AEIO_Verbiage		*verbiage);

	A_Err	(*AEIO_OutputInfoChanged)(
		AEIO_BasicData		*basic_dataP,
		AEIO_OutSpecH		outH);

	A_Err	(*AEIO_SetOutputFile)(
		AEIO_BasicData		*basic_dataP,
		AEIO_OutSpecH		outH, 
		const A_UTF16Char	*file_pathZ);		// Null terminated UTF16 string with platform separators

	A_Err	(*AEIO_StartAdding)(
		AEIO_BasicData		*basic_dataP,
		AEIO_OutSpecH		outH, 
		A_long				flags);

	A_Err	(*AEIO_AddFrame)(
		AEIO_BasicData				*basic_dataP,
		AEIO_OutSpecH				outH, 
		A_long						frame_index, 
		A_long						frames,
		const PF_EffectWorld		*wP, 
		const A_LPoint				*origin0,
		A_Boolean					was_compressedB,	
		AEIO_InterruptFuncs			*inter0);

	A_Err	(*AEIO_EndAdding)(
		AEIO_BasicData		*basic_dataP,
		AEIO_OutSpecH		outH, 
		A_long				flags);

	A_Err	(*AEIO_OutputFrame)(
		AEIO_BasicData			*basic_dataP,
		AEIO_OutSpecH			outH, 
		const PF_EffectWorld	*wP);

	A_Err	(*AEIO_WriteLabels)(
		AEIO_BasicData		*basic_dataP,
		AEIO_OutSpecH		outH, 
		AEIO_LabelFlags		*written);

	A_Err	(*AEIO_GetSizes)(
		AEIO_BasicData		*basic_dataP,
		AEIO_OutSpecH		outH, 
		A_u_longlong		*free_space, 
		A_u_longlong		*file_size);

	A_Err	(*AEIO_Flush)(
		AEIO_BasicData		*basic_dataP,
		AEIO_OutSpecH		outH);

	A_Err	(*AEIO_AddSoundChunk)(
		AEIO_BasicData		*basic_dataP,
		AEIO_OutSpecH		outH, 
		const A_Time		*start, 
		A_u_long			num_samplesLu,
		const void			*dataPV);

	A_Err	(*AEIO_Idle)(
		AEIO_BasicData			*basic_dataP,
		AEIO_ModuleSignature	sig,
		AEIO_IdleFlags			*idle_flags0);		/* >> */

	A_Err	(*AEIO_GetDepths)(
		AEIO_BasicData			*basic_dataP,
		AEIO_OutSpecH			outH, 
		AEIO_SupportedDepthFlags		*which);

	A_Err	(*AEIO_GetOutputSuffix)(
		AEIO_BasicData			*basic_dataP,
		AEIO_OutSpecH			outH, 
		A_char					*suffix);

	A_Err	(*AEIO_SeqOptionsDlg)(
		AEIO_BasicData			*basic_dataP,
		AEIO_InSpecH			inH,  
		A_Boolean				*user_interactedPB0);

	A_Err	(*AEIO_GetNumAuxChannels)(
		AEIO_BasicData			*basic_dataP,
		AEIO_InSpecH			inH,
		A_long					*num_channelsPL);

	A_Err	(*AEIO_GetAuxChannelDesc)(
		AEIO_BasicData			*basic_dataP,	
		AEIO_InSpecH			inH,
		A_long					chan_indexL,
		PF_ChannelDesc			*descP);

	A_Err	(*AEIO_DrawAuxChannel)(
		AEIO_BasicData			*basic_dataP,
		AEIO_InSpecH			inH,
		A_long					chan_indexL,
		const AEIO_DrawFramePB	*pbP,
		PF_ChannelChunk			*chunkP);

	A_Err	(*AEIO_FreeAuxChannel)(	
		AEIO_BasicData			*basic_dataP,
		AEIO_InSpecH			inH,
		PF_ChannelChunk			*chunkP);

	A_Err	(*AEIO_NumAuxFiles)(	
		AEIO_BasicData			*basic_dataP,	
		AEIO_InSpecH			seqH,
		A_long					*files_per_framePL0);

	A_Err	(*AEIO_GetNthAuxFileSpec)(
		AEIO_BasicData			*basic_dataP,
		AEIO_InSpecH			seqH,
		A_long					frame_numL, 
		A_long					n,
		AEGP_MemHandle			*pathPH);			// << handle of A_UTF16Char (contains null terminated UTF16 string); must be disposed with AEGP_FreeMemHandle 

	A_Err	(*AEIO_CloseSourceFiles)(
		AEIO_BasicData			*basic_dataP,
		AEIO_InSpecH			seqH);

	A_Err	(*AEIO_CountUserData)(
		AEIO_BasicData			*basic_dataP,
		AEIO_InSpecH			inH,
		A_u_long 				typeLu,
		A_u_long				max_sizeLu,
		A_u_long				*num_of_typePLu);

	A_Err	(*AEIO_SetUserData)(    
		AEIO_BasicData			*basic_dataP,
		AEIO_OutSpecH			outH,
		A_u_long				typeLu,
		A_u_long				indexLu,
		const AEIO_Handle		dataH);

	A_Err	(*AEIO_GetUserData)(  
		AEIO_BasicData			*basic_dataP, 
		AEIO_InSpecH			inH,
		A_u_long 				typeLu,
		A_u_long				indexLu,
		A_u_long				max_sizeLu,
		AEIO_Handle				*dataPH);

	A_Err	(*AEIO_AddMarker)(	
		AEIO_BasicData			*basic_dataP,	
		AEIO_OutSpecH 			outH, 
		A_long 					frame_index, 
		AEIO_MarkerType 		marker_type, 
		void					*marker_dataPV, 
		AEIO_InterruptFuncs		*inter0);

	A_Err	(*AEIO_VerifyFileImportable)(
		AEIO_BasicData			*basic_dataP,
		AEIO_ModuleSignature	sig, 
		const A_UTF16Char	*	file_pathZ,		// Null terminated UTF16 string with platform separators
		A_Boolean				*importablePB);	

	A_Err	(*AEIO_UserAudioOptionsDialog)(
		AEIO_BasicData		*basic_dataP,
		AEIO_OutSpecH		outH, 
		A_Boolean			*user_interacted0);

	A_Err	(*AEIO_AddMarker2)(	
		AEIO_BasicData			*basic_dataP,	
		AEIO_OutSpecH 			outH, 
		A_long 					frame_index, 
		const AEIO_Marker		*markerP, 
		AEIO_InterruptFuncs		*inter0);

	A_Err	(*AEIO_AddMarker3)(	
		AEIO_BasicData			*basic_dataP,	
		AEIO_OutSpecH 			outH, 
		A_long 					frame_index, 
		AEGP_ConstMarkerValP 	marker_valP,
		AEIO_RenderMarkerFlag	marker_flag,
		AEIO_InterruptFuncs		*inter0);
		
	A_Err	(*AEIO_GetMimeType)(
		AEIO_BasicData	*basic_dataP,
		AEIO_OutSpecH	outH,
		A_long			mime_type_sizeL,
		char			*mime_typeZ);

} AEIO_FunctionBlock4;

#ifdef __cplusplus
	}
#endif

#include <adobesdk/config/PostConfig.h>

#endif

```

---

<h2>Begin File: AE_IO_FileExt.h</h2>

```cpp
/*******************************************************************/
/*                                                                 */
/*                      ADOBE CONFIDENTIAL                         */
/*                   _ _ _ _ _ _ _ _ _ _ _ _ _                     */
/*                                                                 */
/* Copyright 2007 Adobe Systems Incorporated                       */
/* All Rights Reserved.                                            */
/*                                                                 */
/* NOTICE:  All information contained herein is, and remains the   */
/* property of Adobe Systems Incorporated and its suppliers, if    */
/* any.  The intellectual and technical concepts contained         */
/* herein are proprietary to Adobe Systems Incorporated and its    */
/* suppliers and may be covered by U.S. and Foreign Patents,       */
/* patents in process, and are protected by trade secret or        */
/* copyright law.  Dissemination of this information or            */
/* reproduction of this material is strictly forbidden unless      */
/* prior written permission is obtained from Adobe Systems         */
/* Incorporated.                                                   */
/*                                                                 */
/*******************************************************************/

#ifndef _AEIO_FileExt_Public_H
#define _AEIO_FileExt_Public_H

#include <A.h>

typedef struct {
	A_char	pad;				// constant: always '.'
	A_char	extension[3];
} AEIO_FileExt;

#endif	//	_AEIO_FileExt_Public_H

```

---

<h2>Begin File: AE_Macros.h</h2>

```cpp
/*******************************************************************/
/*                                                                 */
/*                      ADOBE CONFIDENTIAL                         */
/*                   _ _ _ _ _ _ _ _ _ _ _ _ _                     */
/*                                                                 */
/* Copyright 1999 Adobe Systems Incorporated                       */
/* All Rights Reserved.                                            */
/*                                                                 */
/* NOTICE:  All information contained herein is, and remains the   */
/* property of Adobe Systems Incorporated and its suppliers, if    */
/* any.  The intellectual and technical concepts contained         */
/* herein are proprietary to Adobe Systems Incorporated and its    */
/* suppliers and may be covered by U.S. and Foreign Patents,       */
/* patents in process, and are protected by trade secret or        */
/* copyright law.  Dissemination of this information or            */
/* reproduction of this material is strictly forbidden unless      */
/* prior written permission is obtained from Adobe Systems         */
/* Incorporated.                                                   */
/*                                                                 */
/*******************************************************************/
/**	AE_Macros.h
	
	Part of the Adobe After Effects 4.0 SDK.
	Copyright 1998 Adobe Systems Incorporated.
	All Rights Reserved.
	
	REVISION HISTORY	
		06/12/96	bsa		Updated for After Effects 3.1
		04/06/97	bsa		Updated for After Effects 3.1 Windows version
		03/01/99	bbb		Added DH.

**/

#ifndef _H_AE_MACROS
#define _H_AE_MACROS

#include "A.h"

#include <string.h>

#ifndef ERR
	#define ERR(FUNC)	do { if (!err) { err = (FUNC); } } while (0)
#endif

#ifndef ERR2
	#define ERR2(FUNC)	do { if (((err2 = (FUNC)) != A_Err_NONE) && !err) err = err2; } while (0)
#endif

#ifndef AEFX_CLR_STRUCT
	#define AEFX_CLR_STRUCT(STRUCT) memset(&(STRUCT), 0, sizeof(STRUCT));
#endif

#ifndef DH
#define DH(h)				(*(h))
#endif

#define FIX2INT(X)				((A_long)(X) >> 16)
#define INT2FIX(X)				((A_long)(X) << 16)
#define FIX2INT_ROUND(X)		(FIX2INT((X) + 32768))
#define	FIX_2_FLOAT(X)			((A_FpLong)(X) / 65536.0)
#define	FLOAT2FIX(F)			((PF_Fixed)((F) * 65536 + (((F) < 0) ? -0.5 : 0.5)))

// These are already defined if using Objective-C
#ifndef ABS
	#define ABS(N)					((N) < 0 ? -(N) : (N))
#endif

#ifndef MIN
	#define MIN(A,B)				((A) < (B) ? (A) : (B))
#endif

#ifndef MAX
	#define MAX(A, B)				((A) > (B) ? (A) : (B))
#endif

#define A_Fixed_ONE					((A_Fixed)0x00010000L)
#define A_Fixed_HALF				((A_Fixed)0x00008000L)

#define	PF_RECT_2_FIXEDRECT(R,FR)	do {	\
	(FR).left = INT2FIX((R).left);			\
	(FR).top = INT2FIX((R).top);			\
	(FR).right = INT2FIX((R).right);		\
	(FR).bottom = INT2FIX((R).bottom);		\
	} while (0)

#define	PF_FIXEDRECT_2_RECT(FR,R)	do {			\
	(R).left = (A_short)FIX2INT_ROUND((FR).left);		\
	(R).top  = (A_short)FIX2INT_ROUND((FR).top);		\
	(R).right = (A_short)FIX2INT_ROUND((FR).right);	\
	(R).bottom = (A_short)FIX2INT_ROUND((FR).bottom);	\
	} while (0)

#define CONVERT8TO16(A)		( (((long)(A) * PF_MAX_CHAN16) + PF_HALF_CHAN8) / PF_MAX_CHAN8 )

#define	RATIO2FLOAT(R)		(A_FpLong)((A_FpLong)(R).num / ((A_FpLong)(R).den))

#endif		// _H_AX_MACROS

```

---

<h2>Begin File: AE_PluginData.h</h2>

```cpp
/*******************************************************************/
/*                                                                 */
/*                      ADOBE CONFIDENTIAL                         */
/*                   _ _ _ _ _ _ _ _ _ _ _ _ _                     */
/*                                                                 */
/* Copyright 2017 Adobe Systems Incorporated                       */
/* All Rights Reserved.                                            */
/*                                                                 */
/* NOTICE:  All information contained herein is, and remains the   */
/* property of Adobe Systems Incorporated and its suppliers, if    */
/* any.  The intellectual and technical concepts contained         */
/* herein are proprietary to Adobe Systems Incorporated and its    */
/* suppliers and may be covered by U.S. and Foreign Patents,       */
/* patents in process, and are protected by trade secret or        */
/* copyright law.  Dissemination of this information or            */
/* reproduction of this material is strictly forbidden unless      */
/* prior written permission is obtained from Adobe Systems         */
/* Incorporated.                                                   */
/*                                                                 */
/*******************************************************************/


#ifndef	_H_AE_PLUGIN_DATA
#define	_H_AE_PLUGIN_DATA

#ifdef A_INTERNAL
	#include "PF_Private.h"
#endif

#include "A.h"

#include <adobesdk/config/PreConfig.h>

#ifdef __cplusplus
	extern "C" {
#endif

typedef struct PF_PluginData * PF_PluginDataPtr;


////////////////////////////////////////////////////////////////
//
// Version 2 of the plugin entry point
//   - adds 'inSupportURLPtr' to plugin data callback
//
////////////////////////////////////////////////////////////////


typedef A_Err (*PF_PluginDataCB2)(
                                    // The same plugin data pointer that was sent in the entry point
                                    PF_PluginDataPtr   inPtr,
                                    const A_u_char*  inNamePtr,
                                    const A_u_char*  inMatchNamePtr,
                                    const A_u_char*  inCategoryPtr,
                                    const A_u_char*  inEntryPointNamePtr,
                                    // Type of plugin ( VFlt,eFKT ,8BFM)
                                    A_long        inkind,
                                    // If the kind is eFKT, this argument must be PF_AE_PLUG_IN_VERSION
                                    A_long		  inApiVersionMajor,
                                    // If the kind is eFKT, this argument must be PF_AE_PLUG_IN_SUBVERS
                                    A_long		  inApiVersionMinor,
                                    A_long        inReservedInfo,
									const A_u_char*	 inSupportURLPtr			// newly added
                                    ) ;


/*
 * This is the Entry point function signature that must be implemented by the plugin
 * Name of the function must be PluginDataEntryFunction2
*/
typedef A_Err (*PluginDataEntryFunction2Ptr)(
                                            // An opaque pointer, which must be sent as an argument in the callback
                                            PF_PluginDataPtr inPtr,
                                            // Callback function pointer
                                            PF_PluginDataCB2 inPluginDataCallBackPtr,
                                            // SPBasicSuite function pointer
                                            struct SPBasicSuite* inSPBasicSuitePtr,
                                            // Name of the host application which is invoking the plugin
                                            const char* inHostName,
                                            // Exact version of the  host application  e.x. 10.1.3
                                            const char* inHostVersion
                                            );



////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//////////////////// OLDER VERSIONS ///////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////
//
// Version 1 of the plugin entry point
//
////////////////////////////////////////////////////////////////

typedef A_Err (*PF_PluginDataCB)(
                                    // The same plugin data pointer that was sent in the entry point
                                    PF_PluginDataPtr   inPtr,
                                    const A_u_char*  inNamePtr,
                                    const A_u_char*  inMatchNamePtr,
                                    const A_u_char*  inCategoryPtr,
                                    const A_u_char*  inEntryPointNamePtr,
                                    // Type of plugin ( VFlt,eFKT ,8BFM)
                                    A_long        inkind,
                                    // If the kind is eFKT, this argument must be PF_AE_PLUG_IN_VERSION
                                    A_long		  inApiVersionMajor,
                                    // If the kind is eFKT, this argument must be PF_AE_PLUG_IN_SUBVERS
                                    A_long		  inApiVersionMinor,
                                    A_long        inReservedInfo
                                    ) ;

/*
 * This is the Entry point function signature that must be implemented by the plugin
 * Name of the function must be PluginDataEntryFunction
*/
typedef A_Err (*PluginDataEntryFunctionPtr)(
                                            // An opaque pointer, which must be sent as an argument in the callback
                                            PF_PluginDataPtr inPtr,
                                            // Callback function pointer
                                            PF_PluginDataCB inPluginDataCallBackPtr,
                                            // SPBasicSuite function pointer
                                            struct SPBasicSuite* inSPBasicSuitePtr,
                                            // Name of the host application which is invoking the plugin
                                            const char* inHostName,
                                            // Exact version of the  host application  e.x. 10.1.3
                                            const char* inHostVersion
                                            );



#ifdef __cplusplus
}		// end extern "C"
#endif



#include <adobesdk/config/PostConfig.h>


#endif /* _H_AE_PLUGIN_DATA */

```

---

<h2>Begin File: FIEL_Public.h</h2>

```cpp
#ifndef _H_FIEL_PUBLIC
#define _H_FIEL_PUBLIC

/*	FIEL_Public.h
	
	(c) 1993 CoSA
	
	The purpose of this header is to define a standard way to communicate interlace information
	within common image file formats. The FIEL_Label structure should be included as a
	user data of type 'FIEL' of a QuickTime movie, and as 'FIEL' resouce 128 in an
	image or animation file.
	
	The FIEL_Label structure may also be appended to the end of an ImageDescription if the creator
	is unable to add the resource or user data. Only the first FIEL_Label in the movie may be
	honored, however. If a sequence of frames is composed of multiple files, the FIEL_Label from only
	the first frame may be honored. In a QuickTime movie, the first user data item (index 1) will be honored.
	
	If the version is increased, to preserve backward compatibility we will only add types
	to the existing fields or add to the end of the FIEL_Label structure.

	***	Please note that most applications will only support interlaced full-height frames. The other
	***	formats are included so the spec is as general as possible. If you choose to store field-rendered
	***	video in one of the other formats it may not be de-interlaced properly by most applications.

	CoSA After Effects 1.0/1.1 outputs FIEL_Label version 0, with the obsolete tag 'Fiel' (not 'FIEL').
	The struct has a short version (set to 0) followed by a std::int32_t type that is 0 if field rendered, 1
	if upper field is first, and 2 if lower field is first. All field rendered frames output from
	AE 1.0/1.1 are interlaced.
	
	Future versions of CoSA After Effects will label all output with a version 1 or higher FIEL_Label.
	
*/

#include <stdint.h>

#define		FIEL_Label_VERSION		1

#define		FIEL_Tag				'FIEL'		// use as udata and resource type
#define		FIEL_ResID				128


enum {
	FIEL_Type_FRAME_RENDERED	= 0,		// FIEL_Order is irrelevant
	FIEL_Type_INTERLACED		= 1,
	FIEL_Type_HALF_HEIGHT		= 2,
	FIEL_Type_FIELD_DOUBLED		= 3,		// 60 full size field-doubled frames/sec
	FIEL_Type_UNSPECIFIED		= 4			// do not use!
};
typedef uint32_t	FIEL_Type;


/*
	If the frames are interlaced, the following structure tells which of the interlaced fields is
	temporally first. If the frames are not interlaced but the animation was field rendered 
	(i.e. half height or field doubled), the structure tells which field the first sample (if the
	label is attached to a multi-sample file like a QT movie) or the current sample (if the label is
	attached to a single sample like a PICT file) contains.
*/

enum {
	FIEL_Order_UPPER_FIRST		= 0,
	FIEL_Order_LOWER_FIRST		= 1
};
typedef uint32_t	FIEL_Order;

#pragma pack(push, CoSAalign, 2)
	typedef struct {
		uint32_t	signature;		// always FIEL_Tag
		int16_t			version;
		FIEL_Type		type;
		FIEL_Order		order;
		uint32_t	reserved;
	} FIEL_Label;
	#if	defined(A_INTERNAL) && defined(__cplusplus)
		#include "AE_StructSizeAssert.h"
		AE_STRUCT_SIZE_ASSERT(FIEL_Label, 18);
	#endif

#pragma pack(pop, CoSAalign)

#endif

```

---

<h2>Begin File: Mach-O_prefix.h</h2>

```cpp
#define __MACH__ 1
```

---

<h2>Begin File: PF_Masks.h</h2>

```cpp
/* PF_Masks.h */


#ifndef H_PF_MASKS
#define H_PF_MASKS

#include <A.h>
#include <AE_Effect.h>
#include <SPBasic.h>
#include <AE_EffectSuites.h>


#pragma pack( push, 2 )

#define PF_MASKS_MAJOR_VERSION			1
#define PF_MASKS_MINOR_VERSION			0

#ifdef __cplusplus
	extern "C" {
#endif


#define kPF_MaskSuite				"AEGP Mask Suite"
#define kPF_MaskSuiteVersion1		1

typedef struct PF_MaskSuite1 {

	SPAPI A_Err (*PF_MaskWorldWithPath)(
			PF_ProgPtr			effect_ref,
			PF_PathOutlinePtr	*mask,			/* >> */
			PF_FpLong			feather_x,		/* >> */
			PF_FpLong			feather_y,		/* >> */	
			PF_Boolean			invert,			/* >> */
			PF_FpLong			opacity,		/* >> 0...1 */
			PF_Quality			quality,		/* >> */
			PF_EffectWorld			*worldP,		/* <> */
			PF_Rect				*bboxPR0);		/* >> */
				
} PF_MaskSuite1;

#ifdef __cplusplus
}		// end extern "C"
#endif


#pragma pack( pop )


#endif /* H_PH_MASKS */
```

---

<h2>Begin File: PrSDKAESupport.h</h2>

```cpp
/*******************************************************************/
/*                                                                 */
/*                      ADOBE CONFIDENTIAL                         */
/*                   _ _ _ _ _ _ _ _ _ _ _ _ _                     */
/*                                                                 */
/* Copyright 2002 Adobe Systems Incorporated                       */
/* All Rights Reserved.                                            */
/*                                                                 */
/* NOTICE:  All information contained herein is, and remains the   */
/* property of Adobe Systems Incorporated and its suppliers, if    */
/* any.  The intellectual and technical concepts contained         */
/* herein are proprietary to Adobe Systems Incorporated and its    */
/* suppliers and may be covered by U.S. and Foreign Patents,       */
/* patents in process, and are protected by trade secret or        */
/* copyright law.  Dissemination of this information or            */
/* reproduction of this material is strictly forbidden unless      */
/* prior written permission is obtained from Adobe Systems         */
/* Incorporated.                                                   */
/*                                                                 */
/*******************************************************************/

#ifndef PRSDKAESUPPORT_H
#define PRSDKAESUPPORT_H

#ifdef PREMIERE_INTERNAL

#ifndef PRSDKTYPES_H
#include "PrSDKTypes.h"
#endif

#ifndef	PRSDKTIMESUITE_H
#include "PrSDKTimeSuite.h"
#endif

#endif

#ifndef PRSDKPIXELFORMAT_H
#include "PrSDKPixelFormat.h" 
#endif

#ifdef	_WIN32
// Required for AE Stuff
#ifndef MSWindows
#define MSWindows 1
#endif
#endif

#ifndef _H_AE_Effect
#include "AE_Effect.h"
#endif

#ifndef _H_AE_EffectCB
#include "AE_EffectCB.h"
#endif

#ifndef PREMIERE_INTERNAL
#ifndef csSDK_uint32
typedef unsigned int csSDK_uint32;
typedef int csSDK_int32;

#ifdef AE_OS_WIN
typedef signed __int64 csSDK_int64;
#elif defined AE_OS_MAC
typedef int64_t csSDK_int64;
#endif

typedef csSDK_int64 prInt64;
typedef csSDK_int32 prFieldType;
typedef csSDK_int32 PrTimelineID;
typedef csSDK_int32 PrClipID;
typedef prInt64 PrTime;
// This is a conflicting redefinition for any host
// other than PPRO because PREMIERE_INTERNAL 
// is not defined for other hosts and PrSDKTypes.h 
// will be included through other headers. 
// We need to fix it. We go ahead and redefine it 
// only if PrSDKTypes.h has not been included.
#ifndef PRSDKTYPES_H
typedef struct
{
     csSDK_int64 opaque[2];
} PrSDKString;
#endif // PRSDKTYPES_H
#endif

enum {
	PF_TimeDisplay_24 = 1,
	PF_TimeDisplay_25,
	PF_TimeDisplay_30Drop,
	PF_TimeDisplay_30NonDrop,
	PF_TimeDisplay_50,
	PF_TimeDisplay_60Drop,
	PF_TimeDisplay_60NonDrop,
	PF_TimeDisplay_NonStandard,
	PF_TimeDisplay_Invalid
};
typedef csSDK_uint32	PF_TimeDisplay;
#endif

#define kPFPixelFormatSuite				"PF Pixel Format Suite"
#define kPFPixelFormatSuiteVersion1		1
#define kPFPixelFormatSuiteVersion		kPFPixelFormatSuiteVersion1

typedef struct PF_PixelFormatSuite
{
	SPAPI PF_Err (*AddSupportedPixelFormat)(
		PF_ProgPtr effect_ref,				/* reference from in_data */
		PrPixelFormat pixelFormat);			/* add a supported pixel format */

	SPAPI PF_Err (*ClearSupportedPixelFormats)(
		PF_ProgPtr effect_ref);				/* reference from in_data */

	// not implemented yet
	SPAPI PF_Err (*NewWorldOfPixelFormat)(
		PF_ProgPtr effect_ref,				/* reference from in_data */
		A_u_long width,
		A_u_long height,
		PF_NewWorldFlags flags,				/* should be pre-cleared to zeroes */
		PrPixelFormat pixelFormat,
		PF_EffectWorld *world);				/* always 32 bit */
	
	// not implemented yet
	SPAPI PF_Err (*DisposeWorld)(			/* Identical to dispose_world in PF_WorldSuite */
		PF_ProgPtr effect_ref,				/* reference from in_data */
		PF_EffectWorld *world);

	SPAPI PF_Err (*GetPixelFormat)(
		PF_EffectWorld *inWorld,			/* the pixel buffer of interest */
		PrPixelFormat *pixelFormat);		/* one of the above PF_PixelFormat types */

	SPAPI PF_Err (*GetBlackForPixelFormat)(
		PrPixelFormat pixelFormat,
		void* pixelData);

	SPAPI PF_Err (*GetWhiteForPixelFormat)(
		PrPixelFormat pixelFormat,
		void* pixelData);

	SPAPI PF_Err (*ConvertColorToPixelFormattedData)(
		PrPixelFormat pixelFormat,
		float alpha,
		float red,
		float green,
		float blue,
		void* pixelData);
} PF_PixelFormatSuite;

typedef PF_PixelFormatSuite PF_PixelFormatSuite1;

/********** Documentation ***********************************************
AddSupportedPixelFormat()
	During PF_Cmd_GLOBAL_SETUP a plug-in can add the formats it supports. By definition, 
	the 8-bit ARGB pixel format in use today will be the lowest priority, the default and doesn't 
	need to be added.  The default pixel format will be used when the rendering pipeline 
	indicates it would be optimal and minimizes color space conversions.  Within the scope of 
	Premiere, the effect_ref will be a reference to one of the many types of plug-ins (import, 
	compile, export, etc...).

NewWorldOfPixelFormat()
	Since the pixel buffers for some of the formats are very different in structure, an allocator 
	that understands the new formats would be a nice convenience and have some performance benefits.  
	For example, YCbCr(YUV) is often stored planar rather than packed.

DisposeWorld()
	This call is to balance the suite, however it's functionally equivalent to the dispose_world 
	in the PF_WorldSuite or the dispose_world callback in the _PF_UtilCallbacks.  However, all dispose 
	world calls will need to be updated to understand how to dispose of planar pixels.

GetPixelFormat()
	Retrieves the pixel format label of the PF_EffectWorld of interest.

SetPixelFormat()
	Sets the pixel format label of the PF_EffectWorld of interest.  It does not convert the pixels to the 
	format specified.  Perhaps this call doesn't need to be public, as the user will be using the 
	ConvertToPixelFormat() call which will set the format?

ConvertToPixelFormat()
	Used to convert a PF_EffectWorld to another pixel format, such as converting ARGB to YCbCr(YUV).  The 
	function would use built in conversion routines and would account for white and black levels while 
	performing appropriate clipping or scaling.
***********************************************************************/

#define kPFBackgroundFrameSuite				"PF Background Frame Suite"
#define kPFBackgroundFrameSuiteVersion1		1
#define kPFBackgroundFrameSuiteVersion		kPFBackgroundFrameSuiteVersion1

typedef struct PF_BackgroundFrameSuite
{
	SPAPI PF_Err (*AddSupportedBackgroundTransferMode)(
		PF_ProgPtr inEffectRef,						/* reference from in_data */
		PF_TransferMode supportedTransferMode,		/* transfer mode that an effect can use to composite on the background */
		PrPixelFormat supportedPixelFormat);		/* pixel format that the effect can composite with */

	SPAPI PF_Err (*GetBackgroundFrame)(
		PF_ProgPtr inEffectRef,						/* reference from in_data */
		PF_LayerDef** backgroundFrame,				/* the background frame, if any */
		PF_TransferMode* backgroundTransferMode);	/* the transfer mode to be used on the background frame */
} PF_BackgroundFrameSuite;

typedef PF_BackgroundFrameSuite PF_BackgroundFrameSuite1;

/********** Documentation ***********************************************
AddSupportedBackgroundTransferMode
	Called to register support for a transfer mode in a filter.
	The filter must be able to do its effect and composite onto the background.
	
GetBackgroundLayer()
	Get the background layer and the transfer mode.
	If the returned PF_LayerDef* is nil, there is no background frame.
***********************************************************************/

#define kPFUtilitySuite					"PF Utility Suite"
#define kPFUtilitySuiteVersion2			2
#define kPFUtilitySuiteVersion3			3
#define kPFUtilitySuiteVersion4			4
#define kPFUtilitySuiteVersion5			5
#define kPFUtilitySuiteVersion6			6
#define kPFUtilitySuiteVersion7			7
#define kPFUtilitySuiteVersion8			8
#define kPFUtilitySuiteVersion9			9
#define kPFUtilitySuiteVersion			kPFUtilitySuiteVersion9

typedef struct PF_UtilitySuite4
{
	SPAPI PF_Err (*GetFilterInstanceID)(
		PF_ProgPtr effect_ref,
		A_long* outFilterInstanceID);
	SPAPI PF_Err (*GetMediaTimecode)(
		PF_ProgPtr effect_ref,
		A_long* outCurrentFrame,
		PF_TimeDisplay* outTimeDisplay);
	SPAPI PF_Err (*GetClipSpeed)(
		PF_ProgPtr effect_ref,
		double*	speed);
	SPAPI PF_Err (*GetClipDuration)(
		PF_ProgPtr effect_ref,
		A_long* frameDuration);
	SPAPI PF_Err (*GetClipStart)(
		PF_ProgPtr effect_ref,
		A_long* frameDuration);
	SPAPI PF_Err (*GetUnscaledClipDuration)(
		PF_ProgPtr effect_ref,
		A_long* frameDuration);
	SPAPI PF_Err (*GetUnscaledClipStart)(
		PF_ProgPtr effect_ref,
		A_long* frameDuration);
	SPAPI PF_Err (*GetTrackItemStart)(
		PF_ProgPtr effect_ref,
		A_long* frameDuration);
	SPAPI PF_Err (*GetMediaFieldType)(
		PF_ProgPtr effect_ref,
		prFieldType* outFieldType);
	SPAPI PF_Err (*GetMediaFrameRate)(
		PF_ProgPtr effect_ref,
		PrTime* outTicksPerFrame);
	SPAPI PF_Err (*GetContainingTimelineID)(
		PF_ProgPtr effect_ref,
		PrTimelineID* outTimelineID);
	SPAPI PF_Err (*GetClipName)(
		PF_ProgPtr effect_ref,
		PrSDKString * outSDKString);
	SPAPI PF_Err (*EffectWantsCheckedOutFramesToMatchRenderPixelFormat)(
		PF_ProgPtr effect_ref);
} PF_UtilitySuite4;

typedef struct PF_UtilitySuite
{
	SPAPI PF_Err (*GetFilterInstanceID)(
		PF_ProgPtr effect_ref,
		A_long* outFilterInstanceID);
	SPAPI PF_Err	(*GetMediaTimecode)(
		PF_ProgPtr effect_ref,
		A_long* outCurrentFrame,
		PF_TimeDisplay* outTimeDisplay);
	SPAPI PF_Err (*GetClipSpeed)(
		PF_ProgPtr effect_ref,
		double*	speed);
	SPAPI PF_Err (*GetClipDuration)(
		PF_ProgPtr effect_ref,
		A_long* frameDuration);
	SPAPI PF_Err (*GetClipStart)(
		PF_ProgPtr effect_ref,
		A_long* frameDuration);
	SPAPI PF_Err (*GetUnscaledClipDuration)(
		PF_ProgPtr effect_ref,
		A_long* frameDuration);
	SPAPI PF_Err (*GetUnscaledClipStart)(
		PF_ProgPtr effect_ref,
		A_long* frameDuration);
	SPAPI PF_Err (*GetTrackItemStart)(
		PF_ProgPtr effect_ref,
		A_long* frameDuration);
	SPAPI PF_Err (*GetMediaFieldType)(
		PF_ProgPtr effect_ref,
		prFieldType* outFieldType);
	SPAPI PF_Err (*GetMediaFrameRate)(
		PF_ProgPtr effect_ref,
		PrTime* outTicksPerFrame);
	SPAPI PF_Err (*GetContainingTimelineID)(
		PF_ProgPtr effect_ref,
		PrTimelineID* outTimelineID);
	SPAPI PF_Err	(*GetClipName)(
		PF_ProgPtr effect_ref,
		A_Boolean inGetMasterClipName,
		PrSDKString * outSDKString);
	SPAPI PF_Err (*EffectWantsCheckedOutFramesToMatchRenderPixelFormat)(
		PF_ProgPtr effect_ref);
	SPAPI PF_Err (*EffectDependsOnClipName)(
		PF_ProgPtr effect_ref,
		A_Boolean inDependsOnClipName);
	SPAPI PF_Err (*SetEffectInstanceName)(
		PF_ProgPtr effect_ref,
		const PrSDKString* inSDKString);
	SPAPI PF_Err (*GetFileName)(
		PF_ProgPtr effect_ref,
		PrSDKString* outSDKString);
	SPAPI PF_Err (*GetOriginalClipFrameRate)(
		PF_ProgPtr effect_ref,
		PrTime* outTicksPerFrame);
	SPAPI PF_Err (*GetSourceTrackMediaTimecode)(
		PF_ProgPtr effect_ref,
		csSDK_uint32 inLayerParamIndex,
		bool inApplyTransform,
		bool inAddStartTimeOffset,
		A_long* outCurrentFrame);
	SPAPI PF_Err (*GetSourceTrackClipName)(
		PF_ProgPtr effect_ref,
		csSDK_uint32 inLayerParamIndex,
		A_Boolean inGetMasterClipName,
		PrSDKString* outSDKString);
	SPAPI PF_Err (*GetSourceTrackFileName)(
		PF_ProgPtr effect_ref,
		csSDK_uint32 inLayerParamIndex,
		PrSDKString* outSDKString);
	SPAPI PF_Err (*EffectDependsOnClipName2)(
		PF_ProgPtr effect_ref,
		A_Boolean inDependsOnClipName,
		csSDK_uint32 inLayerParamIndex);
	SPAPI PF_Err (*GetMediaTimecode2)(
		PF_ProgPtr effect_ref,
		bool inApplyTrim,
		A_long* outCurrentFrame,
		PF_TimeDisplay* outTimeDisplay);
	SPAPI PF_Err (*GetSourceTrackMediaTimecode2)(
		PF_ProgPtr effect_ref,
		csSDK_uint32 inLayerParamIndex,
		bool inApplyTransform,
		bool inAddStartTimeOffset,
		PrTime inSequenceTime,
		A_long* outCurrentFrame);
	SPAPI PF_Err (*GetSourceTrackClipName2)(
		PF_ProgPtr effect_ref,
		csSDK_uint32 inLayerParamIndex,
		A_Boolean inGetMasterClipName,
		PrSDKString* outSDKString,
		PrTime inSequenceTime);
	SPAPI PF_Err (*GetSourceTrackFileName2)(
		PF_ProgPtr effect_ref,
		csSDK_uint32 inLayerParamIndex,
		PrSDKString* outSDKString,
		PrTime inSequenceTime);
	SPAPI PF_Err (*GetCommentString)(
		PF_ProgPtr inEffectRef,
		int32_t inSourceTrack,
		PrTime inSequenceTime,
		PrSDKString* outSDKString);
	SPAPI PF_Err (*GetLogNoteString)(
		PF_ProgPtr inEffectRef,
		int32_t inSourceTrack,
		PrTime inSequenceTime,
		PrSDKString* outSDKString);
	SPAPI PF_Err (*GetCameraRollString)(
		PF_ProgPtr inEffectRef,
		int32_t inSourceTrack,
		PrTime inSequenceTime,
		PrSDKString* outSDKString);
	SPAPI PF_Err (*GetClientMetadataString)(
		PF_ProgPtr inEffectRef,
		int32_t inSourceTrack,
		PrTime inSequenceTime,
		PrSDKString* outSDKString);
	SPAPI PF_Err (*GetDailyRollString)(
		PF_ProgPtr inEffectRef,
		int32_t inSourceTrack,
		PrTime inSequenceTime,
		PrSDKString* outSDKString);
	SPAPI PF_Err (*GetDescriptionString)(
		PF_ProgPtr inEffectRef,
		int32_t inSourceTrack,
		PrTime inSequenceTime,
		PrSDKString* outSDKString);
	SPAPI PF_Err (*GetLabRollString)(
		PF_ProgPtr inEffectRef,
		int32_t inSourceTrack,
		PrTime inSequenceTime,
		PrSDKString* outSDKString);
	SPAPI PF_Err (*GetSceneString)(
		PF_ProgPtr inEffectRef,
		int32_t inSourceTrack,
		PrTime inSequenceTime,
		PrSDKString* outSDKString);
	SPAPI PF_Err (*GetShotString)(
		PF_ProgPtr inEffectRef,
		int32_t inSourceTrack,
		PrTime inSequenceTime,
		PrSDKString* outSDKString);
	SPAPI PF_Err (*GetTapeNameString)(
		PF_ProgPtr inEffectRef,
		int32_t inSourceTrack,
		PrTime inSequenceTime,
		PrSDKString* outSDKString);
	SPAPI PF_Err (*GetVideoCodecString)(
		PF_ProgPtr inEffectRef,
		int32_t inSourceTrack,
		PrTime inSequenceTime,
		PrSDKString* outSDKString);
	SPAPI PF_Err (*GetGoodMetadataString)(
		PF_ProgPtr inEffectRef,
		int32_t inSourceTrack,
		PrTime inSequenceTime,
		PrSDKString* outSDKString);
	SPAPI PF_Err (*GetSoundRollString)(
		PF_ProgPtr inEffectRef,
		int32_t inSourceTrack,
		PrTime inSequenceTime,
		PrSDKString* outSDKString);
	SPAPI PF_Err (*GetSequenceTime)(
		PF_ProgPtr inEffectRef,
		PrTime* outSequenceTime);
	SPAPI PF_Err (*GetSoundTimecode)(
		PF_ProgPtr inEffectRef,
		int32_t inSourceTrack,
		PrTime inSequenceTime,
		A_long*	outCurrentFrame);
	SPAPI PF_Err (*GetOriginalClipFrameRateForSourceTrack)(
		PF_ProgPtr inEffectRef,
		int32_t inSourceTrack,
		PrTime* outTicksPerFrame);
	SPAPI PF_Err (*GetMediaFrameRateForSourceTrack)(
		PF_ProgPtr inEffectRef,
		int32_t inSourceTrack,
		PrTime inSequenceTime,
		PrTime* outTicksPerFrame);
	SPAPI PF_Err (*GetSourceTrackMediaActualStartTime)(
		PF_ProgPtr inEffectRef,
		csSDK_uint32 inLayerParamIndex,
		PrTime inSequenceTime,
		PrTime* outClipActualStartTime);
	SPAPI PF_Err (*IsSourceTrackMediaTrimmed)(
		PF_ProgPtr inEffectRef,
		csSDK_uint32 inLayerParamIndex,
		PrTime inSequenceTime,
		bool* outTrimApplied);
	SPAPI PF_Err (*IsMediaTrimmed)(
		PF_ProgPtr inEffectRef,
		PrTime inSequenceTime,
		bool* outTrimApplied);
	SPAPI PF_Err (*IsTrackEmpty)(
		PF_ProgPtr inEffectRef,
		csSDK_uint32 inLayerParamIndex,
		PrTime inSequenceTime,
		bool* outIsTrackEmpty);
	SPAPI PF_Err (*IsTrackItemEffectAppliedToSynthetic)(
		PF_ProgPtr inEffectRef,
		bool* outIsTrackItemEffectAppliedToSynthetic);
} PF_UtilitySuite;

// Legacy function tables
// Please note that version 4 didn't version the GetClipName API correctly, which is why it needs a separate table. But this was fixed in later versions, and that API didn't exist in prior versions, so all of the rest can use PF_UtilitySuite.
typedef PF_UtilitySuite PF_UtilitySuiteVersion1;
typedef PF_UtilitySuite PF_UtilitySuite2;
typedef PF_UtilitySuite PF_UtilitySuite3;
typedef PF_UtilitySuite4 PF_UtilitySuite4;
typedef PF_UtilitySuite PF_UtilitySuite5;
typedef PF_UtilitySuite PF_UtilitySuite6;
typedef PF_UtilitySuite PF_UtilitySuite7;
typedef PF_UtilitySuite PF_UtilitySuite8;

#define kPFSourceSettingsSuite					"PF Source Settings Suite"
#define kPFSourceSettingsSuiteVersion			1

typedef struct PF_SourceSettingsSuite
{
	SPAPI PF_Err	(*PerformSourceSettingsCommand)(
		PF_ProgPtr effect_ref,
		void * ioCommandStruct,
		csSDK_uint32 inDataSize);

} PF_SourceSettingsSuite;

/********** Documentation ***********************************************
GetFilterInstanceID
	An AE filter running in Premiere can call this method to obtain
	its instance ID from the PF_InData->effect_ref.  The instance ID
	obtained is the same value contained in the prtFilterRec of its RT segment.
GetMediaTimecode
	Returns the starting timecode of the media file.
GetClipSpeed
	Returns the playback rate of the underlying clip in the timeline 
	(negative speed means backwards playback).
GetClipDuration
	Returns the trimmed duration (in frames) of the underlying clip in 
	the timeline.
***********************************************************************/



#define kPFTransitionSuite					"PF Transition Suite"
#define kPFTransitionSuiteVersion1			1
#define kPFTransitionSuiteVersion2			2	// Added RegisterTransitionStartParam and RegisterTransitionEndParam
#define kPFTransitionSuiteVersion			kPFTransitionSuiteVersion2

typedef struct PF_TransitionSuite
{
	/**
	**	Register an effect as a transition using the passed in
	**	input layer as the outgoing clip. When registered the effect
	**	will be available to be dragged directly onto clip ends rather
	**	than only applied to layers.
	*/
	SPAPI PF_Err (*RegisterTransitionInputParam)(
		PF_ProgPtr inEffectRef,
 		PF_ParamIndex inIndex);

	/**
	**	Register a PF_ADD_FLOAT_SLIDER parameter to receive
	**	changes to the start of the transition region through the
	**	PF_Cmd_USER_CHANGED_PARAM command.
	*/
	SPAPI PF_Err (*RegisterTransitionStartParam)(
		PF_ProgPtr inEffectRef,
 		PF_ParamIndex inIndex);

	/**
	**	Register a PF_ADD_FLOAT_SLIDER parameter to receive
	**	changes to the end of the transition region through the
	**	PF_Cmd_USER_CHANGED_PARAM command.
	*/
	SPAPI PF_Err (*RegisterTransitionEndParam)(
		PF_ProgPtr inEffectRef,
 		PF_ParamIndex inIndex);

} PF_TransitionSuite;


#endif // PRSDKAESUPPORT_H


```

---

<h2>Begin File: PrSDKPixelFormat.h</h2>

```cpp
/*******************************************************************/
/*                                                                 */
/*                      ADOBE CONFIDENTIAL                         */
/*                   _ _ _ _ _ _ _ _ _ _ _ _ _                     */
/*                                                                 */
/* Copyright 2002-2023 Adobe Inc.                                  */
/* All Rights Reserved.                                            */
/*                                                                 */
/* NOTICE:  All information contained herein is, and remains the   */
/* property of Adobe Inc. and its suppliers, if                    */
/* any.  The intellectual and technical concepts contained         */
/* herein are proprietary to Adobe Inc. and its                    */
/* suppliers and may be covered by U.S. and Foreign Patents,       */
/* patents in process, and are protected by trade secret or        */
/* copyright law.  Dissemination of this information or            */
/* reproduction of this material is strictly forbidden unless      */
/* prior written permission is obtained from Adobe Inc.            */
/* Incorporated.                                                   */
/*                                                                 */
/*******************************************************************/

#ifndef PRSDKPIXELFORMAT_H
#define PRSDKPIXELFORMAT_H

#ifdef PREMIERE_INTERNAL

#ifndef PRSDKTYPES_H
#include "PrSDKTypes.h"
#endif

#endif

#ifndef MAKE_PIXEL_FORMAT_FOURCC
#define MAKE_PIXEL_FORMAT_FOURCC(ch0, ch1, ch2, ch3)                         		    \
                (static_cast<unsigned int>(static_cast<unsigned char>(ch0)) |				\
                (static_cast<unsigned int>(static_cast<unsigned char>(ch1)) << 8) |       \
                (static_cast<unsigned int>(static_cast<unsigned char>(ch2)) << 16) |		\
                (static_cast<unsigned int>(static_cast<unsigned char>(ch3)) << 24 ))
#endif

/**
**	Premiere supported pixel formats for RenderFrame and PPixs
*/

enum PrPixelFormat
{

/**
**	Currently supported types
*/

// Packed formats
PrPixelFormat_BGRA_4444_8u		= MAKE_PIXEL_FORMAT_FOURCC('b', 'g', 'r', 'a'),		// 4 byte BGRA, standard windows 32 bit pixels (was kPixelFormat_BGRA32)
PrPixelFormat_VUYA_4444_8u		= MAKE_PIXEL_FORMAT_FOURCC('v', 'u', 'y', 'a'),		// 4 byte VUYA (was kPixelFormat_VUYA32)
PrPixelFormat_VUYA_4444_8u_709		= MAKE_PIXEL_FORMAT_FOURCC('V', 'U', 'Y', 'A'),		// 4 byte VUYA (was kPixelFormat_VUYA32)
PrPixelFormat_ARGB_4444_8u		= MAKE_PIXEL_FORMAT_FOURCC('a', 'r', 'g', 'b'),		// 4 byte ARGB (the format used by AE) (was kPixelFormat_ARGB32)

PrPixelFormat_BGRX_4444_8u		= MAKE_PIXEL_FORMAT_FOURCC('b', 'g', 'r', 'x'),		// 4 byte BGRX
PrPixelFormat_VUYX_4444_8u		= MAKE_PIXEL_FORMAT_FOURCC('v', 'u', 'y', 'x'),		// 4 byte VUYX 
PrPixelFormat_VUYX_4444_8u_709		= MAKE_PIXEL_FORMAT_FOURCC('v', 'u', 'x', '7'),		// 4 byte VUYX 
PrPixelFormat_XRGB_4444_8u		= MAKE_PIXEL_FORMAT_FOURCC('x', 'r', 'g', 'b'),		// 4 byte XRGB 
																										   
PrPixelFormat_BGRP_4444_8u		= MAKE_PIXEL_FORMAT_FOURCC('b', 'g', 'r', 'p'),		// 4 byte BGRP
PrPixelFormat_VUYP_4444_8u		= MAKE_PIXEL_FORMAT_FOURCC('v', 'u', 'y', 'p'),		// 4 byte VUYP 
PrPixelFormat_VUYP_4444_8u_709		= MAKE_PIXEL_FORMAT_FOURCC('v', 'u', 'p', '7'),		// 4 byte VUYP
PrPixelFormat_PRGB_4444_8u		= MAKE_PIXEL_FORMAT_FOURCC('p', 'r', 'g', 'b'),		// 4 byte PRGB 

PrPixelFormat_BGRA_4444_16u		= MAKE_PIXEL_FORMAT_FOURCC('B', 'g', 'r', 'a'),		// 16 bit integer per component BGRA
PrPixelFormat_VUYA_4444_16u		= MAKE_PIXEL_FORMAT_FOURCC('V', 'u', 'y', 'a'),		// 16 bit integer per component VUYA
PrPixelFormat_ARGB_4444_16u		= MAKE_PIXEL_FORMAT_FOURCC('A', 'r', 'g', 'b'),		// 16 bit integer per component ARGB 

PrPixelFormat_BGRX_4444_16u		= MAKE_PIXEL_FORMAT_FOURCC('B', 'g', 'r', 'x'),		// 16 bit integer per component BGRX
PrPixelFormat_XRGB_4444_16u		= MAKE_PIXEL_FORMAT_FOURCC('X', 'r', 'g', 'b'),		// 16 bit integer per component XRGB 

PrPixelFormat_BGRP_4444_16u		= MAKE_PIXEL_FORMAT_FOURCC('B', 'g', 'r', 'p'),		// 16 bit integer per component BGRP
PrPixelFormat_PRGB_4444_16u		= MAKE_PIXEL_FORMAT_FOURCC('P', 'r', 'g', 'b'),		// 16 bit integer per component PRGB 

PrPixelFormat_BGRA_4444_32f		= MAKE_PIXEL_FORMAT_FOURCC('B', 'G', 'r', 'a'),		// 32 bit float per component BGRA
PrPixelFormat_VUYA_4444_32f		= MAKE_PIXEL_FORMAT_FOURCC('V', 'U', 'y', 'a'),		// 32 bit float per component VUYA
PrPixelFormat_VUYA_4444_32f_709		= MAKE_PIXEL_FORMAT_FOURCC('v', 'U', 'Y', 'a'),		// 32 bit float per component VUYA
PrPixelFormat_ARGB_4444_32f		= MAKE_PIXEL_FORMAT_FOURCC('A', 'R', 'g', 'b'),		// 32 bit float per component ARGB 

PrPixelFormat_BGRX_4444_32f		= MAKE_PIXEL_FORMAT_FOURCC('B', 'G', 'r', 'x'),		// 32 bit float per component BGRX
PrPixelFormat_VUYX_4444_32f		= MAKE_PIXEL_FORMAT_FOURCC('V', 'U', 'y', 'x'),		// 32 bit float per component VUYX
PrPixelFormat_VUYX_4444_32f_709		= MAKE_PIXEL_FORMAT_FOURCC('V', 'U', 'x', '7'),		// 32 bit float per component VUYX
PrPixelFormat_XRGB_4444_32f		= MAKE_PIXEL_FORMAT_FOURCC('X', 'R', 'g', 'b'),		// 32 bit float per component XRGB 

PrPixelFormat_BGRP_4444_32f		= MAKE_PIXEL_FORMAT_FOURCC('B', 'G', 'r', 'p'),		// 32 bit float per component BGRX
PrPixelFormat_VUYP_4444_32f		= MAKE_PIXEL_FORMAT_FOURCC('V', 'U', 'y', 'p'),		// 32 bit float per component VUYX
PrPixelFormat_VUYP_4444_32f_709		= MAKE_PIXEL_FORMAT_FOURCC('V', 'U', 'p', '7'),		// 32 bit float per component VUYX
PrPixelFormat_PRGB_4444_32f		= MAKE_PIXEL_FORMAT_FOURCC('P', 'R', 'g', 'b'),		// 32 bit float per component XRGB 

PrPixelFormat_RGB_444_10u		= MAKE_PIXEL_FORMAT_FOURCC('R', 'G', 'B', '1'),		// Full range 10-bit 444 RGB little-endian

PrPixelFormat_YUYV_422_8u_601	= MAKE_PIXEL_FORMAT_FOURCC('y', 'u', 'y', '2'),		// 8 bit 422 YUY2 601 colorspace
PrPixelFormat_YUYV_422_8u_709	= MAKE_PIXEL_FORMAT_FOURCC('y', 'u', 'y', '3'),		// 8 bit 422 YUY2 709 colorspace

PrPixelFormat_UYVY_422_8u_601	= MAKE_PIXEL_FORMAT_FOURCC('u', 'y', 'v', 'y'),		// 8 bit 422 UYVY 601 colorspace
PrPixelFormat_UYVY_422_8u_709	= MAKE_PIXEL_FORMAT_FOURCC('u', 'y', 'v', '7'),		// 8 bit 422 UYVY 709 colorspace

PrPixelFormat_V210_422_10u_601	= MAKE_PIXEL_FORMAT_FOURCC('v', '2', '1', '0'),		// packed uncompressed 10 bit 422 YUV aka V210 601 colorspace
PrPixelFormat_V210_422_10u_709	= MAKE_PIXEL_FORMAT_FOURCC('v', '2', '1', '1'),		// packed uncompressed 10 bit 422 YUV aka V210 709 colorspace

PrPixelFormat_UYVY_422_32f_601	= MAKE_PIXEL_FORMAT_FOURCC('U', 'Y', 'v', 'y'),
PrPixelFormat_UYVY_422_32f_709	= MAKE_PIXEL_FORMAT_FOURCC('U', 'Y', 'v', '7'),

PrPixelFormat_BGRA_4444_32f_Linear	= MAKE_PIXEL_FORMAT_FOURCC('B', 'G', 'a', 'L'),	// 32 bit float per component linear BGRA
PrPixelFormat_BGRP_4444_32f_Linear	= MAKE_PIXEL_FORMAT_FOURCC('B', 'G', 'p', 'L'),	// 32 bit float per component linear BGRP
PrPixelFormat_BGRX_4444_32f_Linear	= MAKE_PIXEL_FORMAT_FOURCC('B', 'G', 'x', 'L'),	// 32 bit float per component linear BGRX
PrPixelFormat_ARGB_4444_32f_Linear	= MAKE_PIXEL_FORMAT_FOURCC('A', 'R', 'g', 'L'),	// 32 bit float per component linear ARGB
PrPixelFormat_PRGB_4444_32f_Linear	= MAKE_PIXEL_FORMAT_FOURCC('P', 'R', 'g', 'L'),	// 32 bit float per component linear PRGB
PrPixelFormat_XRGB_4444_32f_Linear	= MAKE_PIXEL_FORMAT_FOURCC('X', 'R', 'g', 'L'),	// 32 bit float per component linear XRGB

PrPixelFormat_RGB_444_12u_PQ_709	= MAKE_PIXEL_FORMAT_FOURCC('@', 'P', 'Q', '7'),	// 12 bit integer (in 16 bit words) per component RGB with PQ curve, Rec.709 primaries
PrPixelFormat_RGB_444_12u_PQ_P3		= MAKE_PIXEL_FORMAT_FOURCC('@', 'P', 'Q', 'P'),	// 12 bit integer (in 16 bit words) per component RGB with PQ curve, P3 primaries
PrPixelFormat_RGB_444_12u_PQ_2020	= MAKE_PIXEL_FORMAT_FOURCC('@', 'P', 'Q', '2'), // 12 bit integer (in 16 bit words) per component RGB with PQ curve, Rec.2020 primaries

// Planar formats
PrPixelFormat_YUV_420_MPEG2_FRAME_PICTURE_PLANAR_8u_601	= MAKE_PIXEL_FORMAT_FOURCC('y', 'v', '1', '2'),		//	YUV with 2x2 chroma subsampling. Planar. (for MPEG-2)
PrPixelFormat_YUV_420_MPEG2_FIELD_PICTURE_PLANAR_8u_601	= MAKE_PIXEL_FORMAT_FOURCC('y', 'v', 'i', '2'),		//	YUV with 2x2 chroma subsampling. Planar. (for MPEG-2)
PrPixelFormat_YUV_420_MPEG2_FRAME_PICTURE_PLANAR_8u_601_FullRange	= MAKE_PIXEL_FORMAT_FOURCC('y', 'v', '1', 'f'),		//	YUV with 2x2 chroma subsampling. Planar. (for MPEG-2)
PrPixelFormat_YUV_420_MPEG2_FIELD_PICTURE_PLANAR_8u_601_FullRange	= MAKE_PIXEL_FORMAT_FOURCC('y', 'v', 'i', 'f'),		//	YUV with 2x2 chroma subsampling. Planar. (for MPEG-2)
PrPixelFormat_YUV_420_MPEG2_FRAME_PICTURE_PLANAR_8u_709	= MAKE_PIXEL_FORMAT_FOURCC('y', 'v', '1', '7'),		//	YUV with 2x2 chroma subsampling. Planar. (for MPEG-2) 709 colorspace
PrPixelFormat_YUV_420_MPEG2_FIELD_PICTURE_PLANAR_8u_709	= MAKE_PIXEL_FORMAT_FOURCC('y', 'v', 'i', '7'),		//	YUV with 2x2 chroma subsampling. Planar. (for MPEG-2) 709 colorspace
PrPixelFormat_YUV_420_MPEG2_FRAME_PICTURE_PLANAR_8u_709_FullRange	= MAKE_PIXEL_FORMAT_FOURCC('y', 'v', '1', 'F'),		//	YUV with 2x2 chroma subsampling. Planar. (for MPEG-2) 709 colorspace
PrPixelFormat_YUV_420_MPEG2_FIELD_PICTURE_PLANAR_8u_709_FullRange	= MAKE_PIXEL_FORMAT_FOURCC('y', 'v', 'i', 'F'),		//	YUV with 2x2 chroma subsampling. Planar. (for MPEG-2) 709 colorspace

PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_PLANAR_8u_601	= MAKE_PIXEL_FORMAT_FOURCC('Y', 'v', '1', '2'),		//	YUV with 2x2 chroma subsampling, center chroma. Planar. 
PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_PLANAR_8u_601	= MAKE_PIXEL_FORMAT_FOURCC('Y', 'v', 'i', '2'),		//	YUV with 2x2 chroma subsampling, center chroma. Planar. 
PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_PLANAR_8u_601_FullRange	= MAKE_PIXEL_FORMAT_FOURCC('Y', 'v', '1', 'f'),		//	YUV with 2x2 chroma subsampling, center chroma. Planar. 
PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_PLANAR_8u_601_FullRange	= MAKE_PIXEL_FORMAT_FOURCC('Y', 'v', 'i', 'f'),		//	YUV with 2x2 chroma subsampling, center chroma. Planar. 
PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_PLANAR_8u_709	= MAKE_PIXEL_FORMAT_FOURCC('Y', 'v', '1', '7'),		//	YUV with 2x2 chroma subsampling, center chroma. Planar. 709 colorspace
PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_PLANAR_8u_709	= MAKE_PIXEL_FORMAT_FOURCC('Y', 'v', 'i', '7'),		//	YUV with 2x2 chroma subsampling, center chroma. Planar. 709 colorspace
PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_PLANAR_8u_709_FullRange	= MAKE_PIXEL_FORMAT_FOURCC('Y', 'v', '1', 'F'),		//	YUV with 2x2 chroma subsampling, center chroma. Planar. 709 colorspace
PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_PLANAR_8u_709_FullRange	= MAKE_PIXEL_FORMAT_FOURCC('Y', 'v', 'i', 'F'),		//	YUV with 2x2 chroma subsampling, center chroma. Planar. 709 colorspace

// Compressed formats
PrPixelFormat_NTSCDV25			= MAKE_PIXEL_FORMAT_FOURCC('d', 'v', 'n', '2'),		//	compressed DV-25
PrPixelFormat_PALDV25			= MAKE_PIXEL_FORMAT_FOURCC('d', 'v', 'p', '2'),		//	compressed DV-25
PrPixelFormat_NTSCDV50			= MAKE_PIXEL_FORMAT_FOURCC('d', 'v', 'n', '5'),
PrPixelFormat_PALDV50			= MAKE_PIXEL_FORMAT_FOURCC('d', 'v', 'p', '5'),
PrPixelFormat_NTSCDV100_720p	= MAKE_PIXEL_FORMAT_FOURCC('d', 'v', 'n', '7'),		//	compressed DV-100 720p, 60 Hz
PrPixelFormat_PALDV100_720p		= MAKE_PIXEL_FORMAT_FOURCC('d', 'v', 'p', '7'),		//	compressed DV-100 720p, 50 Hz
PrPixelFormat_NTSCDV100_1080i	= MAKE_PIXEL_FORMAT_FOURCC('d', 'v', 'n', '1'),		//	compressed DV-100 1080i, 60 Hz
PrPixelFormat_PALDV100_1080i	= MAKE_PIXEL_FORMAT_FOURCC('d', 'v', 'p', '1'),		//	compressed DV-100 1080i, 50 Hz

// Raw, opaque data formats
PrPixelFormat_Raw			= MAKE_PIXEL_FORMAT_FOURCC('r', 'a', 'w', 'w'),		// raw, opaque data, with no row bytes or height.

// Invalid
PrPixelFormat_Invalid		= MAKE_PIXEL_FORMAT_FOURCC('b', 'a', 'd', 'f'),		// invalid pixel format - this is used for intialization and erorr conditions

PrPixelFormat_Any			= 0
};

#define MAKE_ADOBE_PRIVATE_PIXEL_FORMAT_FOURCC(ch1, ch2, ch3) (static_cast<PrPixelFormat>(MAKE_PIXEL_FORMAT_FOURCC('@', ch1, ch2, ch3)))
#define MAKE_THIRD_PARTY_CUSTOM_PIXEL_FORMAT_FOURCC(ch1, ch2, ch3) (static_cast<PrPixelFormat>(MAKE_PIXEL_FORMAT_FOURCC('_', ch1, ch2, ch3)))

#endif // PRSDKPIXELFORMAT_H


```

---

<h2>Begin File: PR_Public.h</h2>

```cpp
#ifndef _PR_Public_H
#define _PR_Public_H

/** PR_Public.h
 ** (C)2005 by Adobe Systems Inc.
 **	Public header that defines the API for plug-in renderers
 **
 ** Plugin renderers are known as artisans. They are AEGP modules which register
 ** themselves with the plug-in render manager when they are loaded at 
 ** program startup. 
 ** Very little is passed to these functions, just an opaque context 
 ** and a handle to previously allocated data. The artisan must query 
 ** for other rendering parameters via AEGP suites. The appropriate 
 ** suites will take one of the opaque rendering contexts as one of their 
 ** parameters. 
 **
 ** The entry points are :
 ** PR_GlobalSetupFunc	
 **		Called at artisan load. If necessary allocate global data that will be shared
 **		among all instances of this type of artisan.
 **
 **	PR_GlobalSetdownFunc 
 **		Called at program termination. Delete the global data if any allocated.
 **
 **	PR_GlobalDoAboutFunc 
 **		Display an about box with revelant information about the artisan
 **
 **		
 **	PR_InstanceSetupFunc
 **		An instance of the artisan is associated with each comp. Each instance has its
 **		own data. It should be allocated within this function.
 **
 **	PR_InstanceSetdownFunc
 **		Delete allocated data if needed.
 **		
 **	PR_FlattenInstanceFunc
 **		Return a flattened platform independent version of the instance data.
 **		This is called when the artisan is being written to disk or a copy of the 
 **		artisan is being made. Do not disturb the src instance handle.
 **		
 **	PR_DoInstanceDialogFunc	
 **		Some artisans may have parameters. They may be set here.
 **	
 **	PR_FrameSetupFunc
 **		Called just berfore render. Allocate the render handle, if needed.
 **
 **	PR_RenderFunc
 **		This is the main rendering function. 
 **
 **	PR_FrameSetdownFunc	
 **		Called just after render. Deallocate the render handle if needed.
 **
 **	PR_Query	
 **		This can be called at any time after Instance Setup. It is used by AE
 **		to inquire about geomertic transforms used by the artisan. AE uses this information
 **		to draw layer handles, and manipulate the layers with a mouse better. 
 **
 **/


#include <A.h>
#include <SPBasic.h>
#include <AE_EffectSuites.h>

#pragma pack( push, 4 )




#ifdef __cplusplus
	extern "C" {
#endif



		
#define PR_FileType_ARTISAN			'ARt'
#define PR_ARTISAN_EXTENSION		".aex"

#define PR_ARTISAN_API_VERSION_MAJOR		1
#define PR_ARTISAN_API_VERSION_MINOR		0


#define PR_PUBLIC_MATCH_NAME_LEN			31
#define PR_PUBLIC_ARTISAN_NAME_LEN			31


/** $$$ move to aegp.h ***/
typedef struct _Up_OpaqueMem			**PR_Handle;
typedef PR_Handle						PR_FlatHandle;
									
typedef PR_Handle						PR_GlobalDataH;				// holds data private to the plug-in
typedef PR_Handle						PR_InstanceDataH;
typedef PR_Handle						PR_RenderDataH;

typedef struct PR_GlobalContext			**PR_GlobalContextH;	// opaque until PR.h
typedef struct PR_InstanceContext		**PR_InstanceContextH;	// opaque until PR.h
typedef struct PR_RenderContext			**PR_RenderContextH;	// opaque until PR.h
typedef struct PR_QueryContext			**PR_QueryContextH;		// opaque until PR.h

typedef struct PF_LayerDef	*PF_EffectWorldPtr;
/**
 ** in data is passed to every pr entry function
 **/
typedef void (*PR_MessageFunc) (A_Err err_number, const A_char *msgA);


typedef struct PR_InData {
	PR_MessageFunc				msg_func;
	const struct SPBasicSuite	*pica_basicP;
	A_long						aegp_plug_id;
	void						*aegp_refconPV;
} PR_InData;





/**
 ** response from dialog box function
 **/
enum {
	PR_DialogResult_NO_CHANGE,
	PR_DialogResult_CHANGE_MADE
};
typedef A_long PR_DialogResult;



/**
 ** The types of queries that will be made.
 **
 **/
enum { 
	PR_QueryType_NONE			= 0,
	PR_QueryType_TRANSFORM,
	PR_QueryType_INTERACTIVE_WINDOW_DISPOSE,
	PR_QueryType_INTERACTIVE_WINDOW_CLEAR,
	PR_QueryType_INTERACTIVE_WINDOW_FROZEN_PROXY,
	PR_QueryType_INTERACTIVE_SWAP_BUFFER,
	PR_QueryType_INTERACTIVE_DRAW_PROCS,
	PR_QueryType_PREPARE_FOR_LINE_DRAWING,
	PR_QueryType_UNPREPARE_FOR_LINE_DRAWING,
	PR_QueryType_GET_CURRENT_CONTEXT_SAFE_FOR_LINE_DRAWING,
	PR_QueryType_GET_ARTISAN_QUALITY,
};

typedef A_u_long	PR_QueryType;


// If this sounds interesting, talk to us
enum {
	PR_ArtisanFeature_NONE  = 0
};
typedef A_long PR_ArtisanFeature_Flags;


/**
 ** PR_InstanceSetupFunc flags
 **/
enum {
	PR_InstanceFlags_NONE = 0x0,
	PR_InstanceFlags_DUPLICATE
};

typedef A_u_long PR_InstanceFlags;


/***********************   plugin entry points  *****************************
 ** the main routine of each plugin fills in these function pointers
 ** AE will call them as appropriate
 ****************************************************************************/



/**
 ** called after main. This happens just once, after the plugin is loaded.
 ** The global data is common across all instances of the plugin
 **/
typedef	A_Err	(*PR_GlobalSetupFunc)(	const PR_InData				*in_dataP,				/* >> */
										PR_GlobalContextH			global_contextH,		/* >> */
										PR_GlobalDataH				*global_dataPH);		/* << */

/**
 ** dispose of the global data
 **/
typedef	A_Err	(*PR_GlobalSetdownFunc)(	const PR_InData			*in_dataP,			/* >> */
											PR_GlobalContextH		global_contextH,	/* >> */
											PR_GlobalDataH			global_dataH);		/* <> */ // must be disposed by plugin


/**
 ** display an about box
 **/
typedef A_Err	(*PR_GlobalDoAboutFunc)(	const PR_InData			*in_dataP,			/* >> */
											PR_GlobalContextH		global_contextH,	/* >> */
											PR_GlobalDataH			global_dataH);		/* <> */



/**
 ** Analogous to an Effect's Sequence setup call. This sets up the renderer's
 ** instance data. 
 **/
typedef	A_Err	(*PR_InstanceSetupFunc)(
										const PR_InData			*in_dataP,					/* >> */
										PR_GlobalContextH		global_contextH,			/* >> */
										PR_InstanceContextH		instance_contextH,			/* >> */
										PR_GlobalDataH			global_dataH,				/* >> */
										PR_InstanceFlags		flags,
										PR_FlatHandle			flat_dataH0,				/* >> */
										PR_InstanceDataH		*instance_dataPH);			/* << */


/**
 ** dispose of the instance data
 **/
typedef	A_Err	(*PR_InstanceSetdownFunc)(
										const PR_InData				*in_dataP,			/* >> */
										const PR_GlobalContextH		global_contextH,		/* >> */
										const PR_InstanceContextH	instance_contextH,		/* >> */
										PR_GlobalDataH				global_dataH,			/* >> */
										PR_InstanceDataH			instance_dataH);		/* >> */ // must be disposed by plugin



/**
 ** flatten your data in preparation to being written to disk.
 ** Make sure its OS independent
 **/
typedef	A_Err	(*PR_FlattenInstanceFunc)(
										const PR_InData			*in_dataP,			/* >> */
										PR_GlobalContextH		global_contextH,		/* >> */
										PR_InstanceContextH		instance_contextH,		/* >> */
										PR_GlobalDataH			global_dataH,			/* <> */
										PR_InstanceDataH		instance_dataH,			/* <> */
										PR_FlatHandle			*flatH);				/* << */





/**
 ** if the renderer has parameters, this is where they get set or changed.
 **/


typedef	A_Err	(*PR_DoInstanceDialogFunc)(		const PR_InData		*in_dataP,			/* >> */
												PR_GlobalContextH	global_contextH,		/* >> */
												PR_InstanceContextH	instance_contextH,		/* >> */
												PR_GlobalDataH		global_dataH,			/* <> */
												PR_InstanceDataH	instance_dataH,			/* <> */
												PR_DialogResult		*resultP);				/* << */
			


/** 
 ** allocate render data if needed
 **/
typedef A_Err	(*PR_FrameSetupFunc)(
										const PR_InData			*in_dataP,				/* >> */
										PR_GlobalContextH		global_contextH,			/* >> */
										PR_InstanceContextH		instance_contextH,			/* >> */
										PR_RenderContextH		render_contextH,			/* >> */
										PR_GlobalDataH			global_dataH,				/* <> */
										PR_InstanceDataH		instance_dataH,				/* <> */
										PR_RenderDataH			*render_dataPH);			/* << */


/** 
 ** deallocate render data
 **/
typedef A_Err	(*PR_FrameSetdownFunc)(
										const PR_InData			*in_dataP,				/* >> */
										PR_GlobalContextH		global_contextH,			/* >> */
										PR_InstanceContextH		instance_contextH,			/* >> */
										PR_RenderContextH		render_contextH,			/* >> */
										PR_GlobalDataH			global_dataH,				/* <> */
										PR_InstanceDataH		instance_dataH,				/* <> */
										PR_RenderDataH			render_dataH);	


/** 
 ** the main drawing routine 
 **/
typedef A_Err	(*PR_RenderFunc)(
										const PR_InData			*in_dataP,					/* >> */
										PR_GlobalContextH		global_contextH,			/* >> */
										PR_InstanceContextH		instance_contextH,			/* >> */
										PR_RenderContextH		render_contextH,			/* >> */
										PR_GlobalDataH			global_dataH,				/* <> */
										PR_InstanceDataH		instance_dataH,				/* <> */
										PR_RenderDataH			render_dataH);




/**
 ** AE will need to have the artisan process data on its behalf such as 
 ** projecting points to the screen, transforming axis, etc. This routine will handle
 ** it all
 **/
typedef A_Err	(*PR_QueryFunc)(	const PR_InData			*in_dataP,			/* >> */
									PR_GlobalContextH		global_contextH,	/* >> */
									PR_InstanceContextH		instance_contextH,  /* >> */
									PR_QueryContextH		query_contextH,		/* <> */
									PR_QueryType			query_type,			/* >> */
									PR_GlobalDataH			global_data,		/* >> */
									PR_InstanceDataH		instance_dataH);	/* >> */
									



/**
 ** main fills this in, just once at plugin load time
 ** These are the entry points that AE calls to use an artisan.
 **/

typedef struct {

	PR_GlobalSetupFunc					global_setup_func0;
	PR_GlobalSetdownFunc				global_setdown_func0;
	PR_GlobalDoAboutFunc				global_do_about_func0;

	PR_InstanceSetupFunc				setup_instance_func0;
	PR_InstanceSetdownFunc				setdown_instance_func0;
	PR_FlattenInstanceFunc				flatten_instance_func0;
	PR_DoInstanceDialogFunc				do_instance_dialog_func0;
	
	PR_FrameSetupFunc					frame_setup_func0;
	PR_RenderFunc						render_func;			// must have at least this one function
	PR_FrameSetdownFunc					frame_setdown_func0;

	PR_QueryFunc						query_func0;
	
} PR_ArtisanEntryPoints;




/** 
 ** line drawing routines for interactive artisans
 **/
typedef void	(*PR_Draw_MoveToFunc)(A_FpLong x, A_FpLong y);

typedef void	(*PR_Draw_LineToFunc)(A_FpLong x, A_FpLong y);

typedef void	(*PR_Draw_LineRelFunc)(A_FpLong dx, A_FpLong dy);

typedef void	(*PR_Draw_ForeColorFunc)(const A_Color *fore_color);

typedef void	(*PR_Draw_BackColorFunc)(const A_Color *fore_color);

typedef void	(*PR_Draw_FrameRectFunc)(const A_FloatRect *rectPR );

typedef void	(*PR_Draw_PaintRectFunc)(const A_FloatRect *rectPR );

typedef void	(*PR_Draw_FrameOvalFunc)(const A_FloatRect *rectPR );

typedef void	(*PR_Draw_PaintOvalFunc)(const A_FloatRect *rectPR );

typedef void	(*PR_Draw_InvertRectFunc)(const A_FloatRect *rectPR );

typedef void	(*PR_Draw_SetClipFunc)(const A_FloatRect *rectPR, A_Boolean invertB );

typedef void	(*PR_Draw_PenNormal)(void);

typedef void	(*PR_Draw_PenSize)(A_FpLong widthS, A_FpLong heightS);

typedef void	(*PR_Draw_PenPat)(A_u_char pattern);

typedef void	(*PR_Draw_Invert)(A_Boolean);

typedef void	(*PR_CacheIconFunc)(PF_EffectWorldPtr iconP);

typedef void	(*PR_DrawCachedIconFunc)(A_long x, A_long y);

typedef void	(*PR_DrawStringFunc)(const A_UTF16Char *nameZ, PF_FontStyleSheet style, const A_Color *fore_colorP, const A_Color *shadow_colorP, const A_FloatPoint *originP, const A_FloatPoint *shadow_offsetP);

typedef void	(*PR_StrokePolyFunc) (A_long nptsL, A_FloatPoint *ptsA);

typedef void	(*PR_PaintPolyFunc) (A_long nptsL, A_FloatPoint *ptsA);



typedef struct {

	PR_Draw_MoveToFunc				move_to_func;
	PR_Draw_LineToFunc				line_to_func;
	PR_Draw_LineRelFunc				line_rel_func;
	PR_Draw_ForeColorFunc			fore_color_func;
	PR_Draw_BackColorFunc			back_color_func;
	PR_Draw_FrameRectFunc			frame_rect_func;
	PR_Draw_PaintRectFunc			paint_rect_func;
	PR_Draw_FrameOvalFunc			frame_oval_func;
	PR_Draw_PaintOvalFunc			paint_oval_func;
	PR_Draw_InvertRectFunc			invert_rect_func;
	PR_Draw_SetClipFunc				set_clip_func;
	PR_Draw_PenNormal				pen_normal_func;
	PR_Draw_PenSize					pen_size_func;
	PR_Draw_PenPat					pen_pat_func;
	PR_Draw_Invert					invert_func;
	PR_CacheIconFunc				cache_icon_func;
	PR_DrawCachedIconFunc			draw_cached_icon_func;
	PR_DrawStringFunc				draw_string_func;
	PR_StrokePolyFunc				stroke_poly_func;
	PR_PaintPolyFunc				paint_poly_func;

} PR_InteractiveDrawProcs;





#pragma pack( pop )



#ifdef __cplusplus
	}
#endif

							
#endif

```

---

<h2>Begin File: PT_Public.h</h2>

```cpp
/*******************************************************************/
/*                                                                 */
/*                      ADOBE CONFIDENTIAL                         */
/*                   _ _ _ _ _ _ _ _ _ _ _ _ _                     */
/*                                                                 */
/* Copyright 2007 Adobe Systems Incorporated                       */
/* All Rights Reserved.                                            */
/*                                                                 */
/* NOTICE:  All information contained herein is, and remains the   */
/* property of Adobe Systems Incorporated and its suppliers, if    */
/* any.  The intellectual and technical concepts contained         */
/* herein are proprietary to Adobe Systems Incorporated and its    */
/* suppliers and may be covered by U.S. and Foreign Patents,       */
/* patents in process, and are protected by trade secret or        */
/* copyright law.  Dissemination of this information or            */
/* reproduction of this material is strictly forbidden unless      */
/* prior written permission is obtained from Adobe Systems         */
/* Incorporated.                                                   */
/*                                                                 */
/*******************************************************************/

#ifndef	_H_PT_Public
#define	_H_PT_Public

/***

	This header file defines public interface for tracker or pixel-
	matching plug-ins.
	
	Their function is to implement a pixel matching algorithm that a
	tracker in After Effects could use to track user specified features.
	
	Tracker in the application provides UI and sets the main parameters.
	Tracker plug-ins, however, can provide a simple dialog-based UI for
	parameters specific to the implemented algorithm(s).
	
	
***/

#include <A.h>

#pragma pack( push, 4 )

#ifdef	__cplusplus
	extern "C" {
#endif

#define	PT_TRACKER_API_VERSION_MAJOR	1
#define	PT_TRACKER_API_VERSION_MINOR	0

#define	PT_TRACKER_MATCH_NAME_LEN		31
#define	PT_TRACKER_NAME_LEN				31

typedef	A_long	PT_Index;


typedef	struct	PT_Tracker				*PT_TrackerPtr;
typedef	struct	PT_TrackerInstance		*PT_TrackerInstancePtr;
typedef	struct	PT_TrackingContext		*PT_TrackingContextPtr;

//	plug-in entry points
typedef	A_Err	(*PT_GlobalSetupFunc)(
					const	PT_TrackerPtr	trackerP,
					AEGP_MemHandle			*global_dataPH);			// <<
					
typedef	A_Err	(*PT_GlobalSetdownFunc)(
					const	PT_TrackerPtr	trackerP);

typedef	A_Err	(*PT_GlobalDoAboutFunc)(
					const	PT_TrackerPtr	trackerP);

typedef	A_Err	(*PT_InstanceSetupFunc)(
					const	PT_TrackerInstancePtr	tracker_instanceP,
					AEGP_MemHandle					flat_instance_dataH0,
					AEGP_MemHandle					*instance_dataPH);	// currently has to be flat (no handles inside a handle)
					
typedef	A_Err	(*PT_InstanceSetdownFunc)(
					const	PT_TrackerInstancePtr	tracker_instanceP);
					
typedef A_Err	(*PT_InstanceFlattenFunc)(
					const	PT_TrackerInstancePtr	tracker_instanceP,
					AEGP_MemHandle					*flat_instance_dataPH);
					
typedef A_Err	(*PT_InstanceDoOptionsFunc)(
					const	PT_TrackerInstancePtr	tracker_instanceP);
					
typedef	A_Err	(*PT_PrepareTrackFunc)(
					const	PT_TrackingContextPtr	contextP,
					AEGP_MemHandle					*tracker_dataPH);	// <<
					
typedef	A_Err	(*PT_TrackFunc)(
					const	PT_TrackingContextPtr	contextP);

typedef	A_Err	(*PT_FinishTrackFunc)(
					const	PT_TrackingContextPtr	contextP);
					

typedef struct {
	PT_GlobalSetupFunc				global_setup_func;
	PT_GlobalSetdownFunc			global_setdown_func;
	PT_GlobalDoAboutFunc			global_do_about_func;
	
	PT_InstanceSetupFunc			instance_setup_func;
	PT_InstanceSetdownFunc			instance_setdown_func;
	PT_InstanceFlattenFunc			instance_flatten_func;
	PT_InstanceDoOptionsFunc		instance_do_options_func;
	
	PT_PrepareTrackFunc				track_prepare_func;
	PT_TrackFunc					track_func;
	PT_FinishTrackFunc				track_finish_func;
} PT_TrackerEntryPoints;


#pragma pack( pop )

#ifdef	__cplusplus
	}
#endif

#endif	// _H_PT_Public
```

---

<h2>Begin File: SuiteHelper.h</h2>

```cpp
#ifndef _H_SUITEHELPER
#define _H_SUITEHELPER

#include "A.h"
#include "SPBasic.h"

#include <cassert>

template <typename SuiteType>
struct SuiteTraits
{
	static const A_char*	i_name;
	static const int32_t	i_version;
};

template <typename SuiteType>
class AssertAndThrowOnMissingSuite
{
public:
	void operator()()
	{
		assert( false );
		A_THROW(A_Err_MISSING_SUITE);
	}
};


class MissingSuiteErrFunc_NoOp
{
public:
	void operator()()
	{
		//swallow the error, not much we want to do or can do
	}
};


template<typename SuiteType, class MissingSuiteErrFunc = AssertAndThrowOnMissingSuite<SuiteType> >
class SuiteHelper
{
public:
	SuiteHelper(const SPBasicSuite* const basic_suiteP);
	~SuiteHelper();

	const SuiteType* operator->() const;
	SuiteType* get() const;

private:
	mutable SuiteType*	i_SuiteP;
	const SPBasicSuite* const i_basic_suiteP;
};


template<typename SuiteType, class MissingSuiteErrFunc >
SuiteHelper<SuiteType, MissingSuiteErrFunc>::SuiteHelper(const SPBasicSuite* const basic_suiteP) : i_basic_suiteP(basic_suiteP), i_SuiteP( NULL )
{
	assert(basic_suiteP);
	const void * acquired_suite = NULL;

	A_Err err = i_basic_suiteP->AcquireSuite(SuiteTraits<SuiteType>::i_name, SuiteTraits<SuiteType>::i_version, &acquired_suite);
	if (err || !acquired_suite) {
		MissingSuiteErrFunc error_func;
		error_func();
	} else {
		i_SuiteP = reinterpret_cast<SuiteType*>(const_cast<void*>(acquired_suite));
	}
}

template<typename SuiteType, class MissingSuiteErrFunc>
SuiteHelper<SuiteType, MissingSuiteErrFunc>::~SuiteHelper()
{
	if (i_SuiteP) {
		
		#ifdef DEBUG
			A_Err err = 
		#endif
				
		i_basic_suiteP->ReleaseSuite(SuiteTraits<SuiteType>::i_name, SuiteTraits<SuiteType>::i_version);
		
		#ifdef DEBUG
			assert( !err );
		#endif		
	}
}

template<typename SuiteType, class MissingSuiteErrFunc>
const SuiteType* SuiteHelper<SuiteType, MissingSuiteErrFunc>::operator->() const
{
	return i_SuiteP;
}	

template<typename SuiteType, class MissingSuiteErrFunc>
SuiteType* SuiteHelper<SuiteType, MissingSuiteErrFunc>::get() const
{
	return i_SuiteP;
}
#endif

```

---

<h2>Begin File: DrawbotSuite.h</h2>

```cpp
/**************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2009 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains the property of
* Adobe Systems Incorporated  and its suppliers,  if any.  The intellectual 
* and technical concepts contained herein are proprietary to  Adobe Systems 
* Incorporated  and its suppliers  and may be  covered by U.S.  and Foreign 
* Patents,patents in process,and are protected by trade secret or copyright 
* law.  Dissemination of this  information or reproduction of this material
* is strictly  forbidden  unless prior written permission is  obtained from 
* Adobe Systems Incorporated.
**************************************************************************/

#ifndef DRAWBOT_SUITE_H
#define DRAWBOT_SUITE_H

#include <adobesdk/config/PreConfig.h>

#ifdef __cplusplus
	#include <exception> // for std::exception
#endif
//Sweet pea header
#include <SPBasic.h>

#ifdef ADOBE_SDK_INTERNAL		
	#include <adobesdk/private/drawbotsuite/DrawbotSuiteTypes.h>
#else
	#include <adobesdk/drawbotsuite/DrawbotSuiteTypes.h>
#endif

#include <adobesdk/config/AdobesdkTypes.h>

#ifdef __cplusplus
	extern "C" {
#endif
	
/*
C STYLE
--------
Drawbot suites can be used to draw paths, strings, images using application-provided DrawbotRef. Use C++ style (mentioned later in the file)
if you are creating cpp files as it is more elegant and you don't have to deal with retain/release of objects.

Below function takes DrawbotRef and strokes a circle & a rectangle.

void DrawSomething(DRAWBOT_DrawRef drawbot_ref)
{
	//Acquire drawbot (drawbot_suiteP), supplier (supplier_suiteP), surface (surface_suiteP) & path (path_suiteP) suites
	...

	//Get the supplier and surface reference from drawbot_ref
	DRAWBOT_SupplierRef		supplier_ref;
	DRAWBOT_SurfaceRef		surface_ref;

	drawbot_suiteP->GetSupplier(drawbot_ref, &supplier_ref);
	drawbot_suiteP->GetSurface(drawbot_ref, &surface_ref);

	//Save the surface state by pushing it in stack. It is required to restore state if you are going to clip/transform surface
	//or change interpolation/anti-aliasing policy.
	surface_suiteP->PushStateStack(surface_ref);

	//Create a new red-color brush.
	DRAWBOT_BrushRef	brush_ref;

	supplier_suiteP->NewBrush(supplier_ref, DRAWBOT_ColorRGBA(1.0f, 0.0f, 0.0f, 1.0f), &brush_ref);

	//Create a new path
	DRAWBOT_PathRef		path_ref;

	supplier_suiteP->NewPath(supplier_ref, &path_ref);

	//Add a rectangle to the path
	DRAWBOT_RectF32		rect1(0.0f, 0.0f, 50.0f, 50.0f);

	path_suiteP->AddRect(path_ref, rect1);

	//Add a circle to the path
	path_suiteP->AddArc(path_ref, DRAWBOT_PointF32(25.0f, 25.0f), 10.0f, 0.0f, 360.0f);

	//Fill the path using red-colored brush.
	surface_suiteP->FillPath(surface_ref, brush_ref, path_ref, kDRAWBOT_FillType_EvenOdd);

	//We are done. Release (delete) all the objects. There will be memory leak if you don't release.
	surface_suiteP->ReleaseObject((DRAWBOT_ObjectRef)path_ref);
	surface_suiteP->ReleaseObject((DRAWBOT_ObjectRef)brush_ref);

	//Don't forget to pop surface state (if pushed earlier)
	surface_suiteP->PopStateStack(surface_ref);

	//DO NOT CALL ReleaseObject on surface_ref and supplier_ref as you did not create them.

	//Release drawbot (drawbot_suiteP), supplier (supplier_suiteP), surface (surface_suiteP) & path (path_suiteP) suites
}
*/


#define kDRAWBOT_DrawSuite					"DRAWBOT Draw Suite"
#define kDRAWBOT_DrawSuite_Version1			1

#define kDRAWBOT_DrawSuite_VersionCurrent	kDRAWBOT_DrawSuite_Version1
#define	DRAWBOT_DrawbotSuiteCurrent			DRAWBOT_DrawbotSuite1

typedef struct DRAWBOT_DrawbotSuite1 {
	
	//Get the supplier from the drawbot_ref
	SPAPI SPErr	(*GetSupplier)(	DRAWBOT_DrawRef			in_drawbot_ref,
								DRAWBOT_SupplierRef		*out_supplierP);

	//Get the surface from the drawbot_ref
	SPAPI SPErr	(*GetSurface)(	DRAWBOT_DrawRef			in_drawbot_ref,
								DRAWBOT_SurfaceRef		*out_surfaceP);

} DRAWBOT_DrawbotSuite1;



#define kDRAWBOT_SupplierSuite						"DRAWBOT Supplier Suite"
#define kDRAWBOT_SupplierSuite_Version1				1

#define kDRAWBOT_SupplierSuite_VersionCurrent		kDRAWBOT_SupplierSuite_Version1
#define DRAWBOT_SupplierSuiteCurrent				DRAWBOT_SupplierSuite1

typedef struct DRAWBOT_SupplierSuite1 {

	//Create a new pen.
	//It should be released with ReleaseObject api.
	SPErr	(*NewPen)(	DRAWBOT_SupplierRef				in_supplier_ref,
						const DRAWBOT_ColorRGBA			*in_colorP,
						float							in_size,
						DRAWBOT_PenRef					*out_penP);

	//Create a new brush. 
	//It should be released with ReleaseObject api.
	SPErr	(*NewBrush)(DRAWBOT_SupplierRef				in_supplier_ref,
						const DRAWBOT_ColorRGBA			*in_colorP,
						DRAWBOT_BrushRef				*out_brushP);
	
	//Check if current supplier supports text.
	SPErr	(*SupportsText)(DRAWBOT_SupplierRef			in_supplier_ref,
							DRAWBOT_Boolean				*out_supports_textPB);
	
	//Get default font size.
	SPErr	(*GetDefaultFontSize)(	DRAWBOT_SupplierRef			in_supplier_ref,
									float						*out_font_sizeF);

	//Create a new font with default settings.
	//You can pass default font size from GetDefaultFontSize.
	//It should be released with ReleaseObject api.
	SPErr	(*NewDefaultFont)(	DRAWBOT_SupplierRef				in_supplier_ref,
								float							in_font_sizeF,
								DRAWBOT_FontRef					*out_fontP);

	//Create a new image from buffer. 
	//It should be released with ReleaseObject api.
	SPErr	(*NewImageFromBuffer)(	DRAWBOT_SupplierRef		in_supplier_ref,
									int						in_width,
									int						in_height,
									int						in_row_bytes,
									DRAWBOT_PixelLayout		in_pl,
									const void				*in_dataP,
									DRAWBOT_ImageRef		*out_imageP);

	//Create a new path. 
	//It should be released with ReleaseObject api.
	SPErr	(*NewPath)(	DRAWBOT_SupplierRef				in_supplier_ref,
						DRAWBOT_PathRef					*out_pathP);


	//A given drawbot implementation can support multiple channel orders, but will likely
	//prefer one over the other. Use below apis to get the preferred layout for any api that 
	//takes DRAWBOT_PixelLayout (ex- NewImageFromBuffer).
		
	SPErr	(*SupportsPixelLayoutBGRA)(	DRAWBOT_SupplierRef			in_supplier_ref,
										DRAWBOT_Boolean				*out_supports_bgraPB);

	SPErr	(*PrefersPixelLayoutBGRA) (	DRAWBOT_SupplierRef			in_supplier_ref,
										DRAWBOT_Boolean				*out_prefers_bgraPB);

	SPErr	(*SupportsPixelLayoutARGB)(	DRAWBOT_SupplierRef			in_supplier_ref,
										DRAWBOT_Boolean				*out_supports_argbPB);
	
	SPErr	(*PrefersPixelLayoutARGB) (	DRAWBOT_SupplierRef			in_supplier_ref,
										DRAWBOT_Boolean				*out_prefers_argbPB);

	//Retain (increase reference count) any object (pen, brush, path etc)
	//Ex: It should be used when any object is copied and the copied object should be retained.
	SPErr	(*RetainObject)(DRAWBOT_ObjectRef			in_obj_ref);

	//Release (decrease reference count) any object (pen, brush, path etc)
	//This function MUST be called for any object created using NewXYZ() from this suite.
	SPErr	(*ReleaseObject)(DRAWBOT_ObjectRef			in_obj_ref);

} DRAWBOT_SupplierSuite1;


#define kDRAWBOT_SurfaceSuite					"DRAWBOT Surface Suite"
#define kDRAWBOT_SurfaceSuite_Version1			1
#define kDRAWBOT_SurfaceSuite_Version2			2

#define kDRAWBOT_SurfaceSuite_VersionCurrent	kDRAWBOT_SurfaceSuite_Version2
#define DRAWBOT_SurfaceSuiteCurrent				DRAWBOT_SurfaceSuite2

typedef struct DRAWBOT_SurfaceSuite1 {

	//Push the current surface state in stack. It should be popped to retrieve old state.
	SPErr	(*PushStateStack)( DRAWBOT_SurfaceRef		in_surface_ref);

	//Pop the last pushed surface state.
	SPErr	(*PopStateStack)( DRAWBOT_SurfaceRef		in_surface_ref);

	//Paint a rectangle with a color on the surface.
	SPErr	(*PaintRect)(	DRAWBOT_SurfaceRef			in_surface_ref,
							const DRAWBOT_ColorRGBA		*in_colorP,	
							const DRAWBOT_RectF32		*in_rectPR);

	//Fill a path using a brush and fill type.
	SPErr	(*FillPath)(	DRAWBOT_SurfaceRef			in_surface_ref,
							DRAWBOT_BrushRef			in_brush_ref,
							DRAWBOT_PathRef				in_path_ref,
							DRAWBOT_FillType			in_fill_type);

	//Stroke a path using a pen.
	SPErr	(*StrokePath)(	DRAWBOT_SurfaceRef			in_surface_ref,
							DRAWBOT_PenRef				in_pen_ref,
							DRAWBOT_PathRef				in_path_ref);

	//Clip the surface
	SPErr	(*Clip)(		DRAWBOT_SurfaceRef			in_surface_ref,
							DRAWBOT_SupplierRef			in_supplier_ref,
							const DRAWBOT_Rect32		*in_rectPR);

	//Get clip bounds
	SPErr	(*GetClipBounds)(
							DRAWBOT_SurfaceRef			in_surface_ref,
							DRAWBOT_Rect32				*out_rectPR);

	//Checks whether a rect is within the clip bounds.
	SPErr	(*IsWithinClipBounds)(
							DRAWBOT_SurfaceRef			in_surface_ref,
							const DRAWBOT_Rect32		*in_rectPR,
							DRAWBOT_Boolean				*out_withinPB);

	//Transform the last surface state.
	SPErr	(*Transform)(	DRAWBOT_SurfaceRef			in_surface_ref,
							const DRAWBOT_MatrixF32		*in_matrixP);

	//Draw a string
	SPErr	(*DrawString)(	DRAWBOT_SurfaceRef			in_surface_ref,
							DRAWBOT_BrushRef			in_brush_ref,
							DRAWBOT_FontRef				in_font_ref,
							const DRAWBOT_UTF16Char		*in_stringP,
							const DRAWBOT_PointF32		*in_originP,
							DRAWBOT_TextAlignment		in_alignment_style, 
							DRAWBOT_TextTruncation		in_truncation_style,
							float						in_truncation_width);

	//Draw an image (created using NewImageFromBuffer())on the surface
	//alpha = [0.0f, 1.0f]
	SPErr	(*DrawImage)(	DRAWBOT_SurfaceRef			in_surface_ref,
							DRAWBOT_ImageRef			in_image_ref,
							const DRAWBOT_PointF32		*in_originP,
							float						in_alpha);

	SPErr	(*SetInterpolationPolicy)(	
							DRAWBOT_SurfaceRef			in_surface_ref,
							DRAWBOT_InterpolationPolicy in_interp);

	SPErr	(*GetInterpolationPolicy)(	
							DRAWBOT_SurfaceRef			in_surface_ref,
							DRAWBOT_InterpolationPolicy *out_interpP);

	SPErr	(*SetAntiAliasPolicy)(	
							DRAWBOT_SurfaceRef			in_surface_ref,
							DRAWBOT_AntiAliasPolicy		in_policy);

	SPErr	(*GetAntiAliasPolicy)(	
							DRAWBOT_SurfaceRef			in_surface_ref,
							DRAWBOT_AntiAliasPolicy		*out_policyP);

	//Flush drawing
	SPErr	(*Flush)(		DRAWBOT_SurfaceRef			in_surface_ref);

	//Get the transform of the surface state.
	SPErr	(*GetTransformToScreenScale)(DRAWBOT_SurfaceRef	in_surface_ref,
										 float* out_scale);
} DRAWBOT_SurfaceSuite2;

typedef DRAWBOT_SurfaceSuite2 DRAWBOT_SurfaceSuite1; // At the time, the last function was Flush.


#define kDRAWBOT_PathSuite					"DRAWBOT Path Suite"
#define kDRAWBOT_PathSuite_Version1			1

#define kDRAWBOT_PathSuite_VersionCurrent	kDRAWBOT_PathSuite_Version1
#define DRAWBOT_PathSuiteCurrent			DRAWBOT_PathSuite1

typedef struct DRAWBOT_PathSuite1 {

	//Move to a point
	SPErr	(*MoveTo)(	DRAWBOT_PathRef				in_path_ref,
						float						in_x,
						float						in_y);
	
	//Add a line to the path
	SPErr	(*LineTo)(	DRAWBOT_PathRef				in_path_ref,
						float						in_x,
						float						in_y);
	
	//Add a cubic bezier to the path
	SPErr	(*BezierTo)(DRAWBOT_PathRef				in_path_ref,
						const DRAWBOT_PointF32		*in_pt1P,
						const DRAWBOT_PointF32		*in_pt2P,
						const DRAWBOT_PointF32		*in_pt3P);
	
	//Add a rect to the path 
	SPErr	(*AddRect)(	DRAWBOT_PathRef				in_path_ref,
						const DRAWBOT_RectF32		*in_rectPR);

	//Add a arc to the path
	//zero start degrees == 3 o'clock
	//sweep is clockwise
	//units in degrees
	SPErr	(*AddArc)(	DRAWBOT_PathRef				in_path_ref,
						const DRAWBOT_PointF32		*in_centerP,
						float						in_radius,
						float						in_start_angle,
						float						in_sweep);
	
	SPErr	(*Close)(	DRAWBOT_PathRef				in_path_ref);

} DRAWBOT_PathSuite1;


#define kDRAWBOT_PenSuite					"DRAWBOT Pen Suite"
#define kDRAWBOT_PenSuite_Version1			1

#define kDRAWBOT_PenSuite_VersionCurrent	kDRAWBOT_PenSuite_Version1
#define DRAWBOT_PenSuiteCurrent				DRAWBOT_PenSuite1

typedef struct DRAWBOT_PenSuite1 {

	//Make the line dashed
	SPErr	(*SetDashPattern)(	DRAWBOT_PenRef		in_pen_ref,
								const float			*in_dashesP,
								int					in_pattern_size);

} DRAWBOT_PenSuite1;

#define kDRAWBOT_ImageSuite					"DRAWBOT Image Suite"
#define kDRAWBOT_ImageSuite_Version1		1

#define kDRAWBOT_ImageSuite_VersionCurrent	kDRAWBOT_ImageSuite_Version1
#define DRAWBOT_ImageSuiteCurrent			DRAWBOT_ImageSuite1

typedef struct DRAWBOT_ImageSuite1 {

	//Make the line dashed
	SPErr	(*SetScaleFactor)(	DRAWBOT_ImageRef	in_image_ref,
								float				in_scale_factor);

} DRAWBOT_ImageSuite1;

//Collection of latest drawbot suites
typedef struct {
	DRAWBOT_DrawbotSuiteCurrent				*drawbot_suiteP;
	DRAWBOT_SupplierSuiteCurrent			*supplier_suiteP;
	DRAWBOT_SurfaceSuiteCurrent				*surface_suiteP;
	DRAWBOT_PathSuiteCurrent				*path_suiteP;
	DRAWBOT_PenSuiteCurrent					*pen_suiteP;
	DRAWBOT_ImageSuiteCurrent				*image_suiteP;
} DRAWBOT_Suites;


#ifdef __cplusplus
	}		// end extern "C"
#endif



#ifdef __cplusplus	//C++ Style

/*
Use C++ style as it will automatically deal with memory management of objects. Below example will make it clear.

Below function takes DrawbotRef and strokes a circle & a rectangle.

void DrawSomething(DRAWBOT_DrawRef drawbot_ref)
{
	//Acquire drawbot (drawbot_suiteP), supplier (supplier_suiteP), surface (surface_suiteP) & path (path_suiteP) suites
	...

	//Get the supplier and surface reference from drawbot_ref
	DRAWBOT_SupplierRef		supplier_ref;
	DRAWBOT_SurfaceRef		surface_ref;

	drawbot_suiteP->GetSupplier(drawbot_ref, &supplier_ref);
	drawbot_suiteP->GetSurface(drawbot_ref, &surface_ref);

	//Save the surface state by pushing it in stack. It is required to restore if you are going to clip or transform surface.
	//Below call acts like a a scoper: it will push the current surface state and automatically pop at the end of scope.
	DRAWBOT_SaveAndRestoreStateStack		sc_save_state(surface_suiteP, surface_ref);

	//Create a new red-color brush.
	//Compare below call with C-style apis. It is compact and brush will be automatically released at the end of scope.
	DRAWBOT_BrushP		brushP(supplier_suiteP, supplier_ref, DRAWBOT_ColorRGBA(1.0f, 0.0f, 0.0f, 1.0f));
	
	//Create a new path
	DRAWBOT_PathP		pathP(supplier_suiteP, supplier_ref);

	//Add a rectangle to the path
	DRAWBOT_RectF32		rect1(0.0f, 0.0f, 50.0f, 50.0f);

	path_suiteP->AddRect(pathP, rect1);

	//Add a circle to the path
	path_suiteP->AddArc(pathP, DRAWBOT_PointF32(25.0f, 25.0f), 10.0f, 0.0f, 360.0f);

	//Fill the path using red-colored brush.
	surface_suiteP->FillPath(surface_ref, brushP, pathP, kDRAWBOT_FillType_EvenOdd);

	//Release drawbot (drawbot_suiteP), supplier (supplier_suiteP), surface (surface_suiteP) & path (path_suiteP) suites

	//We are DONE. You don't have to release brush & path objects as you did in C-style.
}
*/
class DRAWBOT_Exception : public std::exception {
public:
		DRAWBOT_Exception(SPErr err): mErr(err)
		{
		}
		virtual ~DRAWBOT_Exception() throw () {}

		SPErr mErr;
};

#define DRAWBOT_ErrorToException(EXPR)		{ SPErr _err = (EXPR); if (_err) throw DRAWBOT_Exception(_err); }


//SharedRefImpl declaration

template<typename REF_T>
class SharedRefImpl {
public:
	SharedRefImpl(DRAWBOT_SupplierSuiteCurrent *suiteP, REF_T r = 0, bool retainB = true)
		:
		mRef(r),
		mSuiteP(suiteP)
	{
		if (retainB) {
			RetainObject();
		}
	}

	virtual ~SharedRefImpl()
	{
		ReleaseObject();
	}

	//copy constructor
	SharedRefImpl(SharedRefImpl const & rhs)
	{
		*this = rhs;
	}

	//assignment operator
	SharedRefImpl & operator=(SharedRefImpl const & rhs)
	{
		mSuiteP = rhs.mSuiteP;
		mRef = rhs.mRef;

		RetainObject();

		return *this;
	}

	inline REF_T Get() const
	{
		return mRef;
	}

	inline operator REF_T() const
	{ 
		return mRef;
	}

	inline void Reset(REF_T rhs = 0, bool retainB = true)
	{
		if (mRef != rhs) {
			ReleaseObject();

			mRef = rhs;

			if (retainB) {
				RetainObject();
			}
		}
	}

private:
	void ReleaseObject()
	{
		if (mRef) {
			DRAWBOT_ErrorToException(mSuiteP->ReleaseObject(reinterpret_cast<DRAWBOT_ObjectRef>(mRef)));
			mRef = NULL;
		}
	}

	void RetainObject()
	{
		if (mRef) {
			DRAWBOT_ErrorToException(mSuiteP->RetainObject(reinterpret_cast<DRAWBOT_ObjectRef>(mRef)));
		}
	}

	REF_T								mRef;
	DRAWBOT_SupplierSuiteCurrent		*mSuiteP;
};


//DRAWBOT_PenP declaration

class DRAWBOT_PenP : public SharedRefImpl<DRAWBOT_PenRef> {
	typedef SharedRefImpl<DRAWBOT_PenRef>	_inherited;
public:
	
	DRAWBOT_PenP(	DRAWBOT_SupplierSuiteCurrent	*suiteP, 
					const DRAWBOT_SupplierRef		supplier_ref, 
					const DRAWBOT_ColorRGBA			*colorP, 
					float							sizeF)
		:
		_inherited(suiteP)
	{
		New(suiteP, supplier_ref, colorP, sizeF);
	}

	void New(	DRAWBOT_SupplierSuiteCurrent	*suiteP, 
				const DRAWBOT_SupplierRef		supplier_ref, 
				const DRAWBOT_ColorRGBA			*colorP, 
				float							sizeF)
	{
		DRAWBOT_PenRef	pen_ref;

		DRAWBOT_ErrorToException(suiteP->NewPen(supplier_ref, colorP, sizeF, &pen_ref));

		Reset(pen_ref, false);
	}
};


//DRAWBOT_PathP declaration

class DRAWBOT_PathP : public SharedRefImpl<DRAWBOT_PathRef> {
	typedef SharedRefImpl<DRAWBOT_PathRef>	_inherited;
public:
	DRAWBOT_PathP(	DRAWBOT_SupplierSuiteCurrent	*suiteP, 
					const DRAWBOT_SupplierRef		supplier_ref)
		:
		_inherited(suiteP)
	{
		New(suiteP, supplier_ref);
	}

	void New(	DRAWBOT_SupplierSuiteCurrent	*suiteP, 
				const DRAWBOT_SupplierRef		supplier_ref)
	{
		DRAWBOT_PathRef	path_ref;

		DRAWBOT_ErrorToException(suiteP->NewPath(supplier_ref, &path_ref));

		Reset(path_ref, false);
	}
};


//DRAWBOT_BrushP declaration

class DRAWBOT_BrushP : public SharedRefImpl<DRAWBOT_BrushRef> {
	typedef SharedRefImpl<DRAWBOT_BrushRef>	_inherited;
public:
	DRAWBOT_BrushP(	DRAWBOT_SupplierSuiteCurrent	*suiteP, 
					const DRAWBOT_SupplierRef		supplier_ref, 
					const DRAWBOT_ColorRGBA			*colorP)
		:
		_inherited(suiteP)
	{
		New(suiteP, supplier_ref, colorP);
	}

	void New(	DRAWBOT_SupplierSuiteCurrent	*suiteP, 
				const DRAWBOT_SupplierRef		supplier_ref, 
				const DRAWBOT_ColorRGBA			*colorP)
	{
		DRAWBOT_BrushRef	brush_ref;

		DRAWBOT_ErrorToException(suiteP->NewBrush(supplier_ref, colorP, &brush_ref));

		Reset(brush_ref, false);
	}
};


//DRAWBOT_FontP declaration

class DRAWBOT_FontP : public SharedRefImpl<DRAWBOT_FontRef> {
	typedef SharedRefImpl<DRAWBOT_FontRef>	_inherited;
public:
	DRAWBOT_FontP(	DRAWBOT_SupplierSuiteCurrent	*suiteP, 
					const DRAWBOT_SupplierRef		supplier_ref, 
					float							in_font_size)
		:
	_inherited(suiteP)
	{
		New(suiteP, supplier_ref, in_font_size);
	}

	void New(	DRAWBOT_SupplierSuiteCurrent	*suiteP, 
				const DRAWBOT_SupplierRef		supplier_ref, 
				float							in_font_size)
	{
		DRAWBOT_FontRef	font_ref;

		DRAWBOT_ErrorToException(suiteP->NewDefaultFont(supplier_ref, in_font_size, &font_ref));

		Reset(font_ref, false);
	}
};


class DRAWBOT_SaveAndRestoreStateStack {
public:
	DRAWBOT_SaveAndRestoreStateStack(	DRAWBOT_SurfaceSuiteCurrent		*suiteP, 
										const DRAWBOT_SurfaceRef		surface_ref) 
			: 
			mSurfaceRef(surface_ref),
			mSuiteP(suiteP) 
	{
		DRAWBOT_ErrorToException(mSuiteP->PushStateStack(mSurfaceRef));
	}

	~DRAWBOT_SaveAndRestoreStateStack() 
	{ 
		(void)mSuiteP->PopStateStack(mSurfaceRef); 
	}

private:
	DRAWBOT_SurfaceRef				mSurfaceRef;
	DRAWBOT_SurfaceSuiteCurrent		*mSuiteP;
};


#endif	//C++ Style


#include <adobesdk/config/PostConfig.h>

#endif //DRAWBOT_SUITE_H

```

---

<h2>Begin File: AdobesdkTypes.h</h2>

```cpp
/**************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2009 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains the property of
* Adobe Systems Incorporated  and its suppliers,  if any.  The intellectual
* and technical concepts contained herein are proprietary to  Adobe Systems
* Incorporated  and its suppliers  and may be  covered by U.S.  and Foreign
* Patents,patents in process,and are protected by trade secret or copyright
* law.  Dissemination of this  information or reproduction of this material
* is strictly  forbidden  unless prior written permission is  obtained from
* Adobe Systems Incorporated.
**************************************************************************/

/**
	Definition of common types used by adobesdk.
**/

#ifndef ADOBESDK_CONFIG_TYPES_H
#define ADOBESDK_CONFIG_TYPES_H

#include <adobesdk/config/PreConfig.h>

#include "stdint.h"


typedef uint16_t			ADOBESDK_UTF16Char;
typedef uint8_t				ADOBESDK_UTF8Char;
typedef uint8_t				ADOBESDK_Boolean;

enum
{
	kAdobesdk_False = 0,
	kAdobesdk_True = 1
};


typedef ADOBESDK_UTF16Char	DRAWBOT_UTF16Char;
typedef ADOBESDK_Boolean	DRAWBOT_Boolean;


typedef struct 
{
	int64_t opaque[2];
} ADOBESDK_String; 


#include <adobesdk/config/PostConfig.h>

#endif //ADOBESDK_CONFIG_TYPES_H

```

---

<h2>Begin File: PostConfig.h</h2>

```cpp

#pragma pack( pop, AdobeSDKExternalAlign )
```

---

<h2>Begin File: PreConfig.h</h2>

```cpp

//Must be balanced with PostConfig.h!

#ifdef _WINDOWS
	//disable warning in VS2008 about unbalanced struct alignment changes
	#pragma warning( disable : 4103 )

	// This is taken from PreConfig_Win.h in dvacore, there is a bug in the VS2010 xlocnum header in particular where it is
	// incorrectly putting a declspec on a static member of a template class 'numpunct'. 
	#if  defined(_MSC_VER) && (_MSC_VER >= 1600) && defined(PREMIERE_INTERNAL)
		// Compilation problems due to locale id being marked as dllimport. -jacquave 2/18/2010
		// Also, opened a Technical Support Request with Microsoft, # 111021865918375.

		// http://connect.microsoft.com/VisualStudio/feedback/details/572376/msvc10-c-std-numpunct-has-a-hardcoded-dllimport-in-definition
		// http://dotnetforum.net/topic/7346-vs2010-error-c2491-stdnumpunctid-while-using-stdbasic-fstream-in-ccli/
		#ifdef __cplusplus
			#include "dvacore/config/win/xlocnum_hack.h"
		#endif
	#endif
#endif

//8 byte alignment for adobesdk public files.
#pragma pack( push, AdobeSDKExternalAlign, 8 )

```

---

<h2>Begin File: DrawbotSuiteTypes.h</h2>

```cpp
/**************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2009 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains the property of
 * Adobe Systems Incorporated  and its suppliers,  if any.  The intellectual 
 * and technical concepts contained herein are proprietary to  Adobe Systems 
 * Incorporated  and its suppliers  and may be  covered by U.S.  and Foreign 
 * Patents,patents in process,and are protected by trade secret or copyright 
 * law.  Dissemination of this  information or reproduction of this material
 * is strictly  forbidden  unless prior written permission is  obtained from 
 * Adobe Systems Incorporated.
 **************************************************************************/
// Author: pankajn@adobe.com

#ifndef DRAWBOT_SUITE_TYPES_H
#define DRAWBOT_SUITE_TYPES_H

#include <adobesdk/config/PreConfig.h>


typedef	struct _DRAWBOT_DrawRef				*DRAWBOT_DrawRef;
typedef struct _DRAWBOT_SupplierRef			*DRAWBOT_SupplierRef;
typedef struct _DRAWBOT_SurfaceRef 			*DRAWBOT_SurfaceRef;
typedef struct _DRAWBOT_PenRef				*DRAWBOT_PenRef;
typedef struct _DRAWBOT_PathRef				*DRAWBOT_PathRef;
typedef struct _DRAWBOT_BrushRef			*DRAWBOT_BrushRef;
typedef struct _DRAWBOT_ImageRef			*DRAWBOT_ImageRef;
typedef struct _DRAWBOT_FontRef				*DRAWBOT_FontRef;
typedef struct _DRAWBOT_ObjectRef			*DRAWBOT_ObjectRef;


// 0.0f to 1.0f
typedef struct {
	float	red;
	float	green;
	float	blue;
	float	alpha;
} DRAWBOT_ColorRGBA;


typedef struct {
	float	x;
	float	y;
} DRAWBOT_PointF32;


typedef struct {
	float	left;
	float	top;
	float	width;	//not right
	float	height;	//not bottom
} DRAWBOT_RectF32;


typedef struct {
	int		left;
	int		top;
	int		width;	//not right
	int		height;	//not bottom
} DRAWBOT_Rect32;


typedef struct {
	float	mat[3][3];
} DRAWBOT_MatrixF32;


//Enum to fill a path
enum {
	kDRAWBOT_FillType_EvenOdd = 0,
	kDRAWBOT_FillType_Winding,

	kDRAWBOT_FillType_Default = kDRAWBOT_FillType_Winding
};
typedef	int	DRAWBOT_FillType;


//Enum to specify pixel layout of buffer to create an image.
enum {
	kDRAWBOT_PixelLayout_24RGB = 0,
	kDRAWBOT_PixelLayout_24BGR,
	kDRAWBOT_PixelLayout_32RGB, // ARGB (A is ignored).
	kDRAWBOT_PixelLayout_32BGR, // BGRA (A is ignored).
	kDRAWBOT_PixelLayout_32ARGB_Straight,
	kDRAWBOT_PixelLayout_32ARGB_Premul,
	kDRAWBOT_PixelLayout_32BGRA_Straight,
	kDRAWBOT_PixelLayout_32BGRA_Premul
};
typedef	int	DRAWBOT_PixelLayout;


//Enum to specify the text alignment (used in DrawString)
enum {
	kDRAWBOT_TextAlignment_Left = 0,
	kDRAWBOT_TextAlignment_Center,
	kDRAWBOT_TextAlignment_Right,
	
	kDRAWBOT_TextAlignment_Default = kDRAWBOT_TextAlignment_Left
};
typedef	int	DRAWBOT_TextAlignment;


//Enum to specify text truncation (used in DrawString)
enum {
	kDRAWBOT_TextTruncation_None = 0,
	kDRAWBOT_TextTruncation_End,
	kDRAWBOT_TextTruncation_EndEllipsis,
	kDRAWBOT_TextTruncation_PathEllipsis // tries to preserve the disk name ellipsis in middle of string
};
typedef	int	DRAWBOT_TextTruncation;


//Enum to specify surface interpolation level
enum {
		kDRAWBOT_InterpolationPolicy_None = 0,
		kDRAWBOT_InterpolationPolicy_Med,
		kDRAWBOT_InterpolationPolicy_High,

		kDRAWBOT_InterpolationPolicy_Default = kDRAWBOT_InterpolationPolicy_None
}; 
typedef int	DRAWBOT_InterpolationPolicy;


//Enum to specify drawing anti-aliasing level
enum {
		kDRAWBOT_AntiAliasPolicy_None = 0,
		kDRAWBOT_AntiAliasPolicy_Med,
		kDRAWBOT_AntiAliasPolicy_High,

		kDRAWBOT_AntiAliasPolicy_Default = kDRAWBOT_AntiAliasPolicy_None
}; 
typedef int DRAWBOT_AntiAliasPolicy;


#include <adobesdk/config/PostConfig.h>

#endif //DRAWBOT_SUITE_TYPES_H





	
```

---

<h2>Begin File: PSIntTypes.h</h2>

```cpp
// ADOBE SYSTEMS INCORPORATED
// (c) Copyright  2009 Adobe Systems Incorporated
// All Rights Reserved
//
// NOTICE:  Adobe permits you to use, modify, and distribute this 
// file in accordance with the terms of the Adobe license agreement
// accompanying it.  If you have received this file from a source
// other than Adobe, then your use, modification, or distribution
// of it requires the prior written permission of Adobe.
//-------------------------------------------------------------------
/**
*
*	\file PSIntTypes.h
*
*	\brief 
*      	Fixed sized integer types used in Photoshop
*
*      Distribution:
*      	PUBLIC
*      
*/     	

#ifndef __PSIntTypes__
#define __PSIntTypes__

//-------------------------------------------------------------------

#if defined(_MSC_VER) && defined(__cplusplus)
#include <cstdint>
#else
#include <stdint.h>
#endif

typedef int8_t  int8;
typedef int16_t int16;
typedef int32_t int32;
typedef int64_t int64;

typedef uint8_t  uint8;
typedef uint16_t uint16;
typedef uint32_t uint32;
typedef uint64_t uint64;

typedef uint8_t  unsigned8;
typedef uint16_t unsigned16;
typedef uint32_t unsigned32;
typedef uint64_t unsigned64;


//-------------------------------------------------------------------
//-------------------------------------------------------------------

#ifndef _BOOL8
    #define _BOOL8
	typedef unsigned char	Bool8;
#endif

#ifndef _BOOL32
	#define _BOOL32
	typedef uint32 Bool32;
#endif

//-------------------------------------------------------------------
//-------------------------------------------------------------------
//REVISIT - PSFixedTypes.h would probably be a more appropriate name for this file

#ifndef _REAL32
    #define _REAL32
	typedef float	real32;
#endif

#ifndef _REAL64
    #define _REAL64
	typedef double	real64;
#endif

typedef double nativeFloat;

#endif /* __PSIntTypes.h__ */

```

---

<h2>Begin File: SPAccess.h</h2>

```cpp
/***********************************************************************/
/*                                                                     */
/* SPAccess.h                                                          */
/*                                                                     */
/* Copyright 1995-2006 Adobe Systems Incorporated.                     */
/* All Rights Reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/***********************************************************************/

#ifndef __SPAccess__
#define __SPAccess__


/*******************************************************************************
 **
 **	Imports
 **
 **/

#include "SPTypes.h"
#include "SPPlugs.h"
#include "SPMData.h"

#ifdef __cplusplus
extern "C" {
#endif


/*******************************************************************************
 **
 ** Constants
 **
 **/

/*
 *	The name and version number of the Sweet Pea Plug-in Access suite.
 */

#define kSPAccessSuite				"SP Access Suite"
/** Plug-in Access suite name */
#define kSPAccessSuiteVersion		3

/** @ingroup Callers
	The \c #SPAccessSuite sends a reload message (\c #kSPAccessReloadSelector)
	to a plug-in when it has just been loaded, and an unload message
	(\c #kSPAccessUnloadSelector) when it is about to be unloaded.
	A plug-in is automatically loaded when the application or another
	plug-in calls it or acquires as suite that it exports.
	A plug-in can be unloaded at any time if it is not being used.

 	A plug-in that exports a suite should unload the suite's procedure pointers
 	when it is unloaded, and restore them when the plug-in is reloaded.
 		\li On unload, replace the suite's procedure pointers
 			with the address of the \c #SPBasicSuite::Undefined() function
 			(which is always available). This is a protective measure
 			against other plug-ins that may mistakenly use the suite after they have
 			released it.
		\li On reload, restore the suite's procedure
			pointers with the updated addresses of their functions.

	For example:
	@code
	 	SPErr UnloadSuite( MySuite *mySuite, SPAccessMessage *message ) {
	 		mySuite->functionA = (void *) message->d.basic->Undefined;
	 		mySuite->functionB = (void *) message->d.basic->Undefined;
	 	}

	 	SPErr ReloadSuite( MySuite *mySuite, SPAccessMessage *message ) {
	 		mySuite->functionA = functionA;
	 		mySuite->functionB = functionB;
	 	}
	@endcode
	*/
#define kSPAccessCaller				"SP Access"
/** @ingroup Selectors
	The first message a plug-in receives on startup (whether
	loaded or reloaded). Allows you to restore saved state information,
	before startup initialization.
	See \c #kSPAccessCaller, \c #SPAccessSuite */
#define kSPAccessReloadSelector		"Reload"
/** @ingroup Selectors
	The first message a plug-in receives before being unloaded.
	Allows you to save state information
	See \c #kSPAccessCaller, \c #SPAccessSuite */
#define kSPAccessUnloadSelector		"Unload"

/** The name of the object that the \c #SPAccessSuite caches,
	which can be purged when caches are flushed. During a cache flush,
	if this is the type sent to the \c #SPFlushCachesProc, it can
	make calls to the Access suite to collect information about
	the access object before deciding to purge it or not.

	For example, this purges filter plug-ins before window plug-ins:
@code
int32 myFlushCachesProc( const char *type, void *data, SPErr *error ) {
int32 flush = TRUE;
if ( strcmp( type, kSPFlushAccessType ) == 0 ) {
	SPAccessRef access = data;
  	SPPluginRef plugin = sAccess->GetAccessPlugin( access, error );
  	fail( error );
		switch ( myPluginType( plugin ) ) {
  			case kMyFilterPlugin:
				if ( gPurgeLevel < kFilterPurgeLevel )
					flush = FALSE;
  				break;
  			case kMyWindowPlugin:
  				if ( gPurgeLevel < kWindowPurgeLevel )
  					flush = FALSE;
  				break;
  		}
  	}
 	return flush;
}
@endcode
*/
#define kSPFlushAccessType			"SP Flush Access"


/*******************************************************************************
 **
 ** Types
 **
 **/

/** Prototype for a plug-in entry point, which receives messages from
	the application or other plug-ins.
		@param caller The caller, which identifies what suite or subsystem
			made the call. See @ref Callers.
		@param selector The specific event that triggered the call. See @ref Selectors.
		@param message The message data, whose type depends on the specific event.
	*/
typedef SPAPI SPErr (*SPEntry)( const char *caller, const char *selector, void *message );


/** A plug-in access object, used with the \c #SPAccessSuite to make calls
	to a plug-in. These objects are reference counted. The count is
	incremented when you acquire the object using \c #SPAccessSuite::AcquirePlugin()
	and decremented when you release it with \c #SPAccessSuite::ReleasePlugin(),
	so you must be careful to balance these calls. The object is automatically
	created and the plug-in loaded if necessary, and the object is destroyed
	and the plug-in unloaded when the reference count is 0.*/
typedef struct SPAccess *SPAccessRef;





/** Plug-in library handle on Windows, resource chain on Mac. \deprecated  */
typedef void *SPPlatformAccessRef;


/** Access  information for the resource chain on Mac OS, or library information on Windows.
	See \c #SPAccessSuite::GetAccessInfo(). */
typedef struct {
	/** File access for entry and resources, when resource-access has not been set. \deprecated */
	SPPlatformAccessRef defaultAccess;	/* */
	/** \deprecated File access for entry and resources, when resource-access
		has been set using \c #SPAccessSuite::SetPluginResourceAccess().
		Otherwise \c NULL. */
	SPPlatformAccessRef resourceAccess;
	/** The time since the last access operation, in clock-ticks (1/60th second). */
	uint32 lastAccessTicks;
} SPPlatformAccessInfo;



/** Sent in the \c #SPAccessMessage to identify when an access call was made.
	Use to distinguish a start-up load from a run-time load or reload,
	and a run-time unload from a shut-down unload. */
typedef enum {
	/** The receiving plug-in has been loaded at application startup, and not yet initialized.
		Sent with the \c #kSPAccessReloadSelector.*/
	kStartup = 0,
	/** The receiving plug-in has been loaded programmatically while the application
		is running, and not yet initialized. <<is this right?>>
		Sent with the \c #kSPAccessReloadSelector.*/
	kRuntime,
	/** The receiving plug-in is about to be unloaded.
		Sent with the \c #kSPAccessUnloadSelector. */
	kShutdown,
	/** The receiving plug-in has a non-zero access count and the application is shutting down.
		Sent with the \c #kSPAccessUnloadSelector.
		If the plug-in has acquired itself in order to remain in memory,
		it should not free any resources  and not acquire others when this
		call is received.*/
	kTerminal
} SPAccessPoint;

/** Message sent with the \c #kSPAccessCaller.  */
typedef struct SPAccessMessage {
	/** The message data. */
	SPMessageData d;
	/** When the access occurred.  */
	SPAccessPoint when;
} SPAccessMessage;


/*******************************************************************************
 **
 ** Suite
 **
 **/

/** @ingroup Suites
	This suite is used to load and unload plug-ins. The functions allow
	you to send messages directly to another plug-in. For example:
@code
 	SPErr SendMessage( SPPluginRef plugin, const char *caller, const char *selector, void *message, SPErr *error ) {

 		SPErr result;
 		SPAccessRef access;

 		access = sAccess->AcquirePlugin( plugin, error );
 		fail( error );

 		result = sAccess->CallPlugin( access, caller, selector, message, error );
 		fail( error );

 		sAccess->ReleasePlugin( access, error );
 		fail( error );

 		return result;
 	}
@endcode
	Standard PICA plug-ins rarely call one another directly. Usually program
  	control flows from plug-in to plug-in through higher-level suites.
 	Plug-in adapters, which provide protocol conversion to non-PICA plug-ins,
 	can add their own access suites to provide access to their foreign plug-ins.

	@see \c #SPInterfaceSuite

	\li Acquire this suite using \c #SPBasicSuite::AcquireSuite() with the constants
		\c #kSPAccessSuite and \c #kSPAccessSuiteVersion.
*/
typedef struct SPAccessSuite {

 	/** Loads a plug-in if necessary, and prepares it to be called. Creates
 		an accessor object if necessary, or increments the reference count
 		of the existing accessor. Use \c #ReleasePlugin() to decrement
		the count when you not longer need the accessor.

		A plug-in can acquire itself in order to remain in memory, even if
		not referenced by any other plug-in.
			@param plugin The plug-in object.
			@param access [out] A buffer in which to return the new access object.
 		*/
	SPAPI SPErr (*AcquirePlugin)( SPPluginRef plugin, SPAccessRef *access );

 	/** Decrements the reference count of an accessor object.
 		When the reference count reaches 0, frees the accessor object
 		and allows the associated plug-in to be unloaded.
 			@param access The access object.
 		*/
	SPAPI SPErr (*ReleasePlugin)( SPAccessRef access );

	/** Retrieves the accessor object for a plug-in.
		You can use this to get the accessor for your own plug-in, in order
		to access the resource chain or library information.

		Used by plug-ins that export suites to manually establish a
		resource context within any of the suite procedures, so that
		they can access resources. Not needed when a plug-in is called
		through its entry point. \c #SPAccessSuite::CallPlugin()
		sets up the resource context for you.

			@param plugin The plug-in object.
			@param access [out] A buffer in which to return the access object,
				or \c NULL if the plug-in is not loaded.
	 	*/
	SPAPI SPErr (*GetPluginAccess)( SPPluginRef plugin, SPAccessRef *access );
	/** Retrieves the plug-in for an accessor.
			@param access The access object.
			@param plugin [out] A buffer in which to return the plug-in object,
				or \c NULL if the plug-in is not loaded. <<right?>>
	 	*/
	SPAPI SPErr (*GetAccessPlugin)( SPAccessRef access, SPPluginRef *plugin );
	/** Retrieves the entry point of a plug-in accessor. This is the point to
		which \c #CallPlugin() jumps. Before accessing the entry point directly,
		use \c #SetCurrentPlugin() to make the plug-in current.
			@param access The access object.
			@param entry [out] A buffer in which to return the entry point structure.
		*/
	SPAPI SPErr (*GetAccessEntry)( SPAccessRef access, SPEntry *entry );
	/** Retrieves the current reference count of an accessor object.
			@param access The access object.
			@param count [out] A buffer in which to return the count.
		*/
	SPAPI SPErr (*GetAccessCount)( SPAccessRef access, int32 *count );
	/** Retrieves the platform-specific resource access information of a plug-in accessor.
		This is for the resource-chain in Mac OS, or the plug-in library in Windows.
			@param access The access object.
			@param info [out] A buffer in which to return the information structure.
		*/
	SPAPI SPErr (*GetAccessInfo)( SPAccessRef access, SPPlatformAccessInfo *info );

	/** Retrieves the platform-specific resource access information of a plug-in accessor.
		This is for the resource-chain in Mac OS, or the plug-in library in Windows.
		<<how is this different from GetAccessInfo?>>
			@param access The access object.
			@param info [out] A buffer in which to return the information structure.
		*/
	SPAPI SPErr (*GetPluginResourceAccess)( SPPluginRef plugin, SPPlatformAccessRef *resourceAccess );
	/** <<how does this work? Does it actually set up the structure? >> */
	SPAPI SPErr (*SetPluginResourceAccess)( SPPluginRef plugin, SPPlatformAccessRef resourceAccess );

	/** Sends a message to a plug-in, using an accessor object.
			@param access The access object.
			@param caller The caller.
			@param slector The selector.
			@param message The message, as required for the selector.
			@param result [out] A buffer in which to return the result of the call,
				returned by the called plug-in.
		*/
	SPAPI SPErr (*CallPlugin)( SPAccessRef access, const char *caller, const char *selector,
					void *message, SPErr *result );

	/** Retrieves the current plug-in, whose access information is the current
		resource context. This is typically the last plug-in to
		receive a call, but can be set by a plug-in adapter, or by
		\c #SetCurrentPlugin().
			@param plugin [out] A buffer in which to return the plug-in object,
		*/
	SPAPI SPErr (*GetCurrentPlugin)( SPPluginRef *plugin );
	/** Makes a plug-in and its resource context current. An adapter can use
		this to set the resource context before making a call to a plug-in.
		Before making this call, you should save the reference for the current
		plug-in, and restore it when this plug-in no longer needs to be current.
			@param plugin The plug-in object,
		*/
	SPAPI SPErr (*SetCurrentPlugin)( SPPluginRef plugin );

} SPAccessSuite;

/** Internal */
SPAPI SPErr SPAcquirePlugin( SPPluginRef plugin, SPAccessRef *access );
/** Internal */
SPAPI SPErr SPReleasePlugin( SPAccessRef access );

/** Internal */
SPAPI SPErr SPGetPluginAccess( SPPluginRef plugin, SPAccessRef *access );
/** Internal */
SPAPI SPErr SPGetAccessPlugin( SPAccessRef access, SPPluginRef *plugin );
/** Internal */
SPAPI SPErr SPGetAccessEntry( SPAccessRef access, SPEntry *entry );
/** Internal */
SPAPI SPErr SPGetAccessCount( SPAccessRef access, int32 *count );
/** Internal */
SPAPI SPErr SPGetAccessInfo( SPAccessRef access, SPPlatformAccessInfo *info );

/** Internal */
SPAPI SPErr SPGetPluginResourceAccess( SPPluginRef plugin, SPPlatformAccessRef *resourceAccess );
/** Internal */
SPAPI SPErr SPSetPluginResourceAccess( SPPluginRef plugin, SPPlatformAccessRef resourceAccess );

/** Internal */
SPAPI SPErr SPCallPlugin( SPAccessRef access, const char *caller, const char *selector,
			void *message, SPErr *result );

/** Internal */
SPAPI SPErr SPGetCurrentPlugin( SPPluginRef *plugin );
/** Internal */
SPAPI SPErr SPSetCurrentPlugin( SPPluginRef plugin );


/*******************************************************************************
 **
 ** Errors
 **
 **/

#include "SPErrorCodes.h"

#ifdef __cplusplus
}
#endif

#endif

```

---

<h2>Begin File: SPAdapts.h</h2>

```cpp
/***********************************************************************/
/*                                                                     */
/* SPAdapts.h														   */
/*                                                                     */
/* Copyright 1995-2006 Adobe Systems Incorporated.                     */
/* All Rights Reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/***********************************************************************/

#ifndef __SPAdapters__
#define __SPAdapters__


/*******************************************************************************
 **
 **	Imports
 **
 **/

#include "SPTypes.h"
#include "SPCaches.h"
#include "SPMData.h"
#include "SPProps.h"

#ifdef __cplusplus
extern "C" {
#endif



/*******************************************************************************
 **
 ** Constants
 **
 **/

/** SPAdapters suite name */
#define kSPAdaptersSuite					"SP Adapters Suite"
/** SPAdapters suite version */
#define kSPAdaptersSuiteVersion				3

/** @ingroup Callers
	Caller for a plug-in adapter. Sent to plug-ins
	with adapters to allow the adapter to load or unload
	files of managed types, or to  make translations for
	compatability with legacy versions of PICA, the application,
	or earlier versions of the plug-in.
	See \c #SPAdaptersSuite.  */
#define kSPAdaptersCaller					"SP Adapters"

/** @ingroup Selectors
	Received by a plug-in with an adapter on application startup, after
	PICA completes its plug-in startup process. Use for initialization
	related to the adapter.
	See \c #kSPAdaptersCaller, \c #SPAdaptersMessage, \c #SPAdaptersSuite.  */
#define kSPAdaptersStartupSelector			"Start up"
/** @ingroup Selectors
	Received by a plug-in with an adapter on application shutdown, after
	PICA completes its plug-in shutdown process. Use for termination cleanup
	related to the adapter.
	See \c #kSPAdaptersCaller, \c #SPAdaptersMessage, \c #SPAdaptersSuite.  */
#define kSPAdaptersShutdownSelector			"Shut down"
/** @ingroup Selectors
	Received by a plug-in with an adapter after a call to
	\c #SPCachesSuite::SPFlushCaches(), for a final flush of
	any memory used for private data, including PICA lists and
	string pools.
	See \c #kSPAdaptersCaller, \c #SPAdaptersMessage, \c #SPAdaptersSuite.  */
#define kSPAdaptersDisposeInfoSelector		"Dispose info"
/** @ingroup Selectors
	Received by a plug-in with an adapter when	the application
	frees memory, to allow garbage collection.
	See \c #kSPAdaptersCaller, \c #SPAdaptersMessage, \c #SPAdaptersSuite.  */
#define kSPAdaptersFlushSelector			"Flush"

// Second generation adapters (has property 'adpt'/2)
//---------------------------------------------------
/** @ingroup Selectors
	Received by a plug-in after its initialization, to allow it to
	register its own adapter. Get the adapter list from PICA and
	use \c #SPAdaptersSuite::AddAdapter( ) to register your adapter.
	For example:
	@code
SPAdapterRef oldAPI;
SPAdapterListRef adapterList;
SPErr error;
error = sSPRuntime->GetRuntimeAdapterList( &adapterList);
error = sSPAdapters->AddAdapter( adapterList, message->d.self, "old API adapter", &oldAPI );
	@endcode

	See \c #kSPAdaptersCaller, \c #SPAdaptersMessage, \c #SPAdaptersSuite.  */
#define kSPAdaptersRegisterPluginsSelector		"Register plugins"

/** @ingroup Selectors
	Received by a plug-in with an adapter before it is loaded, to allow the
	adapter to perform needed translations before the load occurs. The
	handler does not need to call the load operation.
	See \c #kSPAdaptersCaller, \c #SPAdaptersMessage, \c #SPAdaptersSuite.  */
#define kSPAdaptersLoadPluginSelector			"Load plugin"
/** @ingroup Selectors
	Received by a plug-in with an adapter before it is unloaded, to allow the
	adapter to perform needed translations before the unload occurs. The
	handler does not need to call the unload operation.
	See \c #kSPAdaptersCaller, \c #SPAdaptersMessage, \c #SPAdaptersSuite.  */
#define kSPAdaptersReleasePluginSelector		"Release plugin"

/** @ingroup Selectors
	Received by a plug-in with an adapter when the application needs to
	communicate with it. The adapter should relay the message, performing
	any required translation.
	See \c #kSPAdaptersCaller, \c #SPAdaptersMessage, \c #SPAdaptersSuite.  */
#define kSPAdaptersSendMessageSelector			"Send message"

// First generation adapters (no 'adpt' property, or 'adpt'/1 )
//-------------------------------------------------------------
// These messages are only for the "SP2 Adapter" that is built into
// Sweet Pea and maybe legacy adapters (i.e., AI6Adapter for AI7).
// For newer adapters, all of these methods are now deprecated.
// New adapters should do the vast majority of their processing via
// the message kSPAdaptersSendMessageSelector.
/** @deprecated Used internally. */
#define kSPAdaptersFindPropertySelector			"Find property"
/** @deprecated Used internally.  */
#define kSPAdaptersAboutSelector				"About"
/** @deprecated Used internally.   */
#define kSPAdaptersAcquireSuiteHostSelector		"Acquire Suite"
/** @deprecated Used internally.   */
#define kSPAdaptersReleaseSuiteHostSelector		"Release Suite"

/** PICA global list of registered plug-in adapters.
	@see \c #SPAdaptersSuite::AddAdapter(), \c #SPRuntimeSuite::GetRuntimeAdapterList(). */
#define kSPRuntimeAdapterList				((SPAdapterListRef)NULL)


/*******************************************************************************
 **
 ** Types
 **
 **/

/** An opaque reference to an adapter object. Access using the \c #SPAdaptersSuite. */
typedef struct SPAdapter *SPAdapterRef;
/** A list of adapter objects. Create with
	\c #SPAdaptersSuite::AllocateAdapterList(), or use
	the global list, \c #kSPRuntimeAdapterList. */
typedef struct SPAdapterList *SPAdapterListRef;
/** An iterator object for examining an adapter list.
	See \c #SPAdaptersSuite::NewAdapterListIterator(). */
typedef struct SPAdapterListIterator *SPAdapterListIteratorRef;

/** The message passed with all \c #kSPAdaptersCaller calls.
	Fields are used by specific selectors as indicated. */
typedef struct SPAdaptersMessage {
	/** The message data. All selectors. */
	SPMessageData d;
	/** The adapter object. All selectors. If you add more than
		one adapter for a plug-in, use this to determine which handler to use. */
	SPAdapterRef adapter;

	/** For \c #kSPAdaptersAboutSelector, the plug-in object for which to display information.
		No longer used. <<right?>> */
	struct SPPlugin *targetPlugin;
	/** For \c #kSPAdaptersAboutSelector, the target result of the handler, if any.
		No longer used. <<right?>>  */
	SPErr targetResult;

	/** For \c #kSPAdaptersFindPropertySelector.
		No longer used. */
	PIType vendorID;
	/** For \c #kSPAdaptersFindPropertySelector.
		No longer used. */
	PIType propertyKey;
	/** For \c #kSPAdaptersFindPropertySelector.
		No longer used.  */
	int32 propertyID;
	/** For \c #kSPAdaptersFindPropertySelector.
		No longer used.  */
	void *property;

	/** For \c #kSPAdaptersFlushSelector. The procedure with which to flush caches,
		passed from the call to \c #SPCachesSuite::SPFlushCaches().
		The adapter should call this to determine which plug-ins are being removed from
		memory, and unload them.  */
	SPFlushCachesProc flushProc;
	/** For \c #kSPAdaptersFlushSelector. Return the result of the flush procedure,
		the number of plug-ins removed.*/
	int32 flushed;

	/** For \c #kSPAdaptersAcquireSuiteHostSelector and \c #kSPAdaptersReleaseSuiteHostSelector.
	 	No longer used.*/
	struct SPSuiteList *suiteList;	/* use these if you need name, apiVersion, internalVersion */
	/** For \c #kSPAdaptersAcquireSuiteHostSelector and \c #kSPAdaptersReleaseSuiteHostSelector.
	 	No longer used.*/
	struct SPSuite *suite;
	/** For \c #kSPAdaptersAcquireSuiteHostSelector and \c #kSPAdaptersReleaseSuiteHostSelector.
	 	No longer used.*/
	struct SPPlugin *host;			/* plug-in hosting the suite, to be aquired/released by adapter */
	/** For \c #kSPAdaptersAcquireSuiteHostSelector and \c #kSPAdaptersReleaseSuiteHostSelector.
	 	No longer used.*/
	const void *suiteProcs;			/* returned here if reallocated */
	/** For \c #kSPAdaptersAcquireSuiteHostSelector and \c #kSPAdaptersReleaseSuiteHostSelector.
	 	No longer used.*/
	int32 acquired;					/* returned here */

	/** For \c #kSPAdaptersSendMessageSelector.
		The caller to pass to the adapted plug-in. */
	const char *plugin_caller;
	/** For \c #kSPAdaptersSendMessageSelector.
		The selector to pass to the adapted plug-in. */
	const char *plugin_selector;
	/** For \c #kSPAdaptersSendMessageSelector.
		The message to pass to the adapted plug-in. */
	void *plugin_message;
} SPAdaptersMessage;

/** A string pool structure. See \c #SPStringsSuite. */
struct SPStringPool;

/*******************************************************************************
 **
 ** Suite
 **
 **/
/** @ingroup Suites
	An adapter is an interface between the PICA plug-in manager and
	an individual plug-in. PICA and application plug-ins are hosted by
	internal PICA adapters. Plug-ins can add other adapters to PICA's
	\e adapter \e list, allowing non-PICA plug-ins to run under the PICA API.

	\li Acquire this suite using \c #SPBasicSuite::AcquireSuite() with the constants
		\c #kSPAdaptersSuite and \c #kSPAdaptersSuiteVersion.

	An adapter searches the PICA \e file \e list (\c #kSPRuntimeFileList)
	for plug-ins types that it supports, and adds them to the \e plug-in \e list
	(\c #kSPRuntimePluginList). When notified by PICA to do so, the adapter is
	responsible for loading and calling the plug-ins it adds, and must
	do any conversion of messages, data structures or other API elements.
	An adapter can be used to update

	There are always at least two adapters, the internal adapters for PICA
	and for the application, in the  global adapter list (\c #kSPRuntimeAdapterList).
	The internal adapters translate any legacy function calls into those
	currently supported by PICA and the application.

	You can provide an adapter for backward compatability with older
	versions of your own plug-ins, or to interpret your own file types.
	To make an adapter available for your plug-in, add it in response to the
	\c #kSPAdaptersRegisterPluginsSelector when your plug-in is loaded.

	You can also use this suite to create and maintain your own adapter list,
	in addition to the global list.

	Use the adapter to load and call the adapted plug-in. For example, to
	verify that a message could be sent to a plug-in:
@code
SPErr error;
SPPluginRef pluginToCall;
SPAdapterRef pluginsAdapter;
char *adapterName;
int32 adapterVersion;

error = sSPPlugins->GetPluginAdapter( pluginToCall, &pluginsAdapter );
error = sSPAdapters->GetAdapterName( pluginsAdapter, &adapterName );
if ( strcmp( adapterName, kSPSweetPea2Adapter ) == 0 ) {
	// it is a PICA plug-in, call it as such with sSPInterface.
	} else if ( strcmp( adapterName, "MYAPP Legacy Plug-in Adapter" ) == 0 ) {
		// it is an adapted plug-in, call it with the adapter's
		// interface suite
		error = sSPAdapters->GetAdapterVersion( pluginsAdapter, &adapterVersion );
		if ( adapterVersion == 1 ) {
			// use one hypothetical interface suite
			} else if ( adapterVersion == 2) {
			// use another hypothetical interface suite
		}
	}
@endcode
*/
typedef struct SPAdaptersSuite {

	/** Allocates a new list of adapters. You can keep your own list,
		or obtain the global list with \c #SPRuntimeSuite::GetRuntimeAdapterList().
			@param stringPool The string pool in which to keep adapter names.
			@param adapterList [out] A buffer in which to return the new list object.
		*/
	SPAPI SPErr (*AllocateAdapterList)( struct SPStringPool *stringPool, SPAdapterListRef *adapterList );
	/** Frees a list of adapters allocated with \c #AllocateAdapterList(), and
		also frees any entries in the list. Do not free the global list (\c #kSPRuntimeAdapterList).
			@param adapterList The adapter list object.
		*/
	SPAPI SPErr (*FreeAdapterList)( SPAdapterListRef adapterList );
	/** Creates a new adapter object and adds it to an adapter list. Do this in
		response to the \c #kSPAdaptersRegisterPluginsSelector message.
			@param adapterList The adapter list object, or \c NULL to use the
				global list.
			@param host	This plug-in object, for which the adapter is responsible.
			@param name The unique, identifying name of the adapter.
			@param version The version number of the adapter. Only the latest version
				of any adapter is used to start up plug-ins.
			@param adapter [out] A buffer in which to return the new adapter object, or
				\c NULL if you add only one adapter. If you add more than one adapter,
				compare this to \c #SPAdaptersMessage::adapter to determine which handler to use.
			@see \c #AllocateAdapterList()
		*/
	SPAPI SPErr (*AddAdapter)( SPAdapterListRef adapterList, struct SPPlugin *host, const char *name,
				int32 version, SPAdapterRef *adapter );

	/** Retrieves an adapter by name.
			@param adapterList The adapter list object, or \c NULL to use the
				global list.
			@param name The unique, identifying name of the adapter.
			@param adapter [out] A buffer in which to return the adapter object.
		*/
	SPAPI SPErr (*SPFindAdapter)( SPAdapterListRef adapterList, const char *name, SPAdapterRef *adapter );

	/** Creates an iterator object with which to traverse an adapter list.
		The iterator is initially set to the first adapter in the list.
			@param adapterList The adapter list object, or \c NULL to use the
				global list.
			@param iter [out] A buffer in which to return the new iterator object.
			@see \c #NextAdapter(), \c #DeleteAdapterListIterator()
		*/
	SPAPI SPErr (*NewAdapterListIterator)( SPAdapterListRef adapterList, SPAdapterListIteratorRef *iter );
	/** Retrieves the current adapter and advances an adapter-list iterator to the
		next adapter in the list.
			@param iter The adapter-list iterator object.
			@param adapter [out] A buffer in which to return the current adapter object, \c NULL
				if the end of the list has been reached.
		    @see \c #NewAdapterListIterator(),
		*/
	SPAPI SPErr (*NextAdapter)( SPAdapterListIteratorRef iter, SPAdapterRef *adapter );
	/** Frees an adapter-list iterator that is no longer needed.
			@param iter The adapter-list iterator object.
			@see \c #NewAdapterListIterator(),
		*/
	SPAPI SPErr (*DeleteAdapterListIterator)( SPAdapterListIteratorRef iter );

	/** Retrieves the plug-in that an adapter manages.
			@param adapter The adapter object.
			@param plug-in [out] A buffer in which to return the plug-in object.
		*/
	SPAPI SPErr (*GetAdapterHost)( SPAdapterRef adapter, struct SPPlugin **plugin );
	/** Retrieves the unique, identifying name of an adapter.
			@param adapter The adapter object.
			@param name [out] A buffer in which to return the name string.
		*/
	SPAPI SPErr (*GetAdapterName)( SPAdapterRef adapter, const char **name );
	/** Retrieves the version of an adapter.
			@param adapter The adapter object.
			@param version [out] A buffer in which to return the version number.
		*/
	SPAPI SPErr (*GetAdapterVersion)( SPAdapterRef adapter, int32 *version );

} SPAdaptersSuite;


/** Internal */
SPAPI SPErr SPAllocateAdapterList( struct SPStringPool *stringPool, SPAdapterListRef *adapterList );
/** Internal */
SPAPI SPErr SPFreeAdapterList( SPAdapterListRef adapterList );

/** Internal */
SPAPI SPErr SPAddAdapter( SPAdapterListRef adapterList, struct SPPlugin *host, const char *name,
			int32 version, SPAdapterRef *adapter );

/** Internal */
SPAPI SPErr SPFindAdapter( SPAdapterListRef adapterList, const char *name, SPAdapterRef *adapter );

/** Internal */
SPAPI SPErr SPNewAdapterListIterator( SPAdapterListRef adapterList, SPAdapterListIteratorRef *iter );
/** Internal */
SPAPI SPErr SPNextAdapter( SPAdapterListIteratorRef iter, SPAdapterRef *adapter );
/** Internal */
SPAPI SPErr SPDeleteAdapterListIterator( SPAdapterListIteratorRef iter );

/** Internal */
SPAPI SPErr SPGetAdapterHost( SPAdapterRef adapter, struct SPPlugin **plugin );
/** Internal */
SPAPI SPErr SPGetAdapterName( SPAdapterRef adapter, const char **name );
/** Internal */
SPAPI SPErr SPGetAdapterVersion( SPAdapterRef adapter, int32 *version );


/*******************************************************************************
 **
 ** Errors
 **
 **/

#include "SPErrorCodes.h"


#ifdef __cplusplus
}
#endif

#endif

```

---

<h2>Begin File: SPBasic.h</h2>

```cpp
/***********************************************************************/
/*                                                                     */
/* SPBasic.h                                                           */
/*                                                                     */
/* Copyright 1995-2006 Adobe Systems Incorporated.                     */
/* All Rights Reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/***********************************************************************/

#ifndef __SPBasic__
#define __SPBasic__


/*******************************************************************************
 **
 **	Imports
 **
 **/

#include "SPTypes.h"
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif


/*******************************************************************************
 **
 **	Constants
 **
 **/
/** PICA basic suite name */
#define kSPBasicSuite				"SP Basic Suite"
/** PICA basic suite version */
#define kSPBasicSuiteVersion		4


/*******************************************************************************
 **
 **	Suite
 **
 **/

/** @ingroup Suites
	This suite provides basic memory management for PICA (the Adobe plug-in manager)
	and defines the basic functions for acquiring and releasing other suites.

	A suite consists of a list of function pointers. The application, or a
	plug-in that loads a suite, provides valid pointers when the suite is
	acquired. When a suite is not available, the pointers are set to the
	address of the \c #Undefined() function.

	Do not attempt to acquire a suite (other than the \c #SPBlocksSuite)
	in response to a PICA access (\c #kSPAccessCaller) or property
	(\c #kSPPropertiesCaller) message. Most suites are unavailable
	during these load and unload operations.

	You can acquire all the suites you will need when your plug-in is first
	loaded, as long as you release them before your plug-in is unloaded.
	At shutdown, however, it is most efficient to acquire only those
	suites explicitly needed to shut down; for example, to free memory
	and save preferences.

	The \c SPBasicSuite itself is a part of the message data passed
	to your plug-in with any call. To access it from the message data structure:
	@code
	SPBasicSuite sBasic = message->d.basic;
	sBasic->function( )
	@endcode
	*/
typedef struct SPBasicSuite {
	/** Acquires a function suite. Loads the suite if necessary,
		and increments its reference count. For example:
	@code
SPErr error;
SPBasicSuite *sBasic = message->d.basic;
AIRandomSuite *sRandom;
sBasic->AcquireSuite( kAIRandomSuite, kAIRandomVersion, &sRandom );
	@endcode
			@param name The suite name.
			@param version The suite version number.
			@param suite [out] A buffer in which to return the suite pointer.
			@see \c #SPSuitesSuite::AcquireSuite()
		*/
	SPAPI SPErr (*AcquireSuite)( const char *name, int32 version, const void **suite );
	/** Decrements the reference count of a suite and unloads it when the
		reference count reaches 0.
			@param name The suite name.
			@param version The suite version number.
		*/
	SPAPI SPErr (*ReleaseSuite)( const char *name, int32 version );
	/** Compares two strings for equality.
			@param token1 The first null-terminated string.
			@param token2 The second null-terminated string.
			@return True if the strings are the same, false otherwise.
		*/
	SPAPI SPBoolean (*IsEqual)( const char *token1, const char *token2 );
	/** Allocates a block of memory.
			@param size The number of bytes.
			@param block [out] A buffer in which to return the block pointer.
			@see \c #SPBlocksSuite::AllocateBlock()
		*/
	SPAPI SPErr (*AllocateBlock)( size_t size, void **block );
	/** Frees a block of memory allocated with \c #AllocateBlock().
			@param block The block pointer.
			@see \c #SPBlocksSuite::FreeBlock()
		*/
	SPAPI SPErr (*FreeBlock)( void *block );
	/** Reallocates a block previously allocated with \c #AllocateBlock().
		Increases the size without changing the location, if possible.
			@param block The block pointer.
			@param newSize The new number of bytes.
			@param newblock [out] A buffer in which to return the new block pointer.
			@see \c #SPBlocksSuite::ReallocateBlock()
		*/
	SPAPI SPErr (*ReallocateBlock)( void *block, size_t newSize, void **newblock );
 	/** A function pointer for unloaded suites. This is a protective measure
 		against other plug-ins that may mistakenly use the suite after they have
 		released it.

 		A plug-in that exports a suite should unload the suite's procedure pointers
 		when it is unloaded, and restore them when the plug-in is reloaded.
 		\li On unload, replace the suite's procedure pointers
 			with the address of this function.
		\li On reload, restore the suite's procedure
			pointers with the updated addresses of their functions.

		For example:
	@code
	 	SPErr UnloadSuite( MySuite *mySuite, SPAccessMessage *message ) {
	 		mySuite->functionA = (void *) message->d.basic->Undefined;
	 		mySuite->functionB = (void *) message->d.basic->Undefined;
	 	}

	 	SPErr ReloadSuite( MySuite *mySuite, SPAccessMessage *message ) {
	 		mySuite->functionA = functionA;
	 		mySuite->functionB = functionB;
	 	}
	@endcode
		*/
	SPAPI SPErr (*Undefined)( void );

} SPBasicSuite;


/** Internal */
SPAPI SPErr SPBasicAcquireSuite( const char *name, int32 version, const void **suite );
/** Internal */
SPAPI SPErr SPBasicReleaseSuite( const char *name, int32 version );
/** Internal */
SPAPI SPBoolean SPBasicIsEqual( const char *token1, const char *token2 );
/** Internal */
SPAPI SPErr SPBasicAllocateBlock( size_t size, void **block );
/** Internal */
SPAPI SPErr SPBasicFreeBlock( void *block );
/** Internal */
SPAPI SPErr SPBasicReallocateBlock( void *block, size_t newSize, void **newblock );
/** Internal */
SPAPI SPErr SPBasicUndefined( void );

/*******************************************************************************
 **
 **	Errors
 **
 **/

#include "SPErrorCodes.h"

#ifdef __cplusplus
}
#endif

#endif

```

---

<h2>Begin File: SPBckDbg.h</h2>

```cpp
/***********************************************************************/
/*                                                                     */
/* SPBckDbg.h                                                          */
/*                                                                     */
/* Copyright 1995-2006 Adobe Systems Incorporated.                     */
/* All Rights Reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/***********************************************************************/

#ifndef __SPBlockDebug__
#define __SPBlockDebug__


/*******************************************************************************
 **
 **	Imports
 **
 **/

#include "SPTypes.h"

#ifdef __cplusplus
extern "C" {
#endif


/*******************************************************************************
 **
 **	Constants
 **
 **/
/** SPBlockDebug suite name */
#define kSPBlockDebugSuite			"SP Block Debug Suite"
/** SPBlockDebug suite version */
#define kSPBlockDebugSuiteVersion	2


/*******************************************************************************
 **
 **	Suite
 **
 **/

/** @ingroup Suites
	This suite provides basic debugging capability for blocks of memory
	allocated with the \c #SPBlocksSuite.  Debugging can only be enabled
	in the developement environment.

	\li Acquire this suite using \c #SPBasicSuite::AcquireSuite() with the constants
		\c #kSPBlockDebugSuite and \c #kSPBlockDebugSuiteVersion.
	*/
typedef struct SPBlockDebugSuite {
	/** Reports whether block debugging is enabled.
			@param enabled [out] A buffer in which to return 1 if debugging
				is enabled, 0 otherwise.
		*/
	SPAPI SPErr (*GetBlockDebugEnabled)( int32 *enabled );
	/** Turns debugging on or off.
			@param debug 1 to turn debugging on, 0 to turn it off.
		*/
	SPAPI SPErr (*SetBlockDebugEnabled)( int32 debug );
	/** Retrieves the first block of memory allocated. Use with \c #GetNextBlock()
		to iterate through all allocated blocks.
			@param block [out] A buffer in which to return the block pointer.
		*/
	SPAPI SPErr (*GetFirstBlock)( void **block );
	/** Retrieves the block of memory allocated immediately after a given block.
		Use with \c #GetFirstBlock() to iterate through all allocated blocks.
			@param block The current block pointer
			@param nextblock [out] A buffer in which to return the next block pointer.
		*/
	SPAPI SPErr (*GetNextBlock)( void *block, void **nextblock );
	/** Retrieves the debugging tag assigned to a block of memory when it
		was allocated or reallocated.
			@param block The block pointer.
			@param debug [out] A buffer in which to return the tag string.
			@see \c #SPBlocksSuite::AllocateBlock(), \c #SPBlocksSuite::ReallocateBlock()
		*/
	SPAPI SPErr (*GetBlockDebug)( void *block, const char **debug );

} SPBlockDebugSuite;


/** Internal */
SPAPI SPErr SPGetBlockDebugEnabled( int32 *enabled );
/** Internal */
SPAPI SPErr SPSetBlockDebugEnabled( int32 debug );
/** Internal */
SPAPI SPErr SPGetFirstBlock( void **block );
/** Internal */
SPAPI SPErr SPGetNextBlock( void *block, void **nextblock );
/** Internal */
SPAPI SPErr SPGetBlockDebug( void *block, const char **debug );


/*******************************************************************************
 **
 **	Errors
 **
 **/

#include "SPErrorCodes.h"

#ifdef __cplusplus
}
#endif

#endif

```

---

<h2>Begin File: SPBlocks.h</h2>

```cpp
/***********************************************************************/
/*                                                                     */
/* SPBlocks.h                                                          */
/*                                                                     */
/* Copyright 1995-2006 Adobe Systems Incorporated.                     */
/* All Rights Reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/***********************************************************************/

#ifndef __SPBlocks__
#define __SPBlocks__


/*******************************************************************************
 **
 **	Imports
 **
 **/

#ifdef SWEETPEA_STRICTER_HOST_COMPATIBILITY
#include <stddef.h>
#endif
#include "SPTypes.h"

#ifdef __cplusplus
extern "C" {
#endif


/*******************************************************************************
 **
 **	Constants
 **
 **/
/** SPBlocks suite name */
#define kSPBlocksSuite				"SP Blocks Suite"
/** SPBlocks suite version */
#define kSPBlocksSuiteVersion		2


/*******************************************************************************
 **
 **	Suite
 **
 **/
/** @ingroup Suites
	This suite provides basic memory management for PICA (the Adobe plug-in manager),
	with debugging capability for the development version of the application.

	Unlike other suites, this suite is available during plug-in load and unload operations.
	You can acquire it in response to a PICA access (\c #kSPAccessCaller) or property
	(\c #kSPPropertiesCaller) message, and use it to allocate and free memory
	for the plug-in you are loading or unloading.

	\li Acquire this suite using \c #SPBasicSuite::AcquireSuite() with the constants
		\c #kSPBlocksSuite and \c #kSPBlocksSuiteVersion.
	*/
typedef struct SPBlocksSuite {

	/** Allocates a block of memory.
			@param size The number of bytes.
			@param debug Optional. A tag for the block, available in the
				developement version of the application. Otherwise ignored.
				See \c #SPBlockDebugSuite::GetBlockDebug().
			@param block [out] A buffer in which to return the block pointer.
			@see \c #SPBasicSuite::AllocateBlock()
		*/
	SPAPI SPErr (*AllocateBlock)( size_t size, const char *debug, void **block );
	/** Frees a block of memory allocated with \c #AllocateBlock().
			@param block The block pointer.
			@see \c #SPBasicSuite::FreeBlock()
		*/
	SPAPI SPErr (*FreeBlock)( void *block );
	/** Reallocates a block previously allocated with \c #AllocateBlock().
		Increases the size without changing the location, if possible.
			@param block The block pointer.
			@param newSize The new number of bytes.
			@param debug Optional. A tag for the block, available in the
				developement version of the application. Otherwise ignored.
				See \c #SPBlockDebugSuite::GetBlockDebug().
			@param newblock [out] A buffer in which to return the new block pointer.
			@see \c #SPBasicSuite::ReallocateBlock()
		*/
	SPAPI SPErr (*ReallocateBlock)( void *block, size_t newSize, const char *debug, void **rblock );

} SPBlocksSuite;

/** Internal */
SPAPI SPErr SPAllocateBlock( size_t size, const char *debug, void **block );
/** Internal */
SPAPI SPErr SPFreeBlock( void *block );
/** Internal */
SPAPI SPErr SPReallocateBlock( void *block, size_t newSize, const char *debug, void **rblock );


/*******************************************************************************
 **
 **	Errors
 **
 **/

#include "SPErrorCodes.h"

#ifdef __cplusplus
}
#endif

#endif

```

---

<h2>Begin File: SPCaches.h</h2>

```cpp
/***********************************************************************/
/*                                                                     */
/* SPCaches.h                                                          */
/*                                                                     */
/* Copyright 1995-2006 Adobe Systems Incorporated.                     */
/* All Rights Reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/***********************************************************************/

#ifndef __SPCaches__
#define __SPCaches__


/*******************************************************************************
 **
 **	Imports
 **
 **/

#include "SPTypes.h"
#include "SPMData.h"

#ifdef __cplusplus
extern "C" {
#endif


/*******************************************************************************
 **
 **	Constants
 **
 **/
/** Cache suite name */
#define kSPCachesSuite				"SP Caches Suite"
/** Cache suite version */
#define kSPCachesSuiteVersion		2

/* To receive these, an PIConditionalMessages property must be present
 * with the PIAcceptsPurgeCachesMessage flag set. */
/** @ingroup Callers
	The cache management caller. See \c #SPCachesSuite */
#define kSPCacheCaller					"SP Cache"
/** @ingroup Selectors
	Received by plug-in adapters with the \c #PIAcceptsPurgeCachesMessage flag set
	in the \c #PIConditionalMessages property, when a call has
	been made to \c #SPCachesSuite::SPFlushCaches(). Accompanied by
	the \c #SPPurgeCachesMessage.
	@see \c #SPAdaptersSuite, \c #kSPAdaptersDisposeInfoSelector
	*/
#define kSPPluginPurgeCachesSelector	"Plug-in Purge"

/* The plug-in should return one of these two responses when it receives the kSPPluginPurgeCachesSelector */
//<<if these are no longer used, what is the return value?>>
//#define kSPPluginCachesFlushResponse	'pFls'
//#define kSPPluginCouldntFlushResponse	kSPNoError;
#include "SPErrorCodes.h"

/*******************************************************************************
 **
 **	Types
 **
 **/
/** Prototype for the cache-flushing procedure an adapter calls in response to the
	\c #kSPAdaptersDisposeInfoSelector, to determine which plug-ins to unload,
	and inform the caller of whether its managed plug-in have been unloaded.
		@param type The plug-in type, as set by the adapter.<<where is this set?>>
		@param data A pointer to the adapter-defined plug-in data. <<what data? where defined?>>
		@param flushed [out] A buffer in which to return the result,
			the number of plug-ins actually unloaded.
	*/
typedef SPErr (*SPFlushCachesProc)( const char *type, void *data, int32 *flushed );

/** Message passed with the \c #kSPPluginPurgeCachesSelector. */
typedef struct SPPurgeCachesMessage {
	/** The message data. */
	SPMessageData d;
} SPPurgeCachesMessage;


/*******************************************************************************
 **
 **	Suite
 **
 **/
/** @ingroup Suites
	This suite allows you to manage PICA cache memory.

	PICA plug-ins are intended to move in and out of memory (cache) as necessary,
	to allow a small memory footprint. By default, PICA keeps loaded plug-ins in
	cache until the application heap has been filled, and then unloads them.
	Beyond this simple strategy, the application and plug-ins can use this
	function to unload plug-ins when needed. Plug-ins do not typically need
	to do this.

	\li Acquire this suite using \c #SPBasicSuite::AcquireSuite() with the constants
		\c #kSPCachesSuite and \c #kSPCachesSuiteVersion.
*/
typedef struct SPCachesSuite {
	/** Sends a message to all plug-in adapters telling them to unload any
		unused plug-ins from memory.
			@param flushProc The procedure the adapter uses to determine which
				plug-ins to unload.
			@param flushed [out] A buffer in which to return the result of the
				procedure calls, the total number of plug-ins actually unloaded.
		*/
	SPAPI SPErr (*SPFlushCaches)( SPFlushCachesProc flushProc, int32 *flushed );

} SPCachesSuite;

/** Internal */
SPAPI SPErr SPFlushCaches( SPFlushCachesProc flushProc, int32 *flushed );


#ifdef __cplusplus
}
#endif

#endif

```

---

<h2>Begin File: SPCOM.h</h2>

```cpp
/*  (c) Copyright 2002.  Adobe Systems, Incorporated.  All rights reserved. */

#pragma once

#ifndef __SPCOM__
#define __SPCOM__
/* This module is obsolete. */
#endif // __SPCOM__


```

---

<h2>Begin File: SPConfig.h</h2>

```cpp
/***********************************************************************/
/*                                                                     */
/* SPConfig.h                                                          */
/*                                                                     */
/* Copyright 1995-2006 Adobe Systems Incorporated.                     */
/* All Rights Reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/***********************************************************************/

/**

	SPConfig.h is the environment configuration file for Sweet Pea. It
	defines MAC_ENV or WIN_ENV. These are used to control platform-specific
	sections of code.

 **/

#ifndef __SPCnfig__
#define __SPCnfig__

#if defined(__APPLE_CC__)
#if !defined (MAC_ENV) && !defined(SIMULATED_WASM)
#define MAC_ENV 1
#endif
#endif

/*
 *	Windows
 */
#if defined(_WINDOWS) || defined(_MSC_VER) || defined(WINDOWS)		// PSMod, better compiler check
#ifndef WIN_ENV
#define WIN_ENV 1
#endif
#endif

#ifndef qiOS
#if defined(MAC_ENV) && defined(__arm__)
#define qiOS 1
#endif
#endif

/*
 *	Make certain that one and only one of the platform constants is defined.
 */

#ifdef __ANDROID__
	#define ANDROID_ENV 1
#endif

#ifdef __LINUX__
    #define UNIX_ENV 1
#endif

#if defined (__EMSCRIPTEN__)
	#define WEB_ENV 1
#endif

#if !defined(WIN_ENV) && !defined(MAC_ENV) && !defined(ANDROID_ENV) && !defined(UNIX_ENV) && !defined(WEB_ENV)
	#error
#endif

#if defined(WIN_ENV) && defined(MAC_ENV) && defined(ANDROID_ENV) && defined(UNIX_ENV) && defined (WEB_ENV)
	#error
#endif

#endif

```

---

<h2>Begin File: SPErrorCodes.h</h2>

```cpp
/***********************************************************************/
/*                                                                     */
/* SPErrorCodes.h                                                      */
/*                                                                     */
/* Copyright 1995-2006 Adobe Systems Incorporated.                     */
/* All Rights Reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/***********************************************************************/

#ifndef __SPErrorCodes__
#define __SPErrorCodes__

#if PRAGMA_ONCE
#pragma once
#endif

/*******************************************************************************
 **
 ** General Errors
 **
 **/

// General errors
#define kASNoError				0
#define kASUnimplementedError	'!IMP'
#define kASUserCanceledError	'stop'


/*******************************************************************************
 **
 ** SP Errors
 **
 **/

// General errors
/** @ingroup Errors
	PICA no-error code is \c NULL. All other
	PICA errors are strings, except \c #kSPOutOfMemoryError. See \c SPTypes.h. */
#define kSPNoError				0
/** @ingroup Errors
	PICA error, applies to all PICA suites. See \c SPTypes.h. */
#define kSPUnimplementedError	'!IMP'
/** @ingroup Errors
	PICA error. */
#define kSPUserCanceledError	'stop'
#define kSPOperationInterrupted				'intr'
#define	kSPLogicError						'fbar' // general programming error

// SPAccessSuite errors
/** @ingroup Errors
	PICA access error. See \c #SPAccessSuite. */
#define kSPCantAcquirePluginError			'!Acq'
/** @ingroup Errors
	PICA access error. See \c #SPAccessSuite. */
#define kSPCantReleasePluginError			'!Rel'
/** @ingroup Errors
	PICA access error. See \c #SPAccessSuite. */
#define kSPPluginAlreadyReleasedError		'AlRl'

// SPAdaptsSuite errors
/** @ingroup Errors
	PICA adapter error. See \c #SPAdaptsSuite */
#define kSPAdapterAlreadyExistsError		'AdEx'
/** @ingroup Errors
	PICA adapter error.See \c #SPAdaptsSuite */
#define kSPBadAdapterListIteratorError		'BdAL'

// SPBasicSuite errors
/** @ingroup Errors
	Basic PICA error. See \c #SPBasicSuite */
#define kSPBadParameterError				'Parm'

// Block debugging errors
/** @ingroup Errors
	PICA debugging error. See \c #SPBlockDebugSuite */
#define kSPCantChangeBlockDebugNowError		'!Now'
/** @ingroup Errors
	PICA debugging error. See \c #SPBlockDebugSuite */
#define kSPBlockDebugNotEnabledError		'!Nbl'

// SPBlocks errors
/** @ingroup Errors
	PICA memory management error. See \c #SPBlocksSuite */
#define kSPOutOfMemoryError					(int32(0xFFFFFF6c))  /* -108, same as Mac memFullErr */
/** @ingroup Errors
	PICA memory management error. See \c #SPBlocksSuite */
#define kSPBlockSizeOutOfRangeError			'BkRg'

// SPCaches errors
/** @ingroup Errors
	PICA cache-flushing error. See \c #SPCachesSuite */
#define kSPPluginCachesFlushResponse		'pFls'
/** @ingroup Errors
	PICA cache-flushing error. See \c #SPCachesSuite */
#define kSPPluginCouldntFlushResponse		kSPNoError;

// SPFiles errors
/** @ingroup Errors
	PICA file-access error. See \c #SPFilesSuite */
#define kSPTroubleAddingFilesError			'TAdd'
/** @ingroup Errors
	PICA file-access error. See \c #SPFilesSuite */
#define kSPBadFileListIteratorError			'BFIt'

// SPHost errors
/** @ingroup Errors
	PICA plug-in atart-up error. See \c #SPHostSuite */
#define kSPTroubleInitializingError			'TIni'	// Some non-descript problem encountered while starting up.
/** @ingroup Errors PICA plug-in atart-up error. See \c #SPHostSuite */
#define kHostCanceledStartupPluginsError 	'H!St'

// SPInterface errors
/** @ingroup Errors
	PICA interface error. See \c #SPInterfaceSuite */
#define kSPNotASweetPeaPluginError			'NSPP'
/** @ingroup Errors
	PICA interface error. See \c #SPInterfaceSuite */
#define kSPAlreadyInSPCallerError			'AISC'

// SPPlugins errors
/** @ingroup Errors
	PICA plug-in error. See \c #SPPluginsSuite */
#define kSPUnknownAdapterError				'?Adp'
/** @ingroup Errors
	PICA plug-in error. See \c #SPPluginsSuite */
#define kSPBadPluginListIteratorError		'PiLI'
/** @ingroup Errors
	PICA plug-in error. See \c #SPPluginsSuite */
#define kSPBadPluginHost					'PiH0'
/** @ingroup Errors
	PICA plug-in error. See \c #SPPluginsSuite */
#define kSPCantAddHostPluginError			'AdHo'
/** @ingroup Errors
	PICA plug-in error. See \c #SPPluginsSuite */
#define kSPPluginNotFound					'P!Fd'

// SPProperties errors
/** @ingroup Errors
	PICA properties error. See \c #SPPropertiesSuite */
#define kSPCorruptPiPLError					'CPPL'
/** @ingroup Errors
	PICA properties error. See \c #SPPropertiesSuite */
#define kSPBadPropertyListIteratorError		'BPrI'

// SPSuites errors
/** @ingroup Errors
	PICA suite access error. See \c #SPSuitesSuite */
#define kSPSuiteNotFoundError				'S!Fd'
/** @ingroup Errors
	PICA suite access error. See \c #SPSuitesSuite */
#define kSPSuiteAlreadyExistsError			'SExi'
/** @ingroup Errors
	PICA suite access error. See \c #SPSuitesSuite */
#define kSPSuiteAlreadyReleasedError		'SRel'
/** @ingroup Errors
	PICA suite access error. See \c #SPSuitesSuite */
#define kSPBadSuiteListIteratorError		'SLIt'
/** @ingroup Errors
	PICA suite access error. See \c #SPSuitesSuite */
#define kSPBadSuiteInternalVersionError		'SIVs'

#endif

```

---

<h2>Begin File: SPErrors.h</h2>

```cpp
/***********************************************************************/
/*                                                                     */
/* SPErrors.h                                                          */
/*                                                                     */
/* Copyright 1995-2006 Adobe Systems Incorporated.                     */
/* All Rights Reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/***********************************************************************/


/*******************************************************************************
 **
 ** Errors
 **
 **/
/** @ingroup Errors
	PICA access error. See \c #SPAccessSuite. */
#define kSPCantAcquirePluginError		'!Acq'
/** @ingroup Errors
	PICA access error. See \c #SPAccessSuite. */
#define kSPCantReleasePluginError		'!Rel'
/** @ingroup Errors
	PICA access error. See \c #SPAccessSuite. */
#define kSPPluginAlreadyReleasedError	'AlRl'

```

---

<h2>Begin File: SPFiles.h</h2>

```cpp
/***********************************************************************/
/*                                                                     */
/* SPFiles.h                                                           */
/*                                                                     */
/* Copyright 1995-2006 Adobe Systems Incorporated.                     */
/* All Rights Reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/***********************************************************************/

#ifndef __SPFiles__
#define __SPFiles__


/*******************************************************************************
 **
 **	Imports
 **
 **/

#include "SPTypes.h"
#include "SPProps.h"

#include "photoshop/config/platform.hpp"

#if PS_PLATFORM_APPLE
#include "CoreFoundation/CoreFoundation.h"
#if PS_OS_MAC
#include "Carbon/Carbon.h"
#endif
#endif

#if PS_OS_IOS
#include "photoshop/platform/EmulateEndianOnIOS.h"
#include "photoshop/platform/EmulateMacErrorsOnIOS.h"
#include "photoshop/platform/EmulateQuickdrawOnIOS.h"
#include "photoshop/platform/EmulateOSAPIsOnIOS.h"
#include "photoshop/platform/EmulateCarbonFilesOnIOS.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*******************************************************************************
 **
 ** Constants
 **
 **/
/** Files suite name */
#define kSPFilesSuite				"SP Files Suite"
/** Files suite version */
#define kSPFilesSuitePrevVers		3
#define kSPFilesSuiteVersion		4

/** PICA global list of potential plug-in files. .
	@see \c #SPRuntimeSuite::GetRuntimeFileList().*/
#define kSPRuntimeFileList			((SPFileListRef)NULL)

/** Return value for \c #SPFilesSuite::GetFilePropertyList(),
	indicating that the file has no property list. */
#define kFileDoesNotHavePiPL		(SPPropertyListRef)((intptr_t)-1)
/** Return value for \c #SPFilesSuite::GetFilePropertyList(),
	indicating that the file has multiple property lists. <<is this right? how do you retrieve them?>> */
#define kFileHasMulitplePiPLs		NULL

/*******************************************************************************
 **
 ** Types
 **
 **/

/** The maximum number of characters allowed in a file path specification. */
#define kMaxPathLength 300

/** Opaque reference to a file. Access with the \c #SPFilesSuite. */
typedef struct SPFile *SPFileRef;
/** Opaque reference to a file list. Access with the \c #SPFilesSuite. */
typedef struct SPFileList *SPFileListRef;
/** Opaque reference to a file-list iterator. Access with the \c #SPFilesSuite. */
typedef struct SPFileListIterator *SPFileListIteratorRef;
/** Opaque reference to a platform-specific file specification. Access with the \c #SPFilesSuite. */
typedef struct OpaqueSPPlatformFileRef SPPlatformFileRef;

#define kXPlatFileSpecVersion	1

/** The replacement for SPPlatformFileSpecification and SPPlatformFileSpecificationW,
** used in SP Files Suite version 4 and later */
typedef struct XPlatFileSpec {
	int32		mFileSpecVersion;		///< \brief kXPlatFileSpecVersion
										///<
										///< A value of zero implies "not initialized",
										///< and you should not attempt to use mFileReference
#if defined(WIN_ENV) || defined(ANDROID_ENV) || WEB_ENV || defined(UNIX_ENV)
	uint16*		mFileReference;			///< \brief mFileReference could be as long as 64K but MUST be NULL terminated.
#elif defined(MAC_ENV)
	CFURLRef	mFileReference;			///< \brief A CFURLRef, as defined by Mac OS X
#endif
} XPlatFileSpec;


/*******************************************************************************/

#if defined (MAC_ENV)
#if PRAGMA_STRUCT_ALIGN		// DRSWAT
#pragma options align=mac68k
#endif	// PRAGMA_STRUCT_ALIGN


/** A file specification:
		\li In Mac OS 32 bit, the same as \c FSSpec.
		\li In Windows, a path string. */


#if USE_POSIX_API

typedef struct SPPlatformFileSpecification {	/* this handles unicode file names */
    /** The file path string. */
    char path[kMaxPathLength];
}  SPPlatformFileSpecification;

typedef struct SPPlatformFileSpecificationW {	/* this handles unicode file names */
    /** mReference could be as long as 64K but MUST be NULL terminated. */
    uint16 *mReference;
} SPPlatformFileSpecificationW;

/**Platform-specific file metadata. */
typedef struct SPPlatformFileInfo {
    /** File attribute flags; see Windows documentation. */
    uint32 attributes;
    /** Least-significant byte of the file creation date-time (Windows).*/
    uint32 lowCreationTime;
    /** Most-significant byte of the file creation date-time (Windows).*/
    uint32 highCreationTime;
    /** Least-significant byte of the file modification date-time (Windows).*/
    uint32 lowModificationTime;
    /** Most-significant byte of the file cremodification date-time (Windows).*/
    uint32 highModificationTime;
    /** The file-name extension indicating the file type (Windows). */
    const char *extension;
} SPPlatformFileInfo;

#elif PS_PLATFORM_APPLE

typedef struct SPPlatformFileSpecification {	/* this handles unicode file names */
	FSRef mReference;
}  SPPlatformFileSpecification;

typedef struct SPPlatformFileSpecificationW {	/* this handles unicode file names */
	FSRef mReference;
} SPPlatformFileSpecificationW;

#if PRAGMA_STRUCT_ALIGN	// DRSWAT
#pragma options align=reset
#endif

    /*******************************************************************************/

    /** Platform-specific file metadata. */
    typedef struct SPPlatformFileInfo {	 /* On Mac OS*/
        /** Not used. */
        uint32 attributes; 	//Unused, but still required to maintain binary compatibility
        /** Date file was created (Mac OS). */
        uint32 creationDate;
        /** Data file was last modified (Mac OS). */
        uint32 modificationDate;
        /** Type of file for Finder (Mac OS). */
        uint32 finderType;
        /** File creator (Mac OS). */
        uint32 finderCreator;
        /** File flags for Finder; see Mac OS documentation. */
        uint16 finderFlags;
    } SPPlatformFileInfo;
#endif // PS_PLATFORM_APPLE

#endif	// MAC_ENV

/*******************************************************************************/

#ifdef WIN_ENV
/** A file specification in Windows. */
typedef struct SPPlatformFileSpecification {
	/** The file path string. */
	char path[kMaxPathLength];
} SPPlatformFileSpecification;

/** A widechar file specification in Windows to handle unicode file names. */
typedef struct SPPlatformFileSpecificationW {
	/** mReference could be as long as 64K but MUST be NULL terminated. */
	uint16 *mReference;
} SPPlatformFileSpecificationW;

/*******************************************************************************/

/**Platform-specific file metadata. */
typedef struct SPPlatformFileInfo {
	/** File attribute flags; see Windows documentation. */
	uint32 attributes;
	/** Least-significant byte of the file creation date-time (Windows).*/
	uint32 lowCreationTime;
	/** Most-significant byte of the file creation date-time (Windows).*/
	uint32 highCreationTime;
	/** Least-significant byte of the file modification date-time (Windows).*/
	uint32 lowModificationTime;
	/** Most-significant byte of the file cremodification date-time (Windows).*/
	uint32 highModificationTime;
	/** The file-name extension indicating the file type (Windows). */
	const uint16 *extension;
} SPPlatformFileInfo;
#endif	// WIN_ENV

/*******************************************************************************/


#if defined(__ANDROID__) || defined(__LINUX__) || defined (__EMSCRIPTEN__) || defined(SIMULATED_WASM)
typedef struct SPPlatformFileSpecification {
	/** The file path string. */
	char path[kMaxPathLength];
} SPPlatformFileSpecification;

/** A widechar file specification in Windows to handle unicode file names. */
typedef struct SPPlatformFileSpecificationW {
	/** mReference could be as long as 64K but MUST be NULL terminated. */
	uint16 *mReference;
} SPPlatformFileSpecificationW;

/*******************************************************************************/

/**Platform-specific file metadata. */
typedef struct SPPlatformFileInfo {
	uint32 attributes;
	uint32 lowCreationTime;
	uint32 highCreationTime;
	uint32 lowModificationTime;
	uint32 highModificationTime;
	const uint16 *extension;
} SPPlatformFileInfo;
#endif	// __ANDROID__

/** Conversion from new platform file specification to old platform file
** specification, and vice-versa. It's okay to pass NULL pointers to these
** functions. If you do, the value returned will be a default constructed
** structure (i.e. zero-filled)
*/
/** Internal ? */
SPAPI SPPlatformFileSpecification OldFileSpecFromXplatFileSpec(const XPlatFileSpec* newSpec);

SPAPI SPPlatformFileSpecificationW OldFileSpecWFromXplatFileSpec(const XPlatFileSpec* newSpec);

/// Caller owns the CFURLRef contained in XPlatFileSpec::mFileReference
SPAPI XPlatFileSpec XplatFileSpecFromOldFileSpec(const SPPlatformFileSpecification* oldSpec);

/// Caller owns the CFURLRef contained in XPlatFileSpec::mFileReference
SPAPI XPlatFileSpec XplatFileSpecFromOldFileSpecW(const SPPlatformFileSpecificationW* oldSpecW);

/*******************************************************************************/

/** Internal */
typedef SPBoolean (*SPAddPiPLFilterProc)( SPPlatformFileInfo *info );

/*******************************************************************************
 **
 ** Suite
 **
 **/
/** @ingroup Suites
	This suite allows you to access the PICA files list. This list, created at startup,
    contains references to every file in the application's plug-in folder, including
    any resolved file and folder aliases. PICA maintains this list, and uses it to find plug-ins.

    Use this suite to access the plug-in file list, in order to avoid redundant directory
    scans. Adapters looking for their own plug-ins and PICA plug-ins looking for
    support files should scan the list to locate relevant files rather than walking
    platform directory  structures on their own.

	Similarly, you can use this suite to create, maintain, and access your own lists
	of files in a platform-independant and efficient manner.

	\li Acquire this suite using \c #SPBasicSuite::AcquireSuite() with the constants
		\c #kSPFilesSuite and \c #kSPFilesSuiteVersion (4).
    */

typedef struct SPFilesSuite {
	/** Creates a new file list. Typically, you use the main PICA file list to access
		plug-in files, available through \c #SPRuntimeSuite::GetRuntimeFileList().
		You can use this to track other file collections. If you create a new list, you
		must free it when it is no longer needed, using \c #FreeFileList().
			@param fileList [out] A buffer in which to return the new file list object.
		*/
	SPAPI SPErr (*AllocateFileList)( SPFileListRef *fileList );
	/** Frees a file list created with \c #AllocateFileList(), and any entries in the list.
			@param fileList The file list object.
		*/
	SPAPI SPErr (*FreeFileList)( SPFileListRef fileList );

	/** Adds a file or all files in a directory to a file list. Searches a directory
		recursively for contained files.
			@param fileList The file list object.
			@param file The file or directory specification.
		*/
	SPAPI SPErr (*AddFiles)( SPFileListRef fileList, const XPlatFileSpec *file );

	/** Creates a file-list iterator object to use with \c #NextFile() for iterating
		through a file list. The iterator is initially set to the first file in the list.
		When the iterator is no longer needed, free it with \c #DeleteFileListIterator().
			@param fileList The file list object.
			@param iter [out] A buffer in which to return the new iterator object.
		*/
	SPAPI SPErr (*NewFileListIterator)( SPFileListRef fileList, SPFileListIteratorRef *iter );
	/** Retrieves the current file from a file list iterator, and advances the iterator.
			@param iter The iterator object.
			@param file [out] A buffer in which to return the current file object, or \c NULL
				if the end of the list has been reached.
		*/
	SPAPI SPErr (*NextFile)( SPFileListIteratorRef iter, SPFileRef *file );
	/** Frees a file-list iterator created with /c #NewFileListIterator().
			@param iter The iterator object.
		*/
	SPAPI SPErr (*DeleteFileListIterator)( SPFileListIteratorRef iter );

	/** Retrieves the platform-specific file specification for a file.
			@param file The file object.
			@param fileSpec [out] A buffer in which to return the file specification.
		*/
	SPAPI SPErr (*GetFileSpecification)( SPFileRef file, XPlatFileSpec *fileSpec );
	/** Retrieves the  metadata for a file.
			@param file The file object.
			@param info [out] A buffer in which to return the file information.
		*/
	SPAPI SPErr (*GetFileInfo)( SPFileRef file, SPPlatformFileInfo *info );

	/** Reports whether a file in a file list is a plug-in.
			@param file The file object.
			@param isAPlugin [out] A buffer in which to return true if the file is a plug-in.
		*/
	SPAPI SPErr (*GetIsAPlugin)( SPFileRef file, SPBoolean *isAPlugin );
	/** Sets whether a file in a file list is a plug-in.
			@param file The file object.
			@param isAPlugin True to mark the file as a plug-in, false to mark it as not a plug-in.
		*/
	SPAPI SPErr (*SetIsAPlugin)( SPFileRef file, SPBoolean isAPlugin );

	/** Retrieves the property list for a file.
			@param file The file object.
			@param propertList [out] A buffer in which to return the property list,
				or \c #kFileDoesNotHavePiPL if the file does not have a property list,
				or \c #kFileHasMulitplePiPLs if the file has multiple property lists.
			@see \c SPPiPL.h
		*/
	SPAPI SPErr (*GetFilePropertyList)( SPFileRef file, SPPropertyListRef *propertList );
	/** Sets the property list for a file.
			@param file The file object.
			@param propertList The new property list.
		*/
	SPAPI SPErr (*SetFilePropertyList)( SPFileRef file, SPPropertyListRef propertList );

} SPFilesSuite;


/*******************************************************************************
 **
 ** Suite
 **
 **/
/** @ingroup Suites
	This suite allows you to access the PICA files list. This list, created at startup,
    contains references to every file in the application's plug-in folder, including
    any resolved file and folder aliases. PICA maintains this list, and uses it to find plug-ins.

    Use this suite to access the plug-in file list, in order to avoid redundant directory
    scans. Adapters looking for their own plug-ins and PICA plug-ins looking for
    support files should scan the list to locate relevant files rather than walking
    platform directory  structures on their own.

	Similarly, you can use this suite to create, maintain, and access your own lists
	of files in a platform-independant and efficient manner.

	\li Acquire this suite using \c #SPBasicSuite::AcquireSuite() with the constants
		\c #kSPFilesSuite and \c #kSPFilesSuitePrevVers (3).
    */
typedef struct SPFilesV3Suite {
	/** Creates a new file list. Typically, you use the main PICA file list to access
		plug-in files, available through \c #SPRuntimeSuite::GetRuntimeFileList().
		You can use this to track other file collections. If you create a new list, you
		must free it when it is no longer needed, using \c #FreeFileList().
			@param fileList [out] A buffer in which to return the new file list object.
		*/
	SPAPI SPErr (*AllocateFileList)( SPFileListRef *fileList );
	/** Frees a file list created with \c #AllocateFileList(), and any entries in the list.
			@param fileList The file list object.
		*/
	SPAPI SPErr (*FreeFileList)( SPFileListRef fileList );

	/** Adds a file or all files in a directory to a file list. Searches a directory
		recursively for contained files.
			@param fileList The file list object.
			@param file The file or directory specification.
		*/
	SPAPI SPErr (*AddFiles)( SPFileListRef fileList, const SPPlatformFileSpecification *file );

	/** Creates a file-list iterator object to use with \c #NextFile() for iterating
		through a file list. The iterator is initially set to the first file in the list.
		When the iterator is no longer needed, free it with \c #DeleteFileListIterator().
			@param fileList The file list object.
			@param iter [out] A buffer in which to return the new iterator object.
		*/
	SPAPI SPErr (*NewFileListIterator)( SPFileListRef fileList, SPFileListIteratorRef *iter );
	/** Retrieves the current file from a file list iterator, and advances the iterator.
			@param iter The iterator object.
			@param file [out] A buffer in which to return the current file object, or \c NULL
				if the end of the list has been reached.
		*/
	SPAPI SPErr (*NextFile)( SPFileListIteratorRef iter, SPFileRef *file );
	/** Frees a file-list iterator created with /c #NewFileListIterator().
			@param iter The iterator object.
		*/
	SPAPI SPErr (*DeleteFileListIterator)( SPFileListIteratorRef iter );

	/** Retrieves the platform-specific file specification for a file.
			@param file The file object.
			@param fileSpec [out] A buffer in which to return the file specification.
		*/
	SPAPI SPErr (*GetFileSpecification)( SPFileRef file, SPPlatformFileSpecification *fileSpec );
	/** Retrieves the  metadata for a file.
			@param file The file object.
			@param info [out] A buffer in which to return the file information.
		*/
	SPAPI SPErr (*GetFileInfo)( SPFileRef file, SPPlatformFileInfo *info );

	/** Reports whether a file in a file list is a plug-in.
			@param file The file object.
			@param isAPlugin [out] A buffer in which to return true if the file is a plug-in.
		*/
	SPAPI SPErr (*GetIsAPlugin)( SPFileRef file, SPBoolean *isAPlugin );
	/** Sets whether a file in a file list is a plug-in.
			@param file The file object.
			@param isAPlugin True to mark the file as a plug-in, false to mark it as not a plug-in.
		*/
	SPAPI SPErr (*SetIsAPlugin)( SPFileRef file, SPBoolean isAPlugin );

	/** Retrieves the property list for a file.
			@param file The file object.
			@param propertList [out] A buffer in which to return the property list,
				or \c #kFileDoesNotHavePiPL if the file does not have a property list,
				or \c #kFileHasMulitplePiPLs if the file has multiple property lists.
			@see \c SPPiPL.h
		*/
	SPAPI SPErr (*GetFilePropertyList)( SPFileRef file, SPPropertyListRef *propertList );
	/** Sets the property list for a file.
			@param file The file object.
			@param propertList The new property list.
		*/
	SPAPI SPErr (*SetFilePropertyList)( SPFileRef file, SPPropertyListRef propertList );

} SPFilesV3Suite;


/** Internal */
SPAPI SPErr SPAllocateFileList( SPFileListRef *fileList );
/** Internal */
SPAPI SPErr SPFreeFileList( SPFileListRef fileList );
/** Internal */
SPAPI SPErr SPAddFiles( SPFileListRef fileList, const SPPlatformFileSpecification *file );
/** Internal */
SPAPI SPErr SPNewAddFiles( SPFileListRef fileList, const XPlatFileSpec *file );

/** Internal */
SPAPI SPErr SPNewFileListIterator( SPFileListRef fileList, SPFileListIteratorRef *iter );
/** Internal */
SPAPI SPErr SPNextFile( SPFileListIteratorRef iter, SPFileRef *file );
/** Internal */
SPAPI SPErr SPDeleteFileListIterator( SPFileListIteratorRef iter );

/** Internal */
SPAPI SPErr SPGetFileSpecification( SPFileRef file, SPPlatformFileSpecification *fileSpec );
/** Internal */
SPAPI SPErr SPNewGetFileSpecification( SPFileRef file, XPlatFileSpec *fileSpec );
/** Internal */
SPAPI SPErr SPGetFileInfo( SPFileRef file, SPPlatformFileInfo *info );
/** Internal */
SPAPI SPErr SPGetIsAPlugin( SPFileRef file, SPBoolean *isAPlugin );
/** Internal */
SPAPI SPErr SPSetIsAPlugin( SPFileRef file, SPBoolean isAPlugin );

/** Internal */
SPAPI SPErr SPGetFilePropertyList( SPFileRef file, SPPropertyListRef *propertList );
/** Internal */
SPAPI SPErr SPSetFilePropertyList( SPFileRef file, SPPropertyListRef propertList );

/*******************************************************************************
 **
 **	Errors
 **
 **/

#include "SPErrorCodes.h"

#ifdef __cplusplus
}
#endif

#endif

```

---

<h2>Begin File: SPHost.h</h2>

```cpp
/***********************************************************************/
/*                                                                     */
/* SPHost.h                                                            */
/*                                                                     */
/* Copyright 1995-1999 Adobe Systems Incorporated.                     */
/* All Rights Reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/***********************************************************************/

#ifndef __SPHost__
#define __SPHost__


/*******************************************************************************
 **
 **	Imports
 **
 **/

#include "SPTypes.h"
#include "SPAccess.h"
#include "SPAdapts.h"
#include "SPBasic.h"
#include "SPBckDbg.h"
#include "SPBlocks.h"
#include "SPCaches.h"
#include "SPFiles.h"
#include "SPInterf.h"
#include "SPPlugs.h"
#include "SPProps.h"
#include "SPRuntme.h"
#include "SPStrngs.h"
#include "SPSuites.h"

#ifdef __cplusplus
extern "C" {
#endif


/*******************************************************************************
 **
 **	Constants
 **
 **/


/*
 *	The version number of the Sweet Pea host interface. You can compare it to the
 *	version number that Sweet Pea was compiled with to determine that you are
 *	running the version you think you are. See SPVersion() below.
 *
 *	This number consists of a hi word which is the major version number reflecting
 *	changes to the SP inteface, and a low word which is the minor revision number,
 *	for instance indicating bug fixes.
 */

#define kSPVersion		0x000B0002			// version 11.2


/*
 *	Options available to the host at init time. They are:
 *
 *	kSPHostBlockDebugOption - block allocation debugging is enabled. See
 *		SPBckDbg.h for details.
 *
 *	Examples:
 *
 *		SPInit( hostProcs, pluginsFolder, kSPHostNoOptions, error );
 *		// No debugging.
 *
 *		SPInit( hostProcs, pluginsFolder, kSPHostBlockDebugOption, error );
 *		// Enable block debugging.
 */

#define kSPHostNoOptions			0
#define kSPHostBlockDebugOption		(1<<0L)


/*******************************************************************************
 **
 **	Functions
 **
 **/

/*
 *	SPInit() initializes Sweet Pea. It is the first call made to Sweet Pea. It
 *	initializes its suites and builds the list of application files.
 *
 *	HostProcs points to a filled-in structure of host callbacks, as described
 *	in SPRuntme.h. It may be NULL, in which case Sweet Pea uses its default
 *	versions for all of the host callbacks. PluginFolder is the file spec of the
 *	plug-ins folder. The contents of this folder are collected into the application
 *	files list (see SPFiles.h). Options may be any of the host options described
 *	above.
 */
SPErr SPInit( SPHostProcs *hostProcs, const SPPlatformFileSpecification *pluginFolder, int32 options );

/*
 *	SPXPlatInit() uses the XPlatFileSpec rather than the SPPlatformFileSpecification.
 *
 *	Otherwise it's identical to SPInit (and actually calls through to it for Photoshop 17.0)
 */
SPErr SPXPlatInit( SPHostProcs *hostProcs, const XPlatFileSpec *pluginFolder, int32 options );

SPBoolean SPInited( void );

/*
 *	SPTerm() terminates Sweet Pea. Call this when your application quits.
 */
SPErr SPTerm( void );

/*
 *	SPStartupPlugins() scans the list of application files and builds the list
 *	of plug-ins. It then starts them up, calling each in turn with a start up
 *	message (see SPPlugs.h). Call this sometime after SPInit().
 */
SPErr SPStartupPlugins( void );

/*
 *	SPShutdownPlugins() shuts down the plug-ins. It calls each in turn with a
 *	shut down message (see SPPlugs.h). Call this when your application quits
 *	before calling SPTerm().
 */
SPErr SPShutdownPlugins( void );


#ifdef MAC_ENV
/*
 *	SPSetPPCLoadHeap() sets the destination heap of plug-in accesses on PowerPPC
 *	Macintoshes.  Plug-ins can load into the system heap or the application heap.
 */
typedef enum {
	kAppHeap = 0,
	kSysHeap
} SPTargetHeap;

SPErr SPSetPPCLoadHeap( SPTargetHeap target );

/*
 *	SPSetHostBundleRef() lets sweet pea know the bundle ref of the host.
 */
SPErr SPSetHostBundleRef(CFBundleRef hostBundle);
#endif


/*
 *	SPVersion() returns the version number of the Sweet Pea host interface (this
 *	file) for which Sweet Pea was built. You can compare this to the constant
 *	kSPVersion to make sure you're using the version you think you are.
 */
uint32 SPVersion( void );


/*******************************************************************************
 **
 **	Errors
 **
 **/

#include "SPErrorCodes.h"

#ifdef __cplusplus
}
#endif

#endif

```

---

<h2>Begin File: SPInterf.h</h2>

```cpp
/***********************************************************************/
/*                                                                     */
/* SPInterf.h                                                          */
/*                                                                     */
/* Copyright 1995-2006 Adobe Systems Incorporated.                     */
/* All Rights Reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/***********************************************************************/

#ifndef __SPInterface__
#define __SPInterface__


/*******************************************************************************
 **
 **	Imports
 **
 **/

#include "SPTypes.h"
#include "SPBasic.h"
#include "SPFiles.h"
#include "SPMData.h"
#include "SPPlugs.h"
#include "SPProps.h"

#ifdef __cplusplus
extern "C" {
#endif


/*******************************************************************************
 **
 ** Constants
 **
 **/
/** PICA Interface suite name. */
#define kSPInterfaceSuite				"SP Interface Suite"
/** PICA Interface suite version. */
#define kSPInterfaceSuiteVersion		2

/** PICA messaging system caller; see \c #SPInterfaceSuite. */
#define kSPInterfaceCaller				"SP Interface"
/** PICA messaging system startup; see \c #SPInterfaceSuite.  */
#define kSPInterfaceStartupSelector		"Startup"
/** PICA messaging system shutdown; see \c #SPInterfaceSuite. */
#define kSPInterfaceShutdownSelector	"Shutdown"
/**  PICA messaging system request for information; see \c #SPInterfaceSuite.
	Illustrator sends this call to all plug-ins to implement
	the "About Plug-ins" feature.*/
#define kSPInterfaceAboutSelector		"About"

/** Adapter name for PICA version 2. */
#define kSPSweetPea2Adapter				"Sweet Pea 2 Adapter"
/** Adapter version for PICA version 2.*/
#define kSPSweetPea2AdapterVersion		1

/*******************************************************************************
 **
 ** Types
 **
 **/

/** A basic message, sent with \c #kSPInterfaceCaller. */
typedef struct SPInterfaceMessage {

	/** The message data. */
	SPMessageData d;

} SPInterfaceMessage;


/*******************************************************************************
 **
 ** Suite
 **
 **/
/** @ingroup Suites
	This suite provides is the ability for a plug-in to call
	other plug-ins, by sending a message to the main entry point.
	This is how the application communicates with plug-ins.

	Use \c #SetupMessageData() to prepare the message for a call,
	\c #SendMessage() to send the call with the message, and
	\c #EmptyMessageData() to terminate the operation, allowing
	PICA to release the basic suite and store global variables.

	These calls work only with PICA plug-ins. Before making the calls,
	use  \c #SPAdaptersSuite::GetAdapterName() to determine that
	the target is a PICA plug-in.  For non-PICA plug-ins, use the
	interface suite provided by the adapter. See \c #SPAdaptersSuite.

 	\li Acquire this suite using \c #SPBasicSuite::AcquireSuite() with the constants
		\c #kSPInterfaceSuite and \c #kSPInterfaceSuiteVersion.
*/
typedef struct SPInterfaceSuite {

	/** Sends a message to a PICA plug-in, loading it if needed and
		passing the caller, selector, and message to the main entry point.
			@param plug-in The target plug-in object.
			@param caller The caller constant. See @ref Callers.
			@param selector The selector constant. See @ref Selectors.
			@param message The message, initialized by \c #SetupMessageData().
			@param result [out] A buffer in which to return the result of the call,
				as returned by the target plug-in.
		*/
	SPAPI SPErr (*SendMessage)( SPPluginRef plugin, const char *caller, const char *selector,
				void *message, SPErr *result );

	/** Initializes a message to be sent with \c #SendMessage().
		The function fills in the basic suite, the plug-in reference,
		and the globals pointer that PICA keeps for that plug-in.
		You must provide any additional data needed.
			@param plugin The target plug-in object.
			@param data The message structure, initialized with data required
				for the intended call.
		*/
	SPAPI SPErr (*SetupMessageData)( SPPluginRef plugin, SPMessageData *data );
	/** Terminates a call to another plug-in, releasing the basic suite and
		updating the target plug-in's globals pointer, in case it has changed.
		Use after a call to \c #SendMessage().
			@param plugin The target plug-in object.
			@param data The message structure, updated during the call.
		*/
	SPAPI SPErr (*EmptyMessageData)( SPPluginRef plugin, SPMessageData *data );

	/** Starts up the plug-in in a plug-in list that exports a given suite.
		Searches in the given plug-in list for the plug-in that exports the named
		suite, and, if found, sends it the startup message.
			@param pluginList The plug-in list object. Access PICA's global plug-in
				list using \c #SPRuntimeSuite::GetRuntimePluginList(),
				or create your own lists with \c #SPPluginsSuite::AllocatePluginList().
			@param name The suite name constant.
			@param version The suite version number constant.
			@param started [out] A buffer in which to return true (non-zero) if a
				plug-in that exports the suite was found, false (0) if not.
		*/
	SPAPI SPErr (*StartupExport)( SPPluginListRef pluginList, const char *name, int32 version,
				int32 *started );

} SPInterfaceSuite;


/** Internal */
SPAPI SPErr SPSendMessage( SPPluginRef plugin, const char *caller, const char *selector,
			void *message, SPErr *result );

/** Internal */
SPAPI SPErr SPSetupMessageData( SPPluginRef plugin, SPMessageData *data );
/** Internal */
SPAPI SPErr SPEmptyMessageData( SPPluginRef plugin, SPMessageData *data );

/** Internal */
SPAPI SPErr SPStartupExport( SPPluginListRef pluginList, const char *name, int32 version,
			int32 *started );


/*******************************************************************************
 **
 ** Errors
 **
 **/

#include "SPErrorCodes.h"

#ifdef __cplusplus
}
#endif

#endif

```

---

<h2>Begin File: SPMData.h</h2>

```cpp
/***********************************************************************/
/*                                                                     */
/* SPMData.h                                                           */
/*                                                                     */
/* Copyright 1995-2006 Adobe Systems Incorporated.                     */
/* All Rights Reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/***********************************************************************/

#ifndef __SPMessageData__
#define __SPMessageData__


/*******************************************************************************
 **
 **	Imports
 **
 **/

#include "SPTypes.h"

#ifdef __cplusplus
extern "C" {
#endif


/*******************************************************************************
 **
 ** Types
 **
 **/

/** The value of \c #SPMessageData::SPCheck, if the message data associated
	with a call to a plug-in has come from \c #SPInterfaceSuite::SendMessage(),
	or is prepared using \c #SPInterfaceSuite::SetupMessageData(). */
#define kSPValidSPMessageData 'SPCk'

/** Basic suite-access information provided with every call. */
typedef struct SPMessageData {
	/** \c #kSPValidSPMessageData if this is a valid PICA message. */
	int32 SPCheck;
	/** This plug-in, an \c #SPPluginRef. */
	struct SPPlugin *self;
	/** An array of application-wide global variables. */
	void *globals;
	/** A pointer to the basic PICA suite, which you use to obtain all other suites. */
	struct SPBasicSuite *basic;

} SPMessageData;


#ifdef __cplusplus
}
#endif

#endif

```

---

<h2>Begin File: SPObject.h</h2>

```cpp
/******************************************************************************
					SPObject.h
									
Purpose:
	Defines the suite for registering and creating Sweet Pea objects.
	It is a "conventional" Sweet Pea suite used to provide
	COM-like objects from Sweet Pea plugins.
									
	Copyright (c) 1995-1998, 2002 Adobe Systems Incorporated.
******************************************************************************/
#pragma once
#ifndef __SPObject__
#define __SPObject__
/* This module is obsolete. */
#endif	/* __SPObject__ */

```

---

<h2>Begin File: SPPiPL.h</h2>

```cpp
/***********************************************************************/
/*                                                                     */
/* SPPiPL.h                                                            */
/*                                                                     */
/* Copyright 1995-2006 Adobe Systems Incorporated.                     */
/* All Rights Reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/***********************************************************************/

#ifndef __SPPiPL__
#define __SPPiPL__


/*******************************************************************************
 **
 **	Imports and alignment
 **
 **/

#include "SPTypes.h"


#if PRAGMA_STRUCT_ALIGN
#pragma options align=mac68k
#endif


/*******************************************************************************
 **
 **	Constants
 **
 ** Note: 4-character long IDs must be defined in hexidecimal, not long
 ** literal ('long'), due to Windows RC compilers not understanding what
 ** to do with them.
 **
 **/

/** Vendor identifier for a plug-in resource, \c #PIProperty::vendorID value.
	<br> 'ADBE' Vendor identifier for PICA-generic applications. */
#define PIAdobeVendorID				(PIType)0x41444245L

/** Property mechanism version property, \c #PIProperty::propertyKey value
	<br> 'ivrs' PICA plug-in version.   */
#define PISPVersionProperty			(PIType)0x69767273L

/** Plug-in resource type, \c #PIProperty::propertyKey value.
	<br> 'impt' Suite import information.  */
#define PIImportsProperty			(PIType)0x696D7074L

/** Plug-in resource type, \c #PIProperty::propertyKey value.
	<br> 'expt' Suite export information.  */
#define PIExportsProperty			(PIType)0x65787074L

/**  Plug-in resource type, \c #PIProperty::propertyKey value.
	<br> 'ppcR' Power PC resource information.   */
#define PIPowerPCCodeResProperty	(PIType)0x70706352L

/** Plug-in resource type, \c #PIProperty::propertyKey value.
	<br> 'heap' Mac OS PPC-only.
	<br>If not defined, loads application default heap.
 	<br>If 0, loads system heap */
#define PIDestinationHeapProperty 	(PIType)0x68656170L
/** Value of \c #PIDestinationHeapProperty, loads system heap */
#define PILoadInAppHeap				(1L<<0)

/** Plug-in resource type, \c #PIProperty::propertyKey value.
	<br> 'adpt' Adapter version property (a long value) */
#define PIAdapterProperty			(PIType)0x61647074L

/** Plug-in resource type, \c #PIProperty::propertyKey value.
	<br> 'pinm' Internal plug-in name */
#define PIPluginNameProperty		(PIType)0x70696E6DL

/**  Plug-in resource type, \c #PIProperty::propertyKey value.
	<br> 'AcpM' Message flags */
#define PIConditionalMessages		(PIType)0x4163704DL
/** Flag bit for \c #PIConditionalMessages: plug-in accepts property changes. <<??>> */
#define	PIAcceptsPropertyMessage	(1L<<0)
/** Flag bit for \c #PIConditionalMessages: skip shutdown. <<when? why?>> */
#define	PISkipShutDownMessage		(1L<<1)
/** Flag bit for \c #PIConditionalMessages: plug-in accepts purge-cache messages. */
#define PIAcceptsPurgeCachesMessage	(1L<<2)
/** Flag bit for \c #PIConditionalMessages: skip startup message. <<when? why?>> */
#define PISkipStartupMessage		(1L<<3)

/** Internal. Plug-in resource type, \c #PIProperty::propertyKey value.
	<br> 'RelP' generated by Illustrator to optimize program launch */
#define PIReleasePluginEarly		0x52656c50

/*******************************************************************************
 **
 **	General PiPL properties and structures
 **
 ** Many hosts multiply define these properties, so we bracket them
 ** so they are only defined once.
 **
 **/

#ifndef kGeneralPiPLPropertiesDefined // Already defined?
/** Internal: Defines the general properties only if the application has
	not already done so. */
#define kGeneralPiPLPropertiesDefined // Only define once.

/** Data type for plug-in property key and vendor ID. See \c #PIProperty. */
typedef SPUInt32 PIType;

/** Plug-in properties version number. */
#define kCurrentPiPLVersion 0

// 'kind' <PIType> giving the plug-in's kind:
#define PIKindProperty			(PIType)0x6b696e64L

// 'm68k' <PI68KCodeDesc> 68k code descriptor. See struct below.
#define PI68KCodeProperty		(PIType)0x6d36386bL

// 'pwpc' <PICFMCodeDesc> PowerPC code descriptor. See struct below.
#define PIPowerPCCodeProperty	(PIType)0x70777063L

// 'ppcb' <PICFMCodeDesc> PowerPC CARBON code descriptor. See struct below.
#define PIPowerPCCarbonCodeProperty	'ppcb'

// 'mach' <PIMachOCodeDesc> PowerPC Mach-O code descriptor. See struct below.
#define PIPowerPCMachOCodeProperty	'mach'

// 'mi32' <PIMacIntelMachCodeDesc> Intel 32 Mach-O code descriptor. See struct below.
#define PIMacIntel32Property	'mi32'

// 'mi64' <PIMacIntelMachCodeDesc> Intel 64 Mach-O code descriptor. See struct below.
#define PIMacIntel64Property	'mi64'

// 'ma64' <PIMacARM64CodeDesc> ARM 64 Mach-O code descriptor. See struct below.
#define PIMacARM64Property 'ma64'

// 'frag' <PIFragmentCodeDesc> PowerPC fragment descriptor. See struct below.
#define PICodeFragmentProperty		'frag'

// 'frgc' <PIFragmentCodeDesc> PowerPC CARBON fragment descriptor. See struct below.
#define PICarbonCodeFragmentProperty	'frgc'

// '8664' <PIWin64X86CodeDesc> Win32 Intel code descriptor. See struct below.
#define PIWin64X86CodeProperty  (PIType)0x38363634L

// 'wx86' <PIWin32X86CodeDesc> Win32 Intel code descriptor. See struct below.
#define PIWin32X86CodeProperty  (PIType)0x77783836L

// \deprecated 'fx86' <PIWin16X86CodeDesc> Win16 Intel code descriptor. See struct below.
#define PIWin16X86CodeProperty  (PIType)0x66783836L

/** Plug-in property. Properties contain information about
	plug-in resource files, such as their type and location. */
typedef struct PIProperty {
	/** Vendor-specific identifier. */
	PIType vendorID;
	/** Identification key for this resource type. */
	PIType propertyKey;
	/** 0-based index of this resource within its type.
		 Must be unique for properties of a given type within
		 a property list. */
	SPInt32 propertyID;
	/** Number of characters in the data array. Rounded to a multiple of 4. */
	SPInt32 propertyLength;
	/** The property data array that contains the property value, a string of 4 characters. */
	char propertyData[1];
} PIProperty;

/** Plug-in property list. Provides the version number of the plug-in
	property mechanism itself, and properties for the associated plug-in.
	 */
typedef struct PIPropertyList {
	/** Version number for the \c #PIProperty structure. */
	SPInt32 version;
	/** Number of properties in the list. */
	SPInt32 count;
	/** The properties array. */
	PIProperty properties[1];
} PIPropertyList;

/* Following structures describe resource file types used in plug-in property lists.
 * These structures obey Macintosh 68k alignment and padding rules though
 * generally they are laid out so fields have natural alignment and any
 * needed padding is explicit in the structure.
 */
 //<<are these internal?>>

/** 68k code descriptor. */
typedef struct PI68KCodeDesc {
	/** Property type key code. */
	PIType fType;
	/** Property type unique identifier. */
	int16 fID;
} PI68KCodeDesc;

/** PowerPC code descriptor. */
typedef struct PICFMCodeDesc {
	/** The offset within the data fork for the start of this plugin's
		code fragment. This allows more than one code-fragment-based
		plug-in per file. */
	SPInt32 fContainerOffset;
	/** The length of this plug-in's code fragment. If this
		is the only fragment in the file, the length is 0. */
	SPInt32 fContainerLength;
	/** The entry-point name, used to look up the address of
		the function to call within the fragment; allows a single code
		fragment to export more than one plug-in.

		If the name is an empty string, the default entry point
		for the code fragment is used. The entry-point name
		must be an exported symbol of the code fragment. */
	unsigned char fEntryName[1];
} PICFMCodeDesc;

/** PowerPC Mach-O code descriptor. */
typedef struct PIMachCodeDesc
{
	/** Property type key code <<??>> */
	unsigned char fEntryName[1];
} PIMachCodeDesc;

// For 'mi32' PICodeMacIntel32Property:
// For 'mi64' PICodeMacIntel64Property:
typedef struct PIMacIntelMachCodeDesc
{
	unsigned char fEntryName[1];
} PIMacIntelMachCodeDesc;

typedef struct PIFragmentCodeDesc
{
	SPInt32 fFragmentResource;
	SPInt32 fFramentNumber;
	unsigned char fEntryName[1];
} PIFragmentCodeDesc;

/** The entry point name for 64 bit windows, used to lookup the function
which is called to invoke the plug-in. A \c NULL terminated string, padded
with additional \ NULL charcters if needed to satisfy the 4-byte alignment
requirement. See @ref PIWin64X86CodeProperty above. */
typedef struct PIWin64X86CodeDesc
{
	char fEntryName[1];
} PIWin64X86CodeDesc;

/** The entry point name for 32 bit windows, used to lookup the function
which is called to invoke the plug-in. A \c NULL terminated string, padded
with additional \ NULL charcters if needed to satisfy the 4-byte alignment
requirement. See @ref PIWin32X86CodeProperty above. */
typedef struct PIWin32X86CodeDesc {
	char fEntryName[1];
} PIWin32X86CodeDesc;

/** \deprecated Win16 Intel code descriptor.
See @ref PIWin16X86CodeProperty above. */
typedef struct PIWin16X86CodeDesc {
	char fEntryName[1];
} PIWin16X86CodeDesc;

#endif // kGeneralPiPLPropertiesDefined


/*******************************************************************************
 **
 **	Additional Types
 **
 **/

/** CFM code descriptor */
typedef struct PICFMCodeResourceDesc {
	/** Not used.  */
	SPInt32 fContainerOffset;			/* Currently unused, reserved. */
	/** The length of this plug-in's code fragment. If this
		is the only fragment in the file, the length is 0. */
	SPInt32 fContainerLength;
	/** Resource type key code. <<??>> */
	PIType fType;
	/** Unique identifier for the resource within the type. <<??>> */
	int16 fID;
	/** The entry-point name, used to look up the address of
		the function to call within the fragment; allows a single code
		fragment to export more than one plug-in.

		If the name is an empty string, the default entry point
		for the code fragment is used. The entry-point name
		must be an exported symbol of the code fragment. */
	unsigned char fEntryName[1];
} PICFMCodeResourceDesc;

/*******************************************************************************/

#if PRAGMA_STRUCT_ALIGN
#pragma options align=reset
#endif

#endif // SPPiPL

```

---

<h2>Begin File: SPPlugs.h</h2>

```cpp
/***********************************************************************/
/*                                                                     */
/* SPPlugs.h                                                           */
/*                                                                     */
/* Copyright 1995-2006 Adobe Systems Incorporated.                     */
/* All Rights Reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/***********************************************************************/

#ifndef __SPPlugins__
#define __SPPlugins__


/*******************************************************************************
 **
 **	Imports
 **
 **/

#include "SPTypes.h"
#include "SPFiles.h"
#include "SPAdapts.h"
#include "SPProps.h"
#include "SPStrngs.h"

#ifdef __cplusplus
extern "C" {
#endif


/*******************************************************************************
 **
 ** Constants
 **
 **/
/** PICA plugins suite name */
#define kSPPluginsSuite				"SP Plug-ins Suite"
/** PICA plugins suite version */
#define kSPPluginsSuiteVersion4		4
/** PICA plugins suite version */
#define kSPPluginsSuiteVersion5		5
/** PICA plugins suite version */
#define kSPPluginsSuiteVersion6		6

#define kSPPluginsSuiteVersion		kSPPluginsSuiteVersion4

/** PICA global list of available plug-ins..
	@see \c #SPRuntimeSuite::GetRuntimePluginList(). */
#define kSPRuntimePluginList		((SPPluginListRef)NULL)


/*******************************************************************************
 **
 ** Types
 **
 **/

/** Opaque reference to a plug-in object. Access with the \c #SPPluginsSuite. */
typedef struct SPPlugin *SPPluginRef;
/** A list of plug-in objects. Create with
	\c #SPPluginsSuite::AllocatePluginList(), or use
	the global list, \c #kSPRuntimePluginList. */
typedef struct SPPluginList *SPPluginListRef;
/** An iterator object for examining a plug-in list.
	See \c #SPPluginsSuite::NewPluginListIterator(). */
typedef struct SPPluginListIterator *SPPluginListIteratorRef;

/** PICA file-access error */
typedef struct _SPErrorData
{
	/** The file for which the error occurred. */
	SPPlatformFileSpecification	mErrorFile;
	/** Error code, see @ref Errors. */
	SPErr						mErrorCode;
} SPErrorData, *SPErrorDataPtr;

/** File-access error */
typedef struct _SPXPlatErrorData
{
	/** The file for which the error occurred. */
	XPlatFileSpec	mErrorFile;
	/** Error code, see @ref Errors. */
	SPErr			mErrorCode;
} SPXPlatErrorData, *SPXPlatErrorDataPtr;

/**  */
typedef SPAPI SPErr (*SPPluginEntryFunc)( const char *caller, const char *selector, void *message );

/*******************************************************************************
 **
 ** Suite
 **
 **/

/** This suite allows you to access and manipulate the plug-in object for your own
	and those of other plug-ins managed by the Adobe plug-in manager (PICA).
	You can access both plug-ins provided with the application (\e host plug-ins),
	and external plug-ins.You can query and set plug-in states,
	including the "broken" state, which indicates that a plug-in has
	become unavailable due to an error condition.

	You can also use this suite to create and use your own lists of plug-ins,
	in addition to the global list kept by the application.

	For higher-level access to plug-ins, see \c #AIPluginSuite.

	\li Acquire this suite using \c #SPBasicSuite::AcquireSuite() with the constants
		\c #kSPPluginsSuite and \c #kSPPluginsSuiteVersion.
	*/
typedef struct SPPluginsSuite {

	/** Creates a new plug-in list. You can also access PICA's global plug-in list,
		using \c #SPRuntimeSuite::GetRuntimePluginList().
			@param stringPool The string pool in which to keep plug-in names.
			@param pluginList [out] A buffer in which to return the new list object.
		*/
	SPAPI SPErr (*AllocatePluginList)( SPStringPoolRef strings, SPPluginListRef *pluginList );
	/** Frees a list of plug-ins allocated with \c #AllocatePluginList(), and
		also frees any entries in the list. Do not free the global list (\c #kSPRuntimePluginList).
			@param pluginList The plug-in list object.
		*/
	SPAPI SPErr (*FreePluginList)( SPPluginListRef pluginList );

	/** Creates a new plug-in object and adds it to a plug-in list.
			@param pluginList The plug-in list object, or \c NULL to use the
				global list.
			@param fileSpec The file specification for the plug-in code and resources.
			@param PiPL The structure containing the plug-in properties.
			@param adapterName The unique identifiying name of the adapter for the new plug-in.
			@param adapterInfo A pointer to the adapter-defined structure that stores needed
				information about this plug-in.
			@param plugin [out] A buffer in which to return the new plug-in object.
			@see \c #AllocatePluginList(), \c #SPAdaptersSuite
		*/
	SPAPI SPErr (*AddPlugin)( SPPluginListRef pluginList, const SPPlatformFileSpecification *fileSpec,
				PIPropertyList *PiPL, const char *adapterName, void *adapterInfo, SPPluginRef *plugin );

	/** Creates an iterator object with which to traverse a plug-in list.
		The iterator is initially set to the first plug-in in the list.
			@param pluginList The plug-in list object, or \c NULL to use the
				global list.
			@param iter [out] A buffer in which to return the new iterator object.
			@see \c #NextPlugin(), \c #DeletePluginListIterator()
		*/
	SPAPI SPErr (*NewPluginListIterator)( SPPluginListRef pluginList, SPPluginListIteratorRef *iter );
	/** Retrieves the current plug-in and advances a plug-in-list iterator to the next plug-in in the list.
			@param iter The plug-in-list iterator object.
			@param plugin [out] A buffer in which to return the current plug-in object, \c NULL
				if the end of the list has been reached.
		    @see \c #NewPluginListIterator(),
		*/
	SPAPI SPErr (*NextPlugin)( SPPluginListIteratorRef iter, SPPluginRef *plugin );
	/** Frees a plug-in-list iterator that is no longer needed.
			@param iter The plug-in-list iterator object.
			@see \c #NewPluginListIterator(),
		*/
	SPAPI SPErr (*DeletePluginListIterator)( SPPluginListIteratorRef iter );
	/**	Reports whether a plug-in that is needed <<by whom? for what?>> is
		available in a plug-in list.
			@param pluginList The plug-in list object, or \c NULL to use the global list.
			@param available [out] A buffer in which to return true if the plug-in <<what plug-in?>>
				is found in the list.
			@see \c #SPInterfaceSuite::StartupExport()
		*/
	SPAPI SPErr (*GetPluginListNeededSuiteAvailable)( SPPluginListRef pluginList, SPBoolean *available );

	/**	Retrieves <<what?>> for a plug-in provided by the application. <<??>>
			@param plugin The plug-in object.
			@param host A pointer to the callback procedure. <<what does it do?>>
		*/
	SPAPI SPErr (*GetPluginHostEntry)( SPPluginRef plugin, SPPluginEntryFunc *hostEntry );
	/**	Retrieves the code and resources file of a plug-in.
			@param plugin The plug-in object.
			@param fileSpec [out] A buffer in which to return the file specification.
			@see \c #SPFilesSuite
		*/
	SPAPI SPErr (*GetPluginFileSpecification)( SPPluginRef plugin, SPPlatformFileSpecification *fileSpec );
	/**	Retrieves the property list of a plug-in.
			@param plugin The plug-in object.
			@param propertList [out] A buffer in which to return the property list object.
			@see \c #SPPropertiesSuite
		*/
	SPAPI SPErr (*GetPluginPropertyList)( SPPluginRef plugin, SPPropertyListRef *propertList );
	/**	Retrieves the global variables of a plug-in. This is the same value passed in messages
		to the plug-in, which PICA stores when the plug-in is unloaded.
			@param plugin The plug-in object.
			@param globals [out] A buffer in which to return a pointer to the global variable array.
		*/
	SPAPI SPErr (*GetPluginGlobals)( SPPluginRef plugin, void **globals );
	/**	Sets the global variables for a plug-in. This is the same value passed in messages
		to the plug-in, which PICA stores when the plug-in is unloaded.
			@param plugin The plug-in object.
			@param globals The new global variable array.
		*/
	SPAPI SPErr (*SetPluginGlobals)( SPPluginRef plugin, void *globals );
	/**	Reports whether a plug-in has received and returned from the interface start-up message.
			@param plugin The plug-in object.
			@param started [out] A buffer in which to return true (non-zero) if the plug-in has been started,
				false (0) otherwise.
		*/
	SPAPI SPErr (*GetPluginStarted)( SPPluginRef plugin, int32 *started );
	/**	Sets whether a plug-in has received and returned from the interface start-up message.
			@param plugin The plug-in object.
			@param started True (non-zero) if the plug-in has been started, false (0) otherwise.
		*/
	SPAPI SPErr (*SetPluginStarted)( SPPluginRef plugin, int32 started );
	/**	Reports whether a plug-in is instructed to skip the start-up message.
			@param plugin The plug-in object.
			@param skipShutdown [out] A buffer in which to return true (non-zero) if the plug-in skips
				the start-up message, false (0) otherwise.
		*/
	SPAPI SPErr (*GetPluginSkipShutdown)( SPPluginRef plugin, int32 *skipShutdown );
	/**	Instructs a plug-in to respond or not to respond to the start-up message.
			@param plugin The plug-in object.
			@param skipShutdown True (non-zero) to skip	the start-up message, false (0)
				to respond normally to the start-up message.
	*/
	SPAPI SPErr (*SetPluginSkipShutdown)( SPPluginRef plugin, int32 skipShutdown );
	/**	Reports whether a plug-in has reported an error condition that makes it unavailable.
			@param plugin The plug-in object.
			@param broken [out] A buffer in which to return true (non-zero) if
				the plug-in is marked as broken, false (0) otherwise.
		*/
	SPAPI SPErr (*GetPluginBroken)( SPPluginRef plugin, int32 *broken );
	/**	Sets or clears the broken flag that marks a plug-in as unavailable due to an
		error condition.
			@param plugin The plug-in object.
			@param broken True (non-zero) to mark the plug-in as broken, false (0)
				to clear the broken flag.
		*/
	SPAPI SPErr (*SetPluginBroken)( SPPluginRef plugin, int32 broken );
	/**	Retrieves the adapter for a plug-in.
			@param plugin The plug-in object.
			@param adapter [out] A buffer in which to return the adapter object.
			@see \c #SPAdaptersSuite
		*/
	SPAPI SPErr (*GetPluginAdapter)( SPPluginRef plugin, SPAdapterRef *adapter );
	/**	Retrieves the adapter-specific information for a plug-in.  Typically
		used only by the adapter that defined the information. Other plug-ins
		should use \c #AIPluginSuite::GetPluginOptions().
			@param plugin The plug-in object.
			@param adapterInfo [out] A buffer in which to return a pointer to the adapter-defined
				information structure.
			@see \c #SPAdaptersSuite
		*/
	SPAPI SPErr (*GetPluginAdapterInfo)( SPPluginRef plugin, void **adapterInfo );
	/**	Sets the adapter-specific information for a plug-in. Typically
		used only by the adapter that defined the information. Other plug-ins
		should use \c #AIPluginSuite::SetPluginOptions().
			@param plugin The plug-in object.
			@param adapterInfo The adapter-defined information structure.
			@see \c #SPAdaptersSuite
		*/
	SPAPI SPErr (*SetPluginAdapterInfo)( SPPluginRef plugin, void *adapterInfo );

	/**	Retrieves a specific property from the property list for a plug-in.	If
		the property is not found in the list, sends the plug-in the
		\c #kSPPropertiesAcquireSelector message. The plug-in can ignore the
		message, or it can create and return the requested property. In either
        case, this function adds the (possibly \c NULL) property to the list
        and returns it.
			@param plugin The plug-in object.
			@param vendorID The property vendor ID code.
			@param propetyKey The property type key code.
			@param propertyID The specific property identifier.
			@param p [out] A buffer in which to return a pointer to the property object.
			@see \c #SPPropertiesSuite
		*/
	SPAPI SPErr (*FindPluginProperty)( SPPluginRef plugin, PIType vendorID, PIType propertyKey, int32 propertyID, PIProperty **p );

	/**	Retrieves the name of a plug-in.
			@param plugin The plug-in object.
			@param name [out] A buffer in which to return the name string.
		*/
	SPAPI SPErr (*GetPluginName)( SPPluginRef plugin, const char **name );
	/**	Sets the name of a plug-in.
			@param plugin The plug-in object.
			@param name The new name string.
		*/
	SPAPI SPErr (*SetPluginName)( SPPluginRef plugin, const char *name );
	/**	Retrieves a plug-in by name.
			@param name The name string.
			@param plugin [out] A buffer in which to return the plug-in object.
		*/
	SPAPI SPErr (*GetNamedPlugin)( const char *name, SPPluginRef *plugin);

	/**	Sets the property list for a plug-in.
			@param plugin The plug-in object.
			@param file The file containing the property list. <<??>>
		*/
	SPAPI SPErr (*SetPluginPropertyList)( SPPluginRef plugin, SPFileRef file );

	// Plug-ins suite version 5
	/* This attribute frees the adapterInfo field for private data for adapters.
		<<what does this mean? what does adapterInfo have to do with "host info"??>> */
	/**	Retrieves host information for a plug-in. <<what is "host info"? where defined?>>
			@param plugin The plug-in object.
			@param hostInfo [out] A buffer in which to return a pointer to the
				host information structure.
		*/
	SPAPI SPErr (*GetPluginHostInfo)( SPPluginRef plugin, void **hostInfo );
	/**	Sets host information for a plug-in. <<what is "host info"? where defined?>>
			@param plugin The plug-in object.
			@param hostInfo The new host information structure.
		*/
	SPAPI SPErr (*SetPluginHostInfo)( SPPluginRef plugin, void *hostInfo );

} SPPluginsSuite;



/*******************************************************************************
 **
 ** Suite
 **
 **/

/** This suite allows you to access and manipulate the plug-in object but uses
	the XPlatFileSpec rather than the SPPlatformFileSpecification as in previous
	versions.

	For higher-level access to plug-ins, see \c #AIPluginSuite.

	\li Acquire this suite using \c #SPBasicSuite::AcquireSuite() with the constants
		\c #kSPPluginsSuite and \c #kSPPluginsSuiteVersion6.
	*/
typedef struct SPXPlatPluginsSuite {

	/** Creates a new plug-in list. You can also access PICA's global plug-in list,
		using \c #SPRuntimeSuite::GetRuntimePluginList().
			@param stringPool The string pool in which to keep plug-in names.
			@param pluginList [out] A buffer in which to return the new list object.
		*/
	SPAPI SPErr (*AllocatePluginList)( SPStringPoolRef strings, SPPluginListRef *pluginList );
	/** Frees a list of plug-ins allocated with \c #AllocatePluginList(), and
		also frees any entries in the list. Do not free the global list (\c #kSPRuntimePluginList).
			@param pluginList The plug-in list object.
		*/
	SPAPI SPErr (*FreePluginList)( SPPluginListRef pluginList );

	/** Creates a new plug-in object and adds it to a plug-in list.
			@param pluginList The plug-in list object, or \c NULL to use the
				global list.
			@param fileSpec The file specification for the plug-in code and resources.
			@param PiPL The structure containing the plug-in properties.
			@param adapterName The unique identifiying name of the adapter for the new plug-in.
			@param adapterInfo A pointer to the adapter-defined structure that stores needed
				information about this plug-in.
			@param plugin [out] A buffer in which to return the new plug-in object.
			@see \c #AllocatePluginList(), \c #SPAdaptersSuite
		*/
	SPAPI SPErr (*AddXPlatPlugin)( SPPluginListRef pluginList, const XPlatFileSpec *fileSpec,
				PIPropertyList *PiPL, const char *adapterName, void *adapterInfo, SPPluginRef *plugin );

	/** Creates an iterator object with which to traverse a plug-in list.
		The iterator is initially set to the first plug-in in the list.
			@param pluginList The plug-in list object, or \c NULL to use the
				global list.
			@param iter [out] A buffer in which to return the new iterator object.
			@see \c #NextPlugin(), \c #DeletePluginListIterator()
		*/
	SPAPI SPErr (*NewPluginListIterator)( SPPluginListRef pluginList, SPPluginListIteratorRef *iter );
	/** Retrieves the current plug-in and advances a plug-in-list iterator to the next plug-in in the list.
			@param iter The plug-in-list iterator object.
			@param plugin [out] A buffer in which to return the current plug-in object, \c NULL
				if the end of the list has been reached.
		    @see \c #NewPluginListIterator(),
		*/
	SPAPI SPErr (*NextPlugin)( SPPluginListIteratorRef iter, SPPluginRef *plugin );
	/** Frees a plug-in-list iterator that is no longer needed.
			@param iter The plug-in-list iterator object.
			@see \c #NewPluginListIterator(),
		*/
	SPAPI SPErr (*DeletePluginListIterator)( SPPluginListIteratorRef iter );
	/**	Reports whether a plug-in that is needed <<by whom? for what?>> is
		available in a plug-in list.
			@param pluginList The plug-in list object, or \c NULL to use the global list.
			@param available [out] A buffer in which to return true if the plug-in <<what plug-in?>>
				is found in the list.
			@see \c #SPInterfaceSuite::StartupExport()
		*/
	SPAPI SPErr (*GetPluginListNeededSuiteAvailable)( SPPluginListRef pluginList, SPBoolean *available );

	/**	Retrieves <<what?>> for a plug-in provided by the application. <<??>>
			@param plugin The plug-in object.
			@param host A pointer to the callback procedure. <<what does it do?>>
		*/
	SPAPI SPErr (*GetPluginHostEntry)( SPPluginRef plugin, SPPluginEntryFunc *hostEntry );
	/**	Retrieves the code and resources file of a plug-in.
			@param plugin The plug-in object.
			@param fileSpec [out] A buffer in which to return the file specification.
			@see \c #SPFilesSuite
		*/
	SPAPI SPErr (*GetPluginXplatFileSpec)( SPPluginRef plugin, XPlatFileSpec *fileSpec );
	/**	Retrieves the property list of a plug-in.
			@param plugin The plug-in object.
			@param propertList [out] A buffer in which to return the property list object.
			@see \c #SPPropertiesSuite
		*/
	SPAPI SPErr (*GetPluginPropertyList)( SPPluginRef plugin, SPPropertyListRef *propertList );
	/**	Retrieves the global variables of a plug-in. This is the same value passed in messages
		to the plug-in, which PICA stores when the plug-in is unloaded.
			@param plugin The plug-in object.
			@param globals [out] A buffer in which to return a pointer to the global variable array.
		*/
	SPAPI SPErr (*GetPluginGlobals)( SPPluginRef plugin, void **globals );
	/**	Sets the global variables for a plug-in. This is the same value passed in messages
		to the plug-in, which PICA stores when the plug-in is unloaded.
			@param plugin The plug-in object.
			@param globals The new global variable array.
		*/
	SPAPI SPErr (*SetPluginGlobals)( SPPluginRef plugin, void *globals );
	/**	Reports whether a plug-in has received and returned from the interface start-up message.
			@param plugin The plug-in object.
			@param started [out] A buffer in which to return true (non-zero) if the plug-in has been started,
				false (0) otherwise.
		*/
	SPAPI SPErr (*GetPluginStarted)( SPPluginRef plugin, int32 *started );
	/**	Sets whether a plug-in has received and returned from the interface start-up message.
			@param plugin The plug-in object.
			@param started True (non-zero) if the plug-in has been started, false (0) otherwise.
		*/
	SPAPI SPErr (*SetPluginStarted)( SPPluginRef plugin, int32 started );
	/**	Reports whether a plug-in is instructed to skip the start-up message.
			@param plugin The plug-in object.
			@param skipShutdown [out] A buffer in which to return true (non-zero) if the plug-in skips
				the start-up message, false (0) otherwise.
		*/
	SPAPI SPErr (*GetPluginSkipShutdown)( SPPluginRef plugin, int32 *skipShutdown );
	/**	Instructs a plug-in to respond or not to respond to the start-up message.
			@param plugin The plug-in object.
			@param skipShutdown True (non-zero) to skip	the start-up message, false (0)
				to respond normally to the start-up message.
	*/
	SPAPI SPErr (*SetPluginSkipShutdown)( SPPluginRef plugin, int32 skipShutdown );
	/**	Reports whether a plug-in has reported an error condition that makes it unavailable.
			@param plugin The plug-in object.
			@param broken [out] A buffer in which to return true (non-zero) if
				the plug-in is marked as broken, false (0) otherwise.
		*/
	SPAPI SPErr (*GetPluginBroken)( SPPluginRef plugin, int32 *broken );
	/**	Sets or clears the broken flag that marks a plug-in as unavailable due to an
		error condition.
			@param plugin The plug-in object.
			@param broken True (non-zero) to mark the plug-in as broken, false (0)
				to clear the broken flag.
		*/
	SPAPI SPErr (*SetPluginBroken)( SPPluginRef plugin, int32 broken );
	/**	Retrieves the adapter for a plug-in.
			@param plugin The plug-in object.
			@param adapter [out] A buffer in which to return the adapter object.
			@see \c #SPAdaptersSuite
		*/
	SPAPI SPErr (*GetPluginAdapter)( SPPluginRef plugin, SPAdapterRef *adapter );
	/**	Retrieves the adapter-specific information for a plug-in.  Typically
		used only by the adapter that defined the information. Other plug-ins
		should use \c #AIPluginSuite::GetPluginOptions().
			@param plugin The plug-in object.
			@param adapterInfo [out] A buffer in which to return a pointer to the adapter-defined
				information structure.
			@see \c #SPAdaptersSuite
		*/
	SPAPI SPErr (*GetPluginAdapterInfo)( SPPluginRef plugin, void **adapterInfo );
	/**	Sets the adapter-specific information for a plug-in. Typically
		used only by the adapter that defined the information. Other plug-ins
		should use \c #AIPluginSuite::SetPluginOptions().
			@param plugin The plug-in object.
			@param adapterInfo The adapter-defined information structure.
			@see \c #SPAdaptersSuite
		*/
	SPAPI SPErr (*SetPluginAdapterInfo)( SPPluginRef plugin, void *adapterInfo );

	/**	Retrieves a specific property from the property list for a plug-in.	If
		the property is not found in the list, sends the plug-in the
		\c #kSPPropertiesAcquireSelector message. The plug-in can ignore the
		message, or it can create and return the requested property. In either
        case, this function adds the (possibly \c NULL) property to the list
        and returns it.
			@param plugin The plug-in object.
			@param vendorID The property vendor ID code.
			@param propetyKey The property type key code.
			@param propertyID The specific property identifier.
			@param p [out] A buffer in which to return a pointer to the property object.
			@see \c #SPPropertiesSuite
		*/
	SPAPI SPErr (*FindPluginProperty)( SPPluginRef plugin, PIType vendorID, PIType propertyKey, int32 propertyID, PIProperty **p );

	/**	Retrieves the name of a plug-in.
			@param plugin The plug-in object.
			@param name [out] A buffer in which to return the name string.
		*/
	SPAPI SPErr (*GetPluginName)( SPPluginRef plugin, const char **name );
	/**	Sets the name of a plug-in.
			@param plugin The plug-in object.
			@param name The new name string.
		*/
	SPAPI SPErr (*SetPluginName)( SPPluginRef plugin, const char *name );
	/**	Retrieves a plug-in by name.
			@param name The name string.
			@param plugin [out] A buffer in which to return the plug-in object.
		*/
	SPAPI SPErr (*GetNamedPlugin)( const char *name, SPPluginRef *plugin);

	/**	Sets the property list for a plug-in.
			@param plugin The plug-in object.
			@param file The file containing the property list. <<??>>
		*/
	SPAPI SPErr (*SetPluginPropertyList)( SPPluginRef plugin, SPFileRef file );

	// Plug-ins suite version 5
	/* This attribute frees the adapterInfo field for private data for adapters.
		<<what does this mean? what does adapterInfo have to do with "host info"??>> */
	/**	Retrieves host information for a plug-in. <<what is "host info"? where defined?>>
			@param plugin The plug-in object.
			@param hostInfo [out] A buffer in which to return a pointer to the
				host information structure.
		*/
	SPAPI SPErr (*GetPluginHostInfo)( SPPluginRef plugin, void **hostInfo );
	/**	Sets host information for a plug-in. <<what is "host info"? where defined?>>
			@param plugin The plug-in object.
			@param hostInfo The new host information structure.
		*/
	SPAPI SPErr (*SetPluginHostInfo)( SPPluginRef plugin, void *hostInfo );

} SPXPlatPluginsSuite;


/** Internal */
SPAPI SPErr SPAllocatePluginList( SPStringPoolRef strings, SPPluginListRef *pluginList );
/** Internal */
SPAPI SPErr SPFreePluginList( SPPluginListRef pluginList );
/** Internal */
SPAPI SPErr SPGetPluginListNeededSuiteAvailable( SPPluginListRef pluginList, SPBoolean *available );

/** Internal */
SPAPI SPErr SPAddPlugin( SPPluginListRef pluginList, const SPPlatformFileSpecification *fileSpec,
			PIPropertyList *PiPL, const char *adapterName, void *adapterInfo, SPPluginRef *plugin );

/** Internal */
SPAPI SPErr SPAddXPlatPlugin( SPPluginListRef pluginList, const XPlatFileSpec *fileSpec,
			PIPropertyList *PiPL, const char *adapterName, void *adapterInfo, SPPluginRef *plugin );

/** Internal */
SPAPI SPErr SPNewPluginListIterator( SPPluginListRef pluginList, SPPluginListIteratorRef *iter );
/** Internal */
SPAPI SPErr SPNextPlugin( SPPluginListIteratorRef iter, SPPluginRef *plugin );
/** Internal */
SPAPI SPErr SPDeletePluginListIterator( SPPluginListIteratorRef iter );

/** Internal */
SPAPI SPErr SPGetHostPluginEntry( SPPluginRef plugin, SPPluginEntryFunc *hostEntry );
/** Internal */
SPAPI SPErr SPGetPluginFileSpecification( SPPluginRef plugin, SPPlatformFileSpecification *fileSpec );
/** Internal */
SPAPI SPErr SPGetPluginXplatFileSpec( SPPluginRef plugin, XPlatFileSpec *fileSpec );
/** Internal */
SPAPI SPErr SPGetPluginPropertyList( SPPluginRef plugin, SPPropertyListRef *propertyList );
/** Internal */
SPAPI SPErr SPGetPluginGlobals( SPPluginRef plugin, void **globals );
/** Internal */
SPAPI SPErr SPSetPluginGlobals( SPPluginRef plugin, void *globals );
/** Internal */
SPAPI SPErr SPGetPluginStarted( SPPluginRef plugin, int32 *started );
/** Internal */
SPAPI SPErr SPSetPluginStarted( SPPluginRef plugin, int32 started );
/** Internal */
SPAPI SPErr SPGetPluginSkipShutdown( SPPluginRef plugin, int32 *skipShutdown );
/** Internal */
SPAPI SPErr SPSetPluginSkipShutdown( SPPluginRef plugin, int32 skipShutdown );
/** Internal */
SPAPI SPErr SPGetPluginBroken( SPPluginRef plugin, int32 *broken );
/** Internal */
SPAPI SPErr SPSetPluginBroken( SPPluginRef plugin, int32 broken );
/** Internal */
SPAPI SPErr SPGetPluginAdapter( SPPluginRef plugin, SPAdapterRef *adapter );
/** Internal */
SPAPI SPErr SPGetPluginAdapterInfo( SPPluginRef plugin, void **adapterInfo );
/** Internal */
SPAPI SPErr SPSetPluginAdapterInfo( SPPluginRef plugin, void *adapterInfo );

/** Internal */
SPAPI SPErr SPFindPluginProperty( SPPluginRef plugin, PIType vendorID, PIType propertyKey,
			int32 propertyID, PIProperty **p );

/** Internal */
SPAPI SPErr SPGetPluginName( SPPluginRef plugin, const char **name );
/** Internal */
SPAPI SPErr SPSetPluginName( SPPluginRef plugin, const char *name );
/** Internal */
SPAPI SPErr SPGetNamedPlugin( const char *name, SPPluginRef *plugin);

/** Internal */
SPAPI SPErr SPSetPluginPropertyList( SPPluginRef plugin, SPFileRef file );

/** Internal */
SPErr SPAddHostPlugin( SPPluginListRef pluginList, SPPluginEntryFunc entry, void *access, const char *adapterName,
			void *adapterInfo, SPPluginRef *plugin, const char *name);
																  /* access is SPPlatformAccessRef */


// Plug-ins suite version 5
/* This attribute frees the adapterInfo field for private data for adapters. */
/** Internal */
SPAPI SPErr SPGetPluginHostInfo( SPPluginRef plugin, void **hostInfo );
/** Internal */
SPAPI SPErr SPSetPluginHostInfo( SPPluginRef plugin, void *hostInfo );


/*******************************************************************************
 **
 ** Errors
 **
 **/

#include "SPErrorCodes.h"

#ifdef __cplusplus
}
#endif

#endif

```

---

<h2>Begin File: SPProps.h</h2>

```cpp
/***********************************************************************/
/*                                                                     */
/* SPProps.h                                                           */
/*                                                                     */
/* Copyright 1995-2006 Adobe Systems Incorporated.                     */
/* All Rights Reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/***********************************************************************/

#ifndef __SPProperties__
#define __SPProperties__


/*******************************************************************************
 **
 **	Imports
 **
 **/

#include "SPTypes.h"
#include "SPMData.h"
#include "SPPiPL.h"

#ifdef __cplusplus
extern "C" {
#endif


/*******************************************************************************
 **
 ** Constants
 **
 **/

/** PICA properties suite name */
#define kSPPropertiesSuite				"SP Properties Suite"
/** PICA properties suite version */
#define kSPPropertiesSuiteVersion2		2
/** PICA properties suite version */
#define kSPPropertiesSuiteVersion		kSPPropertiesSuiteVersion2	// minimal is default
/** PICA properties suite version */
#define kSPPropertiesSuiteVersion3		3

/** @ingroup Callers
	PICA plug-in property operation; sent with \c #SPPropertiesMessage.
	See \c #SPPropertiesSuite. */
#define kSPPropertiesCaller				"SP Properties"
/** @ingroup Selectors
	Acquire PICA plug-in properties; sent with \c #SPPropertiesMessage.
	See \c #SPPropertiesSuite.*/
#define kSPPropertiesAcquireSelector	"Acquire"
/** @ingroup Selectors
	Release PICA plug-in properties; sent with \c #SPPropertiesMessage.
	See \c #SPPropertiesSuite.*/
#define kSPPropertiesReleaseSelector	"Release"


/*******************************************************************************
 **
 ** Types
 **
 **/
/** An opaque reference to a plug-in property. Access with the \c #SPPropertiesSuite. */
typedef struct SPProperty *SPPropertyRef;
/** An opaque reference to a plug-in property list. Create and access with the \c #SPPropertiesSuite. */
typedef struct SPPropertyList *SPPropertyListRef;
/** An opaque reference to an iterator for a plug-in property list. Create and access with the \c #SPPropertiesSuite. */
typedef struct SPPropertyListIterator *SPPropertyListIteratorRef;

/** Message passed with the \c #kSPPropertiesCaller. */
typedef struct SPPropertiesMessage {
	/** The message data. */
	SPMessageData d;

	/** Unique identifier for the vendor defining this property type. This allows
		you to define your own properties in a way that
		does not conflict with either Adobe or other vendors.
		Use a registered application creator code to ensure uniqueness.
		All PICA properties use \c #PIAdobeVendorID.*/
	PIType vendorID;
	/** The property type key code, typically identifies a resource type. */
	PIType propertyKey;
	/** The unique property identifier, for multiple resources of a given
		type. Normally, there is only one, and the ID value is 0. */
	int32 propertyID;

	/** A structure containing the property data, or value. */
	void *property;
	/** Reference count. Increment when a property is acquired, decrement
		when it is released. */
	int32 refCon;
	/** True (non-zero) if this property does not change betweeen sessions
		and can be cached by the application in the start-up preferences
		file, false (0) otherwise. Typically true. */
	int32 cacheable;

} SPPropertiesMessage;


/*******************************************************************************
 **
 ** Suite
 **
 **/
/** @ingroup Suites
	Use these functions to create, access, and manage plug-in property lists
	associated with a specific plug-in. Plug-in properties provide the
	application with resource information for the plug-in, such as the types
	and locations of code files, and the plug-in version.

	A plug-in can be associated with multiple properties lists.

	\li Acquire this suite using \c #SPBasicSuite::AcquireSuite() with the constants
		\c #kSPPropertiesSuite and \c #kSPPropertiesSuiteVersion.
	*/
typedef struct SPPropertiesSuite {

	/** Creates a new plug-in property list.
			@param stringPool The string pool in which to keep plug-in names.
			@param propertyList [out] A buffer in which to return the new list object.
		*/
	SPAPI SPErr (*AllocatePropertyList)( SPPropertyListRef *propertyList );
	/** Frees a list of plug-in properties allocated with \c #AllocatePropertyList(), and
		also frees any entries in the list. If the list is one of a chain, frees the
		entire chain.
			@param propertyList The plug-in properties list object.
			@see \c #SPHasMultiplePropertyLists()
		*/
	SPAPI SPErr (*FreePropertyList)( SPPropertyListRef propertyList );

	/** Adds a set of properties to a plug-in properties list. This set is typically
		read from a resource file.Creates an \c #SPPropertyRef for each property,
		but does not return these objects.
			@param propertyList The plug-in properties list object.
			@param pList A pointer to the low-level structure for the set of properties to add.
			@param refCon The initial reference count for properties in the set.
			@param cacheable True (non-zero) if these properties do not change betweeen sessions
				and can be cached by the application in the start-up preferences
				file, false (0) otherwise. Typically true.
			@see \c #AddProperty()
		*/
	SPAPI SPErr (*AddProperties)( SPPropertyListRef propertyList, PIPropertyList *pList, int32 refCon, int32 cacheable );

	/** Creates a new individual property and adds it to a plug-in properties list.
		Typically called to install a property returned from an \c #kSPPropertiesAcquireSelector message.
			@param propertyList The plug-in properties list object.
			@param vendorID	The vendor identifier for the new property.
			@param propertyKey The type key code for the new property.
			@param propertyID The unique identifier for the individual property (normally 0).
			@param p A pointer to the property value structure.
		<<this contains the vID/key/pID, so why have those args?>>
			@param refCon The initial reference count for property.
			@param cacheable True (non-zero) if this property does not change betweeen sessions
				and can be cached by the application in the start-up preferences
				file, false (0) otherwise. Typically true.
			@param property [out] A buffer in which to return the new property object.
			@see \c #AllocatePropertyList(), \c #AddProperties()
		*/
	SPAPI SPErr (*AddProperty)( SPPropertyListRef propertyList, PIType vendorID, PIType propertyKey, int32 propertyID, PIProperty *p,
				int32 refCon, int32 cacheable, SPPropertyRef *property );

	/**	Retrieves a property from a plug-in properties list, or from any list in its chain.
			@param propertyList The plug-in properties list object.
			@param vendorID	The vendor identifier for the new property.
			@param propertyKey The type key code for the new property.
			@param propertyID The unique identifier for the individual property (normally 0).
			@param property [out] A buffer in which to return the property object, or \c NULL if a
				matching property is not found.
			@param \c #FindPropertyLocal()
		*/
	SPAPI SPErr (*FindProperty)( SPPropertyListRef propertyList, PIType vendorID, PIType propertyKey, int32 propertyID, SPPropertyRef *property );

	/** Creates an iterator object with which to traverse a plug-in properties list.
		The iterator is initially set to the first property in the list.
			@param propertyList The plug-in properties list object.
			@param iter [out] A buffer in which to return the new iterator object.
			@see \c #NextProperty(), \c #DeletePropertyListIterator()
		*/
	SPAPI SPErr (*NewPropertyListIterator)( SPPropertyListRef propertyList, SPPropertyListIteratorRef *iter );
	/** Retrieves the current property and advances a plug-in properties list iterator
		to the next property in the list.
			@param iter The plug-in properties list iterator object.
			@param property [out] A buffer in which to return the current property object, \c NULL
				if the end of the list has been reached.
		    @see \c #NewPropertyListIterator(),
		*/
	SPAPI SPErr (*NextProperty)( SPPropertyListIteratorRef iter, SPPropertyRef *property );
	/** Frees a plug-in properties list iterator that is no longer needed.
			@param iter The plug-in properties list iterator object.
			@see \c #NewPropertyListIterator(),
		*/
	SPAPI SPErr (*DeletePropertyListIterator)( SPPropertyListIteratorRef iter );

	/**	Retrieves the low-level property structure of a property object.
			@param property The property object.
			@param p [out] A buffer in which to return a pointer to the property structure.
		*/
	SPAPI SPErr (*GetPropertyPIProperty)( SPPropertyRef property, PIProperty **p );
	/**	Retrieves the current reference count of a property.
			@param property The property object.
			@param refCon [out] A buffer in which to return the reference count.
		*/
	SPAPI SPErr (*GetPropertyRefCon)( SPPropertyRef property, int32 *refCon );
	/**	Reports whether a property is cacheable.
			@param property The property object.
			@param cacheable [out] A buffer in which to return true (non-zero)
				if this property does not change betweeen sessions
				and can be cached by the application in the start-up preferences
				file, false (0) otherwise.
		*/
	SPAPI SPErr (*GetPropertyCacheable)( SPPropertyRef property, int32 *cacheable );
	/**	Reports whether a property was allocated by the plug-in that contains it.
			@param property The property object.
			@param allocatedByPlugin [out] A buffer in which to return true (non-zero)
				if this property was created after being acquired from a
				\c #kSPPropertiesAcquireSelector message, false (0) if the
				property was read from a resource file.
			@see \c #AddProperty(), \c #AddProperties()
		*/
	SPAPI SPErr (*GetPropertyAllocatedByPlugin)( SPPropertyRef property, int32 *allocatedByPlugin );

	// kSPPropertiesSuiteVersion3
	/**	Reports whether a plug-in properties list is one of a chain of properties lists for its plug-in.
		(Note that this function returns a boolean value, not an error code.)
			@param propertyList The plug-in properties list object.
			@return True (non-zero) if the list is one of a chain, false (0) otherwise.
			@see \c #GetNextPropertyList()
		*/
	SPAPI SPBoolean (*SPHasMultiplePropertyLists)(SPPropertyListRef propertyList);
	/**	Retrieves the next plug-in properties list in a properties-list chain.
			@param propertyList The current plug-in properties list object.
			@param nextPropertyList [out] A buffer in which to return the next properties list object,
				or \c NULL if the end of the chain has been reached.
		*/
	SPAPI SPErr (*GetNextPropertyList)(SPPropertyListRef propertyList, SPPropertyListRef *nextPropertyList);
	/**	Retrieves a property from a plug-in properties list, but does not search in other
		lists in the chain.
			@param propertyList The plug-in properties list object.
			@param vendorID	The vendor identifier for the new property.
			@param propertyKey The type key code for the new property.
			@param propertyID The unique identifier for the individual property (normally 0).
			@param property [out] A buffer in which to return the property object, or \c NULL if a
				matching property is not found.
			@see \c #FindProperty()
		*/
	SPAPI SPErr (*FindPropertyLocal)( SPPropertyListRef propertyList, PIType vendorID, PIType propertyKey,
				int32 propertyID, SPPropertyRef *property );

} SPPropertiesSuite;


/** Internal */
SPAPI SPErr SPAllocatePropertyList( SPPropertyListRef *propertyList );
/** Internal */
SPAPI SPErr SPFreePropertyList( SPPropertyListRef propertyList );

/** Internal */
SPAPI SPErr SPAddProperties( SPPropertyListRef propertyList, PIPropertyList *pList, int32 refCon,
			int32 cacheable );

/** Internal */
SPAPI SPErr SPAddProperty( SPPropertyListRef propertyList, PIType vendorID, PIType propertyKey,
			int32 propertyID, PIProperty *p, int32 refCon, int32 cacheable, SPPropertyRef *property );

/** Internal */
SPAPI SPErr SPFindProperty( SPPropertyListRef propertyList, PIType vendorID, PIType propertyKey,
			int32 propertyID, SPPropertyRef *property );

/** Internal */
SPAPI SPErr SPNewPropertyListIterator( SPPropertyListRef propertyList, SPPropertyListIteratorRef *iter );
/** Internal */
SPAPI SPErr SPNextProperty( SPPropertyListIteratorRef iter, SPPropertyRef *property );
/** Internal */
SPAPI SPErr SPDeletePropertyListIterator( SPPropertyListIteratorRef iter );

/** Internal */
SPAPI SPErr SPGetPropertyPIProperty( SPPropertyRef property, PIProperty **p );
/** Internal */
SPAPI SPErr SPGetPropertyRefCon( SPPropertyRef property, int32 *refCon );
/** Internal */
SPAPI SPErr SPGetPropertyCacheable( SPPropertyRef property, int32 *cacheable );
/** Internal */
SPAPI SPErr SPGetPropertyAllocatedByPlugin( SPPropertyRef property, int32 *allocatedByPlugin );

/** Internal */
SPAPI SPBoolean SPHasMultiplePropertyLists(SPPropertyListRef propertyList);
/** Internal */
SPAPI SPErr SPGetNextPropertyList(SPPropertyListRef propertyList, SPPropertyListRef *nextPropertyList);

/** Internal */
SPAPI SPErr SPFindPropertyLocal( SPPropertyListRef propertyList, PIType vendorID,
			PIType propertyKey, int32 propertyID, SPPropertyRef *property );

/*******************************************************************************
 **
 **	Errors
 **
 **/

#include "SPErrorCodes.h"

#ifdef __cplusplus
}
#endif

#endif

```

---

<h2>Begin File: SPRuntme.h</h2>

```cpp
/***********************************************************************/
/*                                                                     */
/* SPRuntme.h                                                          */
/*                                                                     */
/* Copyright 1995-2006 Adobe Systems Incorporated.                     */
/* All Rights Reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/***********************************************************************/

#ifndef __SPRuntime__
#define __SPRuntime__


/*******************************************************************************
 **
 **	Imports
 **
 **/

#include "SPTypes.h"
#include "SPAdapts.h"
#include "SPFiles.h"
#include "SPPlugs.h"
#include "SPStrngs.h"
#include "SPSuites.h"
#include "SPStrngs.h"

#ifdef __cplusplus
extern "C" {
#endif


/*******************************************************************************
 **
 **	Constants
 **
 **/

#define kSPRuntimeSuite				"SP Runtime Suite"
#define kSPRuntimeSuiteVersion		5
#define kSPRuntimeSuiteXPlatVersion	6


/*******************************************************************************
 **
 **	Types
 **
 **/

/*	INTERNAL DOCS
 *	PICA makes callbacks into the host through the host procs. The host
 *	procs are filled in by the host and passed to Sweet Pea at SPInit().
 *
 *	hostData - data that is given back to each host proc when Sweet Pea
 *		calls it. Sweet Pea does nothing with it itself.
 *
 *	extAllocate - implementation of the Block Suite's AllocateBlock() routine.
 *		It is identical to ANSI C malloc(). It returns a pointer to the
 *		beginning of the allocated block or NULL.
 *
 *	extFree - implementation of the Block Suite's FreeBlock() routine. It is
 *		identical to ANSI C free(). Note that you can pass it NULL.
 *
 *	extReallocate - implementation of the Block Suite's ReallocateBlock()
 *		routine. It is identical to ANSI C realloc(). It returns a pointer
 *		to the resized block or NULL. Note that you can pass it NULL or a
 *		newSize of 0.
 *
 *	intAllocate, intFree, intReallocate - routines used by Sweet Pea for
 *		its own memory needs. You may want to allocate blocks differently
 *		with plug-ins and Sweet Pea. Plug-ins are unbounded in their memory
 *		needs, while Sweet Pea's memory usage can be approximated.
 *
 *	startupNotify - called as each plug-in is started up. This is intended
 *		as a way to tell the user what's happening during start up.
 *		Note that plug-ins may start up at any time, not just during
 *		SPStartupPlugins().
 *
 *	shutdownNotify - called as each plug-in is shut down. Also intended as
 *		a way to let users know what's going on.
 *
 *	assertTrap - called when a fatal assert is triggered. Sweet Pea does
 *		not expect execution to continue after an assert.
 *
 *	throwTrap - called when an internal error is thrown. This can be used
 *		during debugging to catch errors as they happen. It should return
 *		to allow Sweet Pea to handle the error.
 *
 *
 *	To aid in getting Sweet Pea up and running quickly, you can set any of
 *	these to NULL and Sweet Pea will use a default implementation. However:
 *	you cannot mix your implementations of the memory routines with
 *	Sweet Pea's defaults.
 *
 *
 *	The string pool functions replace the default routines used internally
 *	and exported by the Strings suite.  Because they are exported, the behaviors
 *	listed below should be followed.
 *
 *	allocateStringPool - creates a new string pool instance. The host app and
 *		Sweet Pea have a string pool which can be used by a plug-in, or a plug-in
 *		can create its own.  See the notes in SPStrngs.h on how the pool is
 *		implemented.
 *		The function should return kSPNoError if the pool is allocated successfully
 *		or kSPOutOfMemoryError if allocation fails.
 *
 *	freeStringPool - disposes of the string pool and any associated memory.  The
 *		funtion should return kSPNoError
 *
 *	makeWString - the string pool keeps a list of added strings. When a new string is
 *		added with MakeWString(), the routine checks to see if it is already in the
 *		pool.  If so, the address of the string instance in the pool is returned.  If
 *		not, it will add it to the pool and return the address of the newly
 *		created string instance.  The behavior is:
 *
 *			if ( string == NULL )
 *					*wString = NULL;
 *					returns kSPNoError;
 *			else if ( string in string pool )
 *					*wString = found string;
 *					returns kSPNoError;
 *			else add string
 *				if successful
 *					*wString = new string;
 *					returns kSPNoError;
 *				else
 *					*wString = nil
 *					returns kSPOutOfMemoryError
 *
 *	appStringPool - if the host application has already allocated a string pool to use,
 *		it's reference should be passed here.  If this value is NULL, Sweet Pea will
 *		allocate the pool when initialized and dispose of it at termination.
 *
 *	filterEvent - a function called for each event allowing the host to cancel it.
 *		The event type is indicative of what the filter is to do.  A  file validation
 *		is called before a directory entry is added to the file list (kAddFile).
 *		A plug-in validation before a file is checked for PiPL information (kAddPlugin);
 *		the host might examine the file name/type to determine whether it should be added.
 *		For these 'add' events the return value is TRUE if the item should be skipped
 *		or FALSE if should be should be added. The default filter proc, used (if NULL)
 *		is passed, will skip files/folders in ( ).
 *		The other event is kSuitesAvailable.  It is called when the last suite adding
 *		plug-in	(as determined by available PiPL information) has been added.  This is
 *		a point at which the host can cancel the startup process; for instance, if the host
 *		requires a suite from a plug-in, this is the time to check for it.  If the
 *		host returns TRUE, the startup process continues.  If it returns FALSE, the
 *		plug-in startup is canceled and the host would likely terminate or startup in
 *		an alternate manner.
 *
 *	overrideAddPlugins - if supplied, SP will call the host to create the runtime
 *		plug-in list.  This occurs at SPStartupPlugins().  The function takes no parameters
 *		as it is up to the host to determine how to do this.  For instance, the host can do
 *		this from cached data or, as SP would, from the file list.  A returned error will
 *		stop the plug-in startup process.
 *
 *	overrideStartup - a function called for each SP2 plug-in before it is sent the
 *		startup message.  If the host returns FALSE, SP will startup the plug-in normal.
 *		If the host returns true, it is assumed that the host has handled the startup
 *		for the plug-in, so SP will not do anything for the plug-in.  This is intended
 *		to be used with a plug-in caching scheme.
 *		The host would be responsible, for instance, for defining the cacheable
 * 		information in the PiPL, adding it when the callback is made, and later issuing
 *		a startup message when the plug-in is actually needed (e.g. when a menu item
 *		is selected.)  Two notes: don't forget to SetPluginStarted(), and make sure
 *		to use a string pooled char* to kSPInterfaceCaller and kSPInterfaceStartupSelector.
 *
 *	resolveLink - Windows only.  If the search for plug-ins is to recurse sub-folders,
 *		the host needs to suply this routine.  When a .lnk file is encountered, the
 *		resolveLink host callback function will be called and should return a resolved path.
 *		This is a host callback due to OLE issues such as initialization, which the SP
 *		libary does not currently handle.  If it returns an error code, the result will
 *		be ignored.
 *
 *	getPluginAccess - Allows the host to set the plug-in access information.  This would
 *		be used if, for instance, the host kept its own plug-in list (ala, Photoshop), but
 *		still needed these to be compatible with SPPlugins (e.g. whose accesses are used by ADM)
 *
 *	memoryIsCritical - Mac only.  Allows the host to indicate that memory is in a critical state
 *		(really low, but can't be purged because you are, say, shutdown.)
 * 		If so and the plug-in load target heap is the app heap, when a plug-in fails to load
 *		SP will then try to load the plug-in into the system heap
 */

/* These are passed in startup and shutdown host notify procs and the filter file proc. */
/** A notification event type, that an adapter passes to the \c #SPStartupNotifyProc
	and \c #SPShutdownNotifyProc when the associated plug-in is loaded or unloaded.
	*/
typedef enum {
	/** Sent to the \c #SPStartupNotifyProc after a file has been added as a plug-in.
		The \c notifyData value is the plug-in object, an \c #SPPluginRef. */
	kAddFile,				/* 	Internal: for filter file, received before a file is
								added to a file list, notifyData is a pointer to the
								SPPlatformFileSpecification */
	/** Sent to the \c #SPStartupNotifyProc after a plug-in has been added.
		The \c notifyData value is the plug-in object, an \c #SPPluginRef. */
	kAddPlugin,				/* 	Internal: for filter file, received before a file is
								checked to see if it is a plugin, notifyData is the
								files SPFileRef */
	/** Sent to the \c #SPStartupNotifyProc to specify a general message for the application splash screen.
		The \c notifyData value is a pointer to a C string, <code>char**</code>. */
	kSetMessage,
	/** Internal */
	kSuitesAvailable,		/*  Internal: used only by event filter to allow host to
								check for suites it requires, notifyDatais NULL */
	/** Internal */
	kError,					/* 	Internal: notifyData is SPErrorDataPtr*/
	/** Sent to the \c #SPStartupNotifyProc after the plug-in is started.
		The \c notifyData value is the plug-in object, an \c #SPPluginRef. */
	kStartingupPlugin,		/*  Internal: for filter file, received before a file is
								checked to see if it is a plugin, notifyData is the
								files SPFileRef */
	kXPlatError,			/* 	Internal: notifyData is SPXPlatErrorData */
							/** Sent to the \c #SPStartupNotifyProc after the plug-in is started.
								The \c notifyData value is the plug-in object, an \c #SPPluginRef. */
	/** Internal */
	kNoEvent = 0xffffffff
 } NotifyEvent;

/** Internal */
typedef void *(*SPAllocateProc)( size_t size, void *hostData );
/** Internal */
typedef void (*SPFreeProc)( void *block, void *hostData );
/** Internal */
typedef void *(*SPReallocateProc)( void *block, size_t newSize, void *hostData );
/** Called by an adapter to inform the application that a plug-in is being started up.
	The application uses this information to track the start-up process; for example,
	to display a list of plug-ins being loaded.
		@param event The notification event constant that identifies which event occurred.
		@param notifyData A pointer to plug-in-defined initialization data.
		@param hostData	A pointer to application-defined initialization data.
		@return Nothing.
	*/
typedef void (*SPStartupNotifyProc)( NotifyEvent event, void *notifyData, void *hostData );
/** Called by an adapter to inform the application that a plug-in is being shut down.
	The application uses this information to track the shut-down process.
		@param event The notificatin event.
		@param notifyData A pointer to plug-in-defined termination data.
		@param hostData	A pointer to application-defined termination data.
		@return Nothing.
	*/
typedef void (*SPShutdownNotifyProc)( NotifyEvent event, void *notifyData, void *hostData );
/** Internal */
typedef void (*SPAssertTrapProc)( const char *failMessage, void *hostData );
/** Internal */
typedef void (*SPThrowTrapProc)( SPErr error, void *hostData );
/** Internal */
typedef void (*SPDebugTrapProc)( const char *debugMessage, void *hostData );

/** Internal */
typedef SPAPI SPErr (*SPAllocateStringPoolProc)( SPStringPoolRef *pool );
/** Internal */
typedef SPAPI SPErr (*SPFreeStringPoolProc)( SPStringPoolRef stringPool );
/** Internal */
typedef SPAPI SPErr (*SPMakeWStringProc)( SPStringPoolRef stringPool, const char *string,
			const char **wString );

/** Internal */
typedef SPAPI SPErr (*SPGetHostAccessInfoProc)( SPPlatformAccessInfo *spHostAccessInfo );

/** Internal */
typedef SPAPI SPBoolean (*SPFilterEventProc)( NotifyEvent event, const void *eventData );
/** Internal */
typedef SPAPI SPErr (*SPAddPluginsProc)( void );
/** Internal */
typedef SPAPI SPBoolean (*SPOverrideStartupProc)( SPPluginRef currentPlugin );

#if defined(WIN_ENV) || defined(ANDROID_ENV)
/** Internal */
typedef SPAPI SPErr (*SPResolveLinkProc)(const char *shortcutFile, char *resolvedPath);
#endif

/** Internal */
typedef SPAPI SPErr (*GetNativePluginAccessProc)(SPPluginRef plugin, SPAccessRef *access);

/** Internal */
typedef SPAPI SPBoolean (*MemoryIsCriticalProc)( void );

/** Callback procedures provided to PICA by the application.
	Plug-ins do not use these, except for adapters, which
	call the initialization and termination procedures.
	@see \c #SPRuntimeSuite::GetRuntimeHostFileSpec() */
typedef struct SPHostProcs {

	void *hostData;

	SPAllocateProc extAllocate;
	SPFreeProc extFree;
	SPReallocateProc extReallocate;

	SPAllocateProc intAllocate;
	SPFreeProc intFree;
	SPReallocateProc intReallocate;
	/** Plug-in initialization procedure */
	SPStartupNotifyProc startupNotify;
	/** Plug-in termination procedure */
	SPShutdownNotifyProc shutdownNotify;

	SPAssertTrapProc assertTrap;
	SPThrowTrapProc throwTrap;
	SPDebugTrapProc debugTrap;

	SPAllocateStringPoolProc allocateStringPool;
	SPFreeStringPoolProc freeStringPool;
	SPMakeWStringProc makeWString;
	SPStringPoolRef appStringPool;

	SPFilterEventProc filterEvent;
	SPAddPluginsProc overrideAddPlugins;
	SPOverrideStartupProc overridePluginStartup;

#if defined(WIN_ENV) || defined(ANDROID_ENV)
	SPResolveLinkProc resolveLink;
#endif

	GetNativePluginAccessProc getPluginAccess;

#ifdef MAC_ENV
	// enable second-chance plugin loading for success-critical situations
	MemoryIsCriticalProc memoryIsCritical;
#endif

} SPHostProcs;


/*******************************************************************************
 **
 **	Suite
 **
 **/
/** @ingroup Suites
	This suite allows you to obtain specific references to the
	PICA global lists and string pool.

	\li Acquire this suite using \c #SPBasicSuite::AcquireSuite() with the constants
		\c #kSPRuntimeSuite and \c #kSPRuntimeSuiteVersion.
	*/
typedef struct SPRuntimeSuite {
	/** Retrieves the PICA global string pool.
			@param stringPool [out] A buffer in which to return the string-pool object.
			@see \c #SPStringsSuite
		*/
	SPAPI SPErr (*GetRuntimeStringPool)( SPStringPoolRef *stringPool );
	/** Retrieves the PICA global suite list.
			@param suiteList [out] A buffer in which to return the list object.
			@see \c #SPSuitesSuite
		*/
	SPAPI SPErr (*GetRuntimeSuiteList)( SPSuiteListRef *suiteList );
	/** Retrieves the PICA global file list.
			@param fileList [out] A buffer in which to return the list object.
			@see \c #SPFilesSuite
		*/
	SPAPI SPErr (*GetRuntimeFileList)( SPFileListRef *fileList );
	/** Retrieves the PICA global plug-in list.
			@param pluginList [out] A buffer in which to return the list object.
			@see \c #SPPluginsSuite
		*/
	SPAPI SPErr (*GetRuntimePluginList)( SPPluginListRef *pluginList );
	/** Retrieves the PICA global adapter list.
			@param adapterList [out] A buffer in which to return the list object.
			@see \c #SPAdaptersSuite
		*/
	SPAPI SPErr (*GetRuntimeAdapterList)( SPAdapterListRef *adapterList );
	/** Retrieves the block of function pointers supplied to PICA by the
		application, which contains memory management routines, notification routines,
		exception handling, and string pool routines.

		A plug-in does not normally call the host functions directly; you
		can use the PICA suite functions for most operations. An adapter, however,
		uses the host functions for start-up and shut-down notification.
			@param hostProcs [out] A buffer in which to return a pointer to the
				block of function pointers.
		*/
	SPAPI SPErr (*GetRuntimeHostProcs)( SPHostProcs **hostProcs );
	/** Retrieves the location of the application's plug-in folder.
			@param pluginFolder [out] A buffer in which to return the
				file specification for the directory that contains plug-ins.
		*/
	SPAPI SPErr (*GetRuntimePluginsFolder)( SPPlatformFileSpecification *pluginFolder );
	/** Retrieves the location of the application's executable file.
			@param hostFileSpec [out] A buffer in which to return the
				file specification for the application's executable file.
		*/
	SPAPI SPErr (*GetRuntimeHostFileSpec)( SPPlatformFileSpecification *hostFileSpec );
} SPRuntimeSuite;



/*******************************************************************************
 **
 **	Suite
 **
 **/
/** @ingroup Suites
	This suite allows you to obtain specific references to the
	PICA global lists and string pool using the new XPlatFileSpec
	rather than the old SPPlatformFileSpecification.

	\li Acquire this suite using \c #SPBasicSuite::AcquireSuite() with the constants
		\c #kSPRuntimeSuite and \c #kSPRuntimeSuiteXPlatVersion.
	*/
typedef struct SPXPlatRuntimeSuite {
	/** Retrieves the PICA global string pool.
			@param stringPool [out] A buffer in which to return the string-pool object.
			@see \c #SPStringsSuite
		*/
	SPAPI SPErr (*GetRuntimeStringPool)( SPStringPoolRef *stringPool );
	/** Retrieves the PICA global suite list.
			@param suiteList [out] A buffer in which to return the list object.
			@see \c #SPSuitesSuite
		*/
	SPAPI SPErr (*GetRuntimeSuiteList)( SPSuiteListRef *suiteList );
	/** Retrieves the PICA global file list.
			@param fileList [out] A buffer in which to return the list object.
			@see \c #SPFilesSuite
		*/
	SPAPI SPErr (*GetRuntimeFileList)( SPFileListRef *fileList );
	/** Retrieves the PICA global plug-in list.
			@param pluginList [out] A buffer in which to return the list object.
			@see \c #SPPluginsSuite
		*/
	SPAPI SPErr (*GetRuntimePluginList)( SPPluginListRef *pluginList );
	/** Retrieves the PICA global adapter list.
			@param adapterList [out] A buffer in which to return the list object.
			@see \c #SPAdaptersSuite
		*/
	SPAPI SPErr (*GetRuntimeAdapterList)( SPAdapterListRef *adapterList );
	/** Retrieves the block of function pointers supplied to PICA by the
		application, which contains memory management routines, notification routines,
		exception handling, and string pool routines.

		A plug-in does not normally call the host functions directly; you
		can use the PICA suite functions for most operations. An adapter, however,
		uses the host functions for start-up and shut-down notification.
			@param hostProcs [out] A buffer in which to return a pointer to the
				block of function pointers.
		*/
	SPAPI SPErr (*GetRuntimeHostProcs)( SPHostProcs **hostProcs );
	/** Retrieves the location of the application's plug-in folder.
			@param pluginFolder [out] A buffer in which to return the
				file specification for the directory that contains plug-ins.
		*/
	SPAPI SPErr (*XPlatGetRuntimePluginsFolder)( XPlatFileSpec *pluginFolder );
	/** Retrieves the location of the application's executable file.
			@param hostFileSpec [out] A buffer in which to return the
				file specification for the application's executable file.
		*/
	SPAPI SPErr (*XPlatGetRuntimeHostFileSpec)( XPlatFileSpec *hostFileSpec );
} SPXPlatRuntimeSuite;


/** Internal */
SPAPI SPErr SPGetRuntimeStringPool( SPStringPoolRef *stringPool );
/** Internal */
SPAPI SPErr SPGetRuntimeSuiteList( SPSuiteListRef *suiteList );
/** Internal */
SPAPI SPErr SPGetRuntimeFileList( SPFileListRef *fileList );
/** Internal */
SPAPI SPErr SPGetRuntimePluginList( SPPluginListRef *pluginList );
/** Internal */
SPAPI SPErr SPGetRuntimeAdapterList( SPAdapterListRef *adapterList );
/** Internal */
SPAPI SPErr SPGetRuntimeHostProcs( SPHostProcs **hostProcs );
/** Internal */
SPAPI SPErr SPGetRuntimePluginsFolder( SPPlatformFileSpecification *pluginFolder );
/** Internal */
SPAPI SPErr SPXPlatGetRuntimePluginsFolder( XPlatFileSpec *pluginFolder );
/** Internal */
SPAPI SPErr SPGetRuntimeHostFileSpec( SPPlatformFileSpecification *hostFileSpec );
/** Internal */
SPAPI SPErr SPXPlatGetRuntimeHostFileSpec( XPlatFileSpec *hostFileSpec );

/** Internal */
typedef struct
{
	SPAPI SPErr (*SPAcquireSuiteFunc)( SPSuiteListRef suiteList, const char *name, int32 apiVersion, int32 internalVersion, const void **suiteProcs );
	SPAPI SPErr (*SPReleaseSuiteFunc)( SPSuiteListRef suiteList, const char *name, int32 apiVersion, int32 internalVersion );
	SPErr (*spAllocateBlockFunc)( SPAllocateProc allocateProc, size_t size, const char *debug, void **block );
	SPErr (*spFreeBlockFunc)( SPFreeProc freeProc, void *block );
	SPErr (*spReallocateBlockFunc)( SPReallocateProc reallocateProc, void *block, size_t newSize, const char *debug, void **newblock );
	SPHostProcs *gProcs;
} SPBasicFuncStruct;

/** Internal */
void SetUpBasicFuncs(SPBasicFuncStruct *inStruct);

#ifdef __cplusplus
}
#endif

#endif

```

---

<h2>Begin File: SPStrngs.h</h2>

```cpp
/***********************************************************************/
/*                                                                     */
/* SPStrngs.h                                                          */
/*                                                                     */
/* Copyright 1995-2006 Adobe Systems Incorporated.                     */
/* All Rights Reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/***********************************************************************/

#ifndef __SPStrings__
#define __SPStrings__


/*******************************************************************************
 **
 **	Imports
 **
 **/

#include "SPTypes.h"

#ifdef __cplusplus
extern "C" {
#endif


/*******************************************************************************
 **
 ** Constants
 **
 **/
/** PICA strings suite name */
#define kSPStringsSuite				"SP Strings Suite"
/** PICA strings suite version */
#define kSPStringsSuiteVersion		2

/** Globally available PICA strings resources.
	@see \c #SPRuntimeSuite::GetRuntimeStringPool(). */
#define kSPRuntimeStringPool		((SPStringPoolRef)NULL)


/*******************************************************************************
 **
 ** Types
 **
 **/

/*  If you override the default string pool handler by defining host proc routines,
 *	how the string pool memory allocation and searching is done is up to you.  As an example,
 *	the structure below is similar to what Sweet Pea uses for its default string pool
 *	routines. The pool is a sorted list of strings of number count, kept in memory referenced
 *	by the heap field.
 *
 *			typedef struct SPStringPool {
 *
 *				SPPoolHeapRef heap;
 *				int32 count;
 *
 *			} SPStringPool;
 */

/** Opaque reference to a string pool. Access with the \c #SPStringsSuite. */
typedef struct SPStringPool *SPStringPoolRef;


/*******************************************************************************
 **
 ** Suite
 **
 **/

/** @ingroup Suites
	This suite allows you to work with the PICA string pool.

	PICA manages a string pool, which provides an efficient central
	storage space for C strings. When a string is placed in the pool, PICA
    checks whether it already exists in the pool, and if so, returns a
    pointer to the existing string. If not, it copies the string into the pool,
    and returns a pointer to the copy.

	This mechanisms atomizes the strings. Because each string exists in
	only one place, strings can be compared by address, rather than character
	by character, and string searches are made much more efficient.

	\li Acquire this suite using \c #SPBasicSuite::AcquireSuite() with the constants
		\c #kSPStringsSuite and \c #kSPStringsSuiteVersion.
	*/
typedef struct SPStringsSuite {

	/** Creates a new string pool and allocates an initial block of memory for
		its strings. You can also access PICA's global string pool,
		using \c #SPRuntimeSuite::GetRuntimeStringPool().
			@param stringPool [out] A buffer in which to return the new string pool reference.
		*/
	SPAPI SPErr (*AllocateStringPool)( SPStringPoolRef *stringPool );
	/** Frees the memory used for a string pool created with \c #AllocateStringPool().
		Do not free the global string pool (\c #kSPRuntimeStringPool).
			@param stringPool The string pool reference.
		*/
	SPAPI SPErr (*FreeStringPool)( SPStringPoolRef stringPool );
	/** Adds a string to a string pool, or, if the string has already been added
		to the pool, retrieves a reference to the pooled string.
			@param stringPool The string pool reference.
			@param string The string.
			@param wString [out] A buffer in which to return the address of
				the atomized string in the pool.
		*/
	SPAPI SPErr (*MakeWString)( SPStringPoolRef stringPool, const char *string, const char **wString );

} SPStringsSuite;


SPAPI SPErr SPAllocateStringPool( SPStringPoolRef *stringPool );
SPAPI SPErr SPFreeStringPool( SPStringPoolRef stringPool );
SPAPI SPErr SPMakeWString( SPStringPoolRef stringPool, const char *string, const char **wString );


#ifdef __cplusplus
}
#endif

#endif

```

---

<h2>Begin File: SPSTSPrp.h</h2>

```cpp
/***********************************************************************/
/*                                                                     */
/* SPSTSPrp.h                                                          */
/*                                                                     */
/* Copyright 1995-2006 Adobe Systems Incorporated.                     */
/* All Rights Reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/***********************************************************************/

#ifndef __SPSTSPrp__
#define __SPSTSPrp__


/*******************************************************************************
 **
 **	Imports
 **
 **/

#include "SPPiPL.h"


/*******************************************************************************
 **
 **	Constants
 **
 **/

/** Internal */
#define PISuperTopSecretProperty		'StsP'
/** Internal */
#define PISuperTopSecretValue			'clEn'


/*******************************************************************************
 **
 **	Types
 **
 **/


#endif

```

---

<h2>Begin File: SPSuites.h</h2>

```cpp
/***********************************************************************/
/*                                                                     */
/* SPSuites.h                                                          */
/*                                                                     */
/* Copyright 1995-2006 Adobe Systems Incorporated.                     */
/* All Rights Reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/***********************************************************************/

#ifndef __SPSuites__
#define __SPSuites__


/*******************************************************************************
 **
 **	Imports
 **
 **/

#include "SPTypes.h"
#include "SPAccess.h"
#include "SPPlugs.h"
#include "SPStrngs.h"

#ifdef __cplusplus
extern "C" {
#endif


/*******************************************************************************
 **
 ** Constants
 **
 **/
/** PICA suite-management suite name */
#define kSPSuitesSuite				"SP Suites Suite"
/** PICA suite-management suite version */
#define kSPSuitesSuiteVersion		2

/** Internal */
#define kSPLatestInternalVersion	0

/** PICA global list of available suites.
	@see \c #SPRuntimeSuite::GetRuntimeSuiteList(). */
#define kSPRuntimeSuiteList			((SPSuiteListRef)NULL)


/*******************************************************************************
 **
 ** Types
 **
 **/

/** Opaque reference to a suite object. Access with the \c #SPSuitesSuite. */
typedef struct SPSuite *SPSuiteRef;
/** A list of suite objects. Create with
	\c #SPSuitesSuite::AllocateSuiteList(), or use
	the global list, \c #kSPRuntimeSuiteList. */
typedef struct SPSuiteList *SPSuiteListRef;
/** An iterator object for examining a suite list.
	See \c #SPSuitesSuite::NewSuiteListIterator(). */
typedef struct SPSuiteListIterator *SPSuiteListIteratorRef;


/*******************************************************************************
 **
 ** Suite
 **
 **/

/** @ingroup Suites
	This suite allows you to create, manage, and access PICA function suites.

	A suite associates a name and version number with a pointer to an array of
	function pointers. The functions generally haves some common purpose, such as
	accessing a data type, and are used by plug-ins to interact with PICA, with
	the application, and with each other.

	In order to use a function in a suite, you must first \e acquire it.
	This suite provides the low-level function \c #AcquireSuite(),
	but a plug-in more typically uses the \c #SPBasicSuite, which is provided
	with every message to a plug-in.

	PICA creates a global suite list at application startup, which contains
	references to every suite added by PICA, the application, or other plug-ins.
	You can use this suite to create and manage additional suite lists.

	\li Acquire this suite using \c #SPBasicSuite::AcquireSuite() with the constants
		\c #kSPSuitesSuite and \c #kSPSuitesSuiteVersion.
	*/
typedef struct SPSuitesSuite {

	/** Creates a new suite list. You can also access PICA's global suite list,
		using \c #SPRuntimeSuite::GetRuntimeSuiteList().
			@param stringPool The string pool in which to keep suite names.
			@param plugins <<what is this for? not in old doc>>
			@param suiteList [out] A buffer in which to return the new list object.
		*/
	SPAPI SPErr (*AllocateSuiteList)( SPStringPoolRef stringPool, SPPluginListRef plugins,
				SPSuiteListRef *suiteList );

	/** Frees a list of suites allocated with \c #AllocateSuiteList(), and
		also frees any entries in the list. Do not free the global list (\c #kSPRuntimeSuiteList).
			@param suiteList The suite list object.
		*/
	SPAPI SPErr (*FreeSuiteList)( SPSuiteListRef suiteList );

	/** Creates a new plug-in function suite and adds it to a suite list.
		Identifying constants for the suite name and version must be made
		available in a public header file.
			@param suiteList The suite list object, or \c NULL to use the
				global list.
			@param host The plug-in object providing the suite.
			@param name The unique name of the suite.
			@param apiVersion The public version number of the suite.
			@param internalVersion The internal version number of the suite.
			@param suiteProcs A pointer to a structure containing the function pointers
				for the suite.
			@param suite [out] A buffer in which to return the new suite object.
		*/
	SPAPI SPErr (*AddSuite)( SPSuiteListRef suiteList, SPPluginRef host, const char *name,
				int32 apiVersion, int32 internalVersion, const void *suiteProcs, SPSuiteRef *suite );

	/** Acquires a function suite from a suite list. Loads the suite if necessary,
		and increments its reference count. This function differs from
		\c #SPBasicSuite::AcquireSuite() in that you can specify a suite list
		and internal version number.
			@param suiteList The suite list object, or \c NULL to use the
				global list.
			@param name The suite name.
			@param version The public suite version number.
			@param internalVersion The internal suite version number.
			@param suiteProcs [out] A buffer in which to return a pointer to the
				suite function pointer array.
		*/
	SPAPI SPErr (*AcquireSuite)( SPSuiteListRef suiteList, const char *name, int32 apiVersion,
				int32 internalVersion, const void **suiteProcs );

	/** Decrements the reference count of a suite in a suite list and unloads it when the
		reference count reaches 0.
			@param suiteList The suite list object, or \c NULL to use the
				global list.
			@param name The suite name.
			@param version The public suite version number.
			@param internalVersion The internal suite version number.
		*/
	SPAPI SPErr (*ReleaseSuite)( SPSuiteListRef suiteList, const char *name, int32 apiVersion,
				int32 internalVersion );

	/** Retrieves a suite from a suite list.
			@param suiteList The suite list object, or \c NULL to use the
				global list.
			@param name The suite name.
			@param version The public suite version number.
			@param internalVersion The internal suite version number.
			@param suiteProcs [out] A buffer in which to return the suite object, or
				\c NULL if no matching suite is found in the list.
		*/
	SPAPI SPErr (*FindSuite)( SPSuiteListRef suiteList, const char *name, int32 apiVersion,
				int32 internalVersion, SPSuiteRef *suite );

	/** Creates an iterator object with which to traverse a suite list.
		The iterator is initially set to the first suite in the list.
			@param suiteList The suite list object, or \c NULL to use the
				global list.
			@param iter [out] A buffer in which to return the new iterator object.
			@see \c #NextSuite(), \c #DeleteSuiteListIterator()
		*/
	SPAPI SPErr (*NewSuiteListIterator)( SPSuiteListRef suiteList, SPSuiteListIteratorRef *iter );
	/** Retrieves the current suite and advances a suite-list iterator to the next suite in the list.
			@param iter The suite-list iterator object.
			@param suite [out] A buffer in which to return the current suite object, \c NULL
				if the end of the list has been reached.
		    @see \c #NewSuiteListIterator(),
		*/
	SPAPI SPErr (*NextSuite)( SPSuiteListIteratorRef iter, SPSuiteRef *suite );
	/** Frees a suite-list iterator that is no longer needed.
			@param iter The suite-list iterator object.
			@see \c #NewSuiteListIterator(),
		*/
	SPAPI SPErr (*DeleteSuiteListIterator)( SPSuiteListIteratorRef iter );

	/** Retrieves the plug-in that provides a suite.
			@param suite The suite object.
			@param plugin [out] A buffer in which to return the plug-in object.
		*/
	SPAPI SPErr (*GetSuiteHost)( SPSuiteRef suite, SPPluginRef *plugin );
	/** Retrieves the unique name of a suite.
			@param suite The suite object.
			@param name [out] A buffer in which to return the name string.
		*/
	SPAPI SPErr (*GetSuiteName)( SPSuiteRef suite, const char **name );
	/** Retrieves the public version number of a suite.
			@param suite The suite object.
			@param version [out] A buffer in which to return the public version number.
		*/
	SPAPI SPErr (*GetSuiteAPIVersion)( SPSuiteRef suite, int32 *version );
	/** Retrieves the internal version number of a suite.
			@param suite The suite object.
			@param version [out] A buffer in which to return the internal version number.
		*/
	SPAPI SPErr (*GetSuiteInternalVersion)( SPSuiteRef suite, int32 *version );
	/** Retrieves the function pointer array of a suite.
			@param suite The suite object.
			@param suiteProcs [out] A buffer in which to return a pointer
				to the function pointer array.
		*/
	SPAPI SPErr (*GetSuiteProcs)( SPSuiteRef suite, const void **suiteProcs );
	/** Retrieves the current reference count of a suite.
			@param suite The suite object.
			@param count [out] A buffer in which to return the reference count.
		*/
	SPAPI SPErr (*GetSuiteAcquireCount)( SPSuiteRef suite, int32 *count );

} SPSuitesSuite;


/** Internal */
SPAPI SPErr SPAllocateSuiteList( SPStringPoolRef stringPool, SPPluginListRef plugins,
			SPSuiteListRef *suiteList );

/** Internal */
SPAPI SPErr SPFreeSuiteList( SPSuiteListRef suiteList );

/** Internal */
SPAPI SPErr SPAddSuite( SPSuiteListRef suiteList, SPPluginRef host, const char *name,
			int32 apiVersion, int32 internalVersion, const void *suiteProcs, SPSuiteRef *suite );

/** Internal */
SPAPI SPErr SPAcquireSuite( SPSuiteListRef suiteList, const char *name, int32 apiVersion,
			int32 internalVersion, const void **suiteProcs );

/** Internal */
SPAPI SPErr SPReleaseSuite( SPSuiteListRef suiteList, const char *name, int32 apiVersion,
			int32 internalVersion );

/** Internal */
SPAPI SPErr SPFindSuite( SPSuiteListRef suiteList, const char *name, int32 apiVersion,
			int32 internalVersion, SPSuiteRef *suite );

/** Internal */
SPAPI SPErr SPNewSuiteListIterator( SPSuiteListRef suiteList, SPSuiteListIteratorRef *iter );
/** Internal */
SPAPI SPErr SPNextSuite( SPSuiteListIteratorRef iter, SPSuiteRef *suite );
/** Internal */
SPAPI SPErr SPDeleteSuiteListIterator( SPSuiteListIteratorRef iter );

/** Internal */
SPAPI SPErr SPGetSuiteHost( SPSuiteRef suite, SPPluginRef *plugin );
/** Internal */
SPAPI SPErr SPGetSuiteName( SPSuiteRef suite, const char **name );
/** Internal */
SPAPI SPErr SPGetSuiteAPIVersion( SPSuiteRef suite, int32 *version );
/** Internal */
SPAPI SPErr SPGetSuiteInternalVersion( SPSuiteRef suite, int32 *version );
/** Internal */
SPAPI SPErr SPGetSuiteProcs( SPSuiteRef suite, const void **suiteProcs );
/** Internal */
SPAPI SPErr SPGetSuiteAcquireCount( SPSuiteRef suite, int32 *count );


/*******************************************************************************
 **
 **	Errors
 **
 **/

#include "SPErrorCodes.h"

#ifdef __cplusplus
}
#endif

#endif

```

---

<h2>Begin File: SPTypes.h</h2>

```cpp
/***********************************************************************/
/*                                                                     */
/* SPTypes.h                                                           */
/*                                                                     */
/* Copyright 1995-2006 Adobe Systems Incorporated.                     */
/* All Rights Reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/***********************************************************************/


/**

	These are the basic declarations used by Sweet Pea.

 **/


#ifndef __SPTypes__
#define __SPTypes__


/*******************************************************************************
 **
 **	Imports
 **
 **/

#include "SPConfig.h"


/*
 *	You can replace SPTypes.h with your own. Define OTHER_SP_TYPES_H on the
 *	command line or in SPConfig.h to be the name of the replacement file.
 *
 *	Example:
 *
 *	#define OTHER_SP_TYPES_H "MySPTypes.h"
 *	#include "SPBasic.h"  // for example
 *
 *	Sweet Pea depends on TRUE, FALSE, SPErr, etc. Your replacement must
 *	define them.
 */

#ifdef OTHER_SP_TYPES_H
#include OTHER_SP_TYPES_H
#else


/*******************************************************************************
 **
 **	Constants
 **
 **/

#ifndef TRUE
#define TRUE	1
#endif

#ifndef FALSE
#define FALSE	0
#endif

#ifndef NULL

#ifdef MAC_ENV
#if !defined(__cplusplus) && (defined(__SC__) || defined(THINK_C))
#define NULL	((void *) 0)
#else
#define NULL	0
#endif
#endif

#ifdef WIN_ENV
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

#endif


/*
 *	SPAPI is placed in front of procedure declarations in the API. On the Mac
 *	it used to be 'pascal', which forced consistent calling conventions across different
 *	compilers. No longer needed. On Windows it's nothing.
 *
 *	Example:
 *
 *	SPAPI void *SPAllocateBlock( int32 size, const char *debug, SPErr *error );
 *
 */

#if defined(MAC_ENV) || defined(__ANDROID__) || defined(__LINUX__) || defined (__EMSCRIPTEN__) || defined(SIMULATED_WASM)
#if defined(__GNUC__)
#define SPAPI
#else
#define SPAPI	pascal
#endif
#endif

#ifdef WIN_ENV
#define SPAPI
#endif

#include "PSIntTypes.h"

typedef uint8 SPUInt8;
typedef uint16 SPUInt16;
typedef uint32 SPUInt32;

typedef int32 SPInt32;

#if defined(MAC_ENV) || defined(__ANDROID__) || defined(__LINUX__) || defined (__EMSCRIPTEN__) || defined(SIMULATED_WASM)

/* SPBoolean is the same a Macintosh Boolean. */
typedef uint8 SPBoolean;

#endif

#ifdef WIN_ENV

/* SPBoolean is the same a Windows BOOL. */
typedef int32 SPBoolean;

#endif


/*******************************************************************************
 **
 **	Error Handling
 **
 **/

/*
 *	Error codes in Sweet Pea are C strings, with the exception of the code for
 *	no error, which is NULL. The error can first be compared with kSPNoError to
 *	test if the function succeeded. If it is not NULL then the error can be
 *	string-compared with predefined error strings.
 *
 *	Example:
 *
 *	SPErr error = kSPNoError;
 *
 *	block = SPAllocateBlock( size, debug, &error );
 *	if ( error != kSPNoError ) {
 *		if ( strcmp( error, kSPOutOfMemoryError ) == 0 )
 *			FailOutOfMemory();
 *		...
 *	}
 */

typedef int32 SPErr;

/*
 *	kSPNoError and kSPUnimplementedError are universal. Other error codes should
 *	be defined in the appropriate header files.
 */

#include "SPErrorCodes.h"

#endif /* OTHER_SP_TYPES_H */

#endif

```

---

